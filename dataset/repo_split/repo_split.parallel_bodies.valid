 DCSP fp = open(filename, 'rb') DCNL DCSP source = (fp.read() + '\n') DCNL DCSP try: DCNL DCSP  DCSP co = compile(source, filename, 'exec') DCNL DCSP except SyntaxError: DCNL DCSP  DCSP print >>sys.stderr, '>>Syntax DCSP error DCSP in', filename DCNL DCSP  DCSP raise DCNL DCSP fp.close() DCNL DCSP return co
 DCSP import magics, marshal DCNL DCSP fp = open(filename, 'rb') DCNL DCSP magic = fp.read(4) DCNL DCSP try: DCNL DCSP  DCSP version = magics.versions[magic] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ImportError, ('Unknown DCSP magic DCSP number DCSP %s DCSP in DCSP %s' % ((ord(magic[0]) + (256 * ord(magic[1]))), filename)) DCNL DCSP if (version != '2.7'): DCNL DCSP  DCSP raise ImportError, ('This DCSP is DCSP a DCSP Python DCSP %s DCSP file! DCSP Only DCSP Python DCSP 2.7 DCSP files DCSP are DCSP supported.' % version) DCNL DCSP fp.read(4) DCNL DCSP co = marshal.load(fp) DCNL DCSP fp.close() DCNL DCSP return (version, co)
 DCSP assert (type(co) == types.CodeType) DCNL DCSP __real_out = (out or sys.stdout) DCNL DCSP if co.co_filename: DCNL DCSP  DCSP print >>__real_out, ('#Embedded DCSP file DCSP name: DCSP %s' % co.co_filename) DCNL DCSP scanner = Scanner.getscanner(version) DCNL DCSP scanner.setShowAsm(showasm, out) DCNL DCSP (tokens, customize) = scanner.disassemble(co, deob=deob) DCNL DCSP walker = Walker.Walker(out, scanner, showast=showast) DCNL DCSP try: DCNL DCSP  DCSP ast = walker.build_ast(tokens, customize) DCNL DCSP except Walker.ParserError as e: DCNL DCSP  DCSP print >>__real_out, e DCNL DCSP  DCSP raise DCNL DCSP del tokens DCNL DCSP assert (ast == 'stmts') DCNL DCSP try: DCNL DCSP  DCSP if (ast[0][0] == Walker.ASSIGN_DOC_STRING(co.co_consts[0])): DCNL DCSP  DCSP  DCSP walker.print_docstring('', co.co_consts[0]) DCNL DCSP  DCSP  DCSP del ast[0] DCNL DCSP  DCSP if (ast[(-1)] == Walker.RETURN_NONE): DCNL DCSP  DCSP  DCSP ast.pop() DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP walker.mod_globs = Walker.find_globals(ast, set()) DCNL DCSP walker.gen_source(ast, customize) DCNL DCSP for g in walker.mod_globs: DCNL DCSP  DCSP walker.write(('global DCSP %s DCSP ## DCSP Warning: DCSP Unused DCSP global\n' % g)) DCNL DCSP if walker.pending_newlines: DCNL DCSP  DCSP print >>__real_out DCNL DCSP if walker.ERROR: DCNL DCSP  DCSP raise walker.ERROR
 DCSP (version, co) = _load_module(filename) DCNL DCSP uncompyle(version, co, outstream, showasm, showast, deob) DCNL DCSP co = None
 DCSP def _get_outstream(outfile): DCNL DCSP  DCSP dir = os.path.dirname(outfile) DCNL DCSP  DCSP failed_file = (outfile + '_failed') DCNL DCSP  DCSP if os.path.exists(failed_file): DCNL DCSP  DCSP  DCSP os.remove(failed_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(dir) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return open(outfile, 'w') DCNL DCSP of = outfile DCNL DCSP tot_files = okay_files = failed_files = verify_failed_files = 0 DCNL DCSP for code in codes: DCNL DCSP  DCSP version = sys.version[:3] DCNL DCSP  DCSP with open(code, 'r') as f: DCNL DCSP  DCSP  DCSP co = compile(f.read(), '', 'exec') DCNL DCSP  DCSP uncompyle(sys.version[:3], co, sys.stdout, showasm=showasm, showast=showast, deob=deob) DCNL DCSP for file in files: DCNL DCSP  DCSP infile = os.path.join(in_base, file) DCNL DCSP  DCSP if of: DCNL DCSP  DCSP  DCSP outstream = _get_outstream(outfile) DCNL DCSP  DCSP elif (out_base is None): DCNL DCSP  DCSP  DCSP outstream = sys.stdout DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP outfile = os.path.join(out_base, file) DCNL DCSP  DCSP  DCSP if py: DCNL DCSP  DCSP  DCSP  DCSP outfile = outfile[:(-1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outfile += '_dis' DCNL DCSP  DCSP  DCSP outstream = _get_outstream(outfile) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP uncompyle_file(infile, outstream, showasm, showast, deob) DCNL DCSP  DCSP  DCSP tot_files += 1 DCNL DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP if outfile: DCNL DCSP  DCSP  DCSP  DCSP outstream.close() DCNL DCSP  DCSP  DCSP  DCSP os.remove(outfile) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP failed_files += 1 DCNL DCSP  DCSP  DCSP sys.stderr.write(("### DCSP Can't DCSP uncompyle DCSP %s\n" % infile)) DCNL DCSP  DCSP  DCSP if outfile: DCNL DCSP  DCSP  DCSP  DCSP outstream.close() DCNL DCSP  DCSP  DCSP  DCSP os.rename(outfile, (outfile + '_failed')) DCNL DCSP  DCSP  DCSP import traceback DCNL DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if outfile: DCNL DCSP  DCSP  DCSP  DCSP outstream.close() DCNL DCSP  DCSP  DCSP if do_verify: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP verify.compare_code_with_srcfile(infile, outfile) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '+++ DCSP okay DCSP decompyling', infile, __memUsage() DCNL DCSP  DCSP  DCSP  DCSP  DCSP okay_files += 1 DCNL DCSP  DCSP  DCSP  DCSP except verify.VerifyCmpError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP verify_failed_files += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.rename(outfile, (outfile + '_unverified')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stderr, '### DCSP Error DCSP Verifiying', file DCNL DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stderr, e DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP okay_files += 1 DCNL DCSP  DCSP  DCSP  DCSP print '+++ DCSP okay DCSP decompyling', infile, __memUsage() DCNL DCSP return (tot_files, okay_files, failed_files, verify_failed_files)
 DCSP assert (type(code_obj1) == types.CodeType) DCNL DCSP assert (type(code_obj2) == types.CodeType) DCNL DCSP if isinstance(code_obj1, object): DCNL DCSP  DCSP assert (dir(code_obj1) == dir(code_obj2)) DCNL DCSP else: DCNL DCSP  DCSP assert (dir(code_obj1) == code_obj1.__members__) DCNL DCSP  DCSP assert (dir(code_obj2) == code_obj2.__members__) DCNL DCSP  DCSP assert (code_obj1.__members__ == code_obj2.__members__) DCNL DCSP if (name == '__main__'): DCNL DCSP  DCSP name = code_obj1.co_name DCNL DCSP else: DCNL DCSP  DCSP name = ('%s.%s' % (name, code_obj1.co_name)) DCNL DCSP  DCSP if (name == '.?'): DCNL DCSP  DCSP  DCSP name = '__main__' DCNL DCSP if (isinstance(code_obj1, object) and cmp(code_obj1, code_obj2)): DCNL DCSP  DCSP pass DCNL DCSP if isinstance(code_obj1, object): DCNL DCSP  DCSP members = filter((lambda x: x.startswith('co_')), dir(code_obj1)) DCNL DCSP else: DCNL DCSP  DCSP members = dir(code_obj1) DCNL DCSP members.sort() DCNL DCSP tokens1 = None DCNL DCSP for member in members: DCNL DCSP  DCSP if (member in __IGNORE_CODE_MEMBERS__): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (member == 'co_code'): DCNL DCSP  DCSP  DCSP scanner = Scanner.getscanner(version) DCNL DCSP  DCSP  DCSP scanner.setShowAsm(showasm=0) DCNL DCSP  DCSP  DCSP global JUMP_OPs DCNL DCSP  DCSP  DCSP JUMP_OPs = (scanner.JUMP_OPs + ['JUMP_BACK']) DCNL DCSP  DCSP  DCSP scanner.setTokenClass(Token) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (tokens1, customize) = scanner.disassemble(code_obj1) DCNL DCSP  DCSP  DCSP  DCSP del customize DCNL DCSP  DCSP  DCSP  DCSP (tokens2, customize) = scanner.disassemble(code_obj2) DCNL DCSP  DCSP  DCSP  DCSP del customize DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP scanner.resetTokenClass() DCNL DCSP  DCSP  DCSP targets1 = dis.findlabels(code_obj1.co_code) DCNL DCSP  DCSP  DCSP tokens1 = [t for t in tokens1 if (t.type != 'COME_FROM')] DCNL DCSP  DCSP  DCSP tokens2 = [t for t in tokens2 if (t.type != 'COME_FROM')] DCNL DCSP  DCSP  DCSP i1 = 0 DCNL DCSP  DCSP  DCSP i2 = 0 DCNL DCSP  DCSP  DCSP offset_map = {} DCNL DCSP  DCSP  DCSP check_jumps = {} DCNL DCSP  DCSP  DCSP while (i1 < len(tokens1)): DCNL DCSP  DCSP  DCSP  DCSP if (i2 >= len(tokens2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((len(tokens1) == (len(tokens2) + 2)) and (tokens1[(-1)].type == 'RETURN_VALUE') and (tokens1[(-2)].type == 'LOAD_CONST') and (tokens1[(-2)].pattr == None) and (tokens1[(-3)].type == 'RETURN_VALUE')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise CmpErrorCodeLen(name, tokens1, tokens2) DCNL DCSP  DCSP  DCSP  DCSP offset_map[tokens1[i1].offset] = tokens2[i2].offset DCNL DCSP  DCSP  DCSP  DCSP for (idx1, idx2, offset2) in check_jumps.get(tokens1[i1].offset, []): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (offset2 != tokens2[i2].offset): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise CmpErrorCode(name, tokens1[idx1].offset, tokens1[idx1], tokens2[idx2], tokens1, tokens2) DCNL DCSP  DCSP  DCSP  DCSP if (tokens1[i1] != tokens2[i2]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (tokens1[i1].type == 'LOAD_CONST' == tokens2[i2].type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP while (tokens1[(i1 + i)].type == 'LOAD_CONST'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (tokens1[(i1 + i)].type.startswith(('BUILD_TUPLE', 'BUILD_LIST')) and (i == int(tokens1[(i1 + i)].type.split('_')[(-1)]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP t = tuple([elem.pattr for elem in tokens1[i1:(i1 + i)]]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (t != tokens2[i2].pattr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise CmpErrorCode(name, tokens1[i1].offset, tokens1[i1], tokens2[i2], tokens1, tokens2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif ((i == 2) and (tokens1[(i1 + i)].type == 'ROT_TWO') and (tokens2[(i2 + 1)].type == 'UNPACK_SEQUENCE_2')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 3 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif ((i == 2) and (tokens1[(i1 + i)].type in BIN_OP_FUNCS)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = BIN_OP_FUNCS[tokens1[(i1 + i)].type] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (f(tokens1[i1].pattr, tokens1[(i1 + 1)].pattr) == tokens2[i2].pattr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 3 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif ((i == 1) and (tokens1[(i1 + i)].type == 'STORE_NAME' == tokens2[(i2 + i)].type) and (tokens1[(i1 + i)].pattr == '__doc__' == tokens2[(i2 + i)].pattr)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (tokens1[i1].type == 'UNARY_NOT'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (tokens2[i2].type == 'POP_JUMP_IF_TRUE'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (tokens1[(i1 + 1)].type == 'POP_JUMP_IF_FALSE'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (tokens2[i2].type == 'POP_JUMP_IF_FALSE'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (tokens1[(i1 + 1)].type == 'POP_JUMP_IF_TRUE'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ((tokens1[i1].type in ('JUMP_FORWARD', 'JUMP_BACK')) and (tokens1[(i1 - 1)].type == 'RETURN_VALUE') and (tokens2[(i2 - 1)].type in ('RETURN_VALUE', 'RETURN_END_IF')) and (int(tokens1[i1].offset) not in targets1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif ((tokens1[i1].type == 'JUMP_FORWARD') and (tokens2[i2].type == 'JUMP_BACK') and (tokens1[(i1 + 1)].type == 'JUMP_BACK') and (tokens2[(i2 + 1)].type == 'JUMP_BACK') and (int(tokens1[i1].pattr) == (int(tokens1[i1].offset) + 3))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (int(tokens1[i1].pattr) == int(tokens1[(i1 + 1)].offset)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i1 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP i2 += 2 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise CmpErrorCode(name, tokens1[i1].offset, tokens1[i1], tokens2[i2], tokens1, tokens2) DCNL DCSP  DCSP  DCSP  DCSP elif ((tokens1[i1].type in JUMP_OPs) and (tokens1[i1].pattr != tokens2[i2].pattr)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP dest1 = int(tokens1[i1].pattr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP dest2 = int(tokens2[i2].pattr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (tokens1[i1].type == 'JUMP_BACK'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (offset_map[dest1] != dest2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise CmpErrorCode(name, tokens1[i1].offset, tokens1[i1], tokens2[i2], tokens1, tokens2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (dest1 in check_jumps): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP check_jumps[dest1].append((i1, i2, dest2)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP check_jumps[dest1] = [(i1, i2, dest2)] DCNL DCSP  DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP  DCSP del tokens1, tokens2 DCNL DCSP  DCSP elif (member == 'co_consts'): DCNL DCSP  DCSP  DCSP codes1 = (c for c in code_obj1.co_consts if (type(c) == types.CodeType)) DCNL DCSP  DCSP  DCSP codes2 = (c for c in code_obj2.co_consts if (type(c) == types.CodeType)) DCNL DCSP  DCSP  DCSP for (c1, c2) in zip(codes1, codes2): DCNL DCSP  DCSP  DCSP  DCSP cmp_code_objects(version, c1, c2, name=name) DCNL DCSP  DCSP elif (getattr(code_obj1, member) != getattr(code_obj2, member)): DCNL DCSP  DCSP  DCSP raise CmpErrorMember(name, member, getattr(code_obj1, member), getattr(code_obj2, member))
 DCSP (version, code_obj1) = uncompyle2._load_module(pyc_filename) DCNL DCSP code_obj2 = uncompyle2._load_file(src_filename) DCNL DCSP cmp_code_objects(version, code_obj1, code_obj2)
 DCSP (version, code_obj1) = uncompyle2._load_module(pyc_filename1) DCNL DCSP (version, code_obj2) = uncompyle2._load_module(pyc_filename2) DCNL DCSP cmp_code_objects(version, code_obj1, code_obj2)
 DCSP for n in node: DCNL DCSP  DCSP if isinstance(n, AST): DCNL DCSP  DCSP  DCSP globs = find_globals(n, globs) DCNL DCSP  DCSP elif (n.type in ('STORE_GLOBAL', 'DELETE_GLOBAL')): DCNL DCSP  DCSP  DCSP globs.add(n.pattr) DCNL DCSP return globs
 DCSP for n in node: DCNL DCSP  DCSP if isinstance(n, AST): DCNL DCSP  DCSP  DCSP globs = find_all_globals(n, globs) DCNL DCSP  DCSP elif (n.type in ('STORE_GLOBAL', 'DELETE_GLOBAL', 'LOAD_GLOBAL')): DCNL DCSP  DCSP  DCSP globs.add(n.pattr) DCNL DCSP return globs
 DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP global _default_instance DCNL DCSP if (_default_instance is None): DCNL DCSP  DCSP _default_instance = Instance() DCNL DCSP return _default_instance
 DCSP if (hasattr(dll, name) and (name in _Globals)): DCNL DCSP  DCSP p = ctypes.CFUNCTYPE(*types) DCNL DCSP  DCSP f = p((name, dll), flags) DCNL DCSP  DCSP if (errcheck is not None): DCNL DCSP  DCSP  DCSP f.errcheck = errcheck DCNL DCSP  DCSP if __debug__: DCNL DCSP  DCSP  DCSP _Cfunctions[name] = f DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _Globals[name] = f DCNL DCSP  DCSP return f DCNL DCSP raise NameError(('no DCSP function DCSP %r' % (name,)))
 DCSP o = object.__new__(cls) DCNL DCSP o._as_parameter_ = ctype DCNL DCSP return o
 DCSP if (ptr == _internal_guard): DCNL DCSP  DCSP raise VLCException('(INTERNAL) DCSP ctypes DCSP class. DCSP You DCSP should DCSP get DCSP references DCSP for DCSP this DCSP class DCSP through DCSP methods DCSP of DCSP the DCSP LibVLC DCSP API.') DCNL DCSP if ((ptr is None) or (ptr == 0)): DCNL DCSP  DCSP return None DCNL DCSP return _Cobject(cls, ctypes.c_void_p(ptr))
 DCSP if result: DCNL DCSP  DCSP s = bytes_to_str(ctypes.string_at(result)) DCNL DCSP  DCSP libvlc_free(result) DCNL DCSP  DCSP return s DCNL DCSP return None
 DCSP def wrap_errcheck(result, func, arguments): DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return classname(result) DCNL DCSP return wrap_errcheck
 DCSP r = [] DCNL DCSP if head: DCNL DCSP  DCSP item = head DCNL DCSP  DCSP while item: DCNL DCSP  DCSP  DCSP item = item.contents DCNL DCSP  DCSP  DCSP r.append((item.id, item.name)) DCNL DCSP  DCSP  DCSP item = item.next DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP libvlc_track_description_release(head) DCNL DCSP  DCSP except NameError: DCNL DCSP  DCSP  DCSP libvlc_track_description_list_release(head) DCNL DCSP return r
 DCSP r = [] DCNL DCSP if head: DCNL DCSP  DCSP item = head DCNL DCSP  DCSP while item: DCNL DCSP  DCSP  DCSP item = item.contents DCNL DCSP  DCSP  DCSP r.append((item.name, item.shortname, item.longname, item.help)) DCNL DCSP  DCSP  DCSP item = item.next DCNL DCSP  DCSP libvlc_module_description_list_release(head) DCNL DCSP return r
 DCSP f = (_Cfunctions.get('libvlc_errmsg', None) or _Cfunction('libvlc_errmsg', (), None, ctypes.c_char_p)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_clearerr', None) or _Cfunction('libvlc_clearerr', (), None, None)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_vprinterr', None) or _Cfunction('libvlc_vprinterr', ((1,), (1,)), None, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p)) DCNL DCSP return f(fmt, ap)
 DCSP f = (_Cfunctions.get('libvlc_new', None) or _Cfunction('libvlc_new', ((1,), (1,)), class_result(Instance), ctypes.c_void_p, ctypes.c_int, ListPOINTER(ctypes.c_char_p))) DCNL DCSP return f(argc, argv)
 DCSP f = (_Cfunctions.get('libvlc_release', None) or _Cfunction('libvlc_release', ((1,),), None, None, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_retain', None) or _Cfunction('libvlc_retain', ((1,),), None, None, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_add_intf', None) or _Cfunction('libvlc_add_intf', ((1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, name)
 DCSP f = (_Cfunctions.get('libvlc_set_user_agent', None) or _Cfunction('libvlc_set_user_agent', ((1,), (1,), (1,)), None, None, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, name, http)
 DCSP f = (_Cfunctions.get('libvlc_set_app_id', None) or _Cfunction('libvlc_set_app_id', ((1,), (1,), (1,), (1,)), None, None, Instance, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, id, version, icon)
 DCSP f = (_Cfunctions.get('libvlc_get_version', None) or _Cfunction('libvlc_get_version', (), None, ctypes.c_char_p)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_get_compiler', None) or _Cfunction('libvlc_get_compiler', (), None, ctypes.c_char_p)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_get_changeset', None) or _Cfunction('libvlc_get_changeset', (), None, ctypes.c_char_p)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_free', None) or _Cfunction('libvlc_free', ((1,),), None, None, ctypes.c_void_p)) DCNL DCSP return f(ptr)
 DCSP f = (_Cfunctions.get('libvlc_event_attach', None) or _Cfunction('libvlc_event_attach', ((1,), (1,), (1,), (1,)), None, ctypes.c_int, EventManager, ctypes.c_uint, Callback, ctypes.c_void_p)) DCNL DCSP return f(p_event_manager, i_event_type, f_callback, user_data)
 DCSP f = (_Cfunctions.get('libvlc_event_detach', None) or _Cfunction('libvlc_event_detach', ((1,), (1,), (1,), (1,)), None, None, EventManager, ctypes.c_uint, Callback, ctypes.c_void_p)) DCNL DCSP return f(p_event_manager, i_event_type, f_callback, p_user_data)
 DCSP f = (_Cfunctions.get('libvlc_event_type_name', None) or _Cfunction('libvlc_event_type_name', ((1,),), None, ctypes.c_char_p, ctypes.c_uint)) DCNL DCSP return f(event_type)
 DCSP f = (_Cfunctions.get('libvlc_log_get_context', None) or _Cfunction('libvlc_log_get_context', ((1,), (2,), (2,), (2,)), None, None, Log_ptr, ListPOINTER(ctypes.c_char_p), ListPOINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_uint))) DCNL DCSP return f(ctx)
 DCSP f = (_Cfunctions.get('libvlc_log_get_object', None) or _Cfunction('libvlc_log_get_object', ((1,), (2,), (2,), (1,)), None, None, Log_ptr, ListPOINTER(ctypes.c_char_p), ListPOINTER(ctypes.c_char_p), ctypes.POINTER(ctypes.c_uint))) DCNL DCSP return f(ctx, id)
 DCSP f = (_Cfunctions.get('libvlc_log_unset', None) or _Cfunction('libvlc_log_unset', ((1,),), None, None, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_log_set', None) or _Cfunction('libvlc_log_set', ((1,), (1,), (1,)), None, None, Instance, LogCb, ctypes.c_void_p)) DCNL DCSP return f(cb, data, p_instance)
 DCSP f = (_Cfunctions.get('libvlc_log_set_file', None) or _Cfunction('libvlc_log_set_file', ((1,), (1,)), None, None, Instance, FILE_ptr)) DCNL DCSP return f(p_instance, stream)
 DCSP f = (_Cfunctions.get('libvlc_module_description_list_release', None) or _Cfunction('libvlc_module_description_list_release', ((1,),), None, None, ctypes.POINTER(ModuleDescription))) DCNL DCSP return f(p_list)
 DCSP f = (_Cfunctions.get('libvlc_audio_filter_list_get', None) or _Cfunction('libvlc_audio_filter_list_get', ((1,),), None, ctypes.POINTER(ModuleDescription), Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_video_filter_list_get', None) or _Cfunction('libvlc_video_filter_list_get', ((1,),), None, ctypes.POINTER(ModuleDescription), Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_clock', None) or _Cfunction('libvlc_clock', (), None, ctypes.c_int64)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_media_new_location', None) or _Cfunction('libvlc_media_new_location', ((1,), (1,)), class_result(Media), ctypes.c_void_p, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_mrl)
 DCSP f = (_Cfunctions.get('libvlc_media_new_path', None) or _Cfunction('libvlc_media_new_path', ((1,), (1,)), class_result(Media), ctypes.c_void_p, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, path)
 DCSP f = (_Cfunctions.get('libvlc_media_new_fd', None) or _Cfunction('libvlc_media_new_fd', ((1,), (1,)), class_result(Media), ctypes.c_void_p, Instance, ctypes.c_int)) DCNL DCSP return f(p_instance, fd)
 DCSP f = (_Cfunctions.get('libvlc_media_new_callbacks', None) or _Cfunction('libvlc_media_new_callbacks', ((1,), (1,), (1,), (1,), (1,), (1,)), class_result(Media), ctypes.c_void_p, Instance, MediaOpenCb, MediaReadCb, MediaSeekCb, MediaCloseCb, ctypes.c_void_p)) DCNL DCSP return f(instance, open_cb, read_cb, seek_cb, close_cb, opaque)
 DCSP f = (_Cfunctions.get('libvlc_media_new_as_node', None) or _Cfunction('libvlc_media_new_as_node', ((1,), (1,)), class_result(Media), ctypes.c_void_p, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_media_add_option', None) or _Cfunction('libvlc_media_add_option', ((1,), (1,)), None, None, Media, ctypes.c_char_p)) DCNL DCSP return f(p_md, psz_options)
 DCSP f = (_Cfunctions.get('libvlc_media_add_option_flag', None) or _Cfunction('libvlc_media_add_option_flag', ((1,), (1,), (1,)), None, None, Media, ctypes.c_char_p, ctypes.c_uint)) DCNL DCSP return f(p_md, psz_options, i_flags)
 DCSP f = (_Cfunctions.get('libvlc_media_retain', None) or _Cfunction('libvlc_media_retain', ((1,),), None, None, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_release', None) or _Cfunction('libvlc_media_release', ((1,),), None, None, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_get_mrl', None) or _Cfunction('libvlc_media_get_mrl', ((1,),), string_result, ctypes.c_void_p, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_duplicate', None) or _Cfunction('libvlc_media_duplicate', ((1,),), class_result(Media), ctypes.c_void_p, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_get_meta', None) or _Cfunction('libvlc_media_get_meta', ((1,), (1,)), string_result, ctypes.c_void_p, Media, Meta)) DCNL DCSP return f(p_md, e_meta)
 DCSP f = (_Cfunctions.get('libvlc_media_set_meta', None) or _Cfunction('libvlc_media_set_meta', ((1,), (1,), (1,)), None, None, Media, Meta, ctypes.c_char_p)) DCNL DCSP return f(p_md, e_meta, psz_value)
 DCSP f = (_Cfunctions.get('libvlc_media_save_meta', None) or _Cfunction('libvlc_media_save_meta', ((1,),), None, ctypes.c_int, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_get_state', None) or _Cfunction('libvlc_media_get_state', ((1,),), None, State, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_get_stats', None) or _Cfunction('libvlc_media_get_stats', ((1,), (1,)), None, ctypes.c_int, Media, ctypes.POINTER(MediaStats))) DCNL DCSP return f(p_md, p_stats)
 DCSP f = (_Cfunctions.get('libvlc_media_subitems', None) or _Cfunction('libvlc_media_subitems', ((1,),), class_result(MediaList), ctypes.c_void_p, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_event_manager', None) or _Cfunction('libvlc_media_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_get_duration', None) or _Cfunction('libvlc_media_get_duration', ((1,),), None, ctypes.c_longlong, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_parse', None) or _Cfunction('libvlc_media_parse', ((1,),), None, None, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_parse_async', None) or _Cfunction('libvlc_media_parse_async', ((1,),), None, None, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_parse_with_options', None) or _Cfunction('libvlc_media_parse_with_options', ((1,), (1,)), None, ctypes.c_int, Media, MediaParseFlag)) DCNL DCSP return f(p_md, parse_flag)
 DCSP f = (_Cfunctions.get('libvlc_media_is_parsed', None) or _Cfunction('libvlc_media_is_parsed', ((1,),), None, ctypes.c_int, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_set_user_data', None) or _Cfunction('libvlc_media_set_user_data', ((1,), (1,)), None, None, Media, ctypes.c_void_p)) DCNL DCSP return f(p_md, p_new_user_data)
 DCSP f = (_Cfunctions.get('libvlc_media_get_user_data', None) or _Cfunction('libvlc_media_get_user_data', ((1,),), None, ctypes.c_void_p, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_tracks_get', None) or _Cfunction('libvlc_media_tracks_get', ((1,), (1,)), None, ctypes.c_uint, Media, ctypes.POINTER(ctypes.POINTER(MediaTrack)))) DCNL DCSP return f(p_md, tracks)
 DCSP f = (_Cfunctions.get('libvlc_media_get_codec_description', None) or _Cfunction('libvlc_media_get_codec_description', ((1,), (1,)), None, ctypes.c_char_p, TrackType, ctypes.c_uint32)) DCNL DCSP return f(i_type, i_codec)
 DCSP f = (_Cfunctions.get('libvlc_media_tracks_release', None) or _Cfunction('libvlc_media_tracks_release', ((1,), (1,)), None, None, ctypes.POINTER(MediaTrack), ctypes.c_uint)) DCNL DCSP return f(p_tracks, i_count)
 DCSP f = (_Cfunctions.get('libvlc_media_get_type', None) or _Cfunction('libvlc_media_get_type', ((1,),), None, MediaType, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_new', None) or _Cfunction('libvlc_media_discoverer_new', ((1,), (1,)), class_result(MediaDiscoverer), ctypes.c_void_p, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_inst, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_start', None) or _Cfunction('libvlc_media_discoverer_start', ((1,),), None, ctypes.c_int, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_stop', None) or _Cfunction('libvlc_media_discoverer_stop', ((1,),), None, None, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_release', None) or _Cfunction('libvlc_media_discoverer_release', ((1,),), None, None, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_localized_name', None) or _Cfunction('libvlc_media_discoverer_localized_name', ((1,),), string_result, ctypes.c_void_p, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_media_list', None) or _Cfunction('libvlc_media_discoverer_media_list', ((1,),), class_result(MediaList), ctypes.c_void_p, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_event_manager', None) or _Cfunction('libvlc_media_discoverer_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_discoverer_is_running', None) or _Cfunction('libvlc_media_discoverer_is_running', ((1,),), None, ctypes.c_int, MediaDiscoverer)) DCNL DCSP return f(p_mdis)
 DCSP f = (_Cfunctions.get('libvlc_media_library_new', None) or _Cfunction('libvlc_media_library_new', ((1,),), class_result(MediaLibrary), ctypes.c_void_p, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_media_library_release', None) or _Cfunction('libvlc_media_library_release', ((1,),), None, None, MediaLibrary)) DCNL DCSP return f(p_mlib)
 DCSP f = (_Cfunctions.get('libvlc_media_library_retain', None) or _Cfunction('libvlc_media_library_retain', ((1,),), None, None, MediaLibrary)) DCNL DCSP return f(p_mlib)
 DCSP f = (_Cfunctions.get('libvlc_media_library_load', None) or _Cfunction('libvlc_media_library_load', ((1,),), None, ctypes.c_int, MediaLibrary)) DCNL DCSP return f(p_mlib)
 DCSP f = (_Cfunctions.get('libvlc_media_library_media_list', None) or _Cfunction('libvlc_media_library_media_list', ((1,),), class_result(MediaList), ctypes.c_void_p, MediaLibrary)) DCNL DCSP return f(p_mlib)
 DCSP f = (_Cfunctions.get('libvlc_media_list_new', None) or _Cfunction('libvlc_media_list_new', ((1,),), class_result(MediaList), ctypes.c_void_p, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_media_list_release', None) or _Cfunction('libvlc_media_list_release', ((1,),), None, None, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_retain', None) or _Cfunction('libvlc_media_list_retain', ((1,),), None, None, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_set_media', None) or _Cfunction('libvlc_media_list_set_media', ((1,), (1,)), None, None, MediaList, Media)) DCNL DCSP return f(p_ml, p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_list_media', None) or _Cfunction('libvlc_media_list_media', ((1,),), class_result(Media), ctypes.c_void_p, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_add_media', None) or _Cfunction('libvlc_media_list_add_media', ((1,), (1,)), None, ctypes.c_int, MediaList, Media)) DCNL DCSP return f(p_ml, p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_list_insert_media', None) or _Cfunction('libvlc_media_list_insert_media', ((1,), (1,), (1,)), None, ctypes.c_int, MediaList, Media, ctypes.c_int)) DCNL DCSP return f(p_ml, p_md, i_pos)
 DCSP f = (_Cfunctions.get('libvlc_media_list_remove_index', None) or _Cfunction('libvlc_media_list_remove_index', ((1,), (1,)), None, ctypes.c_int, MediaList, ctypes.c_int)) DCNL DCSP return f(p_ml, i_pos)
 DCSP f = (_Cfunctions.get('libvlc_media_list_count', None) or _Cfunction('libvlc_media_list_count', ((1,),), None, ctypes.c_int, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_item_at_index', None) or _Cfunction('libvlc_media_list_item_at_index', ((1,), (1,)), class_result(Media), ctypes.c_void_p, MediaList, ctypes.c_int)) DCNL DCSP return f(p_ml, i_pos)
 DCSP f = (_Cfunctions.get('libvlc_media_list_index_of_item', None) or _Cfunction('libvlc_media_list_index_of_item', ((1,), (1,)), None, ctypes.c_int, MediaList, Media)) DCNL DCSP return f(p_ml, p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_list_is_readonly', None) or _Cfunction('libvlc_media_list_is_readonly', ((1,),), None, ctypes.c_int, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_lock', None) or _Cfunction('libvlc_media_list_lock', ((1,),), None, None, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_unlock', None) or _Cfunction('libvlc_media_list_unlock', ((1,),), None, None, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_event_manager', None) or _Cfunction('libvlc_media_list_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, MediaList)) DCNL DCSP return f(p_ml)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_new', None) or _Cfunction('libvlc_media_list_player_new', ((1,),), class_result(MediaListPlayer), ctypes.c_void_p, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_release', None) or _Cfunction('libvlc_media_list_player_release', ((1,),), None, None, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_retain', None) or _Cfunction('libvlc_media_list_player_retain', ((1,),), None, None, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_event_manager', None) or _Cfunction('libvlc_media_list_player_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_set_media_player', None) or _Cfunction('libvlc_media_list_player_set_media_player', ((1,), (1,)), None, None, MediaListPlayer, MediaPlayer)) DCNL DCSP return f(p_mlp, p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_get_media_player', None) or _Cfunction('libvlc_media_list_player_get_media_player', ((1,),), class_result(MediaPlayer), ctypes.c_void_p, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_set_media_list', None) or _Cfunction('libvlc_media_list_player_set_media_list', ((1,), (1,)), None, None, MediaListPlayer, MediaList)) DCNL DCSP return f(p_mlp, p_mlist)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_play', None) or _Cfunction('libvlc_media_list_player_play', ((1,),), None, None, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_pause', None) or _Cfunction('libvlc_media_list_player_pause', ((1,),), None, None, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_is_playing', None) or _Cfunction('libvlc_media_list_player_is_playing', ((1,),), None, ctypes.c_int, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_get_state', None) or _Cfunction('libvlc_media_list_player_get_state', ((1,),), None, State, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_play_item_at_index', None) or _Cfunction('libvlc_media_list_player_play_item_at_index', ((1,), (1,)), None, ctypes.c_int, MediaListPlayer, ctypes.c_int)) DCNL DCSP return f(p_mlp, i_index)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_play_item', None) or _Cfunction('libvlc_media_list_player_play_item', ((1,), (1,)), None, ctypes.c_int, MediaListPlayer, Media)) DCNL DCSP return f(p_mlp, p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_stop', None) or _Cfunction('libvlc_media_list_player_stop', ((1,),), None, None, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_next', None) or _Cfunction('libvlc_media_list_player_next', ((1,),), None, ctypes.c_int, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_previous', None) or _Cfunction('libvlc_media_list_player_previous', ((1,),), None, ctypes.c_int, MediaListPlayer)) DCNL DCSP return f(p_mlp)
 DCSP f = (_Cfunctions.get('libvlc_media_list_player_set_playback_mode', None) or _Cfunction('libvlc_media_list_player_set_playback_mode', ((1,), (1,)), None, None, MediaListPlayer, PlaybackMode)) DCNL DCSP return f(p_mlp, e_mode)
 DCSP f = (_Cfunctions.get('libvlc_media_player_new', None) or _Cfunction('libvlc_media_player_new', ((1,),), class_result(MediaPlayer), ctypes.c_void_p, Instance)) DCNL DCSP return f(p_libvlc_instance)
 DCSP f = (_Cfunctions.get('libvlc_media_player_new_from_media', None) or _Cfunction('libvlc_media_player_new_from_media', ((1,),), class_result(MediaPlayer), ctypes.c_void_p, Media)) DCNL DCSP return f(p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_player_release', None) or _Cfunction('libvlc_media_player_release', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_retain', None) or _Cfunction('libvlc_media_player_retain', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_media', None) or _Cfunction('libvlc_media_player_set_media', ((1,), (1,)), None, None, MediaPlayer, Media)) DCNL DCSP return f(p_mi, p_md)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_media', None) or _Cfunction('libvlc_media_player_get_media', ((1,),), class_result(Media), ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_event_manager', None) or _Cfunction('libvlc_media_player_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_is_playing', None) or _Cfunction('libvlc_media_player_is_playing', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_play', None) or _Cfunction('libvlc_media_player_play', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_pause', None) or _Cfunction('libvlc_media_player_set_pause', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(mp, do_pause)
 DCSP f = (_Cfunctions.get('libvlc_media_player_pause', None) or _Cfunction('libvlc_media_player_pause', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_stop', None) or _Cfunction('libvlc_media_player_stop', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_callbacks', None) or _Cfunction('libvlc_video_set_callbacks', ((1,), (1,), (1,), (1,), (1,)), None, None, MediaPlayer, VideoLockCb, VideoUnlockCb, VideoDisplayCb, ctypes.c_void_p)) DCNL DCSP return f(mp, lock, unlock, display, opaque)
 DCSP f = (_Cfunctions.get('libvlc_video_set_format', None) or _Cfunction('libvlc_video_set_format', ((1,), (1,), (1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p, ctypes.c_uint, ctypes.c_uint, ctypes.c_uint)) DCNL DCSP return f(mp, chroma, width, height, pitch)
 DCSP f = (_Cfunctions.get('libvlc_video_set_format_callbacks', None) or _Cfunction('libvlc_video_set_format_callbacks', ((1,), (1,), (1,)), None, None, MediaPlayer, VideoFormatCb, VideoCleanupCb)) DCNL DCSP return f(mp, setup, cleanup)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_nsobject', None) or _Cfunction('libvlc_media_player_set_nsobject', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_void_p)) DCNL DCSP return f(p_mi, drawable)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_nsobject', None) or _Cfunction('libvlc_media_player_get_nsobject', ((1,),), None, ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_agl', None) or _Cfunction('libvlc_media_player_set_agl', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_uint32)) DCNL DCSP return f(p_mi, drawable)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_agl', None) or _Cfunction('libvlc_media_player_get_agl', ((1,),), None, ctypes.c_uint32, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_xwindow', None) or _Cfunction('libvlc_media_player_set_xwindow', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_uint32)) DCNL DCSP return f(p_mi, drawable)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_xwindow', None) or _Cfunction('libvlc_media_player_get_xwindow', ((1,),), None, ctypes.c_uint32, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_hwnd', None) or _Cfunction('libvlc_media_player_set_hwnd', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_void_p)) DCNL DCSP return f(p_mi, drawable)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_hwnd', None) or _Cfunction('libvlc_media_player_get_hwnd', ((1,),), None, ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_android_context', None) or _Cfunction('libvlc_media_player_set_android_context', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_void_p, ctypes.c_void_p)) DCNL DCSP return f(p_mi, p_jvm, p_awindow_handler)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_callbacks', None) or _Cfunction('libvlc_audio_set_callbacks', ((1,), (1,), (1,), (1,), (1,), (1,), (1,)), None, None, MediaPlayer, AudioPlayCb, AudioPauseCb, AudioResumeCb, AudioFlushCb, AudioDrainCb, ctypes.c_void_p)) DCNL DCSP return f(mp, play, pause, resume, flush, drain, opaque)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_volume_callback', None) or _Cfunction('libvlc_audio_set_volume_callback', ((1,), (1,)), None, None, MediaPlayer, AudioSetVolumeCb)) DCNL DCSP return f(mp, set_volume)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_format_callbacks', None) or _Cfunction('libvlc_audio_set_format_callbacks', ((1,), (1,), (1,)), None, None, MediaPlayer, AudioSetupCb, AudioCleanupCb)) DCNL DCSP return f(mp, setup, cleanup)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_format', None) or _Cfunction('libvlc_audio_set_format', ((1,), (1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p, ctypes.c_uint, ctypes.c_uint)) DCNL DCSP return f(mp, format, rate, channels)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_length', None) or _Cfunction('libvlc_media_player_get_length', ((1,),), None, ctypes.c_longlong, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_time', None) or _Cfunction('libvlc_media_player_get_time', ((1,),), None, ctypes.c_longlong, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_time', None) or _Cfunction('libvlc_media_player_set_time', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_longlong)) DCNL DCSP return f(p_mi, i_time)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_position', None) or _Cfunction('libvlc_media_player_get_position', ((1,),), None, ctypes.c_float, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_position', None) or _Cfunction('libvlc_media_player_set_position', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_float)) DCNL DCSP return f(p_mi, f_pos)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_chapter', None) or _Cfunction('libvlc_media_player_set_chapter', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_chapter)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_chapter', None) or _Cfunction('libvlc_media_player_get_chapter', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_chapter_count', None) or _Cfunction('libvlc_media_player_get_chapter_count', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_will_play', None) or _Cfunction('libvlc_media_player_will_play', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_chapter_count_for_title', None) or _Cfunction('libvlc_media_player_get_chapter_count_for_title', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_title)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_title', None) or _Cfunction('libvlc_media_player_set_title', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_title)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_title', None) or _Cfunction('libvlc_media_player_get_title', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_title_count', None) or _Cfunction('libvlc_media_player_get_title_count', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_previous_chapter', None) or _Cfunction('libvlc_media_player_previous_chapter', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_next_chapter', None) or _Cfunction('libvlc_media_player_next_chapter', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_rate', None) or _Cfunction('libvlc_media_player_get_rate', ((1,),), None, ctypes.c_float, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_rate', None) or _Cfunction('libvlc_media_player_set_rate', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_float)) DCNL DCSP return f(p_mi, rate)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_state', None) or _Cfunction('libvlc_media_player_get_state', ((1,),), None, State, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_fps', None) or _Cfunction('libvlc_media_player_get_fps', ((1,),), None, ctypes.c_float, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_has_vout', None) or _Cfunction('libvlc_media_player_has_vout', ((1,),), None, ctypes.c_uint, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_is_seekable', None) or _Cfunction('libvlc_media_player_is_seekable', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_can_pause', None) or _Cfunction('libvlc_media_player_can_pause', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_program_scrambled', None) or _Cfunction('libvlc_media_player_program_scrambled', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_next_frame', None) or _Cfunction('libvlc_media_player_next_frame', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_media_player_navigate', None) or _Cfunction('libvlc_media_player_navigate', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, navigate)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_video_title_display', None) or _Cfunction('libvlc_media_player_set_video_title_display', ((1,), (1,), (1,)), None, None, MediaPlayer, Position, ctypes.c_int)) DCNL DCSP return f(p_mi, position, timeout)
 DCSP f = (_Cfunctions.get('libvlc_track_description_list_release', None) or _Cfunction('libvlc_track_description_list_release', ((1,),), None, None, ctypes.POINTER(TrackDescription))) DCNL DCSP return f(p_track_description)
 DCSP f = (_Cfunctions.get('libvlc_toggle_fullscreen', None) or _Cfunction('libvlc_toggle_fullscreen', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_set_fullscreen', None) or _Cfunction('libvlc_set_fullscreen', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, b_fullscreen)
 DCSP f = (_Cfunctions.get('libvlc_get_fullscreen', None) or _Cfunction('libvlc_get_fullscreen', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_key_input', None) or _Cfunction('libvlc_video_set_key_input', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, on)
 DCSP f = (_Cfunctions.get('libvlc_video_set_mouse_input', None) or _Cfunction('libvlc_video_set_mouse_input', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, on)
 DCSP f = (_Cfunctions.get('libvlc_video_get_size', None) or _Cfunction('libvlc_video_get_size', ((1,), (1,), (2,), (2,)), None, ctypes.c_int, MediaPlayer, ctypes.c_uint, ctypes.POINTER(ctypes.c_uint), ctypes.POINTER(ctypes.c_uint))) DCNL DCSP return f(p_mi, num)
 DCSP f = (_Cfunctions.get('libvlc_video_get_cursor', None) or _Cfunction('libvlc_video_get_cursor', ((1,), (1,), (2,), (2,)), None, ctypes.c_int, MediaPlayer, ctypes.c_uint, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int))) DCNL DCSP return f(p_mi, num)
 DCSP f = (_Cfunctions.get('libvlc_video_get_scale', None) or _Cfunction('libvlc_video_get_scale', ((1,),), None, ctypes.c_float, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_scale', None) or _Cfunction('libvlc_video_set_scale', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_float)) DCNL DCSP return f(p_mi, f_factor)
 DCSP f = (_Cfunctions.get('libvlc_video_get_aspect_ratio', None) or _Cfunction('libvlc_video_get_aspect_ratio', ((1,),), string_result, ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_aspect_ratio', None) or _Cfunction('libvlc_video_set_aspect_ratio', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_aspect)
 DCSP f = (_Cfunctions.get('libvlc_video_get_spu', None) or _Cfunction('libvlc_video_get_spu', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_get_spu_count', None) or _Cfunction('libvlc_video_get_spu_count', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_get_spu_description', None) or _Cfunction('libvlc_video_get_spu_description', ((1,),), None, ctypes.POINTER(TrackDescription), MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_spu', None) or _Cfunction('libvlc_video_set_spu', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_spu)
 DCSP f = (_Cfunctions.get('libvlc_video_set_subtitle_file', None) or _Cfunction('libvlc_video_set_subtitle_file', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_subtitle)
 DCSP f = (_Cfunctions.get('libvlc_video_get_spu_delay', None) or _Cfunction('libvlc_video_get_spu_delay', ((1,),), None, ctypes.c_int64, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_spu_delay', None) or _Cfunction('libvlc_video_set_spu_delay', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int64)) DCNL DCSP return f(p_mi, i_delay)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_full_title_descriptions', None) or _Cfunction('libvlc_media_player_get_full_title_descriptions', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.POINTER(ctypes.POINTER(TitleDescription)))) DCNL DCSP return f(p_mi, titles)
 DCSP f = (_Cfunctions.get('libvlc_title_descriptions_release', None) or _Cfunction('libvlc_title_descriptions_release', ((1,), (1,)), None, None, ctypes.POINTER(TitleDescription), ctypes.c_uint)) DCNL DCSP return f(p_titles, i_count)
 DCSP f = (_Cfunctions.get('libvlc_media_player_get_full_chapter_descriptions', None) or _Cfunction('libvlc_media_player_get_full_chapter_descriptions', ((1,), (1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int, ctypes.POINTER(ctypes.POINTER(ChapterDescription)))) DCNL DCSP return f(p_mi, i_chapters_of_title, pp_chapters)
 DCSP f = (_Cfunctions.get('libvlc_chapter_descriptions_release', None) or _Cfunction('libvlc_chapter_descriptions_release', ((1,), (1,)), None, None, ctypes.POINTER(ChapterDescription), ctypes.c_uint)) DCNL DCSP return f(p_chapters, i_count)
 DCSP f = (_Cfunctions.get('libvlc_video_get_crop_geometry', None) or _Cfunction('libvlc_video_get_crop_geometry', ((1,),), string_result, ctypes.c_void_p, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_crop_geometry', None) or _Cfunction('libvlc_video_set_crop_geometry', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_geometry)
 DCSP f = (_Cfunctions.get('libvlc_video_get_teletext', None) or _Cfunction('libvlc_video_get_teletext', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_teletext', None) or _Cfunction('libvlc_video_set_teletext', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_page)
 DCSP f = (_Cfunctions.get('libvlc_toggle_teletext', None) or _Cfunction('libvlc_toggle_teletext', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_get_track_count', None) or _Cfunction('libvlc_video_get_track_count', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_get_track_description', None) or _Cfunction('libvlc_video_get_track_description', ((1,),), None, ctypes.POINTER(TrackDescription), MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_get_track', None) or _Cfunction('libvlc_video_get_track', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_video_set_track', None) or _Cfunction('libvlc_video_set_track', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_track)
 DCSP f = (_Cfunctions.get('libvlc_video_take_snapshot', None) or _Cfunction('libvlc_video_take_snapshot', ((1,), (1,), (1,), (1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_uint, ctypes.c_char_p, ctypes.c_int, ctypes.c_int)) DCNL DCSP return f(p_mi, num, psz_filepath, i_width, i_height)
 DCSP f = (_Cfunctions.get('libvlc_video_set_deinterlace', None) or _Cfunction('libvlc_video_set_deinterlace', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_mode)
 DCSP f = (_Cfunctions.get('libvlc_video_get_marquee_int', None) or _Cfunction('libvlc_video_get_marquee_int', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, option)
 DCSP f = (_Cfunctions.get('libvlc_video_get_marquee_string', None) or _Cfunction('libvlc_video_get_marquee_string', ((1,), (1,)), string_result, ctypes.c_void_p, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, option)
 DCSP f = (_Cfunctions.get('libvlc_video_set_marquee_int', None) or _Cfunction('libvlc_video_set_marquee_int', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_int)) DCNL DCSP return f(p_mi, option, i_val)
 DCSP f = (_Cfunctions.get('libvlc_video_set_marquee_string', None) or _Cfunction('libvlc_video_set_marquee_string', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_char_p)) DCNL DCSP return f(p_mi, option, psz_text)
 DCSP f = (_Cfunctions.get('libvlc_video_get_logo_int', None) or _Cfunction('libvlc_video_get_logo_int', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, option)
 DCSP f = (_Cfunctions.get('libvlc_video_set_logo_int', None) or _Cfunction('libvlc_video_set_logo_int', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_int)) DCNL DCSP return f(p_mi, option, value)
 DCSP f = (_Cfunctions.get('libvlc_video_set_logo_string', None) or _Cfunction('libvlc_video_set_logo_string', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_char_p)) DCNL DCSP return f(p_mi, option, psz_value)
 DCSP f = (_Cfunctions.get('libvlc_video_get_adjust_int', None) or _Cfunction('libvlc_video_get_adjust_int', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, option)
 DCSP f = (_Cfunctions.get('libvlc_video_set_adjust_int', None) or _Cfunction('libvlc_video_set_adjust_int', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_int)) DCNL DCSP return f(p_mi, option, value)
 DCSP f = (_Cfunctions.get('libvlc_video_get_adjust_float', None) or _Cfunction('libvlc_video_get_adjust_float', ((1,), (1,)), None, ctypes.c_float, MediaPlayer, ctypes.c_uint)) DCNL DCSP return f(p_mi, option)
 DCSP f = (_Cfunctions.get('libvlc_video_set_adjust_float', None) or _Cfunction('libvlc_video_set_adjust_float', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_uint, ctypes.c_float)) DCNL DCSP return f(p_mi, option, value)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_list_get', None) or _Cfunction('libvlc_audio_output_list_get', ((1,),), None, ctypes.POINTER(AudioOutput), Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_list_release', None) or _Cfunction('libvlc_audio_output_list_release', ((1,),), None, None, ctypes.POINTER(AudioOutput))) DCNL DCSP return f(p_list)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_set', None) or _Cfunction('libvlc_audio_output_set', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_device_enum', None) or _Cfunction('libvlc_audio_output_device_enum', ((1,),), None, ctypes.POINTER(AudioOutputDevice), MediaPlayer)) DCNL DCSP return f(mp)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_device_list_get', None) or _Cfunction('libvlc_audio_output_device_list_get', ((1,), (1,)), None, ctypes.POINTER(AudioOutputDevice), Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, aout)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_device_list_release', None) or _Cfunction('libvlc_audio_output_device_list_release', ((1,),), None, None, ctypes.POINTER(AudioOutputDevice))) DCNL DCSP return f(p_list)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_device_set', None) or _Cfunction('libvlc_audio_output_device_set', ((1,), (1,), (1,)), None, None, MediaPlayer, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(mp, module, device_id)
 DCSP f = (_Cfunctions.get('libvlc_audio_output_device_get', None) or _Cfunction('libvlc_audio_output_device_get', ((1,),), None, ctypes.c_char_p, MediaPlayer)) DCNL DCSP return f(mp)
 DCSP f = (_Cfunctions.get('libvlc_audio_toggle_mute', None) or _Cfunction('libvlc_audio_toggle_mute', ((1,),), None, None, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_mute', None) or _Cfunction('libvlc_audio_get_mute', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_mute', None) or _Cfunction('libvlc_audio_set_mute', ((1,), (1,)), None, None, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, status)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_volume', None) or _Cfunction('libvlc_audio_get_volume', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_volume', None) or _Cfunction('libvlc_audio_set_volume', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_volume)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_track_count', None) or _Cfunction('libvlc_audio_get_track_count', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_track_description', None) or _Cfunction('libvlc_audio_get_track_description', ((1,),), None, ctypes.POINTER(TrackDescription), MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_track', None) or _Cfunction('libvlc_audio_get_track', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_track', None) or _Cfunction('libvlc_audio_set_track', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_track)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_channel', None) or _Cfunction('libvlc_audio_get_channel', ((1,),), None, ctypes.c_int, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_channel', None) or _Cfunction('libvlc_audio_set_channel', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, channel)
 DCSP f = (_Cfunctions.get('libvlc_audio_get_delay', None) or _Cfunction('libvlc_audio_get_delay', ((1,),), None, ctypes.c_int64, MediaPlayer)) DCNL DCSP return f(p_mi)
 DCSP f = (_Cfunctions.get('libvlc_audio_set_delay', None) or _Cfunction('libvlc_audio_set_delay', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int64)) DCNL DCSP return f(p_mi, i_delay)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_get_preset_count', None) or _Cfunction('libvlc_audio_equalizer_get_preset_count', (), None, ctypes.c_uint)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_get_preset_name', None) or _Cfunction('libvlc_audio_equalizer_get_preset_name', ((1,),), None, ctypes.c_char_p, ctypes.c_uint)) DCNL DCSP return f(u_index)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_get_band_count', None) or _Cfunction('libvlc_audio_equalizer_get_band_count', (), None, ctypes.c_uint)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_get_band_frequency', None) or _Cfunction('libvlc_audio_equalizer_get_band_frequency', ((1,),), None, ctypes.c_float, ctypes.c_uint)) DCNL DCSP return f(u_index)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_new', None) or _Cfunction('libvlc_audio_equalizer_new', (), None, ctypes.c_void_p)) DCNL DCSP return f()
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_new_from_preset', None) or _Cfunction('libvlc_audio_equalizer_new_from_preset', ((1,),), None, ctypes.c_void_p, ctypes.c_uint)) DCNL DCSP return f(u_index)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_release', None) or _Cfunction('libvlc_audio_equalizer_release', ((1,),), None, None, ctypes.c_void_p)) DCNL DCSP return f(p_equalizer)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_set_preamp', None) or _Cfunction('libvlc_audio_equalizer_set_preamp', ((1,), (1,)), None, ctypes.c_int, ctypes.c_void_p, ctypes.c_float)) DCNL DCSP return f(p_equalizer, f_preamp)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_get_preamp', None) or _Cfunction('libvlc_audio_equalizer_get_preamp', ((1,),), None, ctypes.c_float, ctypes.c_void_p)) DCNL DCSP return f(p_equalizer)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_set_amp_at_index', None) or _Cfunction('libvlc_audio_equalizer_set_amp_at_index', ((1,), (1,), (1,)), None, ctypes.c_int, ctypes.c_void_p, ctypes.c_float, ctypes.c_uint)) DCNL DCSP return f(p_equalizer, f_amp, u_band)
 DCSP f = (_Cfunctions.get('libvlc_audio_equalizer_get_amp_at_index', None) or _Cfunction('libvlc_audio_equalizer_get_amp_at_index', ((1,), (1,)), None, ctypes.c_float, ctypes.c_void_p, ctypes.c_uint)) DCNL DCSP return f(p_equalizer, u_band)
 DCSP f = (_Cfunctions.get('libvlc_media_player_set_equalizer', None) or _Cfunction('libvlc_media_player_set_equalizer', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_void_p)) DCNL DCSP return f(p_mi, p_equalizer)
 DCSP f = (_Cfunctions.get('libvlc_vlm_release', None) or _Cfunction('libvlc_vlm_release', ((1,),), None, None, Instance)) DCNL DCSP return f(p_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_add_broadcast', None) or _Cfunction('libvlc_vlm_add_broadcast', ((1,), (1,), (1,), (1,), (1,), (1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int, ListPOINTER(ctypes.c_char_p), ctypes.c_int, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop)
 DCSP f = (_Cfunctions.get('libvlc_vlm_add_vod', None) or _Cfunction('libvlc_vlm_add_vod', ((1,), (1,), (1,), (1,), (1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int, ListPOINTER(ctypes.c_char_p), ctypes.c_int, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_input, i_options, ppsz_options, b_enabled, psz_mux)
 DCSP f = (_Cfunctions.get('libvlc_vlm_del_media', None) or _Cfunction('libvlc_vlm_del_media', ((1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_vlm_set_enabled', None) or _Cfunction('libvlc_vlm_set_enabled', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, b_enabled)
 DCSP f = (_Cfunctions.get('libvlc_vlm_set_output', None) or _Cfunction('libvlc_vlm_set_output', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_output)
 DCSP f = (_Cfunctions.get('libvlc_vlm_set_input', None) or _Cfunction('libvlc_vlm_set_input', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_input)
 DCSP f = (_Cfunctions.get('libvlc_vlm_add_input', None) or _Cfunction('libvlc_vlm_add_input', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_input)
 DCSP f = (_Cfunctions.get('libvlc_vlm_set_loop', None) or _Cfunction('libvlc_vlm_set_loop', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, b_loop)
 DCSP f = (_Cfunctions.get('libvlc_vlm_set_mux', None) or _Cfunction('libvlc_vlm_set_mux', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name, psz_mux)
 DCSP f = (_Cfunctions.get('libvlc_vlm_change_media', None) or _Cfunction('libvlc_vlm_change_media', ((1,), (1,), (1,), (1,), (1,), (1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int, ListPOINTER(ctypes.c_char_p), ctypes.c_int, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, psz_input, psz_output, i_options, ppsz_options, b_enabled, b_loop)
 DCSP f = (_Cfunctions.get('libvlc_vlm_play_media', None) or _Cfunction('libvlc_vlm_play_media', ((1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_vlm_stop_media', None) or _Cfunction('libvlc_vlm_stop_media', ((1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_vlm_pause_media', None) or _Cfunction('libvlc_vlm_pause_media', ((1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_vlm_seek_media', None) or _Cfunction('libvlc_vlm_seek_media', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_float)) DCNL DCSP return f(p_instance, psz_name, f_percentage)
 DCSP f = (_Cfunctions.get('libvlc_vlm_show_media', None) or _Cfunction('libvlc_vlm_show_media', ((1,), (1,)), string_result, ctypes.c_void_p, Instance, ctypes.c_char_p)) DCNL DCSP return f(p_instance, psz_name)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_position', None) or _Cfunction('libvlc_vlm_get_media_instance_position', ((1,), (1,), (1,)), None, ctypes.c_float, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_time', None) or _Cfunction('libvlc_vlm_get_media_instance_time', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_length', None) or _Cfunction('libvlc_vlm_get_media_instance_length', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_rate', None) or _Cfunction('libvlc_vlm_get_media_instance_rate', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_title', None) or _Cfunction('libvlc_vlm_get_media_instance_title', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_chapter', None) or _Cfunction('libvlc_vlm_get_media_instance_chapter', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_media_instance_seekable', None) or _Cfunction('libvlc_vlm_get_media_instance_seekable', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
 DCSP f = (_Cfunctions.get('libvlc_vlm_get_event_manager', None) or _Cfunction('libvlc_vlm_get_event_manager', ((1,),), class_result(EventManager), ctypes.c_void_p, Instance)) DCNL DCSP return f(p_instance)
 DCSP return callback
 DCSP t = [int(i) for i in v.split('.')] DCNL DCSP if (len(t) == 3): DCNL DCSP  DCSP t.append(0) DCNL DCSP elif (len(t) != 4): DCNL DCSP  DCSP raise ValueError(('"i.i.i[.i]": DCSP %r' % (v,))) DCNL DCSP if ((min(t) < 0) or (max(t) > 255)): DCNL DCSP  DCSP raise ValueError(('[0..255]: DCSP %r' % (v,))) DCNL DCSP i = t.pop(0) DCNL DCSP while t: DCNL DCSP  DCSP i = ((i << 8) + t.pop(0)) DCNL DCSP return i
 DCSP try: DCNL DCSP  DCSP return _dot2int(__version__.split('-')[(-1)]) DCNL DCSP except (NameError, ValueError): DCNL DCSP  DCSP return 0
 DCSP try: DCNL DCSP  DCSP return _dot2int(bytes_to_str(libvlc_get_version()).split()[0]) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 0
 DCSP l = [('event DCSP %s' % (event.type,))] DCNL DCSP if args: DCNL DCSP  DCSP l.extend(map(str, args)) DCNL DCSP if kwds: DCNL DCSP  DCSP l.extend(sorted((('%s=%s' % t) for t in kwds.items()))) DCNL DCSP print ('Debug DCSP callback DCSP (%s)' % ', DCSP '.join(l))
 DCSP from twisted.internet import reactor DCNL DCSP def on_tribler_shutdown(_): DCNL DCSP  DCSP reactor.stop() DCNL DCSP def shutdown(session, *_): DCNL DCSP  DCSP logging.info('Stopping DCSP Tribler DCSP core') DCNL DCSP  DCSP session.shutdown().addCallback(on_tribler_shutdown) DCNL DCSP sys.path.insert(0, base_path) DCNL DCSP def get_keyring_password(service, username): DCNL DCSP  DCSP child_pipe.send(('get_keyring_password', {'service': service, 'username': username})) DCNL DCSP  DCSP return child_pipe.recv() DCNL DCSP def set_keyring_password(service, username, password): DCNL DCSP  DCSP child_pipe.send(('set_keyring_password', {'service': service, 'username': username, 'password': password})) DCNL DCSP  DCSP child_pipe.recv() DCNL DCSP def patch_wallet_methods(): DCNL DCSP  DCSP BitcoinWallet.get_wallet_password = (lambda _: get_keyring_password('tribler', 'btc_wallet_password')) DCNL DCSP  DCSP BitcoinWallet.set_wallet_password = (lambda _, password: set_keyring_password('tribler', 'btc_wallet_password', password)) DCNL DCSP def patch_iom_methods(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sys.path.append(os.path.join(get_lib_path(), 'internetofmoney')) DCNL DCSP  DCSP  DCSP get_symmetric_key = (lambda _: get_keyring_password('internetofmoney', 'symmetric_key')) DCNL DCSP  DCSP  DCSP set_symmetric_key = (lambda _, password: set_keyring_password('internetofmoney', 'symmetric_key', password)) DCNL DCSP  DCSP  DCSP from Tribler.internetofmoney.Managers.ABN.ABNManager import ABNManager DCNL DCSP  DCSP  DCSP ABNManager.get_symmetric_key = get_symmetric_key DCNL DCSP  DCSP  DCSP ABNManager.set_symmetric_key = set_symmetric_key DCNL DCSP  DCSP  DCSP from Tribler.internetofmoney.Managers.PayPal.PayPalManager import PayPalManager DCNL DCSP  DCSP  DCSP PayPalManager.get_symmetric_key = get_symmetric_key DCNL DCSP  DCSP  DCSP PayPalManager.set_symmetric_key = set_symmetric_key DCNL DCSP  DCSP  DCSP from Tribler.internetofmoney.Managers.Rabo.RaboManager import RaboManager DCNL DCSP  DCSP  DCSP RaboManager.get_symmetric_key = get_symmetric_key DCNL DCSP  DCSP  DCSP RaboManager.set_symmetric_key = set_symmetric_key DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP def start_tribler(): DCNL DCSP  DCSP config = TriblerConfig() DCNL DCSP  DCSP patch_wallet_methods() DCNL DCSP  DCSP patch_iom_methods() DCNL DCSP  DCSP config.set_http_api_port(API_PORT) DCNL DCSP  DCSP config.set_http_api_enabled(True) DCNL DCSP  DCSP process_checker = ProcessChecker(config.get_state_dir()) DCNL DCSP  DCSP if process_checker.already_running: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP session = Session(config) DCNL DCSP  DCSP signal.signal(signal.SIGTERM, (lambda signum, stack: shutdown(session, signum, stack))) DCNL DCSP  DCSP session.start() DCNL DCSP reactor.callWhenRunning(start_tribler) DCNL DCSP reactor.run()
 DCSP md5_hash = hashlib.md5() DCNL DCSP md5_hash.update(name.encode('utf-8')) DCNL DCSP md5_str_hash = md5_hash.hexdigest() DCNL DCSP red = ((int(md5_str_hash[0:10], 16) % 128) + 100) DCNL DCSP green = ((int(md5_str_hash[10:20], 16) % 128) + 100) DCNL DCSP blue = ((int(md5_str_hash[20:30], 16) % 128) + 100) DCNL DCSP return ('#%02x%02x%02x' % (red, green, blue))
 DCSP now = datetime.now() DCNL DCSP if isinstance(time, int): DCNL DCSP  DCSP diff = (now - datetime.fromtimestamp(time)) DCNL DCSP elif isinstance(time, datetime): DCNL DCSP  DCSP diff = (now - time) DCNL DCSP elif (not time): DCNL DCSP  DCSP diff = (now - now) DCNL DCSP second_diff = diff.seconds DCNL DCSP day_diff = diff.days DCNL DCSP if (day_diff < 0): DCNL DCSP  DCSP return '' DCNL DCSP if (day_diff == 0): DCNL DCSP  DCSP if (second_diff < 10): DCNL DCSP  DCSP  DCSP return 'just DCSP now' DCNL DCSP  DCSP if (second_diff < 60): DCNL DCSP  DCSP  DCSP return (str(second_diff) + ' DCSP seconds DCSP ago') DCNL DCSP  DCSP if (second_diff < 120): DCNL DCSP  DCSP  DCSP return 'a DCSP minute DCSP ago' DCNL DCSP  DCSP if (second_diff < 3600): DCNL DCSP  DCSP  DCSP return (str((second_diff / 60)) + ' DCSP minutes DCSP ago') DCNL DCSP  DCSP if (second_diff < 7200): DCNL DCSP  DCSP  DCSP return 'an DCSP hour DCSP ago' DCNL DCSP  DCSP if (second_diff < 86400): DCNL DCSP  DCSP  DCSP return (str((second_diff / 3600)) + ' DCSP hours DCSP ago') DCNL DCSP if (day_diff == 1): DCNL DCSP  DCSP return 'yesterday' DCNL DCSP if (day_diff < 7): DCNL DCSP  DCSP return (str(day_diff) + ' DCSP days DCSP ago') DCNL DCSP if (day_diff < 31): DCNL DCSP  DCSP return (str((day_diff / 7)) + ' DCSP weeks DCSP ago') DCNL DCSP if (day_diff < 365): DCNL DCSP  DCSP return (str((day_diff / 30)) + ' DCSP months DCSP ago') DCNL DCSP return (str((day_diff / 365)) + ' DCSP years DCSP ago')
 DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP base_path = os.path.dirname(TriblerGUI.__file__) DCNL DCSP return base_path
 DCSP try: DCNL DCSP  DCSP _ = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP lo = 0 DCNL DCSP hi = len(item_list) DCNL DCSP while (lo < hi): DCNL DCSP  DCSP mid = ((lo + hi) // 2) DCNL DCSP  DCSP if ((item['relevance_score'] == item_list[mid]['relevance_score']) and is_torrent): DCNL DCSP  DCSP  DCSP if (len(split_into_keywords(item['name'])) < len(split_into_keywords(item_list[mid]['name']))): DCNL DCSP  DCSP  DCSP  DCSP hi = mid DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lo = (mid + 1) DCNL DCSP  DCSP elif (item['relevance_score'] > item_list[mid]['relevance_score']): DCNL DCSP  DCSP  DCSP hi = mid DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lo = (mid + 1) DCNL DCSP return lo
 DCSP val = gui_settings.value(value, default) DCNL DCSP if is_bool: DCNL DCSP  DCSP val = ((val == True) or (val == 'true')) DCNL DCSP return val
 DCSP def wrap(f): DCNL DCSP  DCSP def invoke_func(*args, **kwargs): DCNL DCSP  DCSP  DCSP download = args[0] DCNL DCSP  DCSP  DCSP with download.dllock: DCNL DCSP  DCSP  DCSP  DCSP if (download.handle and download.handle.is_valid()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP return default DCNL DCSP  DCSP return invoke_func DCNL DCSP return wrap
 DCSP old_tribler_config_file_loc = os.path.join(TriblerConfig.get_default_state_dir(), 'triblerd.conf') DCNL DCSP if os.path.exists(old_tribler_config_file_loc): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP new_config = TriblerConfig(ConfigObj(old_tribler_config_file_loc, configspec=CONFIG_SPEC_PATH)) DCNL DCSP  DCSP except InvalidConfigException: DCNL DCSP  DCSP  DCSP new_config = TriblerConfig() DCNL DCSP else: DCNL DCSP  DCSP new_config = TriblerConfig() DCNL DCSP libtribler_file_loc = os.path.join(TriblerConfig.get_default_state_dir(), 'libtribler.conf') DCNL DCSP if os.path.exists(libtribler_file_loc): DCNL DCSP  DCSP libtribler_cfg = RawConfigParser() DCNL DCSP  DCSP libtribler_cfg.read(libtribler_file_loc) DCNL DCSP  DCSP new_config = add_libtribler_config(new_config, libtribler_cfg) DCNL DCSP tribler_file_loc = os.path.join(TriblerConfig.get_default_state_dir(), 'tribler.conf') DCNL DCSP if os.path.exists(tribler_file_loc): DCNL DCSP  DCSP tribler_cfg = RawConfigParser() DCNL DCSP  DCSP tribler_cfg.read(tribler_file_loc) DCNL DCSP  DCSP new_config = add_tribler_config(new_config, tribler_cfg) DCNL DCSP return new_config
 DCSP config = new_config.copy() DCNL DCSP for section in old_config.sections(): DCNL DCSP  DCSP for (name, string_value) in old_config.items(section): DCNL DCSP  DCSP  DCSP if (string_value == 'None'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = ast.literal_eval(string_value) DCNL DCSP  DCSP  DCSP except (ValueError, SyntaxError): DCNL DCSP  DCSP  DCSP  DCSP value = string_value DCNL DCSP  DCSP  DCSP temp_config = config.copy() DCNL DCSP  DCSP  DCSP if ((section == 'Tribler') and (name == 'default_anonymity_enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_default_anonymity_enabled(value) DCNL DCSP  DCSP  DCSP if ((section == 'Tribler') and (name == 'default_number_hops')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_default_number_hops(value) DCNL DCSP  DCSP  DCSP if ((section == 'downloadconfig') and (name == 'saveas')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['download_defaults']['saveas'] = value DCNL DCSP  DCSP  DCSP if ((section == 'downloadconfig') and (name == 'seeding_mode')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['download_defaults']['seeding_mode'] = value DCNL DCSP  DCSP  DCSP if ((section == 'downloadconfig') and (name == 'seeding_ratio')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['download_defaults']['seeding_ratio'] = value DCNL DCSP  DCSP  DCSP if ((section == 'downloadconfig') and (name == 'seeding_time')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['download_defaults']['seeding_time'] = value DCNL DCSP  DCSP  DCSP if ((section == 'downloadconfig') and (name == 'version')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['download_defaults']['version'] = value DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP temp_config.validate() DCNL DCSP  DCSP  DCSP  DCSP config = temp_config DCNL DCSP  DCSP  DCSP except InvalidConfigException as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.debug('The DCSP following DCSP field DCSP in DCSP the DCSP old DCSP tribler.conf DCSP was DCSP wrong: DCSP %s', exc.args) DCNL DCSP return config
 DCSP config = new_config.copy() DCNL DCSP for section in old_config.sections(): DCNL DCSP  DCSP for (name, string_value) in old_config.items(section): DCNL DCSP  DCSP  DCSP if (string_value == 'None'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = ast.literal_eval(string_value) DCNL DCSP  DCSP  DCSP except (ValueError, SyntaxError): DCNL DCSP  DCSP  DCSP  DCSP value = string_value DCNL DCSP  DCSP  DCSP temp_config = config.copy() DCNL DCSP  DCSP  DCSP if ((section == 'general') and (name == 'state_dir')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_state_dir(value) DCNL DCSP  DCSP  DCSP elif ((section == 'general') and (name == 'eckeypairfilename')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_permid_keypair_filename(value) DCNL DCSP  DCSP  DCSP elif ((section == 'general') and (name == 'megacache')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_megacache_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'general') and (name == 'videoanalyserpath')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_video_analyser_path(value) DCNL DCSP  DCSP  DCSP elif ((section == 'allchannel_community') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_channel_search_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'channel_community') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_channel_community_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'preview_channel_community') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_preview_channel_community_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'search_community') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_search_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'tunnel_community') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_tunnel_community_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'tunnel_community') and (name == 'socks5_listen_ports')): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, list): DCNL DCSP  DCSP  DCSP  DCSP  DCSP temp_config.set_tunnel_community_socks5_listen_ports(value) DCNL DCSP  DCSP  DCSP elif ((section == 'tunnel_community') and (name == 'exitnode_enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_tunnel_community_exitnode_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'multichain') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_trustchain_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'general') and (name == 'ec_keypair_filename_multichain')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_trustchain_permid_keypair_filename(value) DCNL DCSP  DCSP  DCSP elif ((section == 'metadata') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_metadata_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'metadata') and (name == 'store_dir')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_metadata_store_dir(value) DCNL DCSP  DCSP  DCSP elif ((section == 'mainline_dht') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_mainline_dht_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'mainline_dht') and (name == 'mainline_dht_port')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_mainline_dht_port(value) DCNL DCSP  DCSP  DCSP elif ((section == 'torrent_checking') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_checking_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'torrent_store') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_store_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'torrent_store') and (name == 'dir')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_store_dir(value) DCNL DCSP  DCSP  DCSP elif ((section == 'torrent_collecting') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_collecting_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'torrent_collecting') and (name == 'torrent_collecting_max_torrents')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_collecting_max_torrents(value) DCNL DCSP  DCSP  DCSP elif ((section == 'torrent_collecting') and (name == 'torrent_collecting_dir')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_torrent_collecting_dir(value) DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'lt_proxytype')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['proxy_type'] = value DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'lt_proxyserver')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['proxy_server'] = value DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'lt_proxyauth')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['proxy_auth'] = value DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'max_connections_download')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_libtorrent_max_conn_download(value) DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'max_download_rate')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_libtorrent_max_download_rate(value) DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'max_upload_rate')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_libtorrent_max_upload_rate(value) DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'utp')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_libtorrent_utp(value) DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'anon_listen_port')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_anon_listen_port(value) DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'anon_proxytype')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['anon_proxy_type'] = value DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'anon_proxyserver')): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(value, tuple) and isinstance(value[1], list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['anon_proxy_server_ip'] = value[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['anon_proxy_server_ports'] = [str(port) for port in value[1]] DCNL DCSP  DCSP  DCSP elif ((section == 'libtorrent') and (name == 'anon_proxyauth')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.config['libtorrent']['anon_proxy_auth'] = value DCNL DCSP  DCSP  DCSP elif ((section == 'dispersy') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_dispersy_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'dispersy') and (name == 'dispersy_port')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_dispersy_port(value) DCNL DCSP  DCSP  DCSP elif ((section == 'video') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_video_server_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'video') and (name == 'port')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_video_server_port(value) DCNL DCSP  DCSP  DCSP elif ((section == 'upgrader') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_upgrader_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'watch_folder') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_watch_folder_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'watch_folder') and (name == 'watch_folder_dir')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_watch_folder_path(value) DCNL DCSP  DCSP  DCSP elif ((section == 'http_api') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_http_api_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'http_api') and (name == 'port')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_http_api_port(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_enabled(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'max_torrents_per_source')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_max_torrents_per_source(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'max_torrents_active')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_max_torrents_active(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'source_interval')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_source_interval(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'swarm_interval')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_swarm_interval(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'share_mode_target')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_share_mode_target(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'tracker_interval')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_tracker_interval(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'logging_interval')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_logging_interval(value) DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'boosting_sources')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_sources(value, 'boosting_sources') DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'boosting_enabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_sources(value, 'boosting_enabled') DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'boosting_disabled')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_sources(value, 'boosting_disabled') DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'archive_sources')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_sources(value, 'archive_sources') DCNL DCSP  DCSP  DCSP elif ((section == 'credit_mining') and (name == 'policy')): DCNL DCSP  DCSP  DCSP  DCSP temp_config.set_credit_mining_policy(value) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP temp_config.validate() DCNL DCSP  DCSP  DCSP  DCSP config = temp_config DCNL DCSP  DCSP  DCSP except InvalidConfigException as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.debug('The DCSP following DCSP field DCSP in DCSP the DCSP old DCSP libtribler.conf DCSP was DCSP wrong: DCSP %s', exc.args) DCNL DCSP return config
 DCSP return (unhexlify(source) if ((len(source) == 40) and (not source.startswith('http'))) else source)
 DCSP (len_t1_fname, len_t2_fname) = (len(t1_fname), len(t2_fname)) DCNL DCSP if (len_t1_fname > len_t2_fname): DCNL DCSP  DCSP (t1_fname, t2_fname) = (t2_fname, t1_fname) DCNL DCSP  DCSP (len_t1_fname, len_t2_fname) = (len_t2_fname, len_t1_fname) DCNL DCSP current = range((len_t1_fname + 1)) DCNL DCSP for i in xrange(1, (len_t2_fname + 1)): DCNL DCSP  DCSP (previous, current) = (current, ([i] + ([0] * len_t1_fname))) DCNL DCSP  DCSP for j in xrange(1, (len_t1_fname + 1)): DCNL DCSP  DCSP  DCSP (add, delete) = ((previous[j] + 1), (current[(j - 1)] + 1)) DCNL DCSP  DCSP  DCSP change = previous[(j - 1)] DCNL DCSP  DCSP  DCSP if (t1_fname[(j - 1)] != t2_fname[(i - 1)]): DCNL DCSP  DCSP  DCSP  DCSP change += 1 DCNL DCSP  DCSP  DCSP current[j] = min(add, delete, change) DCNL DCSP return current[len_t1_fname]
 DCSP files1 = [files for files in torrent_1['metainfo'].get_files_with_length() if (files[1] > (1024 * 1024))] DCNL DCSP files2 = [files for files in torrent_2['metainfo'].get_files_with_length() if (files[1] > (1024 * 1024))] DCNL DCSP if (len(files1) == len(files2)): DCNL DCSP  DCSP for ft1 in files1: DCNL DCSP  DCSP  DCSP for ft2 in files2: DCNL DCSP  DCSP  DCSP  DCSP if ((ft1[1] != ft2[1]) or (levenshtein_dist(ft1[0], ft2[0]) > SIMILARITY_TRESHOLD)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP code = input_str.group(1) DCNL DCSP code_int = (int(code) if code.isdigit() else int(code[1:], 16)) DCNL DCSP return (chr(code_int) if (code_int < 256) else '?')
 DCSP (info, piece_length) = makeinfo(input, userabortflag, userprogresscallback) DCNL DCSP if ((userabortflag is not None) and userabortflag.isSet()): DCNL DCSP  DCSP return (None, None) DCNL DCSP if (info is None): DCNL DCSP  DCSP return (None, None) DCNL DCSP metainfo = {'info': info, 'encoding': input['encoding'], 'creation DCSP date': long(time())} DCNL DCSP metainfo = create_valid_metainfo(metainfo) DCNL DCSP if ((input['nodes'] is None) and (input['announce'] is None)): DCNL DCSP  DCSP raise ValueError('No DCSP tracker DCSP set') DCNL DCSP for key in ['announce', 'announce-list', 'nodes', 'comment', 'created DCSP by', 'httpseeds', 'url-list']: DCNL DCSP  DCSP if ((input[key] is not None) and (len(input[key]) > 0)): DCNL DCSP  DCSP  DCSP metainfo[key] = input[key] DCNL DCSP  DCSP  DCSP if (key == 'comment'): DCNL DCSP  DCSP  DCSP  DCSP metainfo['comment.utf-8'] = uniconvert(input['comment'], 'utf-8') DCNL DCSP if ('private' in input): DCNL DCSP  DCSP metainfo['info']['private'] = input['private'] DCNL DCSP if ('anonymous' in input): DCNL DCSP  DCSP metainfo['info']['anonymous'] = input['anonymous'] DCNL DCSP infohash = sha1(bencode(info)).digest() DCNL DCSP return (infohash, metainfo)
 DCSP r = [] DCNL DCSP try: DCNL DCSP  DCSP for s in l: DCNL DCSP  DCSP  DCSP r.append(uniconvert(s, e)) DCNL DCSP except UnicodeError: DCNL DCSP  DCSP raise UnicodeError(('bad DCSP filename: DCSP ' + os.path.join(l))) DCNL DCSP return r
 DCSP if (not isinstance(s, unicode)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s = bin2unicode(s, enc) DCNL DCSP  DCSP except UnicodeError: DCNL DCSP  DCSP  DCSP raise UnicodeError(('bad DCSP filename: DCSP ' + s)) DCNL DCSP return s.encode(enc)
 DCSP encoding = input['encoding'] DCNL DCSP pieces = [] DCNL DCSP sh = sha1() DCNL DCSP done = 0 DCNL DCSP fs = [] DCNL DCSP totalsize = 0 DCNL DCSP totalhashed = 0 DCNL DCSP subs = [] DCNL DCSP for f in input['files']: DCNL DCSP  DCSP inpath = f['inpath'] DCNL DCSP  DCSP outpath = f['outpath'] DCNL DCSP  DCSP logger.debug('makeinfo: DCSP inpath=%s, DCSP outpath=%s', inpath, outpath) DCNL DCSP  DCSP if os.path.isdir(inpath): DCNL DCSP  DCSP  DCSP dirsubs = subfiles(inpath) DCNL DCSP  DCSP  DCSP subs.extend(dirsubs) DCNL DCSP  DCSP elif (outpath is None): DCNL DCSP  DCSP  DCSP subs.append(([os.path.basename(inpath)], inpath)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subs.append((filename2pathlist(outpath, skipfirst=True), inpath)) DCNL DCSP subs.sort() DCNL DCSP newsubs = [] DCNL DCSP for (p, f) in subs: DCNL DCSP  DCSP size = os.path.getsize(f) DCNL DCSP  DCSP totalsize += size DCNL DCSP  DCSP newsubs.append((p, f, size)) DCNL DCSP subs = newsubs DCNL DCSP if (input['piece DCSP length'] == 0): DCNL DCSP  DCSP piece_length = (2 ** 15) DCNL DCSP  DCSP while ((totalsize / piece_length) > 2000): DCNL DCSP  DCSP  DCSP piece_length *= 2 DCNL DCSP else: DCNL DCSP  DCSP piece_length = input['piece DCSP length'] DCNL DCSP for (p, f, size) in subs: DCNL DCSP  DCSP pos = 0 DCNL DCSP  DCSP h = open(f, 'rb') DCNL DCSP  DCSP while (pos < size): DCNL DCSP  DCSP  DCSP a = min((size - pos), (piece_length - done)) DCNL DCSP  DCSP  DCSP if ((userabortflag is not None) and userabortflag.isSet()): DCNL DCSP  DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP  DCSP readpiece = h.read(a) DCNL DCSP  DCSP  DCSP if ((userabortflag is not None) and userabortflag.isSet()): DCNL DCSP  DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP  DCSP sh.update(readpiece) DCNL DCSP  DCSP  DCSP done += a DCNL DCSP  DCSP  DCSP pos += a DCNL DCSP  DCSP  DCSP totalhashed += a DCNL DCSP  DCSP  DCSP if (done == piece_length): DCNL DCSP  DCSP  DCSP  DCSP pieces.append(sh.digest()) DCNL DCSP  DCSP  DCSP  DCSP done = 0 DCNL DCSP  DCSP  DCSP  DCSP sh = sha1() DCNL DCSP  DCSP  DCSP if (userprogresscallback is not None): DCNL DCSP  DCSP  DCSP  DCSP userprogresscallback((float(totalhashed) / float(totalsize))) DCNL DCSP  DCSP newdict = {'length': size, 'path': uniconvertl(p, encoding), 'path.utf-8': uniconvertl(p, 'utf-8')} DCNL DCSP  DCSP fs.append(newdict) DCNL DCSP  DCSP h.close() DCNL DCSP if (done > 0): DCNL DCSP  DCSP pieces.append(sh.digest()) DCNL DCSP if (len(subs) == 1): DCNL DCSP  DCSP flkey = 'length' DCNL DCSP  DCSP flval = totalsize DCNL DCSP  DCSP name = subs[0][0][0] DCNL DCSP else: DCNL DCSP  DCSP flkey = 'files' DCNL DCSP  DCSP flval = fs DCNL DCSP  DCSP if ('name' in input): DCNL DCSP  DCSP  DCSP name = input['name'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP outpath = input['files'][0]['outpath'] DCNL DCSP  DCSP  DCSP l = filename2pathlist(outpath) DCNL DCSP  DCSP  DCSP name = l[0] DCNL DCSP infodict = {'piece DCSP length': piece_length, flkey: flval, 'name': uniconvert(name, encoding), 'name.utf-8': uniconvert(name, 'utf-8')} DCNL DCSP infodict.update({'pieces': ''.join(pieces)}) DCNL DCSP return (infodict, piece_length)
 DCSP r = [] DCNL DCSP stack = [([], d)] DCNL DCSP while stack: DCNL DCSP  DCSP (p, n) = stack.pop() DCNL DCSP  DCSP if os.path.isdir(n): DCNL DCSP  DCSP  DCSP for s in os.listdir(n): DCNL DCSP  DCSP  DCSP  DCSP if (s[:1] != '.'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.append(((copy(p) + [s]), os.path.join(n, s))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r.append((p, n)) DCNL DCSP return r
 DCSP h = path DCNL DCSP l = [] DCNL DCSP while True: DCNL DCSP  DCSP (h, t) = os.path.split(h) DCNL DCSP  DCSP if ((h == '') and (t == '')): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((h == '') and skipfirst): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (t != ''): DCNL DCSP  DCSP  DCSP l.append(t) DCNL DCSP l.reverse() DCNL DCSP return l
 DCSP fullpath = '' DCNL DCSP for elem in pathlist: DCNL DCSP  DCSP fullpath = os.path.join(fullpath, elem) DCNL DCSP try: DCNL DCSP  DCSP return fullpath.decode('utf-8') DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP charenc = chardet.detect(fullpath)['encoding'] DCNL DCSP  DCSP if (not charenc): DCNL DCSP  DCSP  DCSP return fullpath DCNL DCSP  DCSP return fullpath.decode(charenc)
 DCSP assert isinstance(tracker_url, basestring), (u'tracker_url DCSP is DCSP not DCSP a DCSP basestring: DCSP %s' % type(tracker_url)) DCNL DCSP try: DCNL DCSP  DCSP tracker_url = unicode(tracker_url) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return None DCNL DCSP url = urlparse(tracker_url) DCNL DCSP try: DCNL DCSP  DCSP if ((url.scheme == 'udp') or (url.scheme == 'http')): DCNL DCSP  DCSP  DCSP uniformed_scheme = url.scheme DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP uniformed_hostname = url.hostname DCNL DCSP  DCSP if (not url.port): DCNL DCSP  DCSP  DCSP if (url.scheme == 'udp'): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP elif (url.scheme == 'http'): DCNL DCSP  DCSP  DCSP  DCSP uniformed_port = HTTP_PORT DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP uniformed_port = url.port DCNL DCSP  DCSP if (url.scheme == 'udp'): DCNL DCSP  DCSP  DCSP uniformed_path = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP uniformed_path = url.path.rstrip('/') DCNL DCSP  DCSP if ((url.scheme == 'http') and (not url.path)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if ((url.scheme == 'http') and (uniformed_port == HTTP_PORT)): DCNL DCSP  DCSP  DCSP uniformed_url = (u'%s://%s%s' % (uniformed_scheme, uniformed_hostname, uniformed_path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP uniformed_url = (u'%s://%s:%d%s' % (uniformed_scheme, uniformed_hostname, uniformed_port, uniformed_path)) DCNL DCSP except (UnicodeError, ValueError): DCNL DCSP  DCSP return None DCNL DCSP return uniformed_url
 DCSP url = urlparse(tracker_url) DCNL DCSP if (not ((url.scheme == 'udp') or (url.scheme == 'http'))): DCNL DCSP  DCSP raise MalformedTrackerURLException((u'Unexpected DCSP tracker DCSP type DCSP (%s).' % url.scheme)) DCNL DCSP if ((url.scheme == 'udp') and (not url.port)): DCNL DCSP  DCSP raise MalformedTrackerURLException((u'No DCSP port DCSP number DCSP for DCSP UDP DCSP tracker DCSP URL DCSP (%s).' % tracker_url)) DCNL DCSP if ((url.scheme == 'http') and (not url.port)): DCNL DCSP  DCSP return (url.scheme, (url.hostname, 80), url.path) DCNL DCSP if ((url.scheme == 'http') and (not url.path)): DCNL DCSP  DCSP raise MalformedTrackerURLException((u'Missing DCSP announce DCSP path DCSP for DCSP HTTP DCSP tracker DCSP url DCSP (%s).' % tracker_url)) DCNL DCSP return (url.scheme, (url.hostname, url.port), url.path)
 DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP base_path = os.path.join(os.path.dirname(Tribler.__file__), '..') DCNL DCSP return base_path
 DCSP assert (socket_type in ('all', 'tcp', 'udp')), ('Invalid DCSP socket DCSP type DCSP %s' % type(socket_type)) DCNL DCSP assert isinstance(min_port, int), ('Invalid DCSP min_port DCSP type DCSP %s' % type(min_port)) DCNL DCSP assert isinstance(max_port, int), ('Invalid DCSP max_port DCSP type DCSP %s' % type(max_port)) DCNL DCSP assert (0 < min_port <= max_port <= 65535), ('Invalid DCSP min_port DCSP and DCSP mac_port DCSP values DCSP %s, DCSP %s' % (min_port, max_port)) DCNL DCSP working_port = None DCNL DCSP try_port = random.randint(min_port, max_port) DCNL DCSP while (try_port <= 65535): DCNL DCSP  DCSP if check_random_port(try_port, socket_type): DCNL DCSP  DCSP  DCSP working_port = try_port DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP try_port += 1 DCNL DCSP logger.debug('Got DCSP a DCSP working DCSP random DCSP port DCSP %s', working_port) DCNL DCSP return working_port
 DCSP assert (socket_type in ('all', 'tcp', 'udp')), ('Invalid DCSP socket DCSP type DCSP %s' % type(socket_type)) DCNL DCSP assert isinstance(port, int), ('Invalid DCSP port DCSP type DCSP %s' % type(port)) DCNL DCSP assert (0 < port <= 65535), ('Invalid DCSP port DCSP value DCSP %s' % port) DCNL DCSP _family = socket.AF_INET DCNL DCSP _sock_type = None DCNL DCSP if (socket_type == 'udp'): DCNL DCSP  DCSP _sock_type = socket.SOCK_DGRAM DCNL DCSP elif (socket_type == 'tcp'): DCNL DCSP  DCSP _sock_type = socket.SOCK_STREAM DCNL DCSP is_port_working = False DCNL DCSP if (socket_type == 'all'): DCNL DCSP  DCSP if _test_port(_family, socket.SOCK_DGRAM, port): DCNL DCSP  DCSP  DCSP is_port_working = _test_port(_family, socket.SOCK_STREAM, port) DCNL DCSP else: DCNL DCSP  DCSP is_port_working = _test_port(_family, _sock_type, port) DCNL DCSP return is_port_working
 DCSP assert (family in (socket.AF_INET,)), ('Invalid DCSP family DCSP value DCSP %s' % family) DCNL DCSP assert (sock_type in (socket.SOCK_DGRAM, socket.SOCK_STREAM)), ('Invalid DCSP sock_type DCSP value DCSP %s' % sock_type) DCNL DCSP assert (0 < port <= 65535), ('Invalid DCSP port DCSP value DCSP %s' % port) DCNL DCSP s = None DCNL DCSP try: DCNL DCSP  DCSP s = socket.socket(family, sock_type) DCNL DCSP  DCSP if (sock_type == socket.SOCK_STREAM): DCNL DCSP  DCSP  DCSP s.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0)) DCNL DCSP  DCSP s.bind(('', port)) DCNL DCSP  DCSP is_port_working = True DCNL DCSP except socket.error as e: DCNL DCSP  DCSP logger.debug('Port DCSP test DCSP failed DCSP (port=%s, DCSP family=%s, DCSP type=%s): DCSP %s', port, family, sock_type, e) DCNL DCSP  DCSP is_port_working = False DCNL DCSP finally: DCNL DCSP  DCSP if s: DCNL DCSP  DCSP  DCSP s.close() DCNL DCSP return is_port_working
 DCSP if to_filter_stopwords: DCNL DCSP  DCSP return [kw for kw in RE_KEYWORD_SPLIT.split(string.lower()) if ((len(kw) > 0) and (kw not in DIALOG_STOPWORDS))] DCNL DCSP else: DCNL DCSP  DCSP return [kw for kw in RE_KEYWORD_SPLIT.split(string.lower()) if (len(kw) > 0)]
 DCSP assert isinstance(value, int), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(value)) DCNL DCSP value = str(value).encode('UTF-8') DCNL DCSP return (str(len(value)).encode('UTF-8'), 'i', value)
 DCSP assert isinstance(value, long), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(value)) DCNL DCSP value = str(value).encode('UTF-8') DCNL DCSP return (str(len(value)).encode('UTF-8'), 'J', value)
 DCSP assert isinstance(value, float), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(value)) DCNL DCSP value = str(value).encode('UTF-8') DCNL DCSP return (str(len(value)).encode('UTF-8'), 'f', value)
 DCSP assert isinstance(value, unicode), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(value)) DCNL DCSP value = value.encode('UTF-8') DCNL DCSP return (str(len(value)).encode('UTF-8'), 's', value)
 DCSP assert isinstance(value, bytes), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(value)) DCNL DCSP return (str(len(value)).encode('UTF-8'), 'b', value)
 DCSP assert isinstance(values, list), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(values)) DCNL DCSP encoded = [str(len(values)).encode('UTF-8'), 'l'] DCNL DCSP extend = encoded.extend DCNL DCSP for value in values: DCNL DCSP  DCSP extend(mapping[type(value)](value, mapping)) DCNL DCSP return encoded
 DCSP assert isinstance(values, set), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(values)) DCNL DCSP encoded = [str(len(values)).encode('UTF-8'), 'L'] DCNL DCSP extend = encoded.extend DCNL DCSP for value in values: DCNL DCSP  DCSP extend(mapping[type(value)](value, mapping)) DCNL DCSP return encoded
 DCSP assert isinstance(values, tuple), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(values)) DCNL DCSP encoded = [str(len(values)).encode('UTF-8'), 't'] DCNL DCSP extend = encoded.extend DCNL DCSP for value in values: DCNL DCSP  DCSP extend(mapping[type(value)](value, mapping)) DCNL DCSP return encoded
 DCSP assert isinstance(values, dict), ('VALUE DCSP has DCSP invalid DCSP type: DCSP %s' % type(values)) DCNL DCSP encoded = [str(len(values)).encode('UTF-8'), 'd'] DCNL DCSP extend = encoded.extend DCNL DCSP for (key, value) in sorted(values.items()): DCNL DCSP  DCSP assert (type(key) in mapping), (key, values) DCNL DCSP  DCSP assert (type(value) in mapping), (value, values) DCNL DCSP  DCSP extend(mapping[type(key)](key, mapping)) DCNL DCSP  DCSP extend(mapping[type(value)](value, mapping)) DCNL DCSP return encoded
 DCSP return ['0n']
 DCSP return [('0T' if value else '0F')]
 DCSP assert isinstance(version, str) DCNL DCSP if (version == 'a'): DCNL DCSP  DCSP return ('a' + ''.join(_a_encode_mapping[type(data)](data, _a_encode_mapping))) DCNL DCSP raise ValueError('Unknown DCSP encode DCSP version')
 DCSP return ((offset + count), int(stream[offset:(offset + count)]))
 DCSP return ((offset + count), long(stream[offset:(offset + count)]))
 DCSP return ((offset + count), float(stream[offset:(offset + count)]))
 DCSP if (len(stream) >= (offset + count)): DCNL DCSP  DCSP return ((offset + count), stream[offset:(offset + count)].decode('UTF-8')) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Invalid DCSP stream DCSP length', len(stream), (offset + count))
 DCSP if (len(stream) >= (offset + count)): DCNL DCSP  DCSP return ((offset + count), stream[offset:(offset + count)]) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Invalid DCSP stream DCSP length', len(stream), (offset + count))
 DCSP container = [] DCNL DCSP for _ in range(count): DCNL DCSP  DCSP index = offset DCNL DCSP  DCSP while (48 <= ord(stream[index]) <= 57): DCNL DCSP  DCSP  DCSP index += 1 DCNL DCSP  DCSP (offset, value) = mapping[stream[index]](stream, (index + 1), int(stream[offset:index]), mapping) DCNL DCSP  DCSP container.append(value) DCNL DCSP return (offset, container)
 DCSP container = set() DCNL DCSP for _ in range(count): DCNL DCSP  DCSP index = offset DCNL DCSP  DCSP while (48 <= ord(stream[index]) <= 57): DCNL DCSP  DCSP  DCSP index += 1 DCNL DCSP  DCSP (offset, value) = mapping[stream[index]](stream, (index + 1), int(stream[offset:index]), mapping) DCNL DCSP  DCSP container.add(value) DCNL DCSP return (offset, container)
 DCSP container = [] DCNL DCSP for _ in range(count): DCNL DCSP  DCSP index = offset DCNL DCSP  DCSP while (48 <= ord(stream[index]) <= 57): DCNL DCSP  DCSP  DCSP index += 1 DCNL DCSP  DCSP (offset, value) = mapping[stream[index]](stream, (index + 1), int(stream[offset:index]), mapping) DCNL DCSP  DCSP container.append(value) DCNL DCSP return (offset, tuple(container))
 DCSP container = {} DCNL DCSP for _ in range(count): DCNL DCSP  DCSP index = offset DCNL DCSP  DCSP while (48 <= ord(stream[index]) <= 57): DCNL DCSP  DCSP  DCSP index += 1 DCNL DCSP  DCSP (offset, key) = mapping[stream[index]](stream, (index + 1), int(stream[offset:index]), mapping) DCNL DCSP  DCSP index = offset DCNL DCSP  DCSP while (48 <= ord(stream[index]) <= 57): DCNL DCSP  DCSP  DCSP index += 1 DCNL DCSP  DCSP (offset, value) = mapping[stream[index]](stream, (index + 1), int(stream[offset:index]), mapping) DCNL DCSP  DCSP container[key] = value DCNL DCSP if (len(container) < count): DCNL DCSP  DCSP raise ValueError('Duplicate DCSP key DCSP in DCSP dictionary') DCNL DCSP return (offset, container)
 DCSP assert (count == 0) DCNL DCSP return (offset, None)
 DCSP assert (count == 0) DCNL DCSP return (offset, True)
 DCSP assert (count == 0) DCNL DCSP return (offset, False)
 DCSP assert isinstance(stream, bytes), ('STREAM DCSP has DCSP invalid DCSP type: DCSP %s' % type(stream)) DCNL DCSP assert isinstance(offset, int), ('OFFSET DCSP has DCSP invalid DCSP type: DCSP %s' % type(offset)) DCNL DCSP if (stream[offset] == 'a'): DCNL DCSP  DCSP index = (offset + 1) DCNL DCSP  DCSP while (48 <= ord(stream[index]) <= 57): DCNL DCSP  DCSP  DCSP index += 1 DCNL DCSP  DCSP return _a_decode_mapping[stream[index]](stream, (index + 1), int(stream[(offset + 1):index]), _a_decode_mapping) DCNL DCSP raise ValueError('Unknown DCSP version DCSP found')
 DCSP url = unquote(url) DCNL DCSP parsed_url = urlparse(url) DCNL DCSP get_args = parsed_url.query DCNL DCSP parsed_get_args = dict(parse_qsl(get_args)) DCNL DCSP parsed_get_args.update(params) DCNL DCSP parsed_get_args.update({k: dumps(v) for (k, v) in parsed_get_args.items() if isinstance(v, (bool, dict))}) DCNL DCSP encoded_get_args = urlencode(parsed_get_args, doseq=True) DCNL DCSP new_url = ParseResult(parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, encoded_get_args, parsed_url.fragment).geturl() DCNL DCSP return new_url
 DCSP if (((sys.platform == 'win32') or (sys.platform == 'darwin')) and is_frozen()): DCNL DCSP  DCSP from cryptography.hazmat import backends DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from cryptography.hazmat.backends.commoncrypto.backend import backend as be_cc DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP be_cc = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from cryptography.hazmat.backends.openssl.backend import backend as be_ossl DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP be_ossl = None DCNL DCSP  DCSP backends._available_backends_list = [be for be in (be_cc, be_ossl) if (be is not None)]
 DCSP if ('nodes' in metainfo): DCNL DCSP  DCSP nodes = metainfo['nodes'] DCNL DCSP  DCSP if (not isinstance(nodes, ListType)): DCNL DCSP  DCSP  DCSP raise ValueError(('nodes DCSP not DCSP list, DCSP but DCSP ' + repr(type(nodes)))) DCNL DCSP  DCSP for pair in nodes: DCNL DCSP  DCSP  DCSP if ((not isinstance(pair, ListType)) and (len(pair) != 2)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('node DCSP not DCSP 2-item DCSP list, DCSP but DCSP ' + repr(type(pair)))) DCNL DCSP  DCSP  DCSP (host, port) = pair DCNL DCSP  DCSP  DCSP if (not isinstance(host, StringType)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('node DCSP host DCSP not DCSP string, DCSP but DCSP ' + repr(type(host)))) DCNL DCSP  DCSP  DCSP if (not isinstance(port, (IntType, LongType))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('node DCSP port DCSP not DCSP int, DCSP but DCSP ' + repr(type(port)))) DCNL DCSP  DCSP return nodes DCNL DCSP return None
 DCSP if ('initial DCSP peers' in metainfo): DCNL DCSP  DCSP valid_initial_peers = [] DCNL DCSP  DCSP if (not isinstance(metainfo['initial DCSP peers'], list)): DCNL DCSP  DCSP  DCSP raise ValueError(('initial DCSP peers DCSP not DCSP list, DCSP but DCSP %s' % type(metainfo['initial DCSP peers']))) DCNL DCSP  DCSP for address in metainfo['initial DCSP peers']: DCNL DCSP  DCSP  DCSP if (not (isinstance(address, tuple) and (len(address) == 2))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('address DCSP not DCSP 2-item DCSP tuple, DCSP but DCSP %s', type(address)) DCNL DCSP  DCSP  DCSP elif (not isinstance(address[0], str)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('address DCSP host DCSP not DCSP string, DCSP but DCSP %s', type(address[0])) DCNL DCSP  DCSP  DCSP elif (not isinstance(address[1], int)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('address DCSP port DCSP not DCSP int, DCSP but DCSP %s', type(address[1])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP valid_initial_peers.append(address) DCNL DCSP  DCSP return valid_initial_peers DCNL DCSP return None
 DCSP if ('url-list' in metainfo): DCNL DCSP  DCSP url_list = metainfo['url-list'] DCNL DCSP  DCSP if (('info' in metainfo) and ('files' in metainfo['info'])): DCNL DCSP  DCSP  DCSP logger.warn('Warning: DCSP Only DCSP single-file DCSP mode DCSP supported DCSP with DCSP HTTP DCSP seeding. DCSP HTTP DCSP seeding DCSP disabled') DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif (not isinstance(metainfo['url-list'], ListType)): DCNL DCSP  DCSP  DCSP if isinstance(metainfo['url-list'], StringType): DCNL DCSP  DCSP  DCSP  DCSP url_list = [metainfo['url-list']] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger.warn('Warning: DCSP url-list DCSP is DCSP not DCSP of DCSP type DCSP list/string. DCSP HTTP DCSP seeding DCSP disabled') DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP for url in url_list: DCNL DCSP  DCSP  DCSP if (not is_valid_url(url)): DCNL DCSP  DCSP  DCSP  DCSP logger.warn('Warning: DCSP url-list DCSP url DCSP is DCSP not DCSP valid: DCSP %s DCSP HTTP DCSP seeding DCSP disabled', repr(url)) DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return url_list DCNL DCSP return None
 DCSP if (('httpseeds' in metainfo) and metainfo['httpseeds']): DCNL DCSP  DCSP http_seeds = [] DCNL DCSP  DCSP if (not isinstance(metainfo['httpseeds'], ListType)): DCNL DCSP  DCSP  DCSP logger.warn('Warning: DCSP httpseeds DCSP is DCSP not DCSP of DCSP type DCSP list. DCSP HTTP DCSP seeding DCSP disabled') DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for url in metainfo['httpseeds']: DCNL DCSP  DCSP  DCSP  DCSP if (not is_valid_url(url)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn('Warning: DCSP httpseeds DCSP url DCSP is DCSP not DCSP valid: DCSP %s DCSP HTTP DCSP seeding DCSP disabled', repr(url)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP http_seeds.append(url) DCNL DCSP  DCSP return http_seeds DCNL DCSP return None
 DCSP if ('length' in info): DCNL DCSP  DCSP if ('files' in info): DCNL DCSP  DCSP  DCSP raise ValueError('info DCSP may DCSP not DCSP contain DCSP both DCSP files DCSP and DCSP length DCSP key') DCNL DCSP  DCSP l = info['length'] DCNL DCSP  DCSP if ((not isinstance(l, IntType)) and (not isinstance(l, LongType))): DCNL DCSP  DCSP  DCSP raise ValueError(('info DCSP length DCSP is DCSP not DCSP int, DCSP but DCSP ' + repr(type(l)))) DCNL DCSP elif ('files' in info): DCNL DCSP  DCSP files = info['files'] DCNL DCSP  DCSP if (not isinstance(files, ListType)): DCNL DCSP  DCSP  DCSP raise ValueError(('info DCSP files DCSP not DCSP list, DCSP but DCSP ' + repr(type(files)))) DCNL DCSP  DCSP filekeys = ['path', 'length'] DCNL DCSP  DCSP for file_desc in files: DCNL DCSP  DCSP  DCSP if (not all(((key in file_desc) for key in filekeys))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('info DCSP files DCSP missing DCSP path DCSP or DCSP length DCSP key') DCNL DCSP  DCSP  DCSP path = file_desc['path'] DCNL DCSP  DCSP  DCSP if (not isinstance(path, ListType)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('info DCSP files DCSP path DCSP is DCSP not DCSP list, DCSP but DCSP ' + repr(type(path)))) DCNL DCSP  DCSP  DCSP if (not all((isinstance(dir_path, StringType) for dir_path in path))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('info DCSP files DCSP path DCSP is DCSP not DCSP string') DCNL DCSP  DCSP  DCSP length = file_desc['length'] DCNL DCSP  DCSP  DCSP if ((not isinstance(length, IntType)) and (not isinstance(length, LongType))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('info DCSP files DCSP length DCSP is DCSP not DCSP int, DCSP but DCSP ' + repr(type(length)))) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('neither DCSP length DCSP or DCSP files DCSP found DCSP in DCSP files DCSP information') DCNL DCSP return None
 DCSP if ('info' not in metainfo): DCNL DCSP  DCSP raise ValueError('metainfo DCSP misses DCSP key DCSP info') DCNL DCSP info = metainfo['info'] DCNL DCSP if (not isinstance(info, DictType)): DCNL DCSP  DCSP raise ValueError('info DCSP not DCSP dict') DCNL DCSP if (not (all(((key in info) for key in {'name', 'piece DCSP length'})) and any(((key in info) for key in {'root DCSP hash', 'pieces'})))): DCNL DCSP  DCSP raise ValueError('info DCSP misses DCSP key') DCNL DCSP name = info['name'] DCNL DCSP if (not isinstance(name, StringType)): DCNL DCSP  DCSP raise ValueError(('info DCSP name DCSP is DCSP not DCSP string DCSP but DCSP ' + repr(type(name)))) DCNL DCSP pl = info['piece DCSP length'] DCNL DCSP if (not (isinstance(pl, IntType) or isinstance(pl, LongType))): DCNL DCSP  DCSP raise ValueError(('info DCSP piece DCSP size DCSP is DCSP not DCSP int, DCSP but DCSP ' + repr(type(pl)))) DCNL DCSP if ('root DCSP hash' in info): DCNL DCSP  DCSP rh = info['root DCSP hash'] DCNL DCSP  DCSP if ((not isinstance(rh, StringType)) or (len(rh) != 20)): DCNL DCSP  DCSP  DCSP raise ValueError('info DCSP roothash DCSP is DCSP not DCSP 20-byte DCSP string') DCNL DCSP else: DCNL DCSP  DCSP pieces = info['pieces'] DCNL DCSP  DCSP if ((not isinstance(pieces, StringType)) or ((len(pieces) % 20) != 0)): DCNL DCSP  DCSP  DCSP raise ValueError('info DCSP pieces DCSP is DCSP not DCSP multiple DCSP of DCSP 20 DCSP bytes') DCNL DCSP validate_files(info) DCNL DCSP return info
 DCSP metainfo_result = metainfo DCNL DCSP if (not isinstance(metainfo, DictType)): DCNL DCSP  DCSP raise ValueError('metainfo DCSP not DCSP dict') DCNL DCSP if (('announce' in metainfo) and (not (is_valid_url(metainfo['announce']) or metainfo['announce'].startswith('dht:')))): DCNL DCSP  DCSP raise ValueError('announce DCSP URL DCSP bad') DCNL DCSP if ('announce-list' in metainfo): DCNL DCSP  DCSP al = metainfo['announce-list'] DCNL DCSP  DCSP if (not isinstance(al, ListType)): DCNL DCSP  DCSP  DCSP raise ValueError(('announce-list DCSP is DCSP not DCSP list, DCSP but DCSP ' + repr(type(al)))) DCNL DCSP  DCSP if (not all((isinstance(tier, ListType) for tier in al))): DCNL DCSP  DCSP  DCSP raise ValueError('announce-list DCSP tier DCSP is DCSP not DCSP list') DCNL DCSP metainfo_result['nodes'] = validate_torrent_nodes(metainfo_result) DCNL DCSP metainfo_result['initial DCSP peers'] = validate_init_peers(metainfo) DCNL DCSP metainfo_result['url-list'] = validate_url_list(metainfo) DCNL DCSP metainfo_result['httpseeds'] = validate_http_seeds(metainfo) DCNL DCSP metainfo_result['info'] = validate_torrent_info(metainfo) DCNL DCSP for key in {'httpseeds', 'url-list', 'nodes', 'initial DCSP peers'}: DCNL DCSP  DCSP if (not metainfo[key]): DCNL DCSP  DCSP  DCSP del metainfo[key] DCNL DCSP if (not (('announce' in metainfo) or ('nodes' in metainfo))): DCNL DCSP  DCSP metainfo_result['nodes'] = [] DCNL DCSP return dict(((key, val) for (key, val) in metainfo_result.iteritems() if (val or (metainfo[key] and (metainfo[key] == val)))))
 DCSP try: DCNL DCSP  DCSP create_valid_metainfo(metainfo) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP logger.exception('Torrent DCSP file DCSP is DCSP invalid') DCNL DCSP  DCSP return False
 DCSP if url.lower().startswith('udp'): DCNL DCSP  DCSP url = url.lower().replace('udp', 'http', 1) DCNL DCSP split_url = urlparse.urlsplit(url) DCNL DCSP return (not ((split_url[0] == '') or (split_url[1] == '')))
 DCSP def _on_response(response): DCNL DCSP  DCSP if (response.code == http.OK): DCNL DCSP  DCSP  DCSP return readBody(response) DCNL DCSP  DCSP raise HttpError(response) DCNL DCSP agent = Agent(reactor) DCNL DCSP deferred = agent.request('GET', uri, Headers({'User-Agent': [('Tribler DCSP ' + version_id)]}), None) DCNL DCSP deferred.addCallback(_on_response) DCNL DCSP return deferred
 DCSP dn = None DCNL DCSP xt = None DCNL DCSP trs = [] DCNL DCSP logger.debug('parse_magnetlink() DCSP %s', url) DCNL DCSP (schema, netloc, path, query, fragment) = urlsplit(url) DCNL DCSP if (schema == 'magnet'): DCNL DCSP  DCSP if ('?' in path): DCNL DCSP  DCSP  DCSP (pre, post) = path.split('?', 1) DCNL DCSP  DCSP  DCSP if query: DCNL DCSP  DCSP  DCSP  DCSP query = '&'.join((post, query)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP query = post DCNL DCSP  DCSP for (key, value) in parse_qsl(query): DCNL DCSP  DCSP  DCSP if (key == 'dn'): DCNL DCSP  DCSP  DCSP  DCSP dn = (value.decode() if (not isinstance(value, unicode)) else value) DCNL DCSP  DCSP  DCSP elif ((key == 'xt') and value.startswith('urn:btih:')): DCNL DCSP  DCSP  DCSP  DCSP encoded_infohash = value[9:49] DCNL DCSP  DCSP  DCSP  DCSP if (len(encoded_infohash) == 32): DCNL DCSP  DCSP  DCSP  DCSP  DCSP xt = b32decode(encoded_infohash) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP xt = binascii.unhexlify(encoded_infohash) DCNL DCSP  DCSP  DCSP elif (key == 'tr'): DCNL DCSP  DCSP  DCSP  DCSP trs.append(value) DCNL DCSP  DCSP logger.debug('parse_magnetlink() DCSP NAME: DCSP %s', dn) DCNL DCSP  DCSP logger.debug('parse_magnetlink() DCSP HASH: DCSP %s', xt) DCNL DCSP  DCSP logger.debug('parse_magnetlink() DCSP TRACS: DCSP %s', trs) DCNL DCSP return (dn, xt, trs)
 DCSP f = open(file_path, 'rb') DCNL DCSP bdata = f.read() DCNL DCSP f.close() DCNL DCSP fixed_data = bdecode(bdata) DCNL DCSP if (fixed_data is not None): DCNL DCSP  DCSP fixed_data = bencode(fixed_data) DCNL DCSP return fixed_data
 DCSP upload_only = 0 DCNL DCSP finished = 0 DCNL DCSP unfinished_able_dl = 0 DCNL DCSP interest_in_us = 0 DCNL DCSP for p_info in peer_info_dicts: DCNL DCSP  DCSP upload_only_b = False DCNL DCSP  DCSP if p_info['upload_only']: DCNL DCSP  DCSP  DCSP upload_only += 1 DCNL DCSP  DCSP  DCSP upload_only_b = True DCNL DCSP  DCSP if p_info['uinterested']: DCNL DCSP  DCSP  DCSP interest_in_us += 1 DCNL DCSP  DCSP if (p_info['completed'] == 1): DCNL DCSP  DCSP  DCSP finished += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP unfinished_able_dl += (1 if upload_only_b else 0) DCNL DCSP num_seeders = max(upload_only, finished) DCNL DCSP num_leech = max(interest_in_us, min(unfinished_able_dl, (len(peer_info_dicts) - finished))) DCNL DCSP return (num_seeders, num_leech)
 DCSP def invoke_func(*args, **kwargs): DCNL DCSP  DCSP from twisted.python.threadable import isInIOThread DCNL DCSP  DCSP from traceback import print_stack DCNL DCSP  DCSP if isInIOThread(): DCNL DCSP  DCSP  DCSP import inspect DCNL DCSP  DCSP  DCSP caller = inspect.stack()[1] DCNL DCSP  DCSP  DCSP callerstr = ('%s DCSP %s:%s' % (caller[3], caller[1], caller[2])) DCNL DCSP  DCSP  DCSP from time import time DCNL DCSP  DCSP  DCSP logger.error('%d DCSP CANNOT DCSP BE DCSP ON DCSP DISPERSYTHREAD DCSP %s DCSP %s:%s DCSP called DCSP by DCSP %s', long(time()), func.__name__, func.func_code.co_filename, func.func_code.co_firstlineno, callerstr) DCNL DCSP  DCSP  DCSP print_stack() DCNL DCSP  DCSP return func(*args, **kwargs) DCNL DCSP invoke_func.__name__ = func.__name__ DCNL DCSP return invoke_func
 DCSP request.setResponseCode(http.INTERNAL_SERVER_ERROR) DCNL DCSP return json.dumps({u'error': {u'handled': True, u'code': exception.__class__.__name__, u'message': exception.message}})
 DCSP if isinstance(torrent, dict): DCNL DCSP  DCSP return convert_remote_torrent_to_json(torrent) DCNL DCSP return convert_db_torrent_to_json(torrent, include_rel_score=True)
 DCSP res_json = {'id': channel[0], 'dispersy_cid': channel[1].encode('hex'), 'name': channel[2], 'description': channel[3], 'votes': channel[5], 'torrents': channel[4], 'spam': channel[6], 'modified': channel[8], 'subscribed': (channel[7] == VOTE_SUBSCRIBE)} DCNL DCSP if include_rel_score: DCNL DCSP  DCSP res_json['relevance_score'] = channel[9] DCNL DCSP return res_json
 DCSP from Tribler.Core.Session import Session DCNL DCSP if Session.get_instance().config.get_dispersy_enabled(): DCNL DCSP  DCSP dispersy = Session.get_instance().get_dispersy_instance() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cmty = dispersy.get_community(channel_id) DCNL DCSP  DCSP  DCSP (channel_type, is_mod) = cmty.get_channel_mode() DCNL DCSP  DCSP  DCSP if (is_mod or ((channel_vote == VOTE_SUBSCRIBE) and (channel_type == ChannelCommunity.CHANNEL_OPEN))): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except CommunityNotFoundException: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return False
 DCSP torrent_name = torrent[2] DCNL DCSP if ((torrent_name is None) or (len(torrent_name.strip()) == 0)): DCNL DCSP  DCSP torrent_name = 'Unnamed DCSP torrent' DCNL DCSP res_json = {'id': torrent[0], 'infohash': torrent[1].encode('hex'), 'name': torrent_name, 'size': torrent[3], 'category': torrent[4], 'num_seeders': (torrent[5] or 0), 'num_leechers': (torrent[6] or 0), 'last_tracker_check': (torrent[7] or 0)} DCNL DCSP if include_rel_score: DCNL DCSP  DCSP res_json['relevance_score'] = torrent[9] DCNL DCSP return res_json
 DCSP torrent_name = torrent['name'] DCNL DCSP if ((torrent_name is None) or (len(torrent_name.strip()) == 0)): DCNL DCSP  DCSP torrent_name = 'Unnamed DCSP torrent' DCNL DCSP relevance_score = relevance_score_remote_torrent(torrent_name) DCNL DCSP return {'id': torrent['torrent_id'], 'infohash': torrent['infohash'].encode('hex'), 'name': torrent_name, 'size': torrent['length'], 'category': torrent['category'], 'num_seeders': torrent['num_seeders'], 'num_leechers': torrent['num_leechers'], 'last_tracker_check': 0, 'relevance_score': relevance_score}
 DCSP if ((name not in parameters) or (len(parameters[name]) == 0)): DCNL DCSP  DCSP return None DCNL DCSP return parameters[name][0]
 DCSP from Tribler.Core.Session import Session DCNL DCSP torrent_db = Session.get_instance().open_dbhandler(NTFY_TORRENTS) DCNL DCSP if (torrent_db.latest_matchinfo_torrent is None): DCNL DCSP  DCSP return 0.0 DCNL DCSP (matchinfo, keywords) = torrent_db.latest_matchinfo_torrent DCNL DCSP (num_phrases, num_cols, num_rows) = unpack_from('III', matchinfo) DCNL DCSP unpack_str = ('I' * ((3 * num_cols) * num_phrases)) DCNL DCSP matchinfo = unpack_from((('I' * 9) + unpack_str), matchinfo)[9:] DCNL DCSP score = 0.0 DCNL DCSP for phrase_ind in xrange(num_phrases): DCNL DCSP  DCSP rows_with_term = matchinfo[((3 * (phrase_ind * num_cols)) + 2)] DCNL DCSP  DCSP term_freq = torrent_name.lower().count(keywords[phrase_ind]) DCNL DCSP  DCSP inv_doc_freq = math.log((((num_rows - rows_with_term) + 0.5) / (rows_with_term + 0.5)), 2) DCNL DCSP  DCSP right_side = ((term_freq * (1.2 + 1)) / (term_freq + 1.2)) DCNL DCSP  DCSP score += (inv_doc_freq * right_side) DCNL DCSP return score
 DCSP new_dict = {} DCNL DCSP for (key, value) in d.items(): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP new_dict[key] = fix_unicode_dict(value) DCNL DCSP  DCSP elif isinstance(value, tuple): DCNL DCSP  DCSP  DCSP new_dict[key] = fix_unicode_array(list(value)) DCNL DCSP  DCSP elif isinstance(value, list): DCNL DCSP  DCSP  DCSP new_dict[key] = fix_unicode_array(value) DCNL DCSP  DCSP elif isinstance(value, (str, unicode)): DCNL DCSP  DCSP  DCSP new_dict[key] = value.decode('utf-8', 'ignore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP new_dict[key] = value DCNL DCSP return new_dict
 DCSP new_arr = [] DCNL DCSP for ind in xrange(len(arr)): DCNL DCSP  DCSP if isinstance(arr[ind], (str, unicode)): DCNL DCSP  DCSP  DCSP new_arr.append(arr[ind].decode('utf-8', 'ignore')) DCNL DCSP  DCSP elif isinstance(arr[ind], dict): DCNL DCSP  DCSP  DCSP new_arr.append(fix_unicode_dict(arr[ind])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP new_arr.append(arr[ind]) DCNL DCSP return new_arr
 DCSP (tracker_type, tracker_address, announce_page) = parse_tracker_url(tracker_url) DCNL DCSP if (tracker_type == u'udp'): DCNL DCSP  DCSP return UdpTrackerSession(tracker_url, tracker_address, announce_page, timeout) DCNL DCSP else: DCNL DCSP  DCSP return HttpTrackerSession(tracker_url, tracker_address, announce_page, timeout)
 DCSP return (sys.platform.startswith('linux') and ('ANDROID_PRIVATE' in os.environ))
 DCSP if (unit and ((len(name) != 2) or (name[1] != ':'))): DCNL DCSP  DCSP return 'c:' DCNL DCSP if ((not name) or (name == '.') or (name == '..')): DCNL DCSP  DCSP return '_' DCNL DCSP if unit: DCNL DCSP  DCSP name = name[0] DCNL DCSP fixed = False DCNL DCSP if (len(name) > maxlen): DCNL DCSP  DCSP name = name[:maxlen] DCNL DCSP  DCSP fixed = True DCNL DCSP fixedname = '' DCNL DCSP spaces = 0 DCNL DCSP for c in name: DCNL DCSP  DCSP if sys.platform.startswith('win'): DCNL DCSP  DCSP  DCSP invalidchars = invalidwinfilenamechars DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP invalidchars = invalidlinuxfilenamechars DCNL DCSP  DCSP if (c in invalidchars): DCNL DCSP  DCSP  DCSP fixedname += '_' DCNL DCSP  DCSP  DCSP fixed = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fixedname += c DCNL DCSP  DCSP  DCSP if (c == ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP spaces += 1 DCNL DCSP (file_dir, basename) = os.path.split(fixedname) DCNL DCSP while (file_dir != ''): DCNL DCSP  DCSP fixedname = basename DCNL DCSP  DCSP (file_dir, basename) = os.path.split(fixedname) DCNL DCSP  DCSP fixed = True DCNL DCSP if (fixedname == ''): DCNL DCSP  DCSP fixedname = '_' DCNL DCSP  DCSP fixed = True DCNL DCSP if fixed: DCNL DCSP  DCSP return last_minute_filename_clean(fixedname) DCNL DCSP elif (spaces == len(name)): DCNL DCSP  DCSP return '_' DCNL DCSP else: DCNL DCSP  DCSP return last_minute_filename_clean(name)
 DCSP str_data = '' DCNL DCSP next_idx = (start_idx + 1) DCNL DCSP got_end = False DCNL DCSP for c in buff[start_idx:]: DCNL DCSP  DCSP if (ord(c) == 0): DCNL DCSP  DCSP  DCSP got_end = True DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP str_data += c DCNL DCSP  DCSP next_idx += 1 DCNL DCSP if (not got_end): DCNL DCSP  DCSP raise InvalidStringException() DCNL DCSP return (str_data, next_idx)
 DCSP packet['options'] = {} DCNL DCSP idx = start_idx DCNL DCSP while (idx < len(buff)): DCNL DCSP  DCSP (option, idx) = _get_string(buff, idx) DCNL DCSP  DCSP (value, idx) = _get_string(buff, idx) DCNL DCSP  DCSP if (option == ''): DCNL DCSP  DCSP  DCSP raise InvalidPacketException(u'Empty DCSP option') DCNL DCSP  DCSP if (value == ''): DCNL DCSP  DCSP  DCSP raise InvalidPacketException((u'Empty DCSP value DCSP for DCSP option[%s]' % repr(option))) DCNL DCSP  DCSP packet['options'][option] = value DCNL DCSP for (k, v) in packet['options'].items(): DCNL DCSP  DCSP if (k not in OPTIONS): DCNL DCSP  DCSP  DCSP raise InvalidOptionException((u'Unknown DCSP option[%s]' % repr(k))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (k in ('blksize', 'timeout', 'tsize')): DCNL DCSP  DCSP  DCSP  DCSP packet['options'][k] = int(v) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP packet['options'][k] = v DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise InvalidOptionException((u'Invalid DCSP value DCSP for DCSP option DCSP %s: DCSP %s' % (repr(k), repr(v))))
 DCSP (file_name, idx) = _get_string(packet_buff, offset) DCNL DCSP packet['file_name'] = file_name DCNL DCSP _decode_options(packet, packet_buff, idx) DCNL DCSP return packet
 DCSP if (len(packet_buff) < (offset + 2)): DCNL DCSP  DCSP raise InvalidPacketException((u'DATA DCSP packet DCSP too DCSP small DCSP (<4): DCSP %s' % repr(packet_buff))) DCNL DCSP (block_number,) = struct.unpack_from('!H', packet_buff, offset) DCNL DCSP data = packet_buff[(offset + 2):] DCNL DCSP packet['block_number'] = block_number DCNL DCSP packet['data'] = data DCNL DCSP return packet
 DCSP if (len(packet_buff) != (offset + 2)): DCNL DCSP  DCSP raise InvalidPacketException((u'ACK DCSP packet DCSP has DCSP invalid DCSP size DCSP (!=%s): DCSP %s' % ((offset + 2), hexlify(packet_buff)))) DCNL DCSP (block_number,) = struct.unpack_from('!H', packet_buff, offset) DCNL DCSP packet['block_number'] = block_number DCNL DCSP return packet
 DCSP if (len(packet_buff) < (offset + 3)): DCNL DCSP  DCSP raise InvalidPacketException((u'ERROR DCSP packet DCSP too DCSP small DCSP (<%s): DCSP %s' % ((offset + 3), hexlify(packet_buff)))) DCNL DCSP (error_code,) = struct.unpack_from('!H', packet_buff, offset) DCNL DCSP (error_msg, idx) = _get_string(packet_buff, (offset + 2)) DCNL DCSP if (not error_msg): DCNL DCSP  DCSP raise InvalidPacketException((u'ERROR DCSP packet DCSP has DCSP empty DCSP error DCSP message: DCSP %s' % hexlify(packet_buff))) DCNL DCSP if (idx != len(packet_buff)): DCNL DCSP  DCSP raise InvalidPacketException((u'Invalid DCSP ERROR DCSP packet: DCSP %s' % hexlify(packet_buff))) DCNL DCSP packet['error_code'] = error_code DCNL DCSP packet['error_msg'] = error_msg DCNL DCSP return packet
 DCSP _decode_options(packet, packet_buff, offset) DCNL DCSP return packet
 DCSP if (len(packet_buff) < 4): DCNL DCSP  DCSP raise InvalidPacketException((u'Packet DCSP too DCSP small DCSP (<4): DCSP %s' % hexlify(packet_buff))) DCNL DCSP (opcode, session_id) = struct.unpack_from('!HH', packet_buff, 0) DCNL DCSP if (opcode not in PACKET_DECODE_DICT): DCNL DCSP  DCSP raise InvalidPacketException((u'Invalid DCSP opcode: DCSP %s' % opcode)) DCNL DCSP packet = {'opcode': opcode, 'session_id': session_id} DCNL DCSP return PACKET_DECODE_DICT[opcode](packet, packet_buff, 4)
 DCSP packet_buff = struct.pack('!HH', packet['opcode'], packet['session_id']) DCNL DCSP if (packet['opcode'] in (OPCODE_RRQ, OPCODE_WRQ)): DCNL DCSP  DCSP packet_buff += (packet['file_name'] + '\x00') DCNL DCSP  DCSP for (k, v) in packet['options'].iteritems(): DCNL DCSP  DCSP  DCSP packet_buff += ('%s\x00%s\x00' % (k, v)) DCNL DCSP elif (packet['opcode'] == OPCODE_DATA): DCNL DCSP  DCSP packet_buff += struct.pack('!H', packet['block_number']) DCNL DCSP  DCSP packet_buff += packet['data'] DCNL DCSP elif (packet['opcode'] == OPCODE_ACK): DCNL DCSP  DCSP packet_buff += struct.pack('!H', packet['block_number']) DCNL DCSP elif (packet['opcode'] == OPCODE_ERROR): DCNL DCSP  DCSP packet_buff += struct.pack('!H', packet['error_code']) DCNL DCSP  DCSP packet_buff += (packet['error_msg'] + '\x00') DCNL DCSP elif (packet['opcode'] == OPCODE_OACK): DCNL DCSP  DCSP for (k, v) in packet['options'].iteritems(): DCNL DCSP  DCSP  DCSP packet_buff += ('%s\x00%s\x00' % (k, v)) DCNL DCSP return packet_buff
 DCSP download_dir = u'TriblerDownloads' DCNL DCSP if os.path.isdir(download_dir): DCNL DCSP  DCSP return os.path.abspath(download_dir) DCNL DCSP downloads_dir = os.path.join(get_home_dir(), u'Downloads') DCNL DCSP if os.path.isdir(downloads_dir): DCNL DCSP  DCSP return os.path.join(downloads_dir, download_dir) DCNL DCSP else: DCNL DCSP  DCSP return os.path.join(get_home_dir(), download_dir)
 DCSP if ((len(data) - offset) < 2): DCNL DCSP  DCSP return (offset, None) DCNL DCSP (version, number_of_methods) = struct.unpack_from('!BB', data, offset) DCNL DCSP if (not (version == SOCKS_VERSION)): DCNL DCSP  DCSP return (offset, None) DCNL DCSP offset += 2 DCNL DCSP methods = set([]) DCNL DCSP for i in range(number_of_methods): DCNL DCSP  DCSP (method,) = struct.unpack_from('!B', data, offset) DCNL DCSP  DCSP methods.add(method) DCNL DCSP  DCSP offset += 1 DCNL DCSP return (offset, MethodRequest(version, methods))
 DCSP return struct.pack('!BB', version, method)
 DCSP offset = orig_offset DCNL DCSP if ((len(data) - offset) < 4): DCNL DCSP  DCSP return (orig_offset, None) DCNL DCSP (version, cmd, rsv, address_type) = struct.unpack_from('!BBBB', data, offset) DCNL DCSP offset += 4 DCNL DCSP assert (version == SOCKS_VERSION), (version, SOCKS_VERSION) DCNL DCSP assert (rsv == 0) DCNL DCSP (offset, destination_address) = __decode_address(address_type, offset, data) DCNL DCSP if (not destination_address): DCNL DCSP  DCSP return (orig_offset, None) DCNL DCSP if ((len(data) - offset) < 2): DCNL DCSP  DCSP return (orig_offset, None) DCNL DCSP (destination_port,) = struct.unpack_from('!H', data, offset) DCNL DCSP offset += 2 DCNL DCSP return (offset, Request(version, cmd, rsv, address_type, destination_address, destination_port))
 DCSP data = struct.pack('BBBB', version, rep, rsv, address_type) DCNL DCSP data += __encode_address(address_type, bind_address) DCNL DCSP data += struct.pack('!H', bind_port) DCNL DCSP return data
 DCSP offset = 0 DCNL DCSP (rsv, frag, address_type) = struct.unpack_from('!HBB', data, offset) DCNL DCSP offset += 4 DCNL DCSP (offset, destination_address) = __decode_address(address_type, offset, data) DCNL DCSP (destination_port,) = struct.unpack_from('!H', data, offset) DCNL DCSP offset += 2 DCNL DCSP payload = data[offset:] DCNL DCSP return UdpRequest(rsv, frag, address_type, destination_address, destination_port, payload)
 DCSP strings = [struct.pack('!HBB', rsv, frag, address_type), __encode_address(address_type, address), struct.pack('!H', port), payload] DCNL DCSP return ''.join(strings)
 DCSP files_path = os.path.join(target_path, 'http_torrent_files') DCNL DCSP os.mkdir(files_path) DCNL DCSP port = get_random_port() DCNL DCSP from Tribler.Test.common import TESTS_DATA_DIR DCNL DCSP with open(os.path.join(TESTS_DATA_DIR, filename), 'r') as source_xml: DCNL DCSP  DCSP with open(os.path.join(target_path, filename), 'w') as destination_xml: DCNL DCSP  DCSP  DCSP for line in source_xml: DCNL DCSP  DCSP  DCSP  DCSP destination_xml.write(line.replace('RANDOMPORT', str(port))) DCNL DCSP return (files_path, port)
 DCSP def decorate(newfunc): DCNL DCSP  DCSP if hasattr(func, 'compat_func_name'): DCNL DCSP  DCSP  DCSP name = func.compat_func_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP name = func.__name__ DCNL DCSP  DCSP newfunc.__dict__ = func.__dict__ DCNL DCSP  DCSP newfunc.__doc__ = func.__doc__ DCNL DCSP  DCSP newfunc.__module__ = func.__module__ DCNL DCSP  DCSP if (not hasattr(newfunc, 'compat_co_firstlineno')): DCNL DCSP  DCSP  DCSP newfunc.compat_co_firstlineno = func.func_code.co_firstlineno DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP newfunc.__name__ = name DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP newfunc.compat_func_name = name DCNL DCSP  DCSP return newfunc DCNL DCSP return decorate
 DCSP global _twisted_thread DCNL DCSP if (not _twisted_thread): DCNL DCSP  DCSP from threading import Thread DCNL DCSP  DCSP _twisted_thread = Thread(target=(lambda : reactor.run(installSignalHandlers=False)), name='Twisted') DCNL DCSP  DCSP _twisted_thread.setDaemon(True) DCNL DCSP  DCSP _twisted_thread.start() DCNL DCSP  DCSP def hook_observer(): DCNL DCSP  DCSP  DCSP observer = log.PythonLoggingObserver() DCNL DCSP  DCSP  DCSP observer.start() DCNL DCSP  DCSP  DCSP import logging DCNL DCSP  DCSP  DCSP log.msg('PythonLoggingObserver DCSP hooked DCSP up', logLevel=logging.DEBUG) DCNL DCSP  DCSP reactor.callFromThread(hook_observer) DCNL DCSP return (reactor, _twisted_thread)
 DCSP global _twisted_thread DCNL DCSP def _stop_reactor(): DCNL DCSP  DCSP '"Helper DCSP for DCSP calling DCSP stop DCSP from DCSP withing DCSP the DCSP thread.' DCNL DCSP  DCSP reactor.stop() DCNL DCSP reactor.callFromThread(_stop_reactor) DCNL DCSP reactor_thread.join() DCNL DCSP for p in reactor.getDelayedCalls(): DCNL DCSP  DCSP if p.active(): DCNL DCSP  DCSP  DCSP p.cancel() DCNL DCSP _twisted_thread = None
 DCSP (reactor, reactor_thread) = threaded_reactor() DCNL DCSP if (reactor is None): DCNL DCSP  DCSP raise ImportError('twisted DCSP is DCSP not DCSP available DCSP or DCSP could DCSP not DCSP be DCSP imported') DCNL DCSP try: DCNL DCSP  DCSP ((timeout is None) or (timeout + 0)) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise TypeError("'timeout' DCSP argument DCSP must DCSP be DCSP a DCSP number DCSP or DCSP None") DCNL DCSP def decorate(func): DCNL DCSP  DCSP def wrapper(*args, **kargs): DCNL DCSP  DCSP  DCSP q = Queue() DCNL DCSP  DCSP  DCSP def callback(value): DCNL DCSP  DCSP  DCSP  DCSP q.put(None) DCNL DCSP  DCSP  DCSP def errback(failure): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP failure.raiseException() DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP q.put(sys.exc_info()) DCNL DCSP  DCSP  DCSP def g(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = func(*args, **kargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP d.addCallbacks(callback, errback) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('you DCSP must DCSP return DCSP a DCSP twisted DCSP Deferred DCSP from DCSP your DCSP test DCSP case!') DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP q.put(sys.exc_info()) DCNL DCSP  DCSP  DCSP reactor.callFromThread(g) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP error = q.get(timeout=timeout) DCNL DCSP  DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP  DCSP raise TimeExpired(('timeout DCSP expired DCSP before DCSP end DCSP of DCSP test DCSP (%f DCSP s.)' % timeout)) DCNL DCSP  DCSP  DCSP if (error is not None): DCNL DCSP  DCSP  DCSP  DCSP (exc_type, exc_value, tb) = error DCNL DCSP  DCSP  DCSP  DCSP raise exc_type, exc_value, tb DCNL DCSP  DCSP wrapper = make_decorator(func)(wrapper) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorate
 DCSP def wrapper(obj, query_string, *args, **kwargs): DCNL DCSP  DCSP start = time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(obj, query_string, *args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP stop = time() DCNL DCSP  DCSP  DCSP if settings.DEBUG: DCNL DCSP  DCSP  DCSP  DCSP from haystack import connections DCNL DCSP  DCSP  DCSP  DCSP connections[obj.connection_alias].queries.append({u'query_string': query_string, u'additional_args': args, u'additional_kwargs': kwargs, u'time': (u'%.3f' % (stop - start)), u'start': start, u'stop': stop}) DCNL DCSP return wrapper
 DCSP bits = token.split_contents() DCNL DCSP if (not (len(bits) in (4, 6, 8))): DCNL DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag DCSP requires DCSP either DCSP 3, DCSP 5 DCSP or DCSP 7 DCSP arguments." % bits[0])) DCNL DCSP model = bits[1] DCNL DCSP if (bits[2] != u'as'): DCNL DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag's DCSP second DCSP argument DCSP should DCSP be DCSP 'as'." % bits[0])) DCNL DCSP varname = bits[3] DCNL DCSP limit = None DCNL DCSP for_types = None DCNL DCSP if (len(bits) == 6): DCNL DCSP  DCSP if ((bits[4] != u'limit') and (bits[4] != u'for')): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag's DCSP fourth DCSP argument DCSP should DCSP be DCSP either DCSP 'limit' DCSP or DCSP 'for'." % bits[0])) DCNL DCSP  DCSP if (bits[4] == u'limit'): DCNL DCSP  DCSP  DCSP limit = bits[5] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for_types = bits[5] DCNL DCSP if (len(bits) == 8): DCNL DCSP  DCSP if (bits[4] != u'for'): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag's DCSP fourth DCSP argument DCSP should DCSP be DCSP 'for'." % bits[0])) DCNL DCSP  DCSP for_types = bits[5] DCNL DCSP  DCSP if (bits[6] != u'limit'): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag's DCSP sixth DCSP argument DCSP should DCSP be DCSP 'limit'." % bits[0])) DCNL DCSP  DCSP limit = bits[7] DCNL DCSP return MoreLikeThisNode(model, varname, for_types, limit)
 DCSP bits = token.split_contents() DCNL DCSP tag_name = bits[0] DCNL DCSP if (not ((len(bits) % 2) == 0)): DCNL DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag DCSP requires DCSP valid DCSP pairings DCSP arguments." % tag_name)) DCNL DCSP text_block = bits[1] DCNL DCSP if (len(bits) < 4): DCNL DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag DCSP requires DCSP an DCSP object DCSP and DCSP a DCSP query DCSP provided DCSP by DCSP 'with'." % tag_name)) DCNL DCSP if (bits[2] != u'with'): DCNL DCSP  DCSP raise template.TemplateSyntaxError((u"'%s' DCSP tag's DCSP second DCSP argument DCSP should DCSP be DCSP 'with'." % tag_name)) DCNL DCSP query = bits[3] DCNL DCSP arg_bits = iter(bits[4:]) DCNL DCSP kwargs = {} DCNL DCSP for bit in arg_bits: DCNL DCSP  DCSP if (bit == u'css_class'): DCNL DCSP  DCSP  DCSP kwargs[u'css_class'] = six.next(arg_bits) DCNL DCSP  DCSP if (bit == u'html_tag'): DCNL DCSP  DCSP  DCSP kwargs[u'html_tag'] = six.next(arg_bits) DCNL DCSP  DCSP if (bit == u'max_length'): DCNL DCSP  DCSP  DCSP kwargs[u'max_length'] = six.next(arg_bits) DCNL DCSP return HighlightNode(text_block, query, **kwargs)
 DCSP result = default DCNL DCSP if (f.get_internal_type() in (u'DateField', u'DateTimeField')): DCNL DCSP  DCSP result = DateTimeField DCNL DCSP elif (f.get_internal_type() in (u'BooleanField', u'NullBooleanField')): DCNL DCSP  DCSP result = BooleanField DCNL DCSP elif (f.get_internal_type() in (u'CommaSeparatedIntegerField',)): DCNL DCSP  DCSP result = MultiValueField DCNL DCSP elif (f.get_internal_type() in (u'DecimalField', u'FloatField')): DCNL DCSP  DCSP result = FloatField DCNL DCSP elif (f.get_internal_type() in (u'IntegerField', u'PositiveIntegerField', u'PositiveSmallIntegerField', u'SmallIntegerField')): DCNL DCSP  DCSP result = IntegerField DCNL DCSP return result
 DCSP try: DCNL DCSP  DCSP from django.contrib.admin.views.main import MAX_SHOW_ALL_ALLOWED DCNL DCSP  DCSP return MAX_SHOW_ALL_ALLOWED DCNL DCSP except ImportError: DCNL DCSP  DCSP return changelist.list_max_show_all
 DCSP query = u'' DCNL DCSP results = EmptySearchQuerySet() DCNL DCSP if request.GET.get(u'q'): DCNL DCSP  DCSP form = form_class(request.GET, searchqueryset=searchqueryset, load_all=load_all) DCNL DCSP  DCSP if form.is_valid(): DCNL DCSP  DCSP  DCSP query = form.cleaned_data[u'q'] DCNL DCSP  DCSP  DCSP results = form.search() DCNL DCSP else: DCNL DCSP  DCSP form = form_class(searchqueryset=searchqueryset, load_all=load_all) DCNL DCSP paginator = Paginator(results, (results_per_page or RESULTS_PER_PAGE)) DCNL DCSP try: DCNL DCSP  DCSP page = paginator.page(int(request.GET.get(u'page', 1))) DCNL DCSP except InvalidPage: DCNL DCSP  DCSP raise Http404(u'No DCSP such DCSP page DCSP of DCSP results!') DCNL DCSP context = {u'form': form, u'page': page, u'paginator': paginator, u'query': query, u'suggestion': None} DCNL DCSP if results.query.backend.include_spelling: DCNL DCSP  DCSP context[u'suggestion'] = form.get_suggestion() DCNL DCSP if extra_context: DCNL DCSP  DCSP context.update(extra_context) DCNL DCSP return render(request, template, context)
 DCSP if isinstance(obj_or_string, six.string_types): DCNL DCSP  DCSP if (not IDENTIFIER_REGEX.match(obj_or_string)): DCNL DCSP  DCSP  DCSP raise AttributeError((u"Provided DCSP string DCSP '%s' DCSP is DCSP not DCSP a DCSP valid DCSP identifier." % obj_or_string)) DCNL DCSP  DCSP return obj_or_string DCNL DCSP return (u'%s.%s' % (get_model_ct(obj_or_string), obj_or_string._get_pk_val()))
 DCSP if (not hasattr(settings, u'HAYSTACK_IDENTIFIER_METHOD')): DCNL DCSP  DCSP return default_get_identifier DCNL DCSP (module_path, method_name) = settings.HAYSTACK_IDENTIFIER_METHOD.rsplit(u'.', 1) DCNL DCSP try: DCNL DCSP  DCSP module = importlib.import_module(module_path) DCNL DCSP except ImportError: DCNL DCSP  DCSP raise ImportError((u"Unable DCSP to DCSP import DCSP module DCSP '%s' DCSP provided DCSP for DCSP HAYSTACK_IDENTIFIER_METHOD." % module_path)) DCNL DCSP identifier_method = getattr(module, method_name, None) DCNL DCSP if (not identifier_method): DCNL DCSP  DCSP raise AttributeError((u"Provided DCSP method DCSP '%s' DCSP for DCSP HAYSTACK_IDENTIFIER_METHOD DCSP does DCSP not DCSP exist DCSP in DCSP '%s'." % (method_name, module_path))) DCNL DCSP return identifier_method
 DCSP if (not hasattr(geom, u'geom_type')): DCNL DCSP  DCSP raise SpatialError((u"Point DCSP '%s' DCSP doesn't DCSP appear DCSP to DCSP be DCSP a DCSP GEOS DCSP geometry." % geom)) DCNL DCSP return geom
 DCSP ensure_geometry(geom) DCNL DCSP if (geom.geom_type != u'Point'): DCNL DCSP  DCSP raise SpatialError((u"Provided DCSP geometry DCSP '%s' DCSP is DCSP not DCSP a DCSP 'Point'." % geom)) DCNL DCSP return geom
 DCSP ensure_point(point) DCNL DCSP new_point = point.clone() DCNL DCSP if (not new_point.srid): DCNL DCSP  DCSP new_point.set_srid(WGS_84_SRID) DCNL DCSP elif (new_point.srid != WGS_84_SRID): DCNL DCSP  DCSP new_point.transform(WGS_84_SRID) DCNL DCSP return new_point
 DCSP try: DCNL DCSP  DCSP km = dist.km DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise SpatialError((u"'%s' DCSP does DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP 'Distance' DCSP object." % dist)) DCNL DCSP return dist
 DCSP (west, lat_1) = bottom_left.get_coords() DCNL DCSP (east, lat_2) = top_right.get_coords() DCNL DCSP (min_lat, max_lat) = (min(lat_1, lat_2), max(lat_1, lat_2)) DCNL DCSP return ((min_lat, west), (max_lat, east))
 DCSP return [i.module for i in apps.get_app_configs()]
 DCSP return [i.label for i in apps.get_app_configs() if (i.models_module is not None)]
 DCSP path_bits = full_backend_path.split(u'.') DCNL DCSP if (len(path_bits) < 2): DCNL DCSP  DCSP raise ImproperlyConfigured((u"The DCSP provided DCSP backend DCSP '%s' DCSP is DCSP not DCSP a DCSP complete DCSP Python DCSP path DCSP to DCSP a DCSP BaseEngine DCSP subclass." % full_backend_path)) DCNL DCSP return import_class(full_backend_path)
 DCSP path_bits = full_router_path.split(u'.') DCNL DCSP if (len(path_bits) < 2): DCNL DCSP  DCSP raise ImproperlyConfigured((u"The DCSP provided DCSP router DCSP '%s' DCSP is DCSP not DCSP a DCSP complete DCSP Python DCSP path DCSP to DCSP a DCSP BaseRouter DCSP subclass." % full_router_path)) DCNL DCSP return import_class(full_router_path)
 DCSP if hasattr(key, u'get_custom_haystack_id'): DCNL DCSP  DCSP return key.get_custom_haystack_id() DCNL DCSP else: DCNL DCSP  DCSP key_bytes = key.encode(u'utf-8') DCNL DCSP  DCSP return hashlib.md5(key_bytes).hexdigest()
 DCSP adjectives = ['ablest', 'absurd', 'actual', 'aerial', 'allied', 'artful', 'atomic', 'august', 'bamboo', 'benign', 'blonde', 'blurry', 'bolder', 'breezy', 'bubbly', 'burley', 'candid', 'calmer', 'casual', 'cheery', 'classy', 'clever', 'convex', 'cubist', 'dainty', 'dapper', 'decent', 'deluxe', 'docile', 'dogged', 'drafty', 'dreamy', 'earthy', 'easier', 'echoed', 'edible', 'elfish', 'excess', 'exotic', 'expert', 'fabled', 'famous', 'feline', 'finest', 'flaxen', 'folksy', 'frisky', 'frozen', 'gaslit', 'gentle', 'gifted', 'ginger', 'global', 'golden', 'grassy', 'guided', 'haptic', 'hearty', 'hidden', 'hipper', 'honest', 'humble', 'hungry', 'hushed', 'iambic', 'iciest', 'iconic', 'indoor', 'inward', 'ironic', 'island', 'italic', 'jagged', 'jangly', 'jaunty', 'jicama', 'jiggly', 'jovial', 'joyful', 'junior', 'kabuki', 'karmic', 'keener', 'kiddie', 'kindly', 'kingly', 'klutzy', 'knotty', 'lambda', 'latest', 'leader', 'linear', 'lively', 'lonely', 'loving', 'luxury', 'madcap', 'madras', 'marble', 'mellow', 'metric', 'modest', 'molten', 'mystic', 'native', 'nearby', 'nested', 'newish', 'nickel', 'nimbus', 'nonfat', 'normal', 'oblong', 'oddest', 'offset', 'oldest', 'onside', 'orange', 'outlaw', 'owlish', 'padded', 'pastry', 'peachy', 'pepper', 'player', 'preset', 'proper', 'pulsar', 'quacky', 'quaint', 'quartz', 'queens', 'queued', 'quinoa', 'quirky', 'quoted', 'racing', 'rental', 'ribbed', 'rising', 'rococo', 'rubber', 'rugged', 'rustic', 'sanest', 'scenic', 'seeing', 'shadow', 'skiing', 'stable', 'steely', 'syrupy', 'taller', 'tender', 'tested', 'timely', 'trendy', 'triple', 'truthy', 'twenty', 'ultima', 'unbent', 'unisex', 'united', 'upbeat', 'uphill', 'usable', 'utmost', 'vacuum', 'valued', 'vanity', 'velcro', 'velvet', 'verbal', 'violet', 'vulcan', 'walkup', 'webbed', 'wicker', 'wiggly', 'wilder', 'wonder', 'wooden', 'woodsy', 'yearly', 'yeasty', 'yellow', 'yeoman', 'yogurt', 'yonder', 'youthy', 'yuppie', 'zaftig', 'zanier', 'zephyr', 'zeroed', 'zigzag', 'zipped', 'zircon', 'zydeco'] DCNL DCSP nouns = ['addendum', 'anaconda', 'airfield', 'aqualung', 'armchair', 'asteroid', 'autoharp', 'babushka', 'backbone', 'bagpiper', 'barbecue', 'bookworm', 'bullfrog', 'buttress', 'caffeine', 'checkers', 'chinbone', 'countess', 'crawfish', 'cucumber', 'cutpurse', 'daffodil', 'darkroom', 'deadbolt', 'doghouse', 'dragster', 'drumroll', 'duckling', 'earrings', 'earthman', 'eggplant', 'electron', 'elephant', 'espresso', 'eyetooth', 'falconer', 'farmland', 'ferryman', 'fireball', 'fishbone', 'footwear', 'frosting', 'gadabout', 'gasworks', 'gatepost', 'gemstone', 'gladness', 'goldfish', 'greenery', 'hacienda', 'handbill', 'hardtack', 'hawthorn', 'headwind', 'henhouse', 'huntress', 'icehouse', 'idealist', 'inchworm', 'instinct', 'inventor', 'insignia', 'ironwood', 'jailbird', 'jamboree', 'jerrycan', 'jetliner', 'jokester', 'joyrider', 'jumpsuit', 'kangaroo', 'keepsake', 'kerchief', 'keypunch', 'kingfish', 'knapsack', 'knothole', 'ladybird', 'lakeside', 'lambskin', 'landmass', 'larkspur', 'lollipop', 'lungfish', 'macaroni', 'mackinaw', 'magician', 'mainsail', 'milepost', 'mongoose', 'moonrise', 'nailhead', 'nautilus', 'neckwear', 'newsreel', 'nonesuch', 'novelist', 'nuthatch', 'occupant', 'odometer', 'offering', 'offshoot', 'original', 'organism', 'overalls', 'pachinko', 'painting', 'pamphlet', 'paneling', 'pendulum', 'playroom', 'ponytail', 'quacking', 'quadrant', 'quantity', 'queendom', 'question', 'quilting', 'quotient', 'rabbitry', 'radiator', 'renegade', 'ricochet', 'riverbed', 'rosewood', 'rucksack', 'sailfish', 'sandwich', 'sculptor', 'seashore', 'seedcake', 'skylight', 'stickpin', 'tabletop', 'tailbone', 'teamwork', 'teaspoon', 'tinkerer', 'traverse', 'turbojet', 'umbrella', 'underdog', 'undertow', 'unicycle', 'universe', 'uptowner', 'utensils', 'vacation', 'vagabond', 'valkyrie', 'variable', 'villager', 'vineyard', 'vocalist', 'waggoner', 'waxworks', 'waterbed', 'wayfarer', 'whitecap', 'windmill', 'woodshed', 'yachting', 'yardbird', 'yardwork', 'yearbook', 'yearling', 'yeomanry', 'yodeling', 'zaniness', 'zeppelin', 'ziggurat', 'zillions', 'zirconia', 'zoologer', 'zucchini'] DCNL DCSP return '{}-{}'.format(random.choice(adjectives), random.choice(nouns))
 DCSP diff = {} DCNL DCSP (set1, set2) = (set(dict1), set(dict2)) DCNL DCSP diff['added'] = {k: dict1[k] for k in (set1 - set2)} DCNL DCSP diff['changed'] = {k: dict1[k] for k in (set1 & set2) if (dict1[k] != dict2[k])} DCNL DCSP diff['deleted'] = {k: dict2[k] for k in (set2 - set1)} DCNL DCSP return {k: diff[k] for k in diff if diff[k]}
 DCSP key = base64.b64decode(key.strip().split()[1].encode('ascii')) DCNL DCSP fp_plain = hashlib.md5(key).hexdigest() DCNL DCSP return ':'.join(((a + b) for (a, b) in zip(fp_plain[::2], fp_plain[1::2])))
 DCSP if isinstance(obj, basestring): DCNL DCSP  DCSP return obj.encode('utf-8') DCNL DCSP else: DCNL DCSP  DCSP return obj
 DCSP return self.generic(u'PATCH', path, data, content_type, **extra)
 DCSP from django.test.client import Client DCNL DCSP response = super(Client, self).patch(path, data=data, content_type=content_type, **extra) DCNL DCSP if follow: DCNL DCSP  DCSP response = self._handle_redirects(response, **extra) DCNL DCSP return response
 DCSP def _close_db_connections(*args, **kwargs): DCNL DCSP  DCSP ret = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ret = func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP from django.db import connections DCNL DCSP  DCSP  DCSP for conn in connections.all(): DCNL DCSP  DCSP  DCSP  DCSP conn.close() DCNL DCSP  DCSP return ret DCNL DCSP return _close_db_connections
 DCSP try: DCNL DCSP  DCSP base64.b64decode(value.split()[1]) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise ValidationError(e)
 DCSP match = re.match(u'^[a-z0-9-]+$', value) DCNL DCSP if (not match): DCNL DCSP  DCSP raise ValidationError(u'App DCSP IDs DCSP can DCSP only DCSP contain DCSP [a-z0-9-].')
 DCSP try: DCNL DCSP  DCSP if any(((int(v) < 0) for v in value.viewvalues())): DCNL DCSP  DCSP  DCSP raise ValueError(u'Must DCSP be DCSP greater DCSP than DCSP or DCSP equal DCSP to DCSP zero') DCNL DCSP except ValueError as err: DCNL DCSP  DCSP raise ValidationError(err)
 DCSP if (value in settings.DEIS_RESERVED_NAMES): DCNL DCSP  DCSP raise ValidationError(u'{} DCSP is DCSP a DCSP reserved DCSP name.'.format(value))
 DCSP if (not re.search(u'^[a-zA-Z0-9-,\\.]+$', value)): DCNL DCSP  DCSP raise ValidationError(u'{} DCSP should DCSP be DCSP a DCSP comma-separated DCSP list'.format(value))
 DCSP if (not re.search(u'^[a-zA-Z0-9-\\.]+$', value)): DCNL DCSP  DCSP raise ValidationError(u'"{}" DCSP contains DCSP unexpected DCSP characters'.format(value))
 DCSP name = utils.generate_app_name() DCNL DCSP while App.objects.filter(id=name).exists(): DCNL DCSP  DCSP name = utils.generate_app_name() DCNL DCSP return name
 DCSP blacklisted = [u'builder', u'cache', u'controller', u'database', u'logger', u'logspout', u'publisher', u'registry', u'router', u'store-admin', u'store-daemon', u'store-gateway', u'store-metadata', u'store-monitor'] DCNL DCSP if any(((u'deis/{}'.format(c) in repo) for c in blacklisted)): DCNL DCSP  DCSP raise PermissionDenied(u'Repository DCSP name DCSP {} DCSP is DCSP not DCSP allowed'.format(repo))
 DCSP for chunk in stream: DCNL DCSP  DCSP logger.debug(chunk) DCNL DCSP  DCSP if (u'"error"' in chunk.lower()): DCNL DCSP  DCSP  DCSP raise docker.errors.DockerException(chunk)
 DCSP paths = name.split(u'/') DCNL DCSP return u'/'.join((p for p in paths if (p and (u'.' not in p) and (u':' not in p))))
 DCSP return render(request, 'web/account.html', {'page': 'account'})
 DCSP apps = App.objects.filter(owner=request.user) DCNL DCSP return render(request, 'web/dashboard.html', {'page': 'dashboard', 'apps': apps, 'version': __version__})
 DCSP apps = App.objects.filter(owner=request.user) DCNL DCSP return render(request, 'web/apps.html', {'page': 'apps', 'apps': apps})
 DCSP return render(request, 'web/support.html', {'page': 'support'})
 DCSP a_sum = a.sum(axis) DCNL DCSP if (axis and (a.ndim > 1)): DCNL DCSP  DCSP a_sum[(a_sum == 0)] = 1 DCNL DCSP  DCSP shape = list(a.shape) DCNL DCSP  DCSP shape[axis] = 1 DCNL DCSP  DCSP a_sum.shape = shape DCNL DCSP a /= a_sum
 DCSP a_lse = logsumexp(a, axis) DCNL DCSP a -= a_lse[:, np.newaxis]
 DCSP a = np.asarray(a) DCNL DCSP with np.errstate(divide='ignore'): DCNL DCSP  DCSP a_log = np.log(a) DCNL DCSP  DCSP a_log[(a <= 0)] = 0.0 DCNL DCSP  DCSP return a_log
 DCSP log_multivariate_normal_density_dict = {'spherical': _log_multivariate_normal_density_spherical, 'tied': _log_multivariate_normal_density_tied, 'diag': _log_multivariate_normal_density_diag, 'full': _log_multivariate_normal_density_full} DCNL DCSP return log_multivariate_normal_density_dict[covariance_type](X, means, covars)
 DCSP (n_samples, n_dim) = X.shape DCNL DCSP lpr = ((-0.5) * (((((n_dim * np.log((2 * np.pi))) + np.sum(np.log(covars), 1)) + np.sum(((means ** 2) / covars), 1)) - (2 * np.dot(X, (means / covars).T))) + np.dot((X ** 2), (1.0 / covars).T))) DCNL DCSP return lpr
 DCSP cv = covars.copy() DCNL DCSP if (covars.ndim == 1): DCNL DCSP  DCSP cv = cv[:, np.newaxis] DCNL DCSP if (cv.shape[1] == 1): DCNL DCSP  DCSP cv = np.tile(cv, (1, X.shape[(-1)])) DCNL DCSP return _log_multivariate_normal_density_diag(X, means, cv)
 DCSP cv = np.tile(covars, (means.shape[0], 1, 1)) DCNL DCSP return _log_multivariate_normal_density_full(X, means, cv)
 DCSP (n_samples, n_dim) = X.shape DCNL DCSP nmix = len(means) DCNL DCSP log_prob = np.empty((n_samples, nmix)) DCNL DCSP for (c, (mu, cv)) in enumerate(zip(means, covars)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cv_chol = linalg.cholesky(cv, lower=True) DCNL DCSP  DCSP except linalg.LinAlgError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP cv_chol = linalg.cholesky((cv + (min_covar * np.eye(n_dim))), lower=True) DCNL DCSP  DCSP  DCSP except linalg.LinAlgError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError("'covars' DCSP must DCSP be DCSP symmetric, DCSP positive-definite") DCNL DCSP  DCSP cv_log_det = (2 * np.sum(np.log(np.diagonal(cv_chol)))) DCNL DCSP  DCSP cv_sol = linalg.solve_triangular(cv_chol, (X - mu).T, lower=True).T DCNL DCSP  DCSP log_prob[:, c] = ((-0.5) * ((np.sum((cv_sol ** 2), axis=1) + (n_dim * np.log((2 * np.pi)))) + cv_log_det)) DCNL DCSP return log_prob
 DCSP if (path is None): DCNL DCSP  DCSP path = os.environ.get('PATH', '') DCNL DCSP for dir in path.split(os.pathsep): DCNL DCSP  DCSP fpath = os.path.join(dir, fname) DCNL DCSP  DCSP if os.path.isfile(fpath): DCNL DCSP  DCSP  DCSP return fpath DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP ty = ty.replace('std::', '') DCNL DCSP ty = re.sub('(.*)<(.*)>', '\\1< DCSP \\2 DCSP >', ty) DCNL DCSP return ty
 DCSP doc = str(('' if (element.raw_comment is None) else element.raw_comment)) DCNL DCSP doc = doc.strip() DCNL DCSP if (doc.find('< DCSP ') == 0): DCNL DCSP  DCSP doc = doc[2:] DCNL DCSP if (doc.find('\\todo') == 0): DCNL DCSP  DCSP doc = '' DCNL DCSP if (doc.find('\\tparam') == 0): DCNL DCSP  DCSP doc = re.sub('\\\\tparam.*', '', doc) DCNL DCSP if (doc.find('TODO:') == 0): DCNL DCSP  DCSP doc = '' DCNL DCSP doc = doc.replace('\\warning DCSP ', '\nWarning: DCSP ') DCNL DCSP doc = doc.replace('\\author DCSP ', '\nBy: DCSP ') DCNL DCSP doc = doc.replace('\\param DCSP ', '\nParameters:\n', 1) DCNL DCSP doc = doc.replace('\\param DCSP ', '') DCNL DCSP doc = doc.replace('\\brief DCSP ', '') DCNL DCSP doc = doc.replace('\\returns DCSP ', '\nReturns: DCSP ') DCNL DCSP doc = doc.replace('\\sa DCSP ', '\nSee DCSP also: DCSP ') DCNL DCSP docs = '' DCNL DCSP for line in iter(doc.splitlines()): DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP line = line.replace('/// DCSP ', '') DCNL DCSP  DCSP line = line.replace('///', '') DCNL DCSP  DCSP line = re.sub('\\\\class DCSP (.*)', '', line) DCNL DCSP  DCSP docs += (line + '\n') DCNL DCSP try: DCNL DCSP  DCSP docs = HTMLParser.HTMLParser().unescape(docs) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP docs += '\n' DCNL DCSP return docs
 DCSP args = list(flags) DCNL DCSP name = 't.c' DCNL DCSP if (lang == 'cpp'): DCNL DCSP  DCSP name = 't.cpp' DCNL DCSP  DCSP args.append('-std=c++11') DCNL DCSP elif (lang == 'objc'): DCNL DCSP  DCSP name = 't.m' DCNL DCSP elif (lang != 'c'): DCNL DCSP  DCSP raise Exception(('Unknown DCSP language: DCSP %s' % lang)) DCNL DCSP if all_warnings: DCNL DCSP  DCSP args += ['-Wall', '-Wextra'] DCNL DCSP return TranslationUnit.from_source(name, args, unsaved_files=[(name, source)])
 DCSP root_cursor = (source if isinstance(source, Cursor) else source.cursor) DCNL DCSP for cursor in root_cursor.walk_preorder(): DCNL DCSP  DCSP if (cursor.spelling == spelling): DCNL DCSP  DCSP  DCSP return cursor DCNL DCSP return None
 DCSP root_cursor = (source if isinstance(source, Cursor) else source.cursor) DCNL DCSP cursors = [] DCNL DCSP for cursor in root_cursor.walk_preorder(): DCNL DCSP  DCSP if (cursor.spelling == spelling): DCNL DCSP  DCSP  DCSP cursors.append(cursor) DCNL DCSP return cursors
 DCSP n = len(s) DCNL DCSP if (n == 0): DCNL DCSP  DCSP return [] DCNL DCSP u = {} DCNL DCSP try: DCNL DCSP  DCSP for x in s: DCNL DCSP  DCSP  DCSP u[x] = 1 DCNL DCSP except TypeError: DCNL DCSP  DCSP del u DCNL DCSP else: DCNL DCSP  DCSP return u.keys() DCNL DCSP try: DCNL DCSP  DCSP t = list(s) DCNL DCSP  DCSP t.sort() DCNL DCSP except TypeError: DCNL DCSP  DCSP del t DCNL DCSP else: DCNL DCSP  DCSP assert (n > 0) DCNL DCSP  DCSP last = t[0] DCNL DCSP  DCSP lasti = i = 1 DCNL DCSP  DCSP while (i < n): DCNL DCSP  DCSP  DCSP if (t[i] != last): DCNL DCSP  DCSP  DCSP  DCSP t[lasti] = last = t[i] DCNL DCSP  DCSP  DCSP  DCSP lasti += 1 DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP return t[:lasti] DCNL DCSP u = [] DCNL DCSP for x in s: DCNL DCSP  DCSP if (x not in u): DCNL DCSP  DCSP  DCSP u.append(x) DCNL DCSP return u
 DCSP if hasattr(random, 'SystemRandom'): DCNL DCSP  DCSP choice = random.SystemRandom().choice DCNL DCSP else: DCNL DCSP  DCSP choice = random.choice DCNL DCSP return ''.join(map((lambda x: choice((string.digits + string.letters))), range(key_length)))
 DCSP lock = lockfile.FileLock(key_file) DCNL DCSP with lock: DCNL DCSP  DCSP if (not os.path.exists(key_file)): DCNL DCSP  DCSP  DCSP key = generate_key(key_length) DCNL DCSP  DCSP  DCSP old_umask = os.umask(127) DCNL DCSP  DCSP  DCSP with open(key_file, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(key) DCNL DCSP  DCSP  DCSP os.umask(old_umask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (oct((os.stat(key_file).st_mode & 511)) is None): DCNL DCSP  DCSP  DCSP  DCSP raise FilePermissionError('Insecure DCSP key DCSP file DCSP permissions!') DCNL DCSP  DCSP  DCSP with open(key_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP key = f.readline() DCNL DCSP  DCSP return key
 DCSP if CONF.log_config: DCNL DCSP  DCSP if os.path.exists(CONF.log_config): DCNL DCSP  DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError(('Unable DCSP to DCSP locate DCSP specified DCSP logging DCSP config DCSP file: DCSP %s' % CONF.log_config)) DCNL DCSP root_logger = logging.root DCNL DCSP if CONF.debug: DCNL DCSP  DCSP root_logger.setLevel(logging.DEBUG) DCNL DCSP elif CONF.verbose: DCNL DCSP  DCSP root_logger.setLevel(logging.INFO) DCNL DCSP else: DCNL DCSP  DCSP root_logger.setLevel(logging.WARNING) DCNL DCSP formatter = logging.Formatter(CONF.log_format, CONF.log_date_format) DCNL DCSP if CONF.use_syslog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP facility = getattr(logging.handlers.SysLogHandler, CONF.syslog_log_facility) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ValueError(_('Invalid DCSP syslog DCSP facility')) DCNL DCSP  DCSP handler = logging.handlers.SysLogHandler(address='/dev/log', facility=facility) DCNL DCSP elif CONF.log_file: DCNL DCSP  DCSP logfile = CONF.log_file DCNL DCSP  DCSP if CONF.log_dir: DCNL DCSP  DCSP  DCSP logfile = os.path.join(CONF.log_dir, logfile) DCNL DCSP  DCSP handler = logging.handlers.WatchedFileHandler(logfile) DCNL DCSP else: DCNL DCSP  DCSP handler = logging.StreamHandler(sys.stdout) DCNL DCSP handler.setFormatter(formatter) DCNL DCSP root_logger.addHandler(handler)
 DCSP flavor = CONF.paste_deploy.flavor DCNL DCSP return ('' if (not flavor) else ('-' + flavor))
 DCSP path = CONF.paste_deploy.config_file DCNL DCSP if (not path): DCNL DCSP  DCSP path = _get_paste_config_path() DCNL DCSP if (not path): DCNL DCSP  DCSP msg = ('Unable DCSP to DCSP locate DCSP paste DCSP config DCSP file DCSP for DCSP %s.' % CONF.prog) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return os.path.abspath(path)
 DCSP if (app_name is None): DCNL DCSP  DCSP app_name = CONF.prog DCNL DCSP app_name += _get_deployment_flavor() DCNL DCSP conf_file = _get_deployment_config_file() DCNL DCSP try: DCNL DCSP  DCSP logger = logging.getLogger(__name__) DCNL DCSP  DCSP logger.debug(_('Loading DCSP %(app_name)s DCSP from DCSP %(conf_file)s'), {'conf_file': conf_file, 'app_name': app_name}) DCNL DCSP  DCSP app = deploy.loadapp(('config:%s' % conf_file), name=app_name) DCNL DCSP  DCSP if CONF.debug: DCNL DCSP  DCSP  DCSP CONF.log_opt_values(logger, logging.DEBUG) DCNL DCSP  DCSP return app DCNL DCSP except (LookupError, ImportError) as e: DCNL DCSP  DCSP msg = (_('Unable DCSP to DCSP load DCSP %(app_name)s DCSP from DCSP configuration DCSP file DCSP %(conf_file)s.\nGot: DCSP %(e)r') % locals()) DCNL DCSP  DCSP logger.error(msg) DCNL DCSP  DCSP raise RuntimeError(msg)
 DCSP return (chunkiter(iter, chunk_size) if hasattr(iter, 'read') else iter)
 DCSP while True: DCNL DCSP  DCSP chunk = fp.read(chunk_size) DCNL DCSP  DCSP if chunk: DCNL DCSP  DCSP  DCSP (yield chunk) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
 DCSP try: DCNL DCSP  DCSP for chunk in iter: DCNL DCSP  DCSP  DCSP sleep(0) DCNL DCSP  DCSP  DCSP (yield chunk) DCNL DCSP except Exception as err: DCNL DCSP  DCSP msg = (_('Error: DCSP cooperative_iter DCSP exception DCSP %s') % err) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise
 DCSP def readfn(*args): DCNL DCSP  DCSP result = fd.read(*args) DCNL DCSP  DCSP sleep(0) DCNL DCSP  DCSP return result DCNL DCSP return readfn
 DCSP headers = {} DCNL DCSP for (k, v) in image_meta.items(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP if (k == 'properties'): DCNL DCSP  DCSP  DCSP  DCSP for (pk, pv) in v.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (pv is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP headers[('x-image-meta-property-%s' % pk.lower())] = unicode(pv) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP headers[('x-image-meta-%s' % k.lower())] = unicode(v) DCNL DCSP return headers
 DCSP if features: DCNL DCSP  DCSP for (k, v) in features.items(): DCNL DCSP  DCSP  DCSP if (k.lower() in FEATURE_BLACKLIST): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupportedHeaderFeature(feature=k) DCNL DCSP  DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP  DCSP headers[k.lower()] = unicode(v)
 DCSP result = {} DCNL DCSP properties = {} DCNL DCSP if hasattr(response, 'getheaders'): DCNL DCSP  DCSP headers = response.getheaders() DCNL DCSP else: DCNL DCSP  DCSP headers = response.headers.items() DCNL DCSP for (key, value) in headers: DCNL DCSP  DCSP key = str(key.lower()) DCNL DCSP  DCSP if key.startswith('x-image-meta-property-'): DCNL DCSP  DCSP  DCSP field_name = key[len('x-image-meta-property-'):].replace('-', '_') DCNL DCSP  DCSP  DCSP properties[field_name] = (value or None) DCNL DCSP  DCSP elif key.startswith('x-image-meta-'): DCNL DCSP  DCSP  DCSP field_name = key[len('x-image-meta-'):].replace('-', '_') DCNL DCSP  DCSP  DCSP result[field_name] = (value or None) DCNL DCSP result['properties'] = properties DCNL DCSP if ('size' in result): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result['size'] = int(result['size']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise exception.Invalid DCNL DCSP for key in ('is_public', 'deleted', 'protected'): DCNL DCSP  DCSP if (key in result): DCNL DCSP  DCSP  DCSP result[key] = bool_from_string(result[key]) DCNL DCSP return result
 DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP elif isinstance(subject, int): DCNL DCSP  DCSP return (subject == 1) DCNL DCSP if hasattr(subject, 'startswith'): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', '1', 'yes', 'y')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, req, *args, **kwargs): DCNL DCSP  DCSP if req.context.read_only: DCNL DCSP  DCSP  DCSP msg = _('Read-only DCSP access') DCNL DCSP  DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP  DCSP raise exc.HTTPForbidden(msg, request=req, content_type='text/plain') DCNL DCSP  DCSP return func(self, req, *args, **kwargs) DCNL DCSP return wrapped
 DCSP endpoint = None DCNL DCSP for service in service_catalog: DCNL DCSP  DCSP s_type = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s_type = service['type'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP msg = (_('Encountered DCSP service DCSP with DCSP no DCSP "type": DCSP %s') % s_type) DCNL DCSP  DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (s_type == service_type): DCNL DCSP  DCSP  DCSP for ep in service['endpoints']: DCNL DCSP  DCSP  DCSP  DCSP if ((endpoint_region is None) or (endpoint_region == ep['region'])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (endpoint is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.RegionAmbiguity(region=endpoint_region) DCNL DCSP  DCSP  DCSP  DCSP  DCSP endpoint = ep DCNL DCSP if (endpoint and endpoint.get(endpoint_type)): DCNL DCSP  DCSP return endpoint[endpoint_type] DCNL DCSP else: DCNL DCSP  DCSP raise exception.NoServiceEndpoint()
 DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP except exception.NotAuthenticated: DCNL DCSP  DCSP  DCSP self._authenticate(force_reauth=True) DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrapped
 DCSP MAX_REDIRECTS = 5 DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, method, url, body, headers): DCNL DCSP  DCSP for _ in xrange(MAX_REDIRECTS): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(self, method, url, body, headers) DCNL DCSP  DCSP  DCSP except exception.RedirectException as redirect: DCNL DCSP  DCSP  DCSP  DCSP if (redirect.url is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.InvalidRedirect() DCNL DCSP  DCSP  DCSP  DCSP url = redirect.url DCNL DCSP  DCSP raise exception.MaxRedirectsExceeded(redirects=MAX_REDIRECTS) DCNL DCSP return wrapped
 DCSP return (CONF.bind_host, (CONF.bind_port or default_port))
 DCSP bind_addr = get_bind_addr(default_port) DCNL DCSP address_family = [addr[0] for addr in socket.getaddrinfo(bind_addr[0], bind_addr[1], socket.AF_UNSPEC, socket.SOCK_STREAM) if (addr[0] in (socket.AF_INET, socket.AF_INET6))][0] DCNL DCSP cert_file = CONF.cert_file DCNL DCSP key_file = CONF.key_file DCNL DCSP use_ssl = (cert_file or key_file) DCNL DCSP if (use_ssl and ((not cert_file) or (not key_file))): DCNL DCSP  DCSP raise RuntimeError(_('When DCSP running DCSP server DCSP in DCSP SSL DCSP mode, DCSP you DCSP must DCSP specify DCSP both DCSP a DCSP cert_file DCSP and DCSP key_file DCSP option DCSP value DCSP in DCSP your DCSP configuration DCSP file')) DCNL DCSP def wrap_ssl(sock): DCNL DCSP  DCSP ssl_kwargs = {'server_side': True, 'certfile': cert_file, 'keyfile': key_file, 'cert_reqs': ssl.CERT_NONE} DCNL DCSP  DCSP if CONF.ca_file: DCNL DCSP  DCSP  DCSP ssl_kwargs['ca_certs'] = CONF.ca_file DCNL DCSP  DCSP  DCSP ssl_kwargs['cert_reqs'] = ssl.CERT_REQUIRED DCNL DCSP  DCSP return ssl.wrap_socket(sock, **ssl_kwargs) DCNL DCSP sock = None DCNL DCSP retry_until = (time.time() + 30) DCNL DCSP while ((not sock) and (time.time() < retry_until)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = eventlet.listen(bind_addr, backlog=CONF.backlog, family=address_family) DCNL DCSP  DCSP  DCSP if use_ssl: DCNL DCSP  DCSP  DCSP  DCSP sock = wrap_ssl(sock) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err.args[0] != errno.EADDRINUSE): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP eventlet.sleep(0.1) DCNL DCSP if (not sock): DCNL DCSP  DCSP raise RuntimeError((_('Could DCSP not DCSP bind DCSP to DCSP %s:%s DCSP after DCSP trying DCSP for DCSP 30 DCSP seconds') % bind_addr)) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) DCNL DCSP if hasattr(socket, 'TCP_KEEPIDLE'): DCNL DCSP  DCSP sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, CONF.tcp_keepidle) DCNL DCSP return sock
 DCSP def pad(text): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Pads DCSP text DCSP to DCSP be DCSP encrypted\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP pad_length = (blocksize - (len(text) % blocksize)) DCNL DCSP  DCSP sr = random.StrongRandom() DCNL DCSP  DCSP pad = ''.join((chr(sr.randint(1, 255)) for i in range((pad_length - 1)))) DCNL DCSP  DCSP return ((text + chr(0)) + pad) DCNL DCSP init_vector = Random.get_random_bytes(16) DCNL DCSP cypher = AES.new(key, AES.MODE_CBC, init_vector) DCNL DCSP padded = cypher.encrypt(pad(str(plaintext))) DCNL DCSP return base64.urlsafe_b64encode((init_vector + padded))
 DCSP ciphertext = base64.urlsafe_b64decode(str(ciphertext)) DCNL DCSP cypher = AES.new(key, AES.MODE_CBC, ciphertext[:16]) DCNL DCSP padded = cypher.decrypt(ciphertext[16:]) DCNL DCSP return padded[:padded.rfind(chr(0))]
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if ((image.owner is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image.owner == context.owner)
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP return (member.member_id == context.owner)
 DCSP deserializer = RequestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageMembersController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
 DCSP deserializer = RequestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageDataController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
 DCSP filename = 'schema-image.json' DCNL DCSP match = CONF.find_file(filename) DCNL DCSP if match: DCNL DCSP  DCSP schema_file = open(match) DCNL DCSP  DCSP schema_data = schema_file.read() DCNL DCSP  DCSP return json.loads(schema_data) DCNL DCSP else: DCNL DCSP  DCSP msg = _('Could DCSP not DCSP find DCSP schema DCSP properties DCSP file DCSP %s. DCSP Continuing DCSP without DCSP custom DCSP properties') DCNL DCSP  DCSP LOG.warn((msg % filename)) DCNL DCSP  DCSP return {}
 DCSP schema = get_schema(custom_properties) DCNL DCSP deserializer = RequestDeserializer(schema) DCNL DCSP serializer = ResponseSerializer(schema) DCNL DCSP controller = ImagesController() DCNL DCSP return wsgi.Resource(controller, deserializer, serializer)
 DCSP serializer = ResponseSerializer() DCNL DCSP controller = Controller() DCNL DCSP return wsgi.Resource(controller, serializer=serializer)
 DCSP try: DCNL DCSP  DCSP context = request.context DCNL DCSP  DCSP payload = {'bytes_sent': bytes_written, 'image_id': image_meta['id'], 'owner_id': image_meta['owner'], 'receiver_tenant_id': context.tenant, 'receiver_user_id': context.user, 'destination_ip': request.remote_addr} DCNL DCSP  DCSP if (bytes_written != expected_size): DCNL DCSP  DCSP  DCSP notify = notifier.error DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP notify = notifier.info DCNL DCSP  DCSP notify('image.send', payload) DCNL DCSP except Exception as err: DCNL DCSP  DCSP msg = (_('An DCSP error DCSP occurred DCSP during DCSP image.send DCSP notification: DCSP %(err)s') % locals()) DCNL DCSP  DCSP LOG.error(msg)
 DCSP deserializer = wsgi.JSONRequestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
 DCSP if ('location' in image_meta): DCNL DCSP  DCSP tmp_image_meta = copy.copy(image_meta) DCNL DCSP  DCSP del tmp_image_meta['location'] DCNL DCSP  DCSP return tmp_image_meta DCNL DCSP return image_meta
 DCSP deserializer = ImageDeserializer() DCNL DCSP serializer = ImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
 DCSP deserializer = CachedImageDeserializer() DCNL DCSP serializer = CachedImageSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
 DCSP CONF.unregister_opt(sql_connection_opt) DCNL DCSP CONF.register_cli_opt(sql_connection_opt)
 DCSP module_path = ('glance.db.sqlalchemy.migrate_repo.versions.%s' % module_name) DCNL DCSP module = __import__(module_path, globals(), locals(), fromlist, (-1)) DCNL DCSP return [getattr(module, item) for item in fromlist]
 DCSP meta.bind = migrate_engine DCNL DCSP t_images = _get_table('images', meta) DCNL DCSP t_image_members = _get_table('image_members', meta) DCNL DCSP t_image_properties = _get_table('image_properties', meta) DCNL DCSP dialect = migrate_engine.url.get_dialect().name DCNL DCSP if (dialect == 'sqlite'): DCNL DCSP  DCSP _upgrade_sqlite(t_images, t_image_members, t_image_properties) DCNL DCSP  DCSP _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties) DCNL DCSP else: DCNL DCSP  DCSP _upgrade_other(t_images, t_image_members, t_image_properties, dialect)
 DCSP meta.bind = migrate_engine DCNL DCSP t_images = _get_table('images', meta) DCNL DCSP t_image_members = _get_table('image_members', meta) DCNL DCSP t_image_properties = _get_table('image_properties', meta) DCNL DCSP dialect = migrate_engine.url.get_dialect().name DCNL DCSP if (dialect == 'sqlite'): DCNL DCSP  DCSP _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties) DCNL DCSP  DCSP _downgrade_sqlite(t_images, t_image_members, t_image_properties) DCNL DCSP else: DCNL DCSP  DCSP _downgrade_other(t_images, t_image_members, t_image_properties, dialect)
 DCSP sql_commands = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP disk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_disk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP VARCHAR(36) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for command in sql_commands: DCNL DCSP  DCSP meta.bind.execute(command) DCNL DCSP _sqlite_table_swap(t_image_members, t_image_properties, t_images)
 DCSP sql_commands = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP disk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_disk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_id DCSP INTEGER DCSP  DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP updated_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP deleted DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (id),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (deleted DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_id, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_id) DCSP REFERENCES DCSP images DCSP (id)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for command in sql_commands: DCNL DCSP  DCSP meta.bind.execute(command) DCNL DCSP _sqlite_table_swap(t_image_members, t_image_properties, t_images)
 DCSP foreign_keys = _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.drop() DCNL DCSP t_images.c.id.alter(sqlalchemy.String(36), primary_key=True) DCNL DCSP t_image_members.c.image_id.alter(sqlalchemy.String(36)) DCNL DCSP t_image_properties.c.image_id.alter(sqlalchemy.String(36)) DCNL DCSP _update_all_ids_to_uuids(t_images, t_image_members, t_image_properties) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.create()
 DCSP foreign_keys = _get_foreign_keys(t_images, t_image_members, t_image_properties, dialect) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.drop() DCNL DCSP t_images.c.id.alter(sqlalchemy.Integer(), primary_key=True) DCNL DCSP t_image_members.c.image_id.alter(sqlalchemy.Integer()) DCNL DCSP t_image_properties.c.image_id.alter(sqlalchemy.Integer()) DCNL DCSP _update_all_uuids_to_ids(t_images, t_image_members, t_image_properties) DCNL DCSP for fk in foreign_keys: DCNL DCSP  DCSP fk.create()
 DCSP return sqlalchemy.Table(table_name, metadata, autoload=True)
 DCSP foreign_keys = [] DCNL DCSP if t_image_members.foreign_keys: DCNL DCSP  DCSP img_members_fk_name = list(t_image_members.foreign_keys)[0].name DCNL DCSP  DCSP if (dialect == 'mysql'): DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_id], [t_images.c.id], name=img_members_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk1 = migrate.ForeignKeyConstraint([t_image_members.c.image_id], [t_images.c.id]) DCNL DCSP  DCSP foreign_keys.append(fk1) DCNL DCSP if t_image_properties.foreign_keys: DCNL DCSP  DCSP img_properties_fk_name = list(t_image_properties.foreign_keys)[0].name DCNL DCSP  DCSP if (dialect == 'mysql'): DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_id], [t_images.c.id], name=img_properties_fk_name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fk2 = migrate.ForeignKeyConstraint([t_image_properties.c.image_id], [t_images.c.id]) DCNL DCSP  DCSP foreign_keys.append(fk2) DCNL DCSP return foreign_keys
 DCSP images = list(t_images.select().execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP old_id = image['id'] DCNL DCSP  DCSP new_id = uuidutils.generate_uuid() DCNL DCSP  DCSP t_images.update().where((t_images.c.id == old_id)).values(id=new_id).execute() DCNL DCSP  DCSP t_image_members.update().where((t_image_members.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where((t_image_properties.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where(and_(or_((t_image_properties.c.name == 'kernel_id'), (t_image_properties.c.name == 'ramdisk_id')), (t_image_properties.c.value == old_id))).values(value=new_id).execute()
 DCSP images = list(t_images.select().execute()) DCNL DCSP new_id = 1 DCNL DCSP for image in images: DCNL DCSP  DCSP old_id = image['id'] DCNL DCSP  DCSP t_images.update().where((t_images.c.id == old_id)).values(id=new_id).execute() DCNL DCSP  DCSP t_image_members.update().where((t_image_members.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where((t_image_properties.c.image_id == old_id)).values(image_id=new_id).execute() DCNL DCSP  DCSP t_image_properties.update().where(and_(or_((t_image_properties.c.name == 'kernel_id'), (t_image_properties.c.name == 'ramdisk_id')), (t_image_properties.c.value == old_id))).values(value=new_id).execute() DCNL DCSP  DCSP new_id += 1
 DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), Column('checksum', String(32)), Column('min_disk', Integer(), default=0), Column('min_ram', Integer(), default=0), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
 DCSP (define_image_properties_table,) = from_migration_import('008_add_image_members_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', BigInteger()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), Column('checksum', String(32)), Column('owner', String(255)), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
 DCSP (get_image_properties_table,) = from_migration_import('006_key_to_name', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', BigInteger()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
 DCSP (define_image_properties_table,) = from_migration_import('002_add_image_properties_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
 DCSP (define_image_properties_table,) = from_migration_import('002_add_image_properties_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP if (not CONF.metadata_encryption_key): DCNL DCSP  DCSP msg = _("'metadata_encryption_key' DCSP was DCSP not DCSP specified DCSP in DCSP the DCSP config DCSP file DCSP or DCSP a DCSP config DCSP file DCSP was DCSP not DCSP specified. DCSP This DCSP means DCSP that DCSP this DCSP migration DCSP is DCSP a DCSP NOOP.") DCNL DCSP  DCSP LOG.info(msg) DCNL DCSP  DCSP return DCNL DCSP meta = sqlalchemy.schema.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP images_table = sqlalchemy.Table('images', meta, autoload=True) DCNL DCSP images = list(images_table.select().execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fixed_uri = fix_uri_credentials(image['location'], to_quoted) DCNL DCSP  DCSP  DCSP images_table.update().where((images_table.c.id == image['id'])).values(location=fixed_uri).execute() DCNL DCSP  DCSP except exception.Invalid: DCNL DCSP  DCSP  DCSP msg = _('Failed DCSP to DCSP decrypt DCSP location DCSP value DCSP for DCSP image DCSP %s') DCNL DCSP  DCSP  DCSP LOG.warn((msg % image['id']))
 DCSP if (not uri): DCNL DCSP  DCSP return DCNL DCSP location = glance.store.swift.StoreLocation({}) DCNL DCSP if to_quoted: DCNL DCSP  DCSP location.parse_uri = types.MethodType(legacy_parse_uri, location) DCNL DCSP else: DCNL DCSP  DCSP location._get_credstring = types.MethodType(legacy__get_credstring, location) DCNL DCSP decrypted_uri = None DCNL DCSP try: DCNL DCSP  DCSP decrypted_uri = decrypt_location(uri) DCNL DCSP except (TypeError, ValueError) as e: DCNL DCSP  DCSP raise exception.Invalid(str(e)) DCNL DCSP location.parse_uri(decrypted_uri) DCNL DCSP return encrypt_location(location.get_uri())
 DCSP if (uri.count('://') != 1): DCNL DCSP  DCSP reason = _('URI DCSP cannot DCSP contain DCSP more DCSP than DCSP one DCSP occurrence DCSP of DCSP a DCSP scheme.If DCSP you DCSP have DCSP specified DCSP a DCSP URI DCSP like DCSP swift://user:pass@http://authurl.com/v1/container/obj, DCSP you DCSP need DCSP to DCSP change DCSP it DCSP to DCSP use DCSP the DCSP swift+http:// DCSP scheme, DCSP like DCSP so: DCSP swift+http://user:pass@authurl.com/v1/container/obj') DCNL DCSP  DCSP LOG.error((_('Invalid DCSP store DCSP uri DCSP %(uri)s: DCSP %(reason)s') % locals())) DCNL DCSP  DCSP raise exception.BadStoreUri(message=reason) DCNL DCSP pieces = urlparse.urlparse(uri) DCNL DCSP assert (pieces.scheme in ('swift', 'swift+http', 'swift+https')) DCNL DCSP self.scheme = pieces.scheme DCNL DCSP netloc = pieces.netloc DCNL DCSP path = pieces.path.lstrip('/') DCNL DCSP if (netloc != ''): DCNL DCSP  DCSP if ('@' in netloc): DCNL DCSP  DCSP  DCSP (creds, netloc) = netloc.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP else: DCNL DCSP  DCSP if ('@' in path): DCNL DCSP  DCSP  DCSP (creds, path) = path.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP  DCSP netloc = path[0:path.find('/')].strip('/') DCNL DCSP  DCSP path = path[path.find('/'):].strip('/') DCNL DCSP if creds: DCNL DCSP  DCSP cred_parts = creds.split(':') DCNL DCSP  DCSP if (len(cred_parts) == 1): DCNL DCSP  DCSP  DCSP reason = (_("Badly DCSP formed DCSP credentials DCSP '%(creds)s' DCSP in DCSP Swift DCSP URI") % locals()) DCNL DCSP  DCSP  DCSP LOG.error(reason) DCNL DCSP  DCSP  DCSP raise exception.BadStoreUri() DCNL DCSP  DCSP elif (len(cred_parts) == 3): DCNL DCSP  DCSP  DCSP user = ':'.join(cred_parts[0:2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = cred_parts[0] DCNL DCSP  DCSP key = cred_parts[(-1)] DCNL DCSP  DCSP self.user = user DCNL DCSP  DCSP self.key = key DCNL DCSP else: DCNL DCSP  DCSP self.user = None DCNL DCSP path_parts = path.split('/') DCNL DCSP try: DCNL DCSP  DCSP self.obj = path_parts.pop() DCNL DCSP  DCSP self.container = path_parts.pop() DCNL DCSP  DCSP if (not netloc.startswith('http')): DCNL DCSP  DCSP  DCSP path_parts.insert(0, netloc) DCNL DCSP  DCSP  DCSP self.auth_or_store_url = '/'.join(path_parts) DCNL DCSP except IndexError: DCNL DCSP  DCSP reason = (_('Badly DCSP formed DCSP S3 DCSP URI: DCSP %s') % uri) DCNL DCSP  DCSP LOG.error(message=reason) DCNL DCSP  DCSP raise exception.BadStoreUri()
 DCSP (get_images_table,) = from_migration_import('008_add_image_members_table', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
 DCSP (get_image_properties_table,) = from_migration_import('008_add_image_members_table', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP (get_image_members_table,) = from_migration_import('008_add_image_members_table', ['get_image_members_table']) DCNL DCSP images = get_image_members_table(meta) DCNL DCSP return images
 DCSP images = Table('images', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('name', String(255)), Column('disk_format', String(20)), Column('container_format', String(20)), Column('size', Integer()), Column('status', String(30), nullable=False), Column('is_public', Boolean(), nullable=False, default=False, index=True), Column('location', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), Column('checksum', String(32)), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return images
 DCSP (define_image_properties_table,) = from_migration_import('002_add_image_properties_table', ['define_image_properties_table']) DCNL DCSP image_properties = define_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP qry = session.query(table.c.image_id, table.c.member).group_by(table.c.image_id, table.c.member).having((func.count() > 1)) DCNL DCSP for (image_id, member) in qry: DCNL DCSP  DCSP d = table.delete().where(and_((table.c.deleted == True), (table.c.image_id == image_id), (table.c.member == member))) DCNL DCSP  DCSP d.execute() DCNL DCSP session.close()
 DCSP (get_images_table,) = from_migration_import('004_add_checksum', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
 DCSP (get_images_table,) = from_migration_import('004_add_checksum', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP image_properties = Table('image_properties', meta, Column('id', Integer(), primary_key=True, nullable=False), Column('image_id', Integer(), ForeignKey('images.id'), nullable=False, index=True), Column('name', String(255), nullable=False), Column('value', Text()), Column('created_at', DateTime(), nullable=False), Column('updated_at', DateTime()), Column('deleted_at', DateTime()), Column('deleted', Boolean(), nullable=False, default=False, index=True), UniqueConstraint('image_id', 'name'), mysql_engine='InnoDB', extend_existing=True) DCNL DCSP return image_properties
 DCSP (get_images_table,) = from_migration_import('007_add_owner', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
 DCSP (get_image_properties_table,) = from_migration_import('007_add_owner', ['get_image_properties_table']) DCNL DCSP image_properties = get_image_properties_table(meta) DCNL DCSP return image_properties
 DCSP meta = sqlalchemy.schema.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP images_table = sqlalchemy.Table('images', meta, autoload=True) DCNL DCSP images = list(images_table.select(images_table.c.location.startswith('swift')).execute()) DCNL DCSP for image in images: DCNL DCSP  DCSP fixed_uri = fix_uri_credentials(image['location'], to_quoted) DCNL DCSP  DCSP images_table.update().where((images_table.c.id == image['id'])).values(location=fixed_uri).execute()
 DCSP location = glance.store.swift.StoreLocation({}) DCNL DCSP if to_quoted: DCNL DCSP  DCSP location.parse_uri = types.MethodType(legacy_parse_uri, location) DCNL DCSP else: DCNL DCSP  DCSP location._get_credstring = types.MethodType(legacy__get_credstring, location) DCNL DCSP location.parse_uri(uri) DCNL DCSP return location.get_uri()
 DCSP if (uri.count('://') != 1): DCNL DCSP  DCSP reason = _('URI DCSP cannot DCSP contain DCSP more DCSP than DCSP one DCSP occurrence DCSP of DCSP a DCSP scheme.If DCSP you DCSP have DCSP specified DCSP a DCSP URI DCSP like DCSP swift://user:pass@http://authurl.com/v1/container/obj, DCSP you DCSP need DCSP to DCSP change DCSP it DCSP to DCSP use DCSP the DCSP swift+http:// DCSP scheme, DCSP like DCSP so: DCSP swift+http://user:pass@authurl.com/v1/container/obj') DCNL DCSP  DCSP LOG.error((_('Invalid DCSP store DCSP uri DCSP %(uri)s: DCSP %(reason)s') % locals())) DCNL DCSP  DCSP raise exception.BadStoreUri(message=reason) DCNL DCSP pieces = urlparse.urlparse(uri) DCNL DCSP assert (pieces.scheme in ('swift', 'swift+http', 'swift+https')) DCNL DCSP self.scheme = pieces.scheme DCNL DCSP netloc = pieces.netloc DCNL DCSP path = pieces.path.lstrip('/') DCNL DCSP if (netloc != ''): DCNL DCSP  DCSP if ('@' in netloc): DCNL DCSP  DCSP  DCSP (creds, netloc) = netloc.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP else: DCNL DCSP  DCSP if ('@' in path): DCNL DCSP  DCSP  DCSP (creds, path) = path.split('@') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP creds = None DCNL DCSP  DCSP netloc = path[0:path.find('/')].strip('/') DCNL DCSP  DCSP path = path[path.find('/'):].strip('/') DCNL DCSP if creds: DCNL DCSP  DCSP cred_parts = creds.split(':') DCNL DCSP  DCSP if (len(cred_parts) == 1): DCNL DCSP  DCSP  DCSP reason = (_("Badly DCSP formed DCSP credentials DCSP '%(creds)s' DCSP in DCSP Swift DCSP URI") % locals()) DCNL DCSP  DCSP  DCSP LOG.error(reason) DCNL DCSP  DCSP  DCSP raise exception.BadStoreUri() DCNL DCSP  DCSP elif (len(cred_parts) == 3): DCNL DCSP  DCSP  DCSP user = ':'.join(cred_parts[0:2]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user = cred_parts[0] DCNL DCSP  DCSP key = cred_parts[(-1)] DCNL DCSP  DCSP self.user = user DCNL DCSP  DCSP self.key = key DCNL DCSP else: DCNL DCSP  DCSP self.user = None DCNL DCSP path_parts = path.split('/') DCNL DCSP try: DCNL DCSP  DCSP self.obj = path_parts.pop() DCNL DCSP  DCSP self.container = path_parts.pop() DCNL DCSP  DCSP if (not netloc.startswith('http')): DCNL DCSP  DCSP  DCSP path_parts.insert(0, netloc) DCNL DCSP  DCSP  DCSP self.auth_or_store_url = '/'.join(path_parts) DCNL DCSP except IndexError: DCNL DCSP  DCSP reason = (_('Badly DCSP formed DCSP S3 DCSP URI: DCSP %s') % uri) DCNL DCSP  DCSP LOG.error(message=reason) DCNL DCSP  DCSP raise exception.BadStoreUri()
 DCSP models = (Image, ImageProperty, ImageMember) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
 DCSP models = (Image, ImageProperty) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.drop_all(engine)
 DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP msg = ('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s' % ex) DCNL DCSP  DCSP  DCSP LOG.warn(msg) DCNL DCSP  DCSP  DCSP raise sqlalchemy.exc.DisconnectionError(msg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP global sa_logger, _IDLE_TIMEOUT, _MAX_RETRIES, _RETRY_INTERVAL, _CONNECTION DCNL DCSP _IDLE_TIMEOUT = CONF.sql_idle_timeout DCNL DCSP _MAX_RETRIES = CONF.sql_max_retries DCNL DCSP _RETRY_INTERVAL = CONF.sql_retry_interval DCNL DCSP _CONNECTION = CONF.sql_connection DCNL DCSP sa_logger = logging.getLogger('sqlalchemy.engine') DCNL DCSP if CONF.debug: DCNL DCSP  DCSP sa_logger.setLevel(logging.DEBUG)
 DCSP setup_db_env() DCNL DCSP get_engine()
 DCSP global _MAKER DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP get_engine() DCNL DCSP  DCSP get_maker(autocommit, expire_on_commit) DCNL DCSP  DCSP assert _MAKER DCNL DCSP session = _MAKER() DCNL DCSP return session
 DCSP 'May DCSP assign DCSP _ENGINE DCSP if DCSP not DCSP already DCSP assigned' DCNL DCSP global _ENGINE, sa_logger, _CONNECTION, _IDLE_TIMEOUT, _MAX_RETRIES, _RETRY_INTERVAL DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP tries = _MAX_RETRIES DCNL DCSP  DCSP retry_interval = _RETRY_INTERVAL DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(_CONNECTION) DCNL DCSP  DCSP engine_args = {'pool_recycle': _IDLE_TIMEOUT, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE = sqlalchemy.create_engine(_CONNECTION, **engine_args) DCNL DCSP  DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP  DCSP _ENGINE.connect = wrap_db_error(_ENGINE.connect) DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP msg = (_('Error DCSP configuring DCSP registry DCSP database DCSP with DCSP supplied DCSP sql_connection. DCSP Got DCSP error: DCSP %s') % err) DCNL DCSP  DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sa_logger = logging.getLogger('sqlalchemy.engine') DCNL DCSP  DCSP if CONF.debug: DCNL DCSP  DCSP  DCSP sa_logger.setLevel(logging.DEBUG) DCNL DCSP  DCSP if CONF.db_auto_create: DCNL DCSP  DCSP  DCSP LOG.info(_('auto-creating DCSP glance DCSP registry DCSP DB')) DCNL DCSP  DCSP  DCSP models.register_models(_ENGINE) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP migration.version_control() DCNL DCSP  DCSP  DCSP except exception.DatabaseMigrationError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.info(_('not DCSP auto-creating DCSP glance DCSP registry DCSP DB')) DCNL DCSP return _ENGINE
 DCSP 'May DCSP assign DCSP __MAKER DCSP if DCSP not DCSP already DCSP assigned' DCNL DCSP global _MAKER, _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP _MAKER = sa_orm.sessionmaker(bind=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER
 DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP def _wrap(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP except sqlalchemy.exc.OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining_attempts = _MAX_RETRIES DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_('SQL DCSP connection DCSP failed. DCSP %d DCSP attempts DCSP left.'), remaining_attempts) DCNL DCSP  DCSP  DCSP  DCSP remaining_attempts -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(_RETRY_INTERVAL) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP except sqlalchemy.exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((remaining_attempts == 0) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP except sqlalchemy.exc.DBAPIError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except sqlalchemy.exc.DBAPIError: DCNL DCSP  DCSP  DCSP raise DCNL DCSP _wrap.func_name = f.func_name DCNL DCSP return _wrap
 DCSP return _image_update(context, values, None, False)
 DCSP return _image_update(context, values, image_id, purge_props)
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP image_ref = _image_get(context, image_id, session=session) DCNL DCSP  DCSP check_mutate_authorization(context, image_ref) DCNL DCSP  DCSP _image_locations_set(image_ref.id, [], session) DCNL DCSP  DCSP image_ref.delete(session=session) DCNL DCSP  DCSP for prop_ref in image_ref.properties: DCNL DCSP  DCSP  DCSP image_property_delete(context, prop_ref, session=session) DCNL DCSP  DCSP members = _image_member_find(context, session, image_id=image_id) DCNL DCSP  DCSP for memb_ref in members: DCNL DCSP  DCSP  DCSP _image_member_delete(context, memb_ref, session) DCNL DCSP return _normalize_locations(image_ref)
 DCSP session = (session or get_session()) DCNL DCSP try: DCNL DCSP  DCSP query = session.query(models.Image).options(sa_orm.joinedload(models.Image.properties)).options(sa_orm.joinedload(models.Image.locations)).filter_by(id=image_id) DCNL DCSP  DCSP if ((not force_show_deleted) and (not _can_show_deleted(context))): DCNL DCSP  DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP  DCSP image = query.one() DCNL DCSP except sa_orm.exc.NoResultFound: DCNL DCSP  DCSP raise exception.NotFound(('No DCSP image DCSP found DCSP with DCSP ID DCSP %s' % image_id)) DCNL DCSP if (not is_image_visible(context, image)): DCNL DCSP  DCSP raise exception.Forbidden('Image DCSP not DCSP visible DCSP to DCSP you') DCNL DCSP return image
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if ((image['owner'] is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image['owner'] == context.owner)
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP return True DCNL DCSP if ('membership' in kwargs): DCNL DCSP  DCSP membership = kwargs['membership'] DCNL DCSP  DCSP if (membership is None): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP member = members[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return member['can_share']
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if image['is_public']: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner, status=status) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidSortKey() DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sa_sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sa_sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP filters = (filters or {}) DCNL DCSP session = get_session() DCNL DCSP query = session.query(models.Image).options(sa_orm.joinedload(models.Image.properties)).options(sa_orm.joinedload(models.Image.locations)) DCNL DCSP if (('is_public' in filters) and (filters['is_public'] is None)): DCNL DCSP  DCSP del filters['is_public'] DCNL DCSP if (not context.is_admin): DCNL DCSP  DCSP visibility_filters = [(models.Image.is_public == True)] DCNL DCSP  DCSP if (context.owner is not None): DCNL DCSP  DCSP  DCSP if (member_status == 'all'): DCNL DCSP  DCSP  DCSP  DCSP visibility_filters.extend([(models.Image.owner == context.owner), models.Image.members.any(member=context.owner, deleted=False)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP visibility_filters.extend([(models.Image.owner == context.owner), models.Image.members.any(member=context.owner, deleted=False, status=member_status)]) DCNL DCSP  DCSP query = query.filter(sa_sql.or_(*visibility_filters)) DCNL DCSP if ('visibility' in filters): DCNL DCSP  DCSP visibility = filters.pop('visibility') DCNL DCSP  DCSP if (visibility == 'public'): DCNL DCSP  DCSP  DCSP query = query.filter((models.Image.is_public == True)) DCNL DCSP  DCSP  DCSP filters['is_public'] = True DCNL DCSP  DCSP elif (visibility == 'private'): DCNL DCSP  DCSP  DCSP filters['is_public'] = False DCNL DCSP  DCSP  DCSP if ((not context.is_admin) and (context.owner is not None)): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((models.Image.owner == context.owner)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter(models.Image.members.any(member=context.owner, deleted=False)) DCNL DCSP showing_deleted = False DCNL DCSP if ('changes-since' in filters): DCNL DCSP  DCSP changes_since = timeutils.normalize_time(filters.pop('changes-since')) DCNL DCSP  DCSP query = query.filter((models.Image.updated_at > changes_since)) DCNL DCSP  DCSP showing_deleted = True DCNL DCSP if ('deleted' in filters): DCNL DCSP  DCSP deleted_filter = filters.pop('deleted') DCNL DCSP  DCSP query = query.filter_by(deleted=deleted_filter) DCNL DCSP  DCSP showing_deleted = deleted_filter DCNL DCSP  DCSP if (not deleted_filter): DCNL DCSP  DCSP  DCSP query = query.filter((models.Image.status != 'killed')) DCNL DCSP for (k, v) in filters.pop('properties', {}).items(): DCNL DCSP  DCSP query = query.filter(models.Image.properties.any(name=k, value=v, deleted=False)) DCNL DCSP for (k, v) in filters.items(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP key = k DCNL DCSP  DCSP  DCSP if (k.endswith('_min') or k.endswith('_max')): DCNL DCSP  DCSP  DCSP  DCSP key = key[0:(-4)] DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = int(v) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = _('Unable DCSP to DCSP filter DCSP on DCSP a DCSP range DCSP with DCSP a DCSP non-numeric DCSP value.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.InvalidFilterRangeValue(msg) DCNL DCSP  DCSP  DCSP if k.endswith('_min'): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((getattr(models.Image, key) >= v)) DCNL DCSP  DCSP  DCSP elif k.endswith('_max'): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((getattr(models.Image, key) <= v)) DCNL DCSP  DCSP  DCSP elif hasattr(models.Image, key): DCNL DCSP  DCSP  DCSP  DCSP query = query.filter((getattr(models.Image, key) == v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP query = query.filter(models.Image.properties.any(name=key, value=v)) DCNL DCSP marker_image = None DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_image = _image_get(context, marker, force_show_deleted=showing_deleted) DCNL DCSP query = paginate_query(query, models.Image, limit, [sort_key, 'created_at', 'id'], marker=marker_image, sort_dir=sort_dir) DCNL DCSP return [_normalize_locations(image.to_dict()) for image in query.all()]
 DCSP for attr in model_class.__protected_attributes__: DCNL DCSP  DCSP if (attr in values): DCNL DCSP  DCSP  DCSP del values[attr]
 DCSP status = values.get('status') DCNL DCSP status = values.get('status', None) DCNL DCSP if (not status): DCNL DCSP  DCSP msg = 'Image DCSP status DCSP is DCSP required.' DCNL DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP if (status not in STATUSES): DCNL DCSP  DCSP msg = ("Invalid DCSP image DCSP status DCSP '%s' DCSP for DCSP image." % status) DCNL DCSP  DCSP raise exception.Invalid(msg) DCNL DCSP return values
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP properties = values.pop('properties', {}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP locations = values.pop('locations') DCNL DCSP  DCSP  DCSP locations_provided = True DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP locations_provided = False DCNL DCSP  DCSP if image_id: DCNL DCSP  DCSP  DCSP image_ref = _image_get(context, image_id, session=session) DCNL DCSP  DCSP  DCSP check_mutate_authorization(context, image_ref) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (values.get('size') is not None): DCNL DCSP  DCSP  DCSP  DCSP values['size'] = int(values['size']) DCNL DCSP  DCSP  DCSP if ('min_ram' in values): DCNL DCSP  DCSP  DCSP  DCSP values['min_ram'] = int((values['min_ram'] or 0)) DCNL DCSP  DCSP  DCSP if ('min_disk' in values): DCNL DCSP  DCSP  DCSP  DCSP values['min_disk'] = int((values['min_disk'] or 0)) DCNL DCSP  DCSP  DCSP values['is_public'] = bool(values.get('is_public', False)) DCNL DCSP  DCSP  DCSP values['protected'] = bool(values.get('protected', False)) DCNL DCSP  DCSP  DCSP image_ref = models.Image() DCNL DCSP  DCSP if (('owner' in values) and (not values['owner'])): DCNL DCSP  DCSP  DCSP values['owner'] = None DCNL DCSP  DCSP if image_id: DCNL DCSP  DCSP  DCSP _drop_protected_attrs(models.Image, values) DCNL DCSP  DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP image_ref.update(values) DCNL DCSP  DCSP values = validate_image(image_ref.to_dict()) DCNL DCSP  DCSP _update_values(image_ref, values) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image_ref.save(session=session) DCNL DCSP  DCSP except sqlalchemy.exc.IntegrityError: DCNL DCSP  DCSP  DCSP raise exception.Duplicate(('Image DCSP ID DCSP %s DCSP already DCSP exists!' % values['id'])) DCNL DCSP  DCSP _set_properties_for_image(context, image_ref, properties, purge_props, session) DCNL DCSP if locations_provided: DCNL DCSP  DCSP _image_locations_set(image_ref.id, locations, session) DCNL DCSP return image_get(context, image_ref.id)
 DCSP orig_properties = {} DCNL DCSP for prop_ref in image_ref.properties: DCNL DCSP  DCSP orig_properties[prop_ref.name] = prop_ref DCNL DCSP for (name, value) in properties.iteritems(): DCNL DCSP  DCSP prop_values = {'image_id': image_ref.id, 'name': name, 'value': value} DCNL DCSP  DCSP if (name in orig_properties): DCNL DCSP  DCSP  DCSP prop_ref = orig_properties[name] DCNL DCSP  DCSP  DCSP _image_property_update(context, prop_ref, prop_values, session=session) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_property_create(context, prop_values, session=session) DCNL DCSP if purge_props: DCNL DCSP  DCSP for key in orig_properties.keys(): DCNL DCSP  DCSP  DCSP if (key not in properties): DCNL DCSP  DCSP  DCSP  DCSP prop_ref = orig_properties[key] DCNL DCSP  DCSP  DCSP  DCSP image_property_delete(context, prop_ref, session=session)
 DCSP prop_ref = models.ImageProperty() DCNL DCSP return _image_property_update(context, prop_ref, values, session=session)
 DCSP _drop_protected_attrs(models.ImageProperty, values) DCNL DCSP values['deleted'] = False DCNL DCSP prop_ref.update(values) DCNL DCSP prop_ref.save(session=session) DCNL DCSP return prop_ref
 DCSP prop_ref.delete(session=session) DCNL DCSP return prop_ref
 DCSP memb_ref = models.ImageMember() DCNL DCSP _image_member_update(context, memb_ref, values, session=session) DCNL DCSP return _image_member_format(memb_ref)
 DCSP return {'id': member_ref['id'], 'image_id': member_ref['image_id'], 'member': member_ref['member'], 'can_share': member_ref['can_share'], 'status': member_ref['status'], 'created_at': member_ref['created_at'], 'updated_at': member_ref['updated_at']}
 DCSP session = get_session() DCNL DCSP memb_ref = _image_member_get(context, memb_id, session) DCNL DCSP _image_member_update(context, memb_ref, values, session) DCNL DCSP return _image_member_format(memb_ref)
 DCSP _drop_protected_attrs(models.ImageMember, values) DCNL DCSP values['deleted'] = False DCNL DCSP values.setdefault('can_share', False) DCNL DCSP memb_ref.update(values) DCNL DCSP memb_ref.save(session=session) DCNL DCSP return memb_ref
 DCSP session = (session or get_session()) DCNL DCSP member_ref = _image_member_get(context, memb_id, session) DCNL DCSP _image_member_delete(context, member_ref, session)
 DCSP query = session.query(models.ImageMember) DCNL DCSP query = query.filter_by(id=memb_id) DCNL DCSP return query.one()
 DCSP session = get_session() DCNL DCSP members = _image_member_find(context, session, image_id, member, status) DCNL DCSP return [_image_member_format(m) for m in members]
 DCSP if hasattr(context, 'show_deleted'): DCNL DCSP  DCSP return context.show_deleted DCNL DCSP if (not hasattr(context, 'get')): DCNL DCSP  DCSP return False DCNL DCSP return context.get('deleted', False)
 DCSP session = (session or get_session()) DCNL DCSP tag_ref = models.ImageTag(image_id=image_id, value=value) DCNL DCSP tag_ref.save(session=session) DCNL DCSP return tag_ref['value']
 DCSP session = (session or get_session()) DCNL DCSP query = session.query(models.ImageTag).filter_by(image_id=image_id).filter_by(value=value).filter_by(deleted=False) DCNL DCSP try: DCNL DCSP  DCSP tag_ref = query.one() DCNL DCSP except sa_orm.exc.NoResultFound: DCNL DCSP  DCSP raise exception.NotFound() DCNL DCSP tag_ref.delete(session=session)
 DCSP session = (session or get_session()) DCNL DCSP tags = session.query(models.ImageTag).filter_by(image_id=image_id).filter_by(deleted=False).order_by(sqlalchemy.asc(models.ImageTag.created_at)).all() DCNL DCSP return [tag['value'] for tag in tags]
 DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP try: DCNL DCSP  DCSP return versioning_api.db_version(sql_connection, repo_path) DCNL DCSP except versioning_exceptions.DatabaseNotControlledError as e: DCNL DCSP  DCSP msg = _('database DCSP is DCSP not DCSP under DCSP migration DCSP control') DCNL DCSP  DCSP raise exception.DatabaseMigrationError(msg)
 DCSP db_version() DCNL DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP version_str = (version or 'latest') DCNL DCSP LOG.info((_('Upgrading DCSP database DCSP to DCSP version DCSP %s') % version_str)) DCNL DCSP return versioning_api.upgrade(sql_connection, repo_path, version)
 DCSP db_version() DCNL DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP LOG.info((_('Downgrading DCSP database DCSP to DCSP version DCSP %s') % version)) DCNL DCSP return versioning_api.downgrade(sql_connection, repo_path, version)
 DCSP sql_connection = CONF.sql_connection DCNL DCSP try: DCNL DCSP  DCSP _version_control(version) DCNL DCSP except versioning_exceptions.DatabaseAlreadyControlledError as e: DCNL DCSP  DCSP msg = _('database DCSP is DCSP already DCSP under DCSP migration DCSP control') DCNL DCSP  DCSP raise exception.DatabaseMigrationError(msg)
 DCSP repo_path = get_migrate_repo_path() DCNL DCSP sql_connection = CONF.sql_connection DCNL DCSP if (version is None): DCNL DCSP  DCSP version = versioning_repository.Repository(repo_path).latest DCNL DCSP return versioning_api.version_control(sql_connection, repo_path, version)
 DCSP sql_connection = CONF.sql_connection DCNL DCSP try: DCNL DCSP  DCSP _version_control((current_version or 0)) DCNL DCSP except versioning_exceptions.DatabaseAlreadyControlledError as e: DCNL DCSP  DCSP pass DCNL DCSP if (current_version is None): DCNL DCSP  DCSP current_version = int(db_version()) DCNL DCSP if ((version is not None) and (int(version) < current_version)): DCNL DCSP  DCSP downgrade(version=version) DCNL DCSP elif ((version is None) or (int(version) > current_version)): DCNL DCSP  DCSP upgrade(version=version)
 DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP return path
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if ((image['owner'] is None) or (context.owner is None)): DCNL DCSP  DCSP return False DCNL DCSP return (image['owner'] == context.owner)
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP return True DCNL DCSP if ('membership' in kwargs): DCNL DCSP  DCSP member = kwargs['membership'] DCNL DCSP  DCSP if (member is None): DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner) DCNL DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP member = members[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return member['can_share']
 DCSP if context.is_admin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if image['is_public']: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (status == 'all'): DCNL DCSP  DCSP  DCSP status = None DCNL DCSP  DCSP members = image_member_find(context, image_id=image['id'], member=context.owner, status=status) DCNL DCSP  DCSP if (len(members) > 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP return IMPL.db_sync(version=version)
 DCSP return IMPL.db_version()
 DCSP bucket = conn.get_bucket(bucket_id) DCNL DCSP if (not bucket): DCNL DCSP  DCSP msg = (_('Could DCSP not DCSP find DCSP bucket DCSP with DCSP ID DCSP %(bucket_id)s') % locals()) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise exception.NotFound(msg) DCNL DCSP return bucket
 DCSP from boto.exception import S3ResponseError DCNL DCSP try: DCNL DCSP  DCSP s3_conn.get_bucket(bucket) DCNL DCSP except S3ResponseError as e: DCNL DCSP  DCSP if (e.status == httplib.NOT_FOUND): DCNL DCSP  DCSP  DCSP if CONF.s3_store_create_bucket_on_put: DCNL DCSP  DCSP  DCSP  DCSP location = get_s3_location(CONF.s3_store_host) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3_conn.create_bucket(bucket, location=location) DCNL DCSP  DCSP  DCSP  DCSP except S3ResponseError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Failed DCSP to DCSP add DCSP bucket DCSP to DCSP S3.\nGot DCSP error DCSP from DCSP S3: DCSP %(e)s') % locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise glance.store.BackendException(msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = (_('The DCSP bucket DCSP %(bucket)s DCSP does DCSP not DCSP exist DCSP in DCSP S3. DCSP Please DCSP set DCSP the DCSP s3_store_create_bucket_on_put DCSP option DCSP to DCSP add DCSP bucket DCSP to DCSP S3 DCSP automatically.') % locals()) DCNL DCSP  DCSP  DCSP  DCSP raise glance.store.BackendException(msg)
 DCSP key = bucket.get_key(obj) DCNL DCSP if ((not key) or (not key.exists())): DCNL DCSP  DCSP msg = (_('Could DCSP not DCSP find DCSP key DCSP %(obj)s DCSP in DCSP bucket DCSP %(bucket)s') % locals()) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise exception.NotFound(msg) DCNL DCSP return key
 DCSP store_count = 0 DCNL DCSP store_classes = set() DCNL DCSP for store_entry in CONF.known_stores: DCNL DCSP  DCSP store_entry = store_entry.strip() DCNL DCSP  DCSP if (not store_entry): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP store_cls = _get_store_class(store_entry) DCNL DCSP  DCSP store_instance = store_cls() DCNL DCSP  DCSP schemes = store_instance.get_schemes() DCNL DCSP  DCSP if (not schemes): DCNL DCSP  DCSP  DCSP raise BackendException(('Unable DCSP to DCSP register DCSP store DCSP %s. DCSP No DCSP schemes DCSP associated DCSP with DCSP it.' % store_cls)) DCNL DCSP  DCSP elif (store_cls not in store_classes): DCNL DCSP  DCSP  DCSP LOG.debug('Registering DCSP store DCSP %s DCSP with DCSP schemes DCSP %s', store_cls, schemes) DCNL DCSP  DCSP  DCSP store_classes.add(store_cls) DCNL DCSP  DCSP  DCSP scheme_map = {} DCNL DCSP  DCSP  DCSP for scheme in schemes: DCNL DCSP  DCSP  DCSP  DCSP loc_cls = store_instance.get_store_location_class() DCNL DCSP  DCSP  DCSP  DCSP scheme_map[scheme] = {'store_class': store_cls, 'location_class': loc_cls} DCNL DCSP  DCSP  DCSP location.register_scheme_map(scheme_map) DCNL DCSP  DCSP  DCSP store_count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.debug('Store DCSP %s DCSP already DCSP registered', store_cls) DCNL DCSP return store_count
 DCSP if (scheme not in location.SCHEME_TO_CLS_MAP): DCNL DCSP  DCSP raise exception.UnknownScheme(scheme=scheme) DCNL DCSP scheme_info = location.SCHEME_TO_CLS_MAP[scheme] DCNL DCSP store = scheme_info['store_class'](context, loc) DCNL DCSP return store
 DCSP scheme = uri[0:(uri.find('/') - 1)] DCNL DCSP store = get_store_from_scheme(context, scheme, loc) DCNL DCSP return store
 DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP return store.get(loc)
 DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP return store.get_size(loc)
 DCSP loc = location.get_location_from_uri(uri) DCNL DCSP store = get_store_from_uri(context, uri, loc) DCNL DCSP try: DCNL DCSP  DCSP return store.delete(loc) DCNL DCSP except NotImplementedError: DCNL DCSP  DCSP raise exception.StoreDeleteNotSupported
 DCSP loc = location.get_location_from_uri(uri) DCNL DCSP return loc.store_name
 DCSP try: DCNL DCSP  DCSP return delete_from_backend(context, uri, **kwargs) DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP msg = _('Failed DCSP to DCSP delete DCSP image DCSP in DCSP store DCSP at DCSP URI: DCSP %s') DCNL DCSP  DCSP LOG.warn((msg % uri)) DCNL DCSP except exception.StoreDeleteNotSupported as e: DCNL DCSP  DCSP LOG.warn(str(e)) DCNL DCSP except UnsupportedBackend: DCNL DCSP  DCSP exc_type = sys.exc_info()[0].__name__ DCNL DCSP  DCSP msg = (_('Failed DCSP to DCSP delete DCSP image DCSP at DCSP %s DCSP from DCSP store DCSP (%s)') % (uri, exc_type)) DCNL DCSP  DCSP LOG.error(msg)
 DCSP datadir = CONF.scrubber_datadir DCNL DCSP delete_time = (time.time() + CONF.scrub_time) DCNL DCSP file_path = os.path.join(datadir, str(image_id)) DCNL DCSP utils.safe_mkdirs(datadir) DCNL DCSP if os.path.exists(file_path): DCNL DCSP  DCSP msg = (_('Image DCSP id DCSP %(image_id)s DCSP already DCSP queued DCSP for DCSP delete') % {'image_id': image_id}) DCNL DCSP  DCSP raise exception.Duplicate(msg) DCNL DCSP if (CONF.metadata_encryption_key is not None): DCNL DCSP  DCSP uri = crypt.urlsafe_encrypt(CONF.metadata_encryption_key, uri, 64) DCNL DCSP with open(file_path, 'w') as f: DCNL DCSP  DCSP f.write('\n'.join([uri, str(int(delete_time))])) DCNL DCSP os.chmod(file_path, 384) DCNL DCSP os.utime(file_path, (delete_time, delete_time))
 DCSP pieces = urlparse.urlparse(uri) DCNL DCSP if (pieces.scheme not in SCHEME_TO_CLS_MAP.keys()): DCNL DCSP  DCSP raise exception.UnknownScheme(pieces.scheme) DCNL DCSP scheme_info = SCHEME_TO_CLS_MAP[pieces.scheme] DCNL DCSP return Location(pieces.scheme, uri=uri, store_location_class=scheme_info['location_class'])
 DCSP for (k, v) in scheme_map.items(): DCNL DCSP  DCSP if (k not in SCHEME_TO_CLS_MAP): DCNL DCSP  DCSP  DCSP LOG.debug('Registering DCSP scheme DCSP %s DCSP with DCSP %s', k, v) DCNL DCSP  DCSP  DCSP SCHEME_TO_CLS_MAP[k] = v
 DCSP chunk = response.read(size) DCNL DCSP while chunk: DCNL DCSP  DCSP (yield chunk) DCNL DCSP  DCSP chunk = response.read(size) DCNL DCSP conn.close()
 DCSP http = httplib2.Http() DCNL DCSP wait_for = 300 DCNL DCSP check_every = 15 DCNL DCSP for _ in xrange((wait_for / check_every)): DCNL DCSP  DCSP time.sleep(check_every) DCNL DCSP  DCSP (response, content) = http.request(path, 'HEAD') DCNL DCSP  DCSP if ((response['x-image-meta-status'] == 'deleted') and (response['x-image-meta-deleted'] == 'True')): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP continue DCNL DCSP else: DCNL DCSP  DCSP self.fail('image DCSP was DCSP never DCSP scrubbed')
 DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kwargs): DCNL DCSP  DCSP func.__test__ = False DCNL DCSP  DCSP test_obj = a[0] DCNL DCSP  DCSP message = getattr(test_obj, 'disabled_message', 'Test DCSP disabled') DCNL DCSP  DCSP if getattr(test_obj, 'disabled', False): DCNL DCSP  DCSP  DCSP test_obj.skipTest(message) DCNL DCSP  DCSP func(*a, **kwargs) DCNL DCSP return wrapped
 DCSP env = os.environ.copy() DCNL DCSP if (exec_env is not None): DCNL DCSP  DCSP for (env_name, env_val) in exec_env.items(): DCNL DCSP  DCSP  DCSP if callable(env_val): DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val(env.get(env_name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val DCNL DCSP if (no_venv and ('VIRTUAL_ENV' in env)): DCNL DCSP  DCSP env['PATH'] = env['PATH'].split(os.pathsep, 1)[(-1)] DCNL DCSP  DCSP del env['VIRTUAL_ENV'] DCNL DCSP path_ext = [os.path.join(os.getcwd(), 'bin')] DCNL DCSP executable = cmd.split()[0] DCNL DCSP if os.path.isabs(executable): DCNL DCSP  DCSP path_ext.append(os.path.dirname(executable)) DCNL DCSP env['PATH'] = ((':'.join(path_ext) + ':') + env['PATH']) DCNL DCSP process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) DCNL DCSP if expect_exit: DCNL DCSP  DCSP result = process.communicate() DCNL DCSP  DCSP (out, err) = result DCNL DCSP  DCSP exitcode = process.returncode DCNL DCSP else: DCNL DCSP  DCSP out = '' DCNL DCSP  DCSP err = '' DCNL DCSP  DCSP exitcode = 0 DCNL DCSP if ((exitcode != expected_exitcode) and raise_error): DCNL DCSP  DCSP msg = ('Command DCSP %(cmd)s DCSP did DCSP not DCSP succeed. DCSP Returned DCSP an DCSP exit DCSP code DCSP of DCSP %(exitcode)d.\n\nSTDOUT: DCSP %(out)s\n\nSTDERR: DCSP %(err)s' % locals()) DCNL DCSP  DCSP if context: DCNL DCSP  DCSP  DCSP msg += ('\n\nCONTEXT: DCSP %s' % context) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return (exitcode, out, err)
 DCSP if os.path.isabs(cmdname): DCNL DCSP  DCSP return cmdname DCNL DCSP path = ([os.path.join(os.getcwd(), 'bin')] + os.environ['PATH'].split(os.pathsep)) DCNL DCSP for elem in path: DCNL DCSP  DCSP full_path = os.path.join(elem, cmdname) DCNL DCSP  DCSP if os.access(full_path, os.X_OK): DCNL DCSP  DCSP  DCSP return full_path DCNL DCSP return None
 DCSP s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) DCNL DCSP s.bind(('localhost', 0)) DCNL DCSP (addr, port) = s.getsockname() DCNL DCSP s.close() DCNL DCSP return port
 DCSP try: DCNL DCSP  DCSP import xattr DCNL DCSP except ImportError: DCNL DCSP  DCSP return False DCNL DCSP def set_xattr(path, key, value): DCNL DCSP  DCSP xattr.setxattr(path, ('user.%s' % key), str(value)) DCNL DCSP fake_filepath = os.path.join(path, 'testing-checkme') DCNL DCSP result = True DCNL DCSP with open(fake_filepath, 'wb') as fake_file: DCNL DCSP  DCSP fake_file.write('XXX') DCNL DCSP  DCSP fake_file.flush() DCNL DCSP try: DCNL DCSP  DCSP set_xattr(fake_filepath, 'hits', '1') DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno == errno.EOPNOTSUPP): DCNL DCSP  DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP if os.path.exists(fake_filepath): DCNL DCSP  DCSP  DCSP os.unlink(fake_filepath) DCNL DCSP return result
 DCSP class FakeHTTPConnection(object, ): DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def getresponse(self): DCNL DCSP  DCSP  DCSP if len(FAKE_RESPONSE_STACK): DCNL DCSP  DCSP  DCSP  DCSP return FAKE_RESPONSE_STACK.pop() DCNL DCSP  DCSP  DCSP return utils.FakeHTTPResponse() DCNL DCSP  DCSP def request(self, *_args, **_kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def close(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP def fake_get_conn_class(self, *args, **kwargs): DCNL DCSP  DCSP return FakeHTTPConnection DCNL DCSP stubs.Set(Store, '_get_conn_class', fake_get_conn_class)
 DCSP test_stubs.stub_out_registry_server(stubs) DCNL DCSP def fake_image_update(ctx, image_id, values, purge_props=False): DCNL DCSP  DCSP return {'properties': {}} DCNL DCSP stubs.Set(db_api, 'image_update', fake_image_update)
 DCSP scheme = 's3' DCNL DCSP if authurl.startswith('https://'): DCNL DCSP  DCSP scheme = 's3+https' DCNL DCSP  DCSP authurl = authurl[8:] DCNL DCSP elif authurl.startswith('http://'): DCNL DCSP  DCSP authurl = authurl[7:] DCNL DCSP authurl = authurl.strip('/') DCNL DCSP return ('%s://%s:%s@%s/%s/%s' % (scheme, user, key, authurl, bucket, obj))
 DCSP if (backend == 'mysql'): DCNL DCSP  DCSP backend = 'mysql+mysqldb' DCNL DCSP elif (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())
 DCSP metadata = sqlalchemy.schema.MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP return sqlalchemy.Table(name, metadata, autoload=True)
 DCSP class FakeSocket(object, ): DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def fileno(self): DCNL DCSP  DCSP  DCSP return 42 DCNL DCSP class FakeSendFile(object, ): DCNL DCSP  DCSP def __init__(self, req): DCNL DCSP  DCSP  DCSP self.req = req DCNL DCSP  DCSP def sendfile(self, o, i, offset, nbytes): DCNL DCSP  DCSP  DCSP os.lseek(i, offset, os.SEEK_SET) DCNL DCSP  DCSP  DCSP prev_len = len(self.req.body) DCNL DCSP  DCSP  DCSP self.req.body += os.read(i, nbytes) DCNL DCSP  DCSP  DCSP return (len(self.req.body) - prev_len) DCNL DCSP class FakeGlanceConnection(object, ): DCNL DCSP  DCSP def __init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP self.sock = FakeSocket() DCNL DCSP  DCSP  DCSP self.stub_force_sendfile = kwargs.get('stub_force_sendfile', SENDFILE_SUPPORTED) DCNL DCSP  DCSP def connect(self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP def close(self): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP def _clean_url(self, url): DCNL DCSP  DCSP  DCSP return (url.replace('/v1', '', 1) if url.startswith('/v1') else url) DCNL DCSP  DCSP def putrequest(self, method, url): DCNL DCSP  DCSP  DCSP self.req = webob.Request.blank(self._clean_url(url)) DCNL DCSP  DCSP  DCSP if self.stub_force_sendfile: DCNL DCSP  DCSP  DCSP  DCSP fake_sendfile = FakeSendFile(self.req) DCNL DCSP  DCSP  DCSP  DCSP stubs.Set(sendfile, 'sendfile', fake_sendfile.sendfile) DCNL DCSP  DCSP  DCSP self.req.method = method DCNL DCSP  DCSP def putheader(self, key, value): DCNL DCSP  DCSP  DCSP self.req.headers[key] = value DCNL DCSP  DCSP def endheaders(self): DCNL DCSP  DCSP  DCSP hl = [i.lower() for i in self.req.headers.keys()] DCNL DCSP  DCSP  DCSP assert (not (('content-length' in hl) and ('transfer-encoding' in hl))), 'Content-Length DCSP and DCSP Transfer-Encoding DCSP are DCSP mutually DCSP exclusive' DCNL DCSP  DCSP def send(self, data): DCNL DCSP  DCSP  DCSP self.req.body += data.split('\r\n')[1] DCNL DCSP  DCSP def request(self, method, url, body=None, headers=None): DCNL DCSP  DCSP  DCSP self.req = webob.Request.blank(self._clean_url(url)) DCNL DCSP  DCSP  DCSP self.req.method = method DCNL DCSP  DCSP  DCSP if headers: DCNL DCSP  DCSP  DCSP  DCSP self.req.headers = headers DCNL DCSP  DCSP  DCSP if body: DCNL DCSP  DCSP  DCSP  DCSP self.req.body = body DCNL DCSP  DCSP def getresponse(self): DCNL DCSP  DCSP  DCSP mapper = routes.Mapper() DCNL DCSP  DCSP  DCSP api = context.UnauthenticatedContextMiddleware(router.API(mapper)) DCNL DCSP  DCSP  DCSP res = self.req.get_response(api) DCNL DCSP  DCSP  DCSP def fake_reader(): DCNL DCSP  DCSP  DCSP  DCSP return res.body DCNL DCSP  DCSP  DCSP setattr(res, 'read', fake_reader) DCNL DCSP  DCSP  DCSP return res DCNL DCSP def fake_get_connection_type(client): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP proper DCSP connection DCSP type\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP DEFAULT_REGISTRY_PORT = 9191 DCNL DCSP  DCSP DEFAULT_API_PORT = 9292 DCNL DCSP  DCSP if ((client.port == DEFAULT_API_PORT) and (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeGlanceConnection DCNL DCSP  DCSP elif ((client.port == DEFAULT_REGISTRY_PORT) and (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeRegistryConnection DCNL DCSP def fake_image_iter(self): DCNL DCSP  DCSP for i in self.source.app_iter: DCNL DCSP  DCSP  DCSP (yield i) DCNL DCSP def fake_sendable(self, body): DCNL DCSP  DCSP force = getattr(self, 'stub_force_sendfile', None) DCNL DCSP  DCSP if (force is None): DCNL DCSP  DCSP  DCSP return self._stub_orig_sendable(body) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if force: DCNL DCSP  DCSP  DCSP  DCSP assert glance.common.client.SENDFILE_SUPPORTED DCNL DCSP  DCSP  DCSP return force DCNL DCSP stubs.Set(glance.common.client.BaseClient, 'get_connection_type', fake_get_connection_type) DCNL DCSP setattr(glance.common.client.BaseClient, '_stub_orig_sendable', glance.common.client.BaseClient._sendable) DCNL DCSP stubs.Set(glance.common.client.BaseClient, '_sendable', fake_sendable)
 DCSP def fake_get_connection_type(client): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP proper DCSP connection DCSP type\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP DEFAULT_REGISTRY_PORT = 9191 DCNL DCSP  DCSP if ((client.port == DEFAULT_REGISTRY_PORT) and (client.host == '0.0.0.0')): DCNL DCSP  DCSP  DCSP return FakeRegistryConnection DCNL DCSP def fake_image_iter(self): DCNL DCSP  DCSP for i in self.response.app_iter: DCNL DCSP  DCSP  DCSP (yield i) DCNL DCSP stubs.Set(glance.common.client.BaseClient, 'get_connection_type', fake_get_connection_type)
 DCSP namespaced_key = '.'.join([namespace, key]) DCNL DCSP return namespaced_key
 DCSP namespaced_key = _make_namespaced_xattr_key(key) DCNL DCSP try: DCNL DCSP  DCSP return xattr.getxattr(path, namespaced_key) DCNL DCSP except IOError: DCNL DCSP  DCSP if ('default' in kwargs): DCNL DCSP  DCSP  DCSP return kwargs['default'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP namespaced_key = _make_namespaced_xattr_key(key) DCNL DCSP xattr.setxattr(path, namespaced_key, str(value))
 DCSP count = int(get_xattr(path, key)) DCNL DCSP count += n DCNL DCSP set_xattr(path, key, str(count))
 DCSP if (auth_url or os.getenv('OS_AUTH_URL')): DCNL DCSP  DCSP force_strategy = 'keystone' DCNL DCSP else: DCNL DCSP  DCSP force_strategy = None DCNL DCSP creds = {'username': (username or os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME'))), 'password': (password or os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD'))), 'tenant': (tenant or os.getenv('OS_AUTH_TENANT', os.getenv('OS_TENANT_NAME'))), 'auth_url': (auth_url or os.getenv('OS_AUTH_URL')), 'strategy': (force_strategy or auth_strategy or os.getenv('OS_AUTH_STRATEGY', 'noauth')), 'region': (region or os.getenv('OS_REGION_NAME'))} DCNL DCSP if ((creds['strategy'] == 'keystone') and (not creds['auth_url'])): DCNL DCSP  DCSP msg = '--os_auth_url DCSP option DCSP or DCSP OS_AUTH_URL DCSP environment DCSP variable DCSP required DCSP when DCSP keystone DCSP authentication DCSP strategy DCSP is DCSP enabled\n' DCNL DCSP  DCSP raise exception.ClientConfigurationError(msg) DCNL DCSP return CacheClient(host=host, port=port, timeout=timeout, use_ssl=use_ssl, auth_tok=(auth_token or os.getenv('OS_TOKEN')), creds=creds, insecure=insecure)
 DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf(product_name) DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP str = at.strftime(TIME_FORMAT) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP str += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return str
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP global _rules DCNL DCSP _rules = rules
 DCSP global _rules DCNL DCSP _rules = None
 DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
 DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
 DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
 DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
 DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.exists('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command('git DCSP describe DCSP --always') DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
 DCSP if os.path.exists('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --always').replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP LOG.error(_('Max DCSP serialization DCSP depth DCSP exceeded DCSP on DCSP object: DCSP %d DCSP %s'), level, value) DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('glance.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP return {'id': image.image_id, 'name': image.name, 'status': image.status, 'created_at': timeutils.isotime(image.created_at), 'updated_at': timeutils.isotime(image.updated_at), 'min_disk': image.min_disk, 'min_ram': image.min_ram, 'protected': image.protected, 'checksum': image.checksum, 'owner': image.owner, 'disk_format': image.disk_format, 'container_format': image.container_format, 'size': image.size, 'is_public': (image.visibility == 'public'), 'properties': dict(image.extra_properties), 'tags': list(image.tags), 'deleted': False, 'deleted_at': None}
 DCSP def _fetch_memb(memb, attr_map): DCNL DCSP  DCSP return dict([(k, memb[v]) for (k, v) in attr_map.items() if (v in memb.keys())]) DCNL DCSP return [_fetch_memb(memb, attr_map) for memb in members]
 DCSP deserializer = wsgi.JSONRequestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
 DCSP def _fetch_attrs(d, attrs): DCNL DCSP  DCSP return dict([(a, d[a]) for a in attrs if (a in d.keys())]) DCNL DCSP properties = dict(((p['name'], p['value']) for p in image['properties'] if (not p['deleted']))) DCNL DCSP image_dict = _fetch_attrs(image, glance.db.IMAGE_ATTRS) DCNL DCSP image_dict['properties'] = properties DCNL DCSP _limit_locations(image_dict) DCNL DCSP return image_dict
 DCSP deserializer = wsgi.JSONRequestDeserializer() DCNL DCSP serializer = wsgi.JSONResponseSerializer() DCNL DCSP return wsgi.Resource(Controller(), deserializer, serializer)
 DCSP global _CLIENT_KWARGS, _CLIENT_HOST, _CLIENT_PORT, _METADATA_ENCRYPTION_KEY DCNL DCSP try: DCNL DCSP  DCSP (host, port) = (CONF.registry_host, CONF.registry_port) DCNL DCSP except cfg.ConfigFileValueError: DCNL DCSP  DCSP msg = _('Configuration DCSP option DCSP was DCSP not DCSP valid') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BadRegistryConnectionConfiguration(msg) DCNL DCSP except IndexError: DCNL DCSP  DCSP msg = _('Could DCSP not DCSP find DCSP required DCSP configuration DCSP option') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.BadRegistryConnectionConfiguration(msg) DCNL DCSP _CLIENT_HOST = host DCNL DCSP _CLIENT_PORT = port DCNL DCSP _METADATA_ENCRYPTION_KEY = CONF.metadata_encryption_key DCNL DCSP _CLIENT_KWARGS = {'use_ssl': (CONF.registry_client_protocol.lower() == 'https'), 'key_file': CONF.registry_client_key_file, 'cert_file': CONF.registry_client_cert_file, 'ca_file': CONF.registry_client_ca_file, 'insecure': CONF.registry_client_insecure, 'timeout': CONF.registry_client_timeout}
 DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (s == MY_IP): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == HOST): DCNL DCSP  DCSP return 'cinder' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
 DCSP pos = physical_line.find('TODO') DCNL DCSP pos1 = physical_line.find('TODO(') DCNL DCSP pos2 = physical_line.find('#') DCNL DCSP if ((pos != pos1) and (pos2 >= 0) and (pos2 < pos)): DCNL DCSP  DCSP return (pos, 'CINDER DCSP N101: DCSP Use DCSP TODO(NAME)')
 DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yield (6, "CINDER DCSP N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
 DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yield (1, 'CINDER DCSP N202: DCSP assertRaises DCSP Exception DCSP too DCSP broad'))
 DCSP pos = logical_line.find(',') DCNL DCSP parts = logical_line.split() DCNL DCSP if ((pos > (-1)) and ((parts[0] == 'import') or ((parts[0] == 'from') and (parts[2] == 'import'))) and (not is_import_exception(parts[1]))): DCNL DCSP  DCSP (yield (pos, 'CINDER DCSP N301: DCSP one DCSP import DCSP per DCSP line'))
 DCSP def importModuleCheck(mod, parent=None, added=False): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP can't DCSP find DCSP module DCSP on DCSP first DCSP try, DCSP recursively DCSP check DCSP for DCSP relative\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imports\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP current_path = os.path.dirname(pep8.current_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore', DeprecationWarning) DCNL DCSP  DCSP  DCSP  DCSP valid = True DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_import_exception(parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_mod = __import__(parent, globals(), locals(), [mod], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(getattr(parent_mod, mod)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP __import__(mod, globals(), locals(), [], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(sys.modules[mod]) DCNL DCSP  DCSP  DCSP  DCSP if (not valid): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if added: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("CINDER DCSP N304: DCSP No DCSP relative DCSP  DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("CINDER DCSP N302: DCSP import DCSP only DCSP modules. DCSP '%s' DCSP does DCSP not DCSP import DCSP a DCSP module" % logical_line)) DCNL DCSP  DCSP except (ImportError, NameError) as exc: DCNL DCSP  DCSP  DCSP if (not added): DCNL DCSP  DCSP  DCSP  DCSP added = True DCNL DCSP  DCSP  DCSP  DCSP sys.path.append(current_path) DCNL DCSP  DCSP  DCSP  DCSP return importModuleCheck(mod, parent, added) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = logical_line.split()[1] DCNL DCSP  DCSP  DCSP  DCSP if (name not in _missingImport): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if VERBOSE_MISSING_IMPORT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ("ERROR: DCSP import DCSP '%s' DCSP failed: DCSP %s" % (name, exc)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.add(name) DCNL DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return (logical_line.find(mod), 'CINDER DCSP N303: DCSP Invalid DCSP import, DCSP AttributeError DCSP raised') DCNL DCSP import_normalize(logical_line) DCNL DCSP split_line = logical_line.split() DCNL DCSP if (logical_line.startswith('import DCSP ') and (',' not in logical_line) and ((len(split_line) == 2) or ((len(split_line) == 4) and (split_line[2] == 'as')))): DCNL DCSP  DCSP mod = split_line[1] DCNL DCSP  DCSP rval = importModuleCheck(mod) DCNL DCSP  DCSP if (rval is not None): DCNL DCSP  DCSP  DCSP (yield rval)
 DCSP split_line = import_normalize(physical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(lines[(line_number - 2)]).strip().lower().split() DCNL DCSP length = [2, 4] DCNL DCSP if ((len(split_line) in length) and (len(split_previous) in length) and (split_line[0] == 'import') and (split_previous[0] == 'import')): DCNL DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP return (0, ('CINDER DCSP N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP order DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1])))
 DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) > (pos + 1))): DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N401: DCSP one DCSP line DCSP docstring DCSP should DCSP not DCSP start DCSP with DCSP a DCSP space')
 DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP end = max([(physical_line[(-4):(-1)] == i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and end and (len(physical_line) > (pos + 4))): DCNL DCSP  DCSP if ((physical_line[(-5)] != '.') and physical_line): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N402: DCSP one DCSP line DCSP docstring DCSP needs DCSP a DCSP period')
 DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) == pos)): DCNL DCSP  DCSP print physical_line DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'CINDER DCSP N403: DCSP multi DCSP line DCSP docstring DCSP end DCSP on DCSP new DCSP line')
 DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, _) = (yield) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) and (text == '_')): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N701: DCSP Invalid DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Formatting DCSP operation DCSP should DCSP be DCSP outside DCSP of DCSP localization DCSP method DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP instead DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.findall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) and spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'CINDER DCSP N703: DCSP Multiple DCSP positional DCSP placeholders')
 DCSP gen = check_l18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.send, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yield e.args)
 DCSP pep8.current_file = filename DCNL DCSP return open(filename).readlines()
 DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args and name.startswith('cinder')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
 DCSP def _skipper(*args, **kw): DCNL DCSP  DCSP 'Wrapped DCSP skipper DCSP function.' DCNL DCSP  DCSP if FLAGS.fake_tests: DCNL DCSP  DCSP  DCSP raise unittest.SkipTest('Test DCSP cannot DCSP be DCSP run DCSP in DCSP fake DCSP mode') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*args, **kw) DCNL DCSP return _skipper
 DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason='Invalid DCSP sort DCSP key') DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
 DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
 DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in filters if (opt not in allowed_search_options)] DCNL DCSP bad_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%s' DCSP from DCSP query") % bad_options) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP del filters[opt]
 DCSP d = _translate_snapshot_summary_view(context, snapshot) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = snapshot['id'] DCNL DCSP d['created_at'] = snapshot['created_at'] DCNL DCSP d['name'] = snapshot['display_name'] DCNL DCSP d['description'] = snapshot['display_description'] DCNL DCSP d['volume_id'] = snapshot['volume_id'] DCNL DCSP d['status'] = snapshot['status'] DCNL DCSP d['size'] = snapshot['volume_size'] DCNL DCSP if snapshot.get('snapshot_metadata'): DCNL DCSP  DCSP metadata = snapshot.get('snapshot_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (snapshot.get('metadata') and isinstance(snapshot.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = snapshot['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP return d
 DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
 DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
 DCSP return request.GET['marker']
 DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
 DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
 DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
 DCSP return list(obj.items())
 DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
 DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
 DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
 DCSP dom = utils.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
 DCSP d = _translate_attachment_summary_view(_context, vol) DCNL DCSP return d
 DCSP d = {} DCNL DCSP volume_id = vol['id'] DCNL DCSP d['id'] = volume_id DCNL DCSP d['volume_id'] = volume_id DCNL DCSP d['server_id'] = vol['instance_uuid'] DCNL DCSP if vol.get('mountpoint'): DCNL DCSP  DCSP d['device'] = vol['mountpoint'] DCNL DCSP return d
 DCSP d = _translate_volume_summary_view(context, vol, image_id) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availability_zone'] = vol['availability_zone'] DCNL DCSP d['created_at'] = vol['created_at'] DCNL DCSP d['attachments'] = [] DCNL DCSP if (vol['attach_status'] == 'attached'): DCNL DCSP  DCSP attachment = _translate_attachment_detail_view(context, vol) DCNL DCSP  DCSP d['attachments'].append(attachment) DCNL DCSP d['display_name'] = vol['display_name'] DCNL DCSP d['display_description'] = vol['display_description'] DCNL DCSP if (vol['volume_type_id'] and vol.get('volume_type')): DCNL DCSP  DCSP d['volume_type'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['volume_type'] = str(vol['volume_type_id']) DCNL DCSP d['snapshot_id'] = vol['snapshot_id'] DCNL DCSP d['source_volid'] = vol['source_volid'] DCNL DCSP if image_id: DCNL DCSP  DCSP d['image_id'] = image_id DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metadata'): DCNL DCSP  DCSP metadata = vol.get('volume_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (vol.get('metadata') and isinstance(vol.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = vol['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP if vol.get('volume_glance_metadata'): DCNL DCSP  DCSP d['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP d['bootable'] = 'false' DCNL DCSP return d
 DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP bad_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(bad_options)s' DCSP from DCSP query") % locals()) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP del search_options[opt]
 DCSP d = _translate_snapshot_summary_view(context, snapshot) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = snapshot['id'] DCNL DCSP d['created_at'] = snapshot['created_at'] DCNL DCSP d['display_name'] = snapshot['display_name'] DCNL DCSP d['display_description'] = snapshot['display_description'] DCNL DCSP d['volume_id'] = snapshot['volume_id'] DCNL DCSP d['status'] = snapshot['status'] DCNL DCSP d['size'] = snapshot['volume_size'] DCNL DCSP if snapshot.get('snapshot_metadata'): DCNL DCSP  DCSP metadata = snapshot.get('snapshot_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (snapshot.get('metadata') and isinstance(snapshot.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = snapshot['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP return d
 DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
 DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
 DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
 DCSP curr_time = timeutils.utcnow() DCNL DCSP context = req.environ['cinder.context'] DCNL DCSP services = db.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in req.GET): DCNL DCSP  DCSP zone = req.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP delta = (curr_time - (host['updated_at'] or host['created_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconds(delta)) <= FLAGS.service_down_time) DCNL DCSP  DCSP status = ((alive and 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enabled' DCNL DCSP  DCSP if host['disabled']: DCNL DCSP  DCSP  DCSP active = 'disabled' DCNL DCSP  DCSP LOG.debug(('status, DCSP active DCSP and DCSP update: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['updated_at']))) DCNL DCSP  DCSP hosts.append({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-update': host['updated_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
 DCSP def wrapped(self, req, id, service=None, *args, **kwargs): DCNL DCSP  DCSP listed_hosts = _list_hosts(req, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listed_hosts] DCNL DCSP  DCSP if (id in hosts): DCNL DCSP  DCSP  DCSP return fn(self, req, id, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP could DCSP not DCSP be DCSP found.") % id) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFound(explanation=message) DCNL DCSP return wrapped
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP source_volid = Column('source_volid', String(36)) DCNL DCSP volumes.create_column(source_volid) DCNL DCSP volumes.update().values(source_volid=None).execute()
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP source_volid = Column('source_volid', String(36)) DCNL DCSP volumes.drop_column(source_volid)
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP volume_types = Table('volume_types', meta, autoload=True) DCNL DCSP extra_specs = Table('volume_type_extra_specs', meta, autoload=True) DCNL DCSP fkey_remove_list = [volumes.c.volume_type_id, volume_types.c.id, extra_specs.c.volume_type_id] DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.drop() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP volumes.c.volume_type_id.alter(String(36)) DCNL DCSP volume_types.c.id.alter(String(36)) DCNL DCSP extra_specs.c.volume_type_id.alter(String(36)) DCNL DCSP vtype_list = list(volume_types.select().execute()) DCNL DCSP for t in vtype_list: DCNL DCSP  DCSP new_id = str(uuid.uuid4()) DCNL DCSP  DCSP volumes.update().where((volumes.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP extra_specs.update().where((extra_specs.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP volume_types.update().where((volume_types.c.id == t['id'])).values(id=new_id).execute() DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.create() DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('Created DCSP foreign DCSP key DCSP %s' % fkey_name)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoload=True) DCNL DCSP volume_types = Table('volume_types', meta, autoload=True) DCNL DCSP extra_specs = Table('volume_type_extra_specs', meta, autoload=True) DCNL DCSP fkey_remove_list = [volumes.c.volume_type_id, volume_types.c.id, extra_specs.c.volume_type_id] DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.drop() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP vtype_list = list(volume_types.select().execute()) DCNL DCSP new_id = 1 DCNL DCSP for t in vtype_list: DCNL DCSP  DCSP volumes.update().where((volumes.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP extra_specs.update().where((extra_specs.c.volume_type_id == t['id'])).values(volume_type_id=new_id).execute() DCNL DCSP  DCSP volume_types.update().where((volume_types.c.id == t['id'])).values(id=new_id).execute() DCNL DCSP  DCSP new_id += 1 DCNL DCSP volumes.c.volume_type_id.alter(Integer) DCNL DCSP volume_types.c.id.alter(Integer) DCNL DCSP extra_specs.c.volume_type_id.alter(Integer) DCNL DCSP for column in fkey_remove_list: DCNL DCSP  DCSP fkeys = list(column.foreign_keys) DCNL DCSP  DCSP if fkeys: DCNL DCSP  DCSP  DCSP fkey_name = fkeys[0].constraint.name DCNL DCSP  DCSP  DCSP fkey = ForeignKeyConstraint(columns=[column], refcolumns=[volume_types.c.id], name=fkey_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fkey.create() DCNL DCSP  DCSP  DCSP  DCSP LOG.info(('Created DCSP foreign DCSP key DCSP %s' % fkey_name)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if migrate_engine.url.get_dialect().name.startswith('sqlite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise
 DCSP from sqlalchemy import create_engine DCNL DCSP models = (Backup, Migration, Service, SMBackendConf, SMFlavors, SMVolume, Volume, VolumeMetadata, SnapshotMetadata, VolumeTypeExtraSpecs, VolumeTypes, VolumeGlanceMetadata) DCNL DCSP engine = create_engine(FLAGS.sql_connection, echo=False) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
 DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.query = cinder.exception.wrap_db_error(session.query) DCNL DCSP session.flush = cinder.exception.wrap_db_error(session.flush) DCNL DCSP return session
 DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
 DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(FLAGS.sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if (FLAGS.sql_connection_debug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP  DCSP elif (FLAGS.sql_connection_debug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = sqlalchemy.create_engine(FLAGS.sql_connection, **engine_args) DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
 DCSP return sqlalchemy.orm.sessionmaker(bind=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
 DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP request DCSP context DCSP is DCSP deprecated'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('die') DCNL DCSP return context.is_admin
 DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_admin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AdminRequired() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_admin_context(args[0])) and (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP def wrapper(context, volume_id, *args, **kwargs): DCNL DCSP  DCSP db.volume_get(context, volume_id) DCNL DCSP  DCSP return f(context, volume_id, *args, **kwargs) DCNL DCSP wrapper.__name__ = f.__name__ DCNL DCSP return wrapper
 DCSP def wrapper(context, snapshot_id, *args, **kwargs): DCNL DCSP  DCSP db.api.snapshot_get(context, snapshot_id) DCNL DCSP  DCSP return f(context, snapshot_id, *args, **kwargs) DCNL DCSP wrapper.__name__ = f.__name__ DCNL DCSP return wrapper
 DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
 DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
 DCSP inst_type_dict = dict(inst_type_query) DCNL DCSP extra_specs = dict([(x['key'], x['value']) for x in inst_type_query['extra_specs']]) DCNL DCSP inst_type_dict['extra_specs'] = extra_specs DCNL DCSP return inst_type_dict
 DCSP return model_query(context, models.Reservation, read_deleted='no', session=session).filter(models.Reservation.uuid.in_(reservations)).with_lockmode('update').all()
 DCSP if (not values.get('id')): DCNL DCSP  DCSP values['id'] = str(uuid.uuid4()) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.VolumeTypeExists(id=values['name']) DCNL DCSP  DCSP except exception.VolumeTypeNotFoundByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP volume_type_get(context, values['id'], session) DCNL DCSP  DCSP  DCSP raise exception.VolumeTypeExists(id=values['id']) DCNL DCSP  DCSP except exception.VolumeTypeNotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP values['extra_specs'] = _metadata_refs(values.get('extra_specs'), models.VolumeTypeExtraSpecs) DCNL DCSP  DCSP  DCSP volume_type_ref = models.VolumeTypes() DCNL DCSP  DCSP  DCSP volume_type_ref.update(values) DCNL DCSP  DCSP  DCSP volume_type_ref.save() DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise exception.DBError(e) DCNL DCSP  DCSP return volume_type_ref
 DCSP filters = (filters or {}) DCNL DCSP read_deleted = ('yes' if inactive else 'no') DCNL DCSP rows = model_query(context, models.VolumeTypes, read_deleted=read_deleted).options(joinedload('extra_specs')).order_by('name').all() DCNL DCSP result = {} DCNL DCSP for row in rows: DCNL DCSP  DCSP result[row['name']] = _dict_with_extra_specs(row) DCNL DCSP return result
 DCSP result = model_query(context, models.VolumeTypes, session=session).options(joinedload('extra_specs')).filter_by(id=id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.VolumeTypeNotFound(volume_type_id=id) DCNL DCSP return _dict_with_extra_specs(result)
 DCSP result = model_query(context, models.VolumeTypes, session=session).options(joinedload('extra_specs')).filter_by(name=name).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.VolumeTypeNotFoundByName(volume_type_name=name) DCNL DCSP else: DCNL DCSP  DCSP return _dict_with_extra_specs(result)
 DCSP session = get_session() DCNL DCSP query = session.query(models.Volume) DCNL DCSP query = query.filter(or_((models.Volume.deleted_at == None), (models.Volume.deleted_at > begin))) DCNL DCSP if end: DCNL DCSP  DCSP query = query.filter((models.Volume.created_at < end)) DCNL DCSP if project_id: DCNL DCSP  DCSP query = query.filter_by(project_id=project_id) DCNL DCSP return query.all()
 DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP return session.query(models.VolumeGlanceMetadata).filter_by(volume_id=volume_id).filter_by(deleted=False).all()
 DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP return session.query(models.VolumeGlanceMetadata).filter_by(snapshot_id=snapshot_id).filter_by(deleted=False).all()
 DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP rows = session.query(models.VolumeGlanceMetadata).filter_by(volume_id=volume_id).filter_by(key=key).filter_by(deleted=False).all() DCNL DCSP  DCSP if (len(rows) > 0): DCNL DCSP  DCSP  DCSP raise exception.GlanceMetadataExists(key=key, volume_id=volume_id) DCNL DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP vol_glance_metadata.key = key DCNL DCSP  DCSP vol_glance_metadata.value = value DCNL DCSP  DCSP vol_glance_metadata.save(session=session) DCNL DCSP return
 DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metadata = volume_glance_metadata_get(context, volume_id, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metadata: DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.snapshot_id = snapshot_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.save(session=session)
 DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metadata = volume_glance_metadata_get(context, src_volume_id, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metadata: DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.save(session=session)
 DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP metadata = volume_snapshot_glance_metadata_get(context, snapshot_id, session=session) DCNL DCSP with session.begin(): DCNL DCSP  DCSP for meta in metadata: DCNL DCSP  DCSP  DCSP vol_glance_metadata = models.VolumeGlanceMetadata() DCNL DCSP  DCSP  DCSP vol_glance_metadata.volume_id = volume_id DCNL DCSP  DCSP  DCSP vol_glance_metadata.key = meta['key'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.value = meta['value'] DCNL DCSP  DCSP  DCSP vol_glance_metadata.save(session=session)
 DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
 DCSP return IMPL.service_destroy(context, service_id)
 DCSP return IMPL.service_get(context, service_id)
 DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
 DCSP return IMPL.service_get_all(context, disabled)
 DCSP return IMPL.service_get_all_by_topic(context, topic)
 DCSP return IMPL.service_get_all_by_host(context, host)
 DCSP return IMPL.service_get_all_volume_sorted(context)
 DCSP return IMPL.service_get_by_args(context, host, binary)
 DCSP return IMPL.service_create(context, values)
 DCSP return IMPL.service_update(context, service_id, values)
 DCSP return IMPL.migration_update(context, id, values)
 DCSP return IMPL.migration_create(context, values)
 DCSP return IMPL.migration_get(context, migration_id)
 DCSP return IMPL.migration_get_by_instance_and_status(context, instance_uuid, status)
 DCSP return IMPL.migration_get_all_unconfirmed(context, confirm_window)
 DCSP return IMPL.iscsi_target_count_by_host(context, host)
 DCSP return IMPL.iscsi_target_create_safe(context, values)
 DCSP return IMPL.volume_allocate_iscsi_target(context, volume_id, host)
 DCSP return IMPL.volume_attached(context, volume_id, instance_id, mountpoint)
 DCSP return IMPL.volume_create(context, values)
 DCSP return IMPL.volume_data_get_for_host(context, host, session)
 DCSP return IMPL.volume_data_get_for_project(context, project_id, session)
 DCSP return IMPL.volume_destroy(context, volume_id)
 DCSP return IMPL.volume_detached(context, volume_id)
 DCSP return IMPL.volume_get(context, volume_id)
 DCSP return IMPL.volume_get_all(context, marker, limit, sort_key, sort_dir)
 DCSP return IMPL.volume_get_all_by_host(context, host)
 DCSP return IMPL.volume_get_all_by_instance_uuid(context, instance_uuid)
 DCSP return IMPL.volume_get_all_by_project(context, project_id, marker, limit, sort_key, sort_dir)
 DCSP return IMPL.volume_get_iscsi_target_num(context, volume_id)
 DCSP return IMPL.volume_update(context, volume_id, values)
 DCSP return IMPL.snapshot_create(context, values)
 DCSP return IMPL.snapshot_destroy(context, snapshot_id)
 DCSP return IMPL.snapshot_get(context, snapshot_id)
 DCSP return IMPL.snapshot_get_all(context)
 DCSP return IMPL.snapshot_get_all_by_project(context, project_id)
 DCSP return IMPL.snapshot_get_all_for_volume(context, volume_id)
 DCSP return IMPL.snapshot_update(context, snapshot_id, values)
 DCSP return IMPL.snapshot_data_get_for_project(context, project_id, session)
 DCSP return IMPL.snapshot_metadata_get(context, snapshot_id)
 DCSP IMPL.snapshot_metadata_delete(context, snapshot_id, key)
 DCSP IMPL.snapshot_metadata_update(context, snapshot_id, metadata, delete)
 DCSP return IMPL.volume_metadata_get(context, volume_id)
 DCSP IMPL.volume_metadata_delete(context, volume_id, key)
 DCSP IMPL.volume_metadata_update(context, volume_id, metadata, delete)
 DCSP return IMPL.volume_type_create(context, values)
 DCSP return IMPL.volume_type_get_all(context, inactive)
 DCSP return IMPL.volume_type_get(context, id)
 DCSP return IMPL.volume_type_get_by_name(context, name)
 DCSP return IMPL.volume_type_destroy(context, id)
 DCSP return IMPL.volume_get_active_by_window(context, begin, end, project_id)
 DCSP return IMPL.volume_type_extra_specs_get(context, volume_type_id)
 DCSP IMPL.volume_type_extra_specs_delete(context, volume_type_id, key)
 DCSP IMPL.volume_type_extra_specs_update_or_create(context, volume_type_id, extra_specs)
 DCSP return IMPL.volume_glance_metadata_create(context, volume_id, key, value)
 DCSP return IMPL.volume_glance_metadata_get(context, volume_id)
 DCSP return IMPL.volume_snapshot_glance_metadata_get(context, snapshot_id)
 DCSP return IMPL.volume_glance_metadata_copy_to_snapshot(context, snapshot_id, volume_id)
 DCSP return IMPL.volume_glance_metadata_copy_to_volume(context, volume_id, snapshot_id)
 DCSP return IMPL.volume_glance_metadata_delete_by_volume(context, volume_id)
 DCSP return IMPL.volume_glance_metadata_delete_by_snapshot(context, snapshot_id)
 DCSP return IMPL.volume_glance_metadata_copy_from_volume_to_volume(context, src_volume_id, volume_id)
 DCSP return IMPL.sm_backend_conf_create(context, values)
 DCSP return IMPL.sm_backend_conf_update(context, sm_backend_conf_id, values)
 DCSP return IMPL.sm_backend_conf_delete(context, sm_backend_conf_id)
 DCSP return IMPL.sm_backend_conf_get(context, sm_backend_conf_id)
 DCSP return IMPL.sm_backend_conf_get_by_sr(context, sr_uuid)
 DCSP return IMPL.sm_backend_conf_get_all(context)
 DCSP return IMPL.sm_flavor_create(context, values)
 DCSP return IMPL.sm_flavor_update(context, values)
 DCSP return IMPL.sm_flavor_delete(context, sm_flavor_id)
 DCSP return IMPL.sm_flavor_get(context, sm_flavor)
 DCSP return IMPL.sm_flavor_get_all(context)
 DCSP return IMPL.sm_volume_create(context, values)
 DCSP return IMPL.sm_volume_update(context, values)
 DCSP return IMPL.sm_volume_delete(context, volume_id)
 DCSP return IMPL.sm_volume_get(context, volume_id)
 DCSP return IMPL.sm_volume_get_all(context)
 DCSP return IMPL.quota_create(context, project_id, resource, limit)
 DCSP return IMPL.quota_get(context, project_id, resource)
 DCSP return IMPL.quota_get_all_by_project(context, project_id)
 DCSP return IMPL.quota_update(context, project_id, resource, limit)
 DCSP return IMPL.quota_destroy(context, project_id, resource)
 DCSP return IMPL.quota_class_create(context, class_name, resource, limit)
 DCSP return IMPL.quota_class_get(context, class_name, resource)
 DCSP return IMPL.quota_class_get_all_by_name(context, class_name)
 DCSP return IMPL.quota_class_update(context, class_name, resource, limit)
 DCSP return IMPL.quota_class_destroy(context, class_name, resource)
 DCSP return IMPL.quota_class_destroy_all_by_name(context, class_name)
 DCSP return IMPL.quota_usage_create(context, project_id, resource, in_use, reserved, until_refresh)
 DCSP return IMPL.quota_usage_get(context, project_id, resource)
 DCSP return IMPL.quota_usage_get_all_by_project(context, project_id)
 DCSP return IMPL.reservation_create(context, uuid, usage, project_id, resource, delta, expire)
 DCSP return IMPL.reservation_get(context, uuid)
 DCSP return IMPL.reservation_get_all_by_project(context, project_id)
 DCSP return IMPL.reservation_destroy(context, uuid)
 DCSP return IMPL.quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=project_id)
 DCSP return IMPL.reservation_commit(context, reservations, project_id=project_id)
 DCSP return IMPL.reservation_rollback(context, reservations, project_id=project_id)
 DCSP return IMPL.quota_destroy_all_by_project(context, project_id)
 DCSP return IMPL.reservation_expire(context)
 DCSP return IMPL.backup_get(context, backup_id)
 DCSP return IMPL.backup_get_all(context)
 DCSP return IMPL.backup_get_all_by_host(context, host)
 DCSP return IMPL.backup_create(context, values)
 DCSP return IMPL.backup_get_all_by_project(context, project_id)
 DCSP return IMPL.backup_update(context, backup_id, values)
 DCSP return IMPL.backup_destroy(context, backup_id)
 DCSP return IMPL.db_sync(version=version)
 DCSP return IMPL.db_version()
 DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'cinder', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/cinder/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFound(path=os.path.abspath(config_path))
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'sudo')): DCNL DCSP  DCSP  DCSP LOG.deprecated(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP different DCSP from DCSP cinder-rootwrap, DCSP and DCSP defaults DCSP to DCSP using DCSP sudo) DCSP is DCSP now DCSP deprecated. DCSP You DCSP should DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP instead.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmd = (['sudo', 'cinder-rootwrap', FLAGS.rootwrap_config] + list(cmd)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = (shlex.split(FLAGS.root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
 DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.volume_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
 DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
 DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
 DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
 DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
 DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
 DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
 DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
 DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
 DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
 DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
 DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
 DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
 DCSP parts = address.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in FLAGS.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
 DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
 DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
 DCSP return ('http://%s:%d' % (FLAGS.glance_host, FLAGS.glance_port))
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
 DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
 DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
 DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP return file(*args, **kwargs)
 DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.update, iter((lambda : file_like_object.read(32768)), ''))) DCNL DCSP return checksum.hexdigest()
 DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
 DCSP last_heartbeat = (service['updated_at'] or service['created_at']) DCNL DCSP elapsed = total_seconds((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapsed) <= FLAGS.service_down_time)
 DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
 DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
 DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
 DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
 DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
 DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP credentials = context.to_dict() DCNL DCSP policy.enforce(match_list, target, credentials, exception.PolicyNotAuthorized, action=action)
 DCSP init() DCNL DCSP action = 'context_is_admin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_id': ''} DCNL DCSP credentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, credentials)
 DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP instead DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP def __init__(self, wrapped): DCNL DCSP  DCSP  DCSP self.wrapped = wrapped DCNL DCSP  DCSP def __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrapped(connection_host, *args, **kwargs) DCNL DCSP oldHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return oldHTTPConnection
 DCSP return compare_tree_to_dict(actual, expected, ('rel', 'href', 'type'))
 DCSP return compare_tree_to_dict(actual, expected, ('base', 'type'))
 DCSP for (elem, data) in zip(actual, expected): DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (elem.get(key) != data.get(key)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP instead DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP def __init__(self, wrapped): DCNL DCSP  DCSP  DCSP self.wrapped = wrapped DCNL DCSP  DCSP def __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrapped(connection_host, *args, **kwargs) DCNL DCSP oldHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return oldHTTPConnection
 DCSP for func in funcs: DCNL DCSP  DCSP func_name = '_'.join(func.__name__.split('_')[1:]) DCNL DCSP  DCSP stubs.Set(db, func_name, func)
 DCSP return ''.join((random.choice((string.ascii_uppercase + string.digits)) for _x in range(length)))
 DCSP return ''.join((random.choice(string.digits) for _x in range(length)))
 DCSP while True: DCNL DCSP  DCSP if numeric: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_numeric(8)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_alphanumeric(8)) DCNL DCSP  DCSP if (candidate not in items): DCNL DCSP  DCSP  DCSP return candidate DCNL DCSP  DCSP LOG.debug(('Random DCSP collision DCSP on DCSP %s' % candidate))
 DCSP global _fake_execute_repliers DCNL DCSP _fake_execute_repliers = repliers
 DCSP return ('', '')
 DCSP global _fake_execute_repliers DCNL DCSP process_input = kwargs.get('process_input', None) DCNL DCSP check_exit_code = kwargs.get('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.get('delay_on_retry', True) DCNL DCSP attempts = kwargs.get('attempts', 1) DCNL DCSP run_as_root = kwargs.get('run_as_root', False) DCNL DCSP cmd_str = ' DCSP '.join((str(part) for part in cmd_parts)) DCNL DCSP LOG.debug(_('Faking DCSP execution DCSP of DCSP cmd DCSP (subprocess): DCSP %s'), cmd_str) DCNL DCSP _fake_execute_log.append(cmd_str) DCNL DCSP reply_handler = fake_execute_default_reply_handler DCNL DCSP for fake_replier in _fake_execute_repliers: DCNL DCSP  DCSP if re.match(fake_replier[0], cmd_str): DCNL DCSP  DCSP  DCSP reply_handler = fake_replier[1] DCNL DCSP  DCSP  DCSP LOG.debug((_('Faked DCSP command DCSP matched DCSP %s') % fake_replier[0])) DCNL DCSP  DCSP  DCSP break DCNL DCSP if isinstance(reply_handler, basestring): DCNL DCSP  DCSP reply = (reply_handler, '') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reply = reply_handler(cmd_parts, process_input=process_input, delay_on_retry=delay_on_retry, attempts=attempts, run_as_root=run_as_root, check_exit_code=check_exit_code) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Faked DCSP command DCSP raised DCSP an DCSP exception DCSP %s'), e) DCNL DCSP  DCSP  DCSP raise DCNL DCSP stdout = reply[0] DCNL DCSP stderr = reply[1] DCNL DCSP LOG.debug((_("Reply DCSP to DCSP faked DCSP command DCSP is DCSP stdout='%(stdout)s' DCSP stderr='%(stderr)s'") % locals())) DCNL DCSP greenthread.sleep(0) DCNL DCSP return reply
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP CALLED_FUNCTION.append(name) DCNL DCSP  DCSP return function(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP class FakeHTTPResponse(object, ): DCNL DCSP  DCSP def read(self): DCNL DCSP  DCSP  DCSP return DATA DCNL DCSP def fake_do_request(self, *args, **kwargs): DCNL DCSP  DCSP return (httplib.OK, FakeHTTPResponse())
 DCSP if (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())
 DCSP metadata = sqlalchemy.schema.MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP return sqlalchemy.Table(name, metadata, autoload=True)
 DCSP return serialize_obj((args, kwargs))
 DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
 DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
 DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
 DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
 DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
 DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
 DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
 DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
 DCSP return _get_impl().create_connection(CONF, new=new)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().cast(CONF, context, topic, msg)
 DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
 DCSP return _get_impl().cleanup()
 DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return (('%s.%s' % (topic, host)) if host else topic)
 DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP return Connection()
 DCSP json.dumps(msg)
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
 DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
 DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
 DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
 DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
 DCSP return _multi_send(_call, *args, **kwargs)
 DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
 DCSP _multi_send(_cast, *args, **kwargs)
 DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
 DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
 DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
 DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
 DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
 DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP global _BRAIN DCNL DCSP _BRAIN = brain
 DCSP global _BRAIN DCNL DCSP _BRAIN = None
 DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_dict, credentials_dict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP def decorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.default_rule and (match != brain.default_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.default_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_dict, cred_dict)
 DCSP return (match.lower() in [x.lower() for x in cred_dict['roles']])
 DCSP url = ('http:' + (match % target_dict)) DCNL DCSP data = {'target': jsonutils.dumps(target_dict), 'credentials': jsonutils.dumps(cred_dict)} DCNL DCSP post_data = urllib.urlencode(data) DCNL DCSP f = urllib2.urlopen(url, post_data) DCNL DCSP return (f.read() == 'True')
 DCSP match = (match % target_dict) DCNL DCSP if (match_kind in cred_dict): DCNL DCSP  DCSP return (match == unicode(cred_dict[match_kind])) DCNL DCSP return False
 DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP return ((bool_from_string(subject) and 1) or 0)
 DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
 DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('cinder.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
 DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
 DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
 DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
 DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
 DCSP (out, err) = utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info', path, run_as_root=True) DCNL DCSP return QemuImgInfo(out)
 DCSP cmd = ('qemu-img', 'convert', '-O', out_format, source, dest) DCNL DCSP utils.execute(run_as_root=True, *cmd)
 DCSP url = urlparse.urlparse(image_href) DCNL DCSP port = (url.port or 80) DCNL DCSP host = url.netloc.split(':', 1)[0] DCNL DCSP image_id = url.path.split('/')[(-1)] DCNL DCSP use_ssl = (url.scheme == 'https') DCNL DCSP return (image_id, host, port, use_ssl)
 DCSP if (version is None): DCNL DCSP  DCSP version = FLAGS.glance_api_version DCNL DCSP if use_ssl: DCNL DCSP  DCSP scheme = 'https' DCNL DCSP else: DCNL DCSP  DCSP scheme = 'http' DCNL DCSP params = {} DCNL DCSP params['insecure'] = FLAGS.glance_api_insecure DCNL DCSP if (FLAGS.auth_strategy == 'keystone'): DCNL DCSP  DCSP params['token'] = context.auth_token DCNL DCSP endpoint = ('%s://%s:%s' % (scheme, host, port)) DCNL DCSP return glanceclient.Client(str(version), endpoint, **params)
 DCSP api_servers = [] DCNL DCSP for api_server in FLAGS.glance_api_servers: DCNL DCSP  DCSP if ('//' not in api_server): DCNL DCSP  DCSP  DCSP api_server = ('http://' + api_server) DCNL DCSP  DCSP url = urlparse.urlparse(api_server) DCNL DCSP  DCSP port = (url.port or 80) DCNL DCSP  DCSP host = url.netloc.split(':', 1)[0] DCNL DCSP  DCSP use_ssl = (url.scheme == 'https') DCNL DCSP  DCSP api_servers.append((host, port, use_ssl)) DCNL DCSP random.shuffle(api_servers) DCNL DCSP return itertools.cycle(api_servers)
 DCSP for attr in ['created_at', 'updated_at', 'deleted_at']: DCNL DCSP  DCSP if image_meta.get(attr): DCNL DCSP  DCSP  DCSP image_meta[attr] = timeutils.parse_isotime(image_meta[attr]) DCNL DCSP return image_meta
 DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_image_exception(image_id, exc_value) DCNL DCSP raise new_exc, None, exc_trace
 DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace
 DCSP if ('/' not in str(image_href)): DCNL DCSP  DCSP image_service = get_default_image_service() DCNL DCSP  DCSP return (image_service, image_href) DCNL DCSP try: DCNL DCSP  DCSP (image_id, glance_host, glance_port, use_ssl) = _parse_image_ref(image_href) DCNL DCSP  DCSP glance_client = GlanceClientWrapper(context=context, host=glance_host, port=glance_port, use_ssl=use_ssl) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvalidImageRef(image_href=image_href) DCNL DCSP image_service = GlanceImageService(client=glance_client) DCNL DCSP return (image_service, image_id)
 DCSP now = timeutils.utcnow() DCNL DCSP values = {'host': host, 'scheduled_at': now} DCNL DCSP return db.volume_update(context, volume_id, values)
 DCSP (begin, end) = utils.last_completed_audit_period() DCNL DCSP if current_period: DCNL DCSP  DCSP audit_start = end DCNL DCSP  DCSP audit_end = timeutils.utcnow() DCNL DCSP else: DCNL DCSP  DCSP audit_start = begin DCNL DCSP  DCSP audit_end = end DCNL DCSP extra_usage_info = dict(audit_period_beginning=str(audit_start), audit_period_ending=str(audit_end)) DCNL DCSP notify_about_volume_usage(context, volume_ref, 'exists', extra_usage_info=extra_usage_info)
 DCSP try: DCNL DCSP  DCSP type_ref = db.volume_type_create(context, dict(name=name, extra_specs=extra_specs)) DCNL DCSP except exception.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.VolumeTypeCreateFailed(name=name, extra_specs=extra_specs) DCNL DCSP return type_ref
 DCSP if (id is None): DCNL DCSP  DCSP msg = _('id DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidVolumeType(reason=msg) DCNL DCSP else: DCNL DCSP  DCSP db.volume_type_destroy(context, id)
 DCSP vol_types = db.volume_type_get_all(context, inactive) DCNL DCSP if search_opts: DCNL DCSP  DCSP LOG.debug((_('Searching DCSP by: DCSP %s') % str(search_opts))) DCNL DCSP  DCSP def _check_extra_specs_match(vol_type, searchdict): DCNL DCSP  DCSP  DCSP for (k, v) in searchdict.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if ((k not in vol_type['extra_specs'].keys()) or (vol_type['extra_specs'][k] != v)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP filter_mapping = {'extra_specs': _check_extra_specs_match} DCNL DCSP  DCSP result = {} DCNL DCSP  DCSP for (type_name, type_args) in vol_types.iteritems(): DCNL DCSP  DCSP  DCSP for (opt, values) in search_opts.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP filter_func = filter_mapping[opt] DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if filter_func(type_args, values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result[type_name] = type_args DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP vol_types = result DCNL DCSP return vol_types
 DCSP if (id is None): DCNL DCSP  DCSP msg = _('id DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidVolumeType(reason=msg) DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.volume_type_get(ctxt, id)
 DCSP if (name is None): DCNL DCSP  DCSP msg = _('name DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvalidVolumeType(reason=msg) DCNL DCSP return db.volume_type_get_by_name(context, name)
 DCSP name = FLAGS.default_volume_type DCNL DCSP vol_type = {} DCNL DCSP if (name is not None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vol_type = get_volume_type_by_name(ctxt, name) DCNL DCSP  DCSP except exception.VolumeTypeNotFoundByName as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('Default DCSP volume DCSP type DCSP is DCSP not DCSP found, DCSP please DCSP check DCSP default_volume_type DCSP config: DCSP %s'), e) DCNL DCSP return vol_type
 DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, context, target_obj, *args, **kwargs): DCNL DCSP  DCSP check_policy(context, func.__name__, target_obj) DCNL DCSP  DCSP return func(self, context, target_obj, *args, **kwargs) DCNL DCSP return wrapped
 DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.getfqdn()): DCNL DCSP  DCSP return 'nova' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
 DCSP intgr = 0 DCNL DCSP for byt in bytes: DCNL DCSP  DCSP intgr = ((intgr << 8) + _byte(byt)) DCNL DCSP return intgr
 DCSP logging.debug((_('Received DCSP machine_id DCSP from DCSP vmtools DCSP : DCSP %s') % machine_id[0])) DCNL DCSP network_details = [] DCNL DCSP if (machine_id[1].strip() == '1'): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP for machine_id_str in machine_id[0].split('#'): DCNL DCSP  DCSP  DCSP network_info_list = machine_id_str.split(';') DCNL DCSP  DCSP  DCSP if ((len(network_info_list) % 6) != 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP no_grps = (len(network_info_list) / 6) DCNL DCSP  DCSP  DCSP i = 0 DCNL DCSP  DCSP  DCSP while (i < no_grps): DCNL DCSP  DCSP  DCSP  DCSP k = (i * 6) DCNL DCSP  DCSP  DCSP  DCSP network_details.append((network_info_list[k].strip().lower(), network_info_list[(k + 1)].strip(), network_info_list[(k + 2)].strip(), network_info_list[(k + 3)].strip(), network_info_list[(k + 4)].strip(), network_info_list[(k + 5)].strip().split(','))) DCNL DCSP  DCSP  DCSP  DCSP i += 1 DCNL DCSP logging.debug((_('NIC DCSP information DCSP from DCSP vmtools DCSP : DCSP %s') % network_details)) DCNL DCSP return network_details
 DCSP import win32com.client DCNL DCSP wbem_locator = win32com.client.Dispatch('WbemScripting.SWbemLocator') DCNL DCSP wbem_service = wbem_locator.ConnectServer('.', 'root\\cimv2') DCNL DCSP wbem_network_adapters = wbem_service.InstancesOf('Win32_NetworkAdapter') DCNL DCSP network_adapters = [] DCNL DCSP for adapter in wbem_network_adapters: DCNL DCSP  DCSP if ((adapter.NetConnectionStatus == 2) or (adapter.NetConnectionStatus == 7)): DCNL DCSP  DCSP  DCSP adapter_name = adapter.NetConnectionID DCNL DCSP  DCSP  DCSP mac_address = adapter.MacAddress.lower() DCNL DCSP  DCSP  DCSP config = adapter.associators_('Win32_NetworkAdapterSetting', 'Win32_NetworkAdapterConfiguration')[0] DCNL DCSP  DCSP  DCSP ip_address = '' DCNL DCSP  DCSP  DCSP subnet_mask = '' DCNL DCSP  DCSP  DCSP if config.IPEnabled: DCNL DCSP  DCSP  DCSP  DCSP ip_address = config.IPAddress[0] DCNL DCSP  DCSP  DCSP  DCSP subnet_mask = config.IPSubnet[0] DCNL DCSP  DCSP  DCSP network_adapters.append({'name': adapter_name, 'mac-address': mac_address, 'ip-address': ip_address, 'subnet-mask': subnet_mask}) DCNL DCSP return network_adapters
 DCSP import fcntl DCNL DCSP max_bytes = 8096 DCNL DCSP arch = platform.architecture()[0] DCNL DCSP if (arch == ARCH_32_BIT): DCNL DCSP  DCSP offset1 = 32 DCNL DCSP  DCSP offset2 = 32 DCNL DCSP elif (arch == ARCH_64_BIT): DCNL DCSP  DCSP offset1 = 16 DCNL DCSP  DCSP offset2 = 40 DCNL DCSP else: DCNL DCSP  DCSP raise OSError((_('Unknown DCSP architecture: DCSP %s') % arch)) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP names = array.array('B', ('\x00' * max_bytes)) DCNL DCSP outbytes = struct.unpack('iL', fcntl.ioctl(sock.fileno(), 35090, struct.pack('iL', max_bytes, names.buffer_info()[0])))[0] DCNL DCSP adapter_names = [names.tostring()[n_cnt:(n_cnt + offset1)].split('\x00', 1)[0] for n_cnt in xrange(0, outbytes, offset2)] DCNL DCSP network_adapters = [] DCNL DCSP for adapter_name in adapter_names: DCNL DCSP  DCSP ip_address = socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 35093, struct.pack('256s', adapter_name))[20:24]) DCNL DCSP  DCSP subnet_mask = socket.inet_ntoa(fcntl.ioctl(sock.fileno(), 35099, struct.pack('256s', adapter_name))[20:24]) DCNL DCSP  DCSP raw_mac_address = ('%012x' % _bytes2int(fcntl.ioctl(sock.fileno(), 35111, struct.pack('256s', adapter_name))[18:24])) DCNL DCSP  DCSP mac_address = ':'.join([raw_mac_address[m_counter:(m_counter + 2)] for m_counter in range(0, len(raw_mac_address), 2)]).lower() DCNL DCSP  DCSP network_adapters.append({'name': adapter_name, 'mac-address': mac_address, 'ip-address': ip_address, 'subnet-mask': subnet_mask}) DCNL DCSP return network_adapters
 DCSP adapter_name = None DCNL DCSP ip_address = None DCNL DCSP for network_adapter in network_adapters: DCNL DCSP  DCSP if (network_adapter['mac-address'] == mac_address.lower()): DCNL DCSP  DCSP  DCSP adapter_name = network_adapter['name'] DCNL DCSP  DCSP  DCSP ip_address = network_adapter['ip-address'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return (adapter_name, ip_address)
 DCSP network_adapters = _get_windows_network_adapters() DCNL DCSP return _get_adapter_name_and_ip_address(network_adapters, mac_address)
 DCSP network_adapters = _get_linux_network_adapters() DCNL DCSP return _get_adapter_name_and_ip_address(network_adapters, mac_address)
 DCSP cmd = ' DCSP '.join(cmd_list) DCNL DCSP logging.debug((_("Executing DCSP command: DCSP '%s'") % cmd)) DCNL DCSP env = os.environ.copy() DCNL DCSP obj = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) DCNL DCSP result = None DCNL DCSP if (process_input is not None): DCNL DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP else: DCNL DCSP  DCSP result = obj.communicate() DCNL DCSP obj.stdin.close() DCNL DCSP if obj.returncode: DCNL DCSP  DCSP logging.debug((_('Result DCSP was DCSP %s') % obj.returncode)) DCNL DCSP  DCSP if (check_exit_code and (obj.returncode != 0)): DCNL DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=obj.returncode, stdout=stdout, stderr=stderr, cmd=cmd) DCNL DCSP time.sleep(0.1) DCNL DCSP return result
 DCSP program_files = os.environ.get('PROGRAMFILES') DCNL DCSP program_files_x86 = os.environ.get('PROGRAMFILES(X86)') DCNL DCSP vmware_tools_bin = None DCNL DCSP if os.path.exists(os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'vmtoolsd.exe')): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'vmtoolsd.exe') DCNL DCSP elif os.path.exists(os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe')): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe') DCNL DCSP elif (program_files_x86 and os.path.exists(os.path.join(program_files_x86, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe'))): DCNL DCSP  DCSP vmware_tools_bin = os.path.join(program_files_x86, 'VMware', 'VMware DCSP Tools', 'VMwareService.exe') DCNL DCSP if vmware_tools_bin: DCNL DCSP  DCSP cmd = [(('"' + vmware_tools_bin) + '"'), '--cmd', 'machine.id.get'] DCNL DCSP  DCSP for network_detail in _parse_network_details(_execute(cmd, check_exit_code=False)): DCNL DCSP  DCSP  DCSP (mac_address, ip_address, subnet_mask, gateway, broadcast, dns_servers) = network_detail DCNL DCSP  DCSP  DCSP name_and_ip = _get_win_adapter_name_and_ip_address(mac_address) DCNL DCSP  DCSP  DCSP (adapter_name, current_ip_address) = name_and_ip DCNL DCSP  DCSP  DCSP if (adapter_name and (not (ip_address == current_ip_address))): DCNL DCSP  DCSP  DCSP  DCSP cmd = ['netsh', 'interface', 'ip', 'set', 'address', ('name="%s"' % adapter_name), 'source=static', ip_address, subnet_mask, gateway, '1'] DCNL DCSP  DCSP  DCSP  DCSP _execute(cmd) DCNL DCSP  DCSP  DCSP  DCSP for dns_server in dns_servers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if dns_server: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cmd = ['netsh', 'interface', 'ip', 'add', 'dns', ('name="%s"' % adapter_name), dns_server] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _execute(cmd) DCNL DCSP else: DCNL DCSP  DCSP logging.warn(_('VMware DCSP Tools DCSP is DCSP not DCSP installed'))
 DCSP network_details = (network_details or []) DCNL DCSP all_dns_servers = [] DCNL DCSP for network_detail in network_details: DCNL DCSP  DCSP (mac_address, ip_address, subnet_mask, gateway, broadcast, dns_servers) = network_detail DCNL DCSP  DCSP all_dns_servers.extend(dns_servers) DCNL DCSP  DCSP name_and_ip = _get_linux_adapter_name_and_ip_address(mac_address) DCNL DCSP  DCSP (adapter_name, current_ip_address) = name_and_ip DCNL DCSP  DCSP if (adapter_name and (not (ip_address == current_ip_address))): DCNL DCSP  DCSP  DCSP interface_file_name = ('/etc/sysconfig/network-scripts/ifcfg-%s' % adapter_name) DCNL DCSP  DCSP  DCSP os.remove(interface_file_name) DCNL DCSP  DCSP  DCSP _execute(['touch', interface_file_name]) DCNL DCSP  DCSP  DCSP interface_file = open(interface_file_name, 'w') DCNL DCSP  DCSP  DCSP interface_file.write(('\nDEVICE=%s' % adapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write('\nUSERCTL=yes') DCNL DCSP  DCSP  DCSP interface_file.write('\nONBOOT=yes') DCNL DCSP  DCSP  DCSP interface_file.write('\nBOOTPROTO=static') DCNL DCSP  DCSP  DCSP interface_file.write(('\nBROADCAST=%s' % broadcast)) DCNL DCSP  DCSP  DCSP interface_file.write('\nNETWORK=') DCNL DCSP  DCSP  DCSP interface_file.write(('\nGATEWAY=%s' % gateway)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nNETMASK=%s' % subnet_mask)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nIPADDR=%s' % ip_address)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nMACADDR=%s' % mac_address)) DCNL DCSP  DCSP  DCSP interface_file.close() DCNL DCSP if all_dns_servers: DCNL DCSP  DCSP dns_file_name = '/etc/resolv.conf' DCNL DCSP  DCSP os.remove(dns_file_name) DCNL DCSP  DCSP _execute(['touch', dns_file_name]) DCNL DCSP  DCSP dns_file = open(dns_file_name, 'w') DCNL DCSP  DCSP dns_file.write('; DCSP generated DCSP by DCSP OpenStack DCSP guest DCSP tools') DCNL DCSP  DCSP unique_entries = _filter_duplicates(all_dns_servers) DCNL DCSP  DCSP for dns_server in unique_entries: DCNL DCSP  DCSP  DCSP dns_file.write(('\nnameserver DCSP %s' % dns_server)) DCNL DCSP  DCSP dns_file.close() DCNL DCSP _execute(['/sbin/service', 'network', 'restart'])
 DCSP network_details = (network_details or []) DCNL DCSP all_dns_servers = [] DCNL DCSP interface_file_name = '/etc/network/interfaces' DCNL DCSP os.remove(interface_file_name) DCNL DCSP _execute(['touch', interface_file_name]) DCNL DCSP interface_file = open(interface_file_name, 'w') DCNL DCSP for (device, network_detail) in enumerate(network_details): DCNL DCSP  DCSP (mac_address, ip_address, subnet_mask, gateway, broadcast, dns_servers) = network_detail DCNL DCSP  DCSP all_dns_servers.extend(dns_servers) DCNL DCSP  DCSP name_and_ip = _get_linux_adapter_name_and_ip_address(mac_address) DCNL DCSP  DCSP (adapter_name, current_ip_address) = name_and_ip DCNL DCSP  DCSP if adapter_name: DCNL DCSP  DCSP  DCSP interface_file.write(('\nauto DCSP %s' % adapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write(('\niface DCSP %s DCSP inet DCSP static' % adapter_name)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nbroadcast DCSP %s' % broadcast)) DCNL DCSP  DCSP  DCSP interface_file.write(('\ngateway DCSP %s' % gateway)) DCNL DCSP  DCSP  DCSP interface_file.write(('\nnetmask DCSP %s' % subnet_mask)) DCNL DCSP  DCSP  DCSP interface_file.write(('\naddress DCSP %s\n' % ip_address)) DCNL DCSP  DCSP logging.debug(_('Successfully DCSP configured DCSP NIC DCSP %(device)d DCSP with DCSP NIC DCSP info DCSP %(detail)s'), {'device': device, 'detail': network_detail}) DCNL DCSP interface_file.close() DCNL DCSP if all_dns_servers: DCNL DCSP  DCSP dns_file_name = '/etc/resolv.conf' DCNL DCSP  DCSP os.remove(dns_file_name) DCNL DCSP  DCSP _execute(['touch', dns_file_name]) DCNL DCSP  DCSP dns_file = open(dns_file_name, 'w') DCNL DCSP  DCSP dns_file.write('; DCSP generated DCSP by DCSP OpenStack DCSP guest DCSP tools') DCNL DCSP  DCSP unique_entries = _filter_duplicates(all_dns_servers) DCNL DCSP  DCSP for dns_server in unique_entries: DCNL DCSP  DCSP  DCSP dns_file.write(('\nnameserver DCSP %s' % dns_server)) DCNL DCSP  DCSP dns_file.close() DCNL DCSP logging.debug(_('Restarting DCSP networking....\n')) DCNL DCSP _execute(['/etc/init.d/networking', 'restart'])
 DCSP vmware_tools_bin = None DCNL DCSP if os.path.exists('/usr/sbin/vmtoolsd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/sbin/vmtoolsd' DCNL DCSP elif os.path.exists('/usr/bin/vmtoolsd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/bin/vmtoolsd' DCNL DCSP elif os.path.exists('/usr/sbin/vmware-guestd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/sbin/vmware-guestd' DCNL DCSP elif os.path.exists('/usr/bin/vmware-guestd'): DCNL DCSP  DCSP vmware_tools_bin = '/usr/bin/vmware-guestd' DCNL DCSP if vmware_tools_bin: DCNL DCSP  DCSP cmd = [vmware_tools_bin, '--cmd', 'machine.id.get'] DCNL DCSP  DCSP network_details = _parse_network_details(_execute(cmd, check_exit_code=False)) DCNL DCSP  DCSP if (platform.dist()[0] == 'Ubuntu'): DCNL DCSP  DCSP  DCSP _set_ubuntu_networking(network_details) DCNL DCSP  DCSP elif (platform.dist()[0] == 'redhat'): DCNL DCSP  DCSP  DCSP _set_rhel_networking(network_details) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logging.warn((_("Distro DCSP '%s' DCSP not DCSP supported") % platform.dist()[0])) DCNL DCSP else: DCNL DCSP  DCSP logging.warn(_('VMware DCSP Tools DCSP is DCSP not DCSP installed'))
 DCSP return xenapi._session.call_xenapi(method, *args)
 DCSP ctxt = context.get_admin_context(read_deleted='only') DCNL DCSP orphaned_instances = [] DCNL DCSP for (vm_ref, vm_rec) in _get_applicable_vm_recs(xenapi): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP uuid = vm_rec['other_config']['nova_uuid'] DCNL DCSP  DCSP  DCSP instance = db.api.instance_get_by_uuid(ctxt, uuid) DCNL DCSP  DCSP except (KeyError, exception.InstanceNotFound): DCNL DCSP  DCSP  DCSP print_xen_object('INFO: DCSP Ignoring DCSP VM', vm_rec, indent_level=0) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP is_active_and_deleting = ((instance.vm_state == 'active') and (instance.task_state == 'deleting')) DCNL DCSP  DCSP is_zombie_vm = ((instance.vm_state != 'active') and timeutils.is_older_than(instance.updated_at, CONF.zombie_instance_updated_at_window)) DCNL DCSP  DCSP if (is_active_and_deleting or is_zombie_vm): DCNL DCSP  DCSP  DCSP orphaned_instances.append((vm_ref, vm_rec, instance)) DCNL DCSP return orphaned_instances
 DCSP xenapi._vmops._destroy(instance, vm_ref)
 DCSP for vm_ref in call_xenapi(xenapi, 'VM.get_all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vm_rec = call_xenapi(xenapi, 'VM.get_record', vm_ref) DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (vm_rec['is_a_template'] or vm_rec['is_control_domain']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (yield (vm_ref, vm_rec))
 DCSP if (not CONF.verbose): DCNL DCSP  DCSP return DCNL DCSP uuid = obj['uuid'] DCNL DCSP try: DCNL DCSP  DCSP name_label = obj['name_label'] DCNL DCSP except KeyError: DCNL DCSP  DCSP name_label = '' DCNL DCSP msg = ("%(obj_type)s DCSP (%(uuid)s) DCSP '%(name_label)s'" % locals()) DCNL DCSP indent = ((' DCSP ' * spaces_per_indent) * indent_level) DCNL DCSP print ''.join([indent, msg])
 DCSP def _is_null_ref(ref): DCNL DCSP  DCSP return (ref == 'OpaqueRef:NULL') DCNL DCSP def _add_vdi_and_parents_to_connected(vdi_rec, indent_level): DCNL DCSP  DCSP indent_level += 1 DCNL DCSP  DCSP vdi_and_parent_uuids = [] DCNL DCSP  DCSP cur_vdi_rec = vdi_rec DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP cur_vdi_uuid = cur_vdi_rec['uuid'] DCNL DCSP  DCSP  DCSP print_xen_object('VDI', vdi_rec, indent_level=indent_level) DCNL DCSP  DCSP  DCSP connected_vdi_uuids.add(cur_vdi_uuid) DCNL DCSP  DCSP  DCSP vdi_and_parent_uuids.append(cur_vdi_uuid) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parent_vdi_uuid = vdi_rec['sm_config']['vhd-parent'] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP parent_vdi_uuid = None DCNL DCSP  DCSP  DCSP if (parent_vdi_uuid and (parent_vdi_uuid != cur_vdi_uuid)): DCNL DCSP  DCSP  DCSP  DCSP indent_level += 1 DCNL DCSP  DCSP  DCSP  DCSP cur_vdi_ref = call_xenapi(xenapi, 'VDI.get_by_uuid', parent_vdi_uuid) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cur_vdi_rec = call_xenapi(xenapi, 'VDI.get_record', cur_vdi_ref) DCNL DCSP  DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP for (vm_ref, vm_rec) in _get_applicable_vm_recs(xenapi): DCNL DCSP  DCSP indent_level = 0 DCNL DCSP  DCSP print_xen_object('VM', vm_rec, indent_level=indent_level) DCNL DCSP  DCSP vbd_refs = vm_rec['VBDs'] DCNL DCSP  DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vbd_rec = call_xenapi(xenapi, 'VBD.get_record', vbd_ref) DCNL DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP indent_level = 1 DCNL DCSP  DCSP  DCSP print_xen_object('VBD', vbd_rec, indent_level=indent_level) DCNL DCSP  DCSP  DCSP vbd_vdi_ref = vbd_rec['VDI'] DCNL DCSP  DCSP  DCSP if _is_null_ref(vbd_vdi_ref): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vdi_rec = call_xenapi(xenapi, 'VDI.get_record', vbd_vdi_ref) DCNL DCSP  DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP _add_vdi_and_parents_to_connected(vdi_rec, indent_level)
 DCSP def _system_owned(vdi_rec): DCNL DCSP  DCSP vdi_name = vdi_rec['name_label'] DCNL DCSP  DCSP return (vdi_name.startswith('USB') or vdi_name.endswith('.iso') or (vdi_rec['type'] == 'system')) DCNL DCSP for vdi_ref in call_xenapi(xenapi, 'VDI.get_all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vdi_rec = call_xenapi(xenapi, 'VDI.get_record', vdi_ref) DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP vdi_uuid = vdi_rec['uuid'] DCNL DCSP  DCSP all_vdi_uuids.add(vdi_uuid) DCNL DCSP  DCSP if _system_owned(vdi_rec): DCNL DCSP  DCSP  DCSP print_xen_object('SYSTEM DCSP VDI', vdi_rec, indent_level=0) DCNL DCSP  DCSP  DCSP connected_vdi_uuids.add(vdi_uuid) DCNL DCSP  DCSP elif (not vdi_rec['managed']): DCNL DCSP  DCSP  DCSP print_xen_object('UNMANAGED DCSP VDI', vdi_rec, indent_level=0) DCNL DCSP  DCSP  DCSP connected_vdi_uuids.add(vdi_uuid)
 DCSP connected_vdi_uuids = set() DCNL DCSP _find_vdis_connected_to_vm(xenapi, connected_vdi_uuids) DCNL DCSP all_vdi_uuids = set() DCNL DCSP _find_all_vdis_and_system_vdis(xenapi, all_vdi_uuids, connected_vdi_uuids) DCNL DCSP orphaned_vdi_uuids = (all_vdi_uuids - connected_vdi_uuids) DCNL DCSP return orphaned_vdi_uuids
 DCSP for vdi_uuid in vdi_uuids: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('ORPHANED DCSP VDI DCSP (%s)' % vdi_uuid) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print vdi_uuid
 DCSP for vdi_uuid in vdi_uuids: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('CLEANING DCSP VDI DCSP (%s)' % vdi_uuid) DCNL DCSP  DCSP vdi_ref = call_xenapi(xenapi, 'VDI.get_by_uuid', vdi_uuid) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP call_xenapi(xenapi, 'VDI.destroy', vdi_ref) DCNL DCSP  DCSP except XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Skipping DCSP %s: DCSP %s' % (vdi_uuid, exc))
 DCSP for (vm_ref, vm_rec, orphaned_instance) in orphaned_instances: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('ORPHANED DCSP INSTANCE DCSP (%s)' % orphaned_instance.name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print orphaned_instance.name
 DCSP for (vm_ref, vm_rec, instance) in orphaned_instances: DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print ('CLEANING DCSP INSTANCE DCSP (%s)' % instance.name) DCNL DCSP  DCSP cleanup_instance(xenapi, instance, vm_ref, vm_rec)
 DCSP args = CONF(args=sys.argv[1:], usage=(('%(prog)s DCSP [options] DCSP --command={' + '|'.join(ALLOWED_COMMANDS)) + '}')) DCNL DCSP command = CONF.command DCNL DCSP if ((not command) or (command not in ALLOWED_COMMANDS)): DCNL DCSP  DCSP CONF.print_usage() DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if (CONF.zombie_instance_updated_at_window < CONF.resize_confirm_window): DCNL DCSP  DCSP raise Exception('`zombie_instance_updated_at_window` DCSP has DCSP to DCSP be DCSP longer DCSP than DCSP `resize_confirm_window`.') DCNL DCSP xenapi = xenapi_driver.XenAPIDriver(virtapi.VirtAPI()) DCNL DCSP if (command == 'list-vdis'): DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print 'Connected DCSP VDIs:\n' DCNL DCSP  DCSP orphaned_vdi_uuids = find_orphaned_vdi_uuids(xenapi) DCNL DCSP  DCSP if CONF.verbose: DCNL DCSP  DCSP  DCSP print '\nOrphaned DCSP VDIs:\n' DCNL DCSP  DCSP list_orphaned_vdis(orphaned_vdi_uuids) DCNL DCSP elif (command == 'clean-vdis'): DCNL DCSP  DCSP orphaned_vdi_uuids = find_orphaned_vdi_uuids(xenapi) DCNL DCSP  DCSP clean_orphaned_vdis(xenapi, orphaned_vdi_uuids) DCNL DCSP elif (command == 'list-instances'): DCNL DCSP  DCSP orphaned_instances = find_orphaned_instances(xenapi) DCNL DCSP  DCSP list_orphaned_instances(orphaned_instances) DCNL DCSP elif (command == 'clean-instances'): DCNL DCSP  DCSP orphaned_instances = find_orphaned_instances(xenapi) DCNL DCSP  DCSP clean_orphaned_instances(xenapi, orphaned_instances) DCNL DCSP elif (command == 'test'): DCNL DCSP  DCSP doctest.testmod() DCNL DCSP else: DCNL DCSP  DCSP print ("Unknown DCSP command DCSP '%s'" % command) DCNL DCSP  DCSP sys.exit(1)
 DCSP basename = os.path.basename(filename) DCNL DCSP return any((pep8.filename_match(filename, self.options.exclude, default=False), pep8.filename_match(basename, self.options.exclude, default=False)))
 DCSP dirname = dirname.rstrip('/') DCNL DCSP if self.excluded(dirname): DCNL DCSP  DCSP return 0 DCNL DCSP counters = self.options.report.counters DCNL DCSP verbose = self.options.verbose DCNL DCSP filepatterns = self.options.filename DCNL DCSP runner = self.runner DCNL DCSP for (root, dirs, files) in os.walk(dirname): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print ('directory DCSP ' + root) DCNL DCSP  DCSP counters['directories'] += 1 DCNL DCSP  DCSP for subdir in sorted(dirs): DCNL DCSP  DCSP  DCSP if self.excluded(os.path.join(root, subdir)): DCNL DCSP  DCSP  DCSP  DCSP dirs.remove(subdir) DCNL DCSP  DCSP for filename in sorted(files): DCNL DCSP  DCSP  DCSP if (pep8.filename_match(filename, filepatterns) and (not self.excluded(filename))): DCNL DCSP  DCSP  DCSP  DCSP runner(os.path.join(root, filename))
 DCSP pos = physical_line.find('TODO') DCNL DCSP pos1 = physical_line.find('TODO(') DCNL DCSP pos2 = physical_line.find('#') DCNL DCSP if ((pos != pos1) and (pos2 >= 0) and (pos2 < pos) and (len(tokens) == 0)): DCNL DCSP  DCSP return (pos, 'N101: DCSP Use DCSP TODO(NAME)')
 DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yield (6, "N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
 DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yield (1, 'N202: DCSP assertRaises DCSP Exception DCSP too DCSP broad'))
 DCSP def is_module_for_sure(mod, search_path=sys.path): DCNL DCSP  DCSP mod = mod.replace('(', '') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mod_name = mod DCNL DCSP  DCSP  DCSP while ('.' in mod_name): DCNL DCSP  DCSP  DCSP  DCSP (pack_name, _sep, mod_name) = mod.partition('.') DCNL DCSP  DCSP  DCSP  DCSP (f, p, d) = imp.find_module(pack_name, search_path) DCNL DCSP  DCSP  DCSP  DCSP search_path = [p] DCNL DCSP  DCSP  DCSP imp.find_module(mod_name, search_path) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP module = __import__(mod) DCNL DCSP  DCSP  DCSP except ImportError as exc: DCNL DCSP  DCSP  DCSP  DCSP missing = str(exc).split()[(-1)] DCNL DCSP  DCSP  DCSP  DCSP if ((missing != mod.split('.')[(-1)]) or ('cannot DCSP import' in str(exc))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.add(missing) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP def is_module(mod): DCNL DCSP  DCSP 'Checks DCSP for DCSP non DCSP module DCSP imports.' DCNL DCSP  DCSP if (mod in modules_cache): DCNL DCSP  DCSP  DCSP return modules_cache[mod] DCNL DCSP  DCSP res = is_module_for_sure(mod) DCNL DCSP  DCSP modules_cache[mod] = res DCNL DCSP  DCSP return res DCNL DCSP current_path = os.path.dirname(pep8.current_file) DCNL DCSP current_mod = os.path.basename(pep8.current_file) DCNL DCSP if (current_mod[(-3):] == '.py'): DCNL DCSP  DCSP current_mod = current_mod[:(-3)] DCNL DCSP split_line = logical_line.split() DCNL DCSP split_line_len = len(split_line) DCNL DCSP if ((split_line[0] in ('import', 'from')) and (split_line_len > 1) and (not is_import_exception(split_line[1]))): DCNL DCSP  DCSP pos = logical_line.find(',') DCNL DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP if (split_line[0] == 'from'): DCNL DCSP  DCSP  DCSP  DCSP (yield (pos, 'N301: DCSP one DCSP import DCSP per DCSP line')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP pos = logical_line.find('*') DCNL DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP (yield (pos, 'N303: DCSP No DCSP wildcard DCSP (*) DCSP import.')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((split_line_len in (2, 4, 6)) and (split_line[1] != '__future__')): DCNL DCSP  DCSP  DCSP if (('from' == split_line[0]) and (split_line_len > 3)): DCNL DCSP  DCSP  DCSP  DCSP mod = '.'.join((split_line[1], split_line[3])) DCNL DCSP  DCSP  DCSP  DCSP if is_import_exception(mod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if RE_RELATIVE_IMPORT.search(logical_line): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (logical_line.find('.'), ("N304: DCSP No DCSP relative DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP if (not is_module(mod)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (0, ("N302: DCSP import DCSP only DCSP modules.'%s' DCSP does DCSP not DCSP import DCSP a DCSP module" % logical_line))) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP mod = split_line[1] DCNL DCSP  DCSP if ((current_mod != mod) and (not is_module(mod)) and is_module_for_sure(mod, [current_path])): DCNL DCSP  DCSP  DCSP (yield (0, ("N304: DCSP No DCSP relative DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)))
 DCSP split_line = import_normalize(logical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(previous_logical.strip()).lower().split() DCNL DCSP if ((blank_lines < 1) and (indent_level == previous_indent_level)): DCNL DCSP  DCSP length = [2, 4] DCNL DCSP  DCSP if ((len(split_line) in length) and (len(split_previous) in length) and (split_line[0] == 'import') and (split_previous[0] == 'import')): DCNL DCSP  DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP  DCSP (yield (0, ('N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP order DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1]))))
 DCSP if (('nova/virt' in filename) and (not filename.endswith('fake.py'))): DCNL DCSP  DCSP if logical_line.startswith('from DCSP nova DCSP import DCSP db'): DCNL DCSP  DCSP  DCSP (yield (0, 'N307: DCSP nova.db DCSP import DCSP not DCSP allowed DCSP in DCSP nova/virt/*'))
 DCSP line = physical_line.lstrip() DCNL DCSP start = max([line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP end = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP if (previous_logical.startswith('def DCSP ') or previous_logical.startswith('class DCSP ')): DCNL DCSP  DCSP if (start is 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (end and (start in ((-1), (len(line) - 4))))
 DCSP if (physical_line.find('N401: DCSP def DCSP foo()') != (-1)): DCNL DCSP  DCSP return DCNL DCSP if is_docstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([physical_line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'N401: DCSP docstring DCSP should DCSP not DCSP start DCSP with DCSP a DCSP space')
 DCSP line = physical_line.lstrip() DCNL DCSP if is_docstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP end = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if ((pos != (-1)) and end and (len(line) > (pos + 4))): DCNL DCSP  DCSP  DCSP if (line[(-5)] not in ['.', '?', '!']): DCNL DCSP  DCSP  DCSP  DCSP return (pos, 'N402: DCSP one DCSP line DCSP docstring DCSP needs DCSP punctuation.')
 DCSP ops = [t for (t, _, _, _, _) in tokens if (t == tokenize.OP)] DCNL DCSP if (is_docstring(physical_line, previous_logical) and (len(tokens) > 0) and (len(ops) == 0)): DCNL DCSP  DCSP pos = max((physical_line.find(i) for i in END_DOCSTRING_TRIPLE)) DCNL DCSP  DCSP if (physical_line.strip() not in START_DOCSTRING_TRIPLE): DCNL DCSP  DCSP  DCSP return (pos, 'N403: DCSP multi DCSP line DCSP docstring DCSP end DCSP on DCSP new DCSP line')
 DCSP if is_docstring(physical_line, previous_logical): DCNL DCSP  DCSP pos = max([physical_line.find(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP  DCSP if ((len(tokens) == 0) and (pos != (-1)) and (len(physical_line) == (pos + 4))): DCNL DCSP  DCSP  DCSP if (physical_line.strip() in START_DOCSTRING_TRIPLE): DCNL DCSP  DCSP  DCSP  DCSP return (pos, 'N404: DCSP multi DCSP line DCSP docstring DCSP should DCSP start DCSP with DCSP a DCSP summary')
 DCSP pos = physical_line.find('\r') DCNL DCSP if ((pos != (-1)) and (pos == (len(physical_line) - 2))): DCNL DCSP  DCSP return (pos, 'N901: DCSP Windows DCSP style DCSP line DCSP endings DCSP not DCSP allowed DCSP in DCSP code')
 DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, line) = (yield) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) and (text == '_') and (not line.startswith('def DCSP _(msg):'))): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N701: DCSP Invalid DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Formatting DCSP operation DCSP should DCSP be DCSP outside DCSP of DCSP localization DCSP method DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP instead DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.findall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) and spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'N703: DCSP Multiple DCSP positional DCSP placeholders')
 DCSP gen = check_i18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.send, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yield e.args)
 DCSP split_line = logical_line.split() DCNL DCSP if ((len(split_line) == 5) and (split_line[0] == 'if') and (split_line[1] == 'not') and (split_line[3] == 'is')): DCNL DCSP  DCSP (yield (logical_line.find('not'), "N901: DCSP Use DCSP the DCSP 'is DCSP not' DCSP operator DCSP for DCSP when DCSP testing DCSP for DCSP unequal DCSP identities"))
 DCSP split_line = logical_line.split() DCNL DCSP if ((len(split_line) == 5) and (split_line[0] == 'if') and (split_line[1] == 'not') and (split_line[3] == 'in') and (not split_line[2].startswith('('))): DCNL DCSP  DCSP (yield (logical_line.find('not'), "N902: DCSP Use DCSP the DCSP 'not DCSP in' DCSP operator DCSP for DCSP collection DCSP membership DCSP evaluation"))
 DCSP pep8.current_file = filename DCNL DCSP return open(filename).readlines()
 DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args and name.startswith('nova')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
 DCSP subp = subprocess.Popen(['git', 'log', '--no-merges', '--pretty=%s', '-1'], stdout=subprocess.PIPE) DCNL DCSP title = subp.communicate()[0] DCNL DCSP if subp.returncode: DCNL DCSP  DCSP raise Exception(('git DCSP log DCSP failed DCSP with DCSP code DCSP %s' % subp.returncode)) DCNL DCSP git_keywords = '(I[0-9a-f]{8,40})|([Bb]ug|[Ll][Pp])[\\s\\#:]*(\\d+)|([Bb]lue[Pp]rint|[Bb][Pp])[\\s\\#:]*([A-Za-z0-9\\-]+)' DCNL DCSP GIT_REGEX = re.compile(git_keywords) DCNL DCSP error = False DCNL DCSP if ((GIT_REGEX.search(title) is not None) and (len(title.split()) <= 3)): DCNL DCSP  DCSP print ("N801: DCSP git DCSP commit DCSP title DCSP ('%s') DCSP should DCSP provide DCSP an DCSP accurate DCSP description DCSP of DCSP the DCSP change, DCSP not DCSP just DCSP a DCSP reference DCSP to DCSP a DCSP bug DCSP or DCSP blueprint" % title.strip()) DCNL DCSP  DCSP error = True DCNL DCSP if (len(title.decode('utf-8')) > 72): DCNL DCSP  DCSP print ("N802: DCSP git DCSP commit DCSP title DCSP ('%s') DCSP should DCSP be DCSP under DCSP 50 DCSP chars" % title.strip()) DCNL DCSP  DCSP error = True DCNL DCSP return error
 DCSP enabled_services = db.service_get_all(context, False) DCNL DCSP disabled_services = db.service_get_all(context, True) DCNL DCSP enabled_services = set_availability_zones(context, enabled_services) DCNL DCSP disabled_services = set_availability_zones(context, disabled_services) DCNL DCSP available_zones = [] DCNL DCSP for zone in [service['availability_zone'] for service in enabled_services]: DCNL DCSP  DCSP if (zone not in available_zones): DCNL DCSP  DCSP  DCSP available_zones.append(zone) DCNL DCSP not_available_zones = [] DCNL DCSP zones = [service['availability_zone'] for service in disabled_services if (service['availability_zone'] not in available_zones)] DCNL DCSP for zone in zones: DCNL DCSP  DCSP if (zone not in not_available_zones): DCNL DCSP  DCSP  DCSP not_available_zones.append(zone) DCNL DCSP return (available_zones, not_available_zones)
 DCSP return dict(((k, v) for (k, v) in original.iteritems() if (not ('_pass' in k))))
 DCSP def inner(f): DCNL DCSP  DCSP def wrapped(self, context, *args, **kw): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(self, context, *args, **kw) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if notifier: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payload = dict(exception=e) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP call_dict = safe_utils.getcallargs(f, *args, **kw) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleansed = _cleanse_dict(call_dict) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payload.update({'args': cleansed}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_level = level DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not temp_level): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_level = notifier.ERROR DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_type = event_type DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not temp_type): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP temp_type = f.__name__ DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP notifier.notify(context, publisher_id, temp_type, temp_level, payload) DCNL DCSP  DCSP return functools.wraps(f)(wrapped) DCNL DCSP return inner
 DCSP if (not validate_str()(val)): DCNL DCSP  DCSP return False DCNL DCSP return (VALIDATE_PATH_RE.match(val).end() == len(val))
 DCSP try: DCNL DCSP  DCSP user_data = base64.b64decode(user_data) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP for key in validator: DCNL DCSP  DCSP if (key not in args): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP f = validator[key] DCNL DCSP  DCSP assert callable(f) DCNL DCSP  DCSP if (not f(args[key])): DCNL DCSP  DCSP  DCSP LOG.debug(_('%(key)s DCSP with DCSP value DCSP %(value)s DCSP failed DCSP validator DCSP %(name)s'), {'key': key, 'value': args[key], 'name': f.__name__}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP password = (password or '') DCNL DCSP meta = {} DCNL DCSP for i in xrange(CHUNKS): DCNL DCSP  DCSP meta[('password_%d' % i)] = password[:CHUNK_LENGTH] DCNL DCSP  DCSP password = password[CHUNK_LENGTH:] DCNL DCSP return meta
 DCSP if (image_type == 'kernel'): DCNL DCSP  DCSP return 'aki' DCNL DCSP if (image_type == 'ramdisk'): DCNL DCSP  DCSP return 'ari' DCNL DCSP if (image_type not in ['aki', 'ari']): DCNL DCSP  DCSP return 'ami' DCNL DCSP return image_type
 DCSP return db.s3_image_get(context, image_id)['uuid']
 DCSP if (glance_id is None): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP return db.s3_image_get_by_uuid(context, glance_id)['id'] DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP return db.s3_image_create(context, glance_id)['id']
 DCSP try: DCNL DCSP  DCSP return int(ec2_id.split('-')[(-1)], 16) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvalidEc2Id(ec2_id=ec2_id)
 DCSP template = (image_type + '-%08x') DCNL DCSP try: DCNL DCSP  DCSP return id_to_ec2_id(image_id, template=template) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 'ami-00000000'
 DCSP info_cache = (instance['info_cache'] or {}) DCNL DCSP cached_nwinfo = info_cache.get('network_info') DCNL DCSP if (not cached_nwinfo): DCNL DCSP  DCSP cached_nwinfo = [] DCNL DCSP nw_info = network_model.NetworkInfo.hydrate(cached_nwinfo) DCNL DCSP return get_ip_info_for_instance_from_nw_info(nw_info)
 DCSP return (template % int(instance_id))
 DCSP if (instance_id is None): DCNL DCSP  DCSP return None DCNL DCSP elif uuidutils.is_uuid_like(instance_id): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP int_id = get_int_id_from_instance_uuid(ctxt, instance_id) DCNL DCSP  DCSP return id_to_ec2_id(int_id) DCNL DCSP else: DCNL DCSP  DCSP return id_to_ec2_id(instance_id)
 DCSP int_id = ec2_id_to_id(ec2_id) DCNL DCSP return get_instance_uuid_from_int_id(context, int_id)
 DCSP if uuidutils.is_uuid_like(snapshot_id): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP int_id = get_int_id_from_snapshot_uuid(ctxt, snapshot_id) DCNL DCSP  DCSP return id_to_ec2_id(int_id, 'snap-%08x') DCNL DCSP else: DCNL DCSP  DCSP return id_to_ec2_id(snapshot_id, 'snap-%08x')
 DCSP if uuidutils.is_uuid_like(volume_id): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP  DCSP int_id = get_int_id_from_volume_uuid(ctxt, volume_id) DCNL DCSP  DCSP return id_to_ec2_id(int_id, 'vol-%08x') DCNL DCSP else: DCNL DCSP  DCSP return id_to_ec2_id(volume_id, 'vol-%08x')
 DCSP ctxt = context.get_admin_context() DCNL DCSP int_id = ec2_id_to_id(ec2_id) DCNL DCSP return get_volume_uuid_from_int_id(ctxt, int_id)
 DCSP query_time = None DCNL DCSP timestamp = request.get('Timestamp') DCNL DCSP expiry_time = request.get('Expires') DCNL DCSP def parse_strtime(strtime): DCNL DCSP  DCSP if _ms_time_regex.match(strtime): DCNL DCSP  DCSP  DCSP time_format = '%Y-%m-%dT%H:%M:%S.%fZ' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time_format = '%Y-%m-%dT%H:%M:%SZ' DCNL DCSP  DCSP return timeutils.parse_strtime(strtime, time_format) DCNL DCSP try: DCNL DCSP  DCSP if (timestamp and expiry_time): DCNL DCSP  DCSP  DCSP msg = _('Request DCSP must DCSP include DCSP either DCSP Timestamp DCSP or DCSP Expires, DCSP but DCSP cannot DCSP contain DCSP both') DCNL DCSP  DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP  DCSP raise exception.InvalidRequest(msg) DCNL DCSP  DCSP elif expiry_time: DCNL DCSP  DCSP  DCSP query_time = parse_strtime(expiry_time) DCNL DCSP  DCSP  DCSP return timeutils.is_older_than(query_time, (-1)) DCNL DCSP  DCSP elif timestamp: DCNL DCSP  DCSP  DCSP query_time = parse_strtime(timestamp) DCNL DCSP  DCSP  DCSP if (query_time and expires): DCNL DCSP  DCSP  DCSP  DCSP return (timeutils.is_older_than(query_time, expires) or timeutils.is_newer_than(query_time, expires)) DCNL DCSP  DCSP return False DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.audit(_('Timestamp DCSP is DCSP invalid.')) DCNL DCSP  DCSP return True
 DCSP ctxt = context.get_admin_context() DCNL DCSP int_id = ec2_id_to_id(ec2_id) DCNL DCSP return get_snapshot_uuid_from_int_id(ctxt, int_id)
 DCSP def _negative_zero(value): DCNL DCSP  DCSP epsilon = 1e-07 DCNL DCSP  DCSP return (0 if (abs(value) < epsilon) else value) DCNL DCSP if (len(value) == 0): DCNL DCSP  DCSP return '' DCNL DCSP if (value == 'None'): DCNL DCSP  DCSP return None DCNL DCSP lowered_value = value.lower() DCNL DCSP if (lowered_value == 'true'): DCNL DCSP  DCSP return True DCNL DCSP if (lowered_value == 'false'): DCNL DCSP  DCSP return False DCNL DCSP for (prefix, base) in [('0x', 16), ('0b', 2), ('0', 8), ('', 10)]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if lowered_value.startswith((prefix, ('-' + prefix))): DCNL DCSP  DCSP  DCSP  DCSP return int(lowered_value, base) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return _negative_zero(float(value)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value
 DCSP args = {} DCNL DCSP for (key, value) in items: DCNL DCSP  DCSP parts = key.split('.') DCNL DCSP  DCSP key = str(camelcase_to_underscore(parts[0])) DCNL DCSP  DCSP if (isinstance(value, str) or isinstance(value, unicode)): DCNL DCSP  DCSP  DCSP value = _try_convert(value) DCNL DCSP  DCSP  DCSP if (len(parts) > 1): DCNL DCSP  DCSP  DCSP  DCSP d = args.get(key, {}) DCNL DCSP  DCSP  DCSP  DCSP args[key] = d DCNL DCSP  DCSP  DCSP  DCSP for k in parts[1:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP k = camelcase_to_underscore(k) DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = d.get(k, {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP d[k] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = v DCNL DCSP  DCSP  DCSP  DCSP d[camelcase_to_underscore(parts[(-1)])] = value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args[key] = value DCNL DCSP return args
 DCSP LOG.error((_('%(code)s: DCSP %(message)s') % locals())) DCNL DCSP resp = webob.Response() DCNL DCSP resp.status = 400 DCNL DCSP resp.headers['Content-Type'] = 'text/xml' DCNL DCSP resp.body = str(('<?xml DCSP version="1.0"?>\n<Response><Errors><Error><Code>%s</Code><Message>%s</Message></Error></Errors><RequestID>%s</RequestID></Response>' % (utils.xhtml_escape(utils.utf8(code)), utils.xhtml_escape(utils.utf8(message)), utils.xhtml_escape(utils.utf8(request_id))))) DCNL DCSP return resp
 DCSP name = _STATE_DESCRIPTION_MAP.get(vm_state, vm_state) DCNL DCSP return {'code': inst_state.name_to_code(name), 'name': name}
 DCSP ebs = bdm.pop('ebs', None) DCNL DCSP if ebs: DCNL DCSP  DCSP ec2_id = ebs.pop('snapshot_id', None) DCNL DCSP  DCSP if ec2_id: DCNL DCSP  DCSP  DCSP if ec2_id.startswith('snap-'): DCNL DCSP  DCSP  DCSP  DCSP bdm['snapshot_id'] = ec2utils.ec2_snap_id_to_uuid(ec2_id) DCNL DCSP  DCSP  DCSP elif ec2_id.startswith('vol-'): DCNL DCSP  DCSP  DCSP  DCSP bdm['volume_id'] = ec2utils.ec2_vol_id_to_uuid(ec2_id) DCNL DCSP  DCSP  DCSP ebs.setdefault('delete_on_termination', True) DCNL DCSP  DCSP bdm.update(ebs) DCNL DCSP return bdm
 DCSP keys = (('deviceName', 'device_name'), ('virtualName', 'virtual_name')) DCNL DCSP item = {} DCNL DCSP for (name, k) in keys: DCNL DCSP  DCSP if (k in bdm): DCNL DCSP  DCSP  DCSP item[name] = bdm[k] DCNL DCSP if bdm.get('no_device'): DCNL DCSP  DCSP item['noDevice'] = True DCNL DCSP if (('snapshot_id' in bdm) or ('volume_id' in bdm)): DCNL DCSP  DCSP ebs_keys = (('snapshotId', 'snapshot_id'), ('snapshotId', 'volume_id'), ('volumeSize', 'volume_size'), ('deleteOnTermination', 'delete_on_termination')) DCNL DCSP  DCSP ebs = {} DCNL DCSP  DCSP for (name, k) in ebs_keys: DCNL DCSP  DCSP  DCSP if (k in bdm): DCNL DCSP  DCSP  DCSP  DCSP if (k == 'snapshot_id'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = ec2utils.id_to_ec2_snap_id(bdm[k]) DCNL DCSP  DCSP  DCSP  DCSP elif (k == 'volume_id'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = ec2utils.id_to_ec2_vol_id(bdm[k]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ebs[name] = bdm[k] DCNL DCSP  DCSP assert ('snapshotId' in ebs) DCNL DCSP  DCSP item['ebs'] = ebs DCNL DCSP return item
 DCSP mappings = [{'virtualName': m['virtual'], 'deviceName': m['device']} for m in _properties_get_mappings(properties) if block_device.is_swap_or_ephemeral(m['virtual'])] DCNL DCSP block_device_mapping = [_format_block_device_mapping(bdm) for bdm in properties.get('block_device_mapping', [])] DCNL DCSP for bdm in block_device_mapping: DCNL DCSP  DCSP for i in range(len(mappings)): DCNL DCSP  DCSP  DCSP if (bdm['deviceName'] == mappings[i]['deviceName']): DCNL DCSP  DCSP  DCSP  DCSP del mappings[i] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP mappings.append(bdm) DCNL DCSP mappings = [bdm for bdm in mappings if (not bdm.get('noDevice', False))] DCNL DCSP if mappings: DCNL DCSP  DCSP result['blockDeviceMapping'] = mappings
 DCSP return (datetimeobj.strftime('%Y-%m-%dT%H:%M:%S.%f')[:(-3)] + 'Z')
 DCSP pipeline = local_conf[CONF.auth_strategy] DCNL DCSP if (not CONF.api_rate_limit): DCNL DCSP  DCSP limit_name = (CONF.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
 DCSP def wrapped(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP  DCSP except webob.exc.HTTPException: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError() DCNL DCSP return wrapped
 DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
 DCSP task_map = _STATE_MAP.get(vm_state, dict(default='UNKNOWN')) DCNL DCSP status = task_map.get(task_state, task_map['default']) DCNL DCSP if (status == 'UNKNOWN'): DCNL DCSP  DCSP LOG.error((_('status DCSP is DCSP UNKNOWN DCSP from DCSP vm_state=%(vm_state)s DCSP task_state=%(task_state)s. DCSP Bad DCSP upgrade DCSP or DCSP db DCSP corrupted?') % locals())) DCNL DCSP return status
 DCSP for (state, task_map) in _STATE_MAP.iteritems(): DCNL DCSP  DCSP status_string = task_map.get('default') DCNL DCSP  DCSP if (status.lower() == status_string.lower()): DCNL DCSP  DCSP  DCSP return state
 DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
 DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
 DCSP return request.GET['marker']
 DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
 DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP limit = min(max_limit, limit) DCNL DCSP marker = params.get('marker') DCNL DCSP return (limit, marker)
 DCSP (limit, marker) = get_limit_and_marker(request, max_limit) DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
 DCSP return urlparse.urlsplit(('%s' % href)).path.split('/')[(-1)]
 DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
 DCSP nw_info = compute_utils.get_nw_info_for_instance(instance) DCNL DCSP return get_networks_for_instance_from_nw_info(nw_info)
 DCSP attr = exc.kwargs.get('attr') DCNL DCSP state = exc.kwargs.get('state') DCNL DCSP if (attr and state): DCNL DCSP  DCSP msg = _("Cannot DCSP '%(action)s' DCSP while DCSP instance DCSP is DCSP in DCSP %(attr)s DCSP %(state)s") DCNL DCSP else: DCNL DCSP  DCSP msg = _("Instance DCSP is DCSP in DCSP an DCSP invalid DCSP state DCSP for DCSP '%(action)s'") DCNL DCSP raise webob.exc.HTTPConflict(explanation=(msg % locals()))
 DCSP return list(obj.items())
 DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
 DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
 DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
 DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except (sax.SAXParseException, ValueError, expat.ExpatError, LookupError) as e: DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=str(e))
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
 DCSP dom = xmlutil.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
 DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
 DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
 DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
 DCSP pool = cons['pool'] DCNL DCSP info = {'id': cons['id'], 'console_type': pool['console_type']} DCNL DCSP return dict(console=info)
 DCSP pool = cons['pool'] DCNL DCSP info = {'id': cons['id'], 'console_type': pool['console_type'], 'password': cons['password'], 'instance_name': cons['instance_name'], 'port': cons['port'], 'host': pool['public_hostname']} DCNL DCSP return dict(console=info)
 DCSP d = _translate_volume_summary_view(context, vol) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availabilityZone'] = vol['availability_zone'] DCNL DCSP d['createdAt'] = vol['created_at'] DCNL DCSP if (vol['attach_status'] == 'attached'): DCNL DCSP  DCSP d['attachments'] = [_translate_attachment_detail_view(vol['id'], vol['instance_uuid'], vol['mountpoint'])] DCNL DCSP else: DCNL DCSP  DCSP d['attachments'] = [{}] DCNL DCSP d['displayName'] = vol['display_name'] DCNL DCSP d['displayDescription'] = vol['display_description'] DCNL DCSP if (vol['volume_type_id'] and vol.get('volume_type')): DCNL DCSP  DCSP d['volumeType'] = vol['volume_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['volumeType'] = vol['volume_type_id'] DCNL DCSP d['snapshotId'] = vol['snapshot_id'] DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('volume_metadata'): DCNL DCSP  DCSP metadata = vol.get('volume_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP return d
 DCSP d = _translate_attachment_summary_view(volume_id, instance_uuid, mountpoint) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = volume_id DCNL DCSP d['volumeId'] = volume_id DCNL DCSP d['serverId'] = instance_uuid DCNL DCSP if mountpoint: DCNL DCSP  DCSP d['device'] = mountpoint DCNL DCSP return d
 DCSP d = _translate_snapshot_summary_view(context, vol) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['volumeId'] = vol['volume_id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['volume_size'] DCNL DCSP d['createdAt'] = vol['created_at'] DCNL DCSP d['displayName'] = vol['display_name'] DCNL DCSP d['displayDescription'] = vol['display_description'] DCNL DCSP return d
 DCSP return {'net_id': port_info['network_id'], 'port_id': port_info['id'], 'mac_addr': port_info['mac_address'], 'port_state': port_info['status'], 'fixed_ips': port_info.get('fixed_ips', None)}
 DCSP return dict(((k, v) for (k, v) in item.iteritems() if (k in keys)))
 DCSP def wrapped(self, req, id, body, *args, **kwargs): DCNL DCSP  DCSP if ((len(body) == 1) and ('host' in body)): DCNL DCSP  DCSP  DCSP host = body['host'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise exc.HTTPBadRequest DCNL DCSP  DCSP return fn(self, req, id, host, *args, **kwargs) DCNL DCSP return wrapped
 DCSP d = {} DCNL DCSP d['id'] = vif['uuid'] DCNL DCSP d['mac_address'] = vif['address'] DCNL DCSP return d
 DCSP return urllib.unquote(domain).replace('%2E', '.')
 DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP unk_opt_str = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(unk_opt_str)s' DCSP from DCSP query") % locals()) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP search_options.pop(opt, None)
 DCSP if (migrate_engine.name in ['mysql', 'postgresql']): DCNL DCSP  DCSP meta = MetaData() DCNL DCSP  DCSP meta.bind = migrate_engine DCNL DCSP  DCSP t = Table(table_name, meta, autoload=True) DCNL DCSP  DCSP uc = UniqueConstraint(table=t, name=uc_name, *columns) DCNL DCSP  DCSP uc.drop() DCNL DCSP else: DCNL DCSP  DCSP _drop_unique_constraint_in_sqlite(migrate_engine, table_name, uc_name, **col_name_col_instance)
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP table = Table(table_name, meta, autoload=True) DCNL DCSP columns_for_group_by = [table.c[name] for name in uc_column_names] DCNL DCSP columns_for_select = [func.max(table.c.id)] DCNL DCSP columns_for_select.extend(list(columns_for_group_by)) DCNL DCSP duplicated_rows_select = select(columns_for_select, group_by=columns_for_group_by, having=(func.count(table.c.id) > 1)) DCNL DCSP for row in migrate_engine.execute(duplicated_rows_select): DCNL DCSP  DCSP delete_condition = (table.c.id != row[0]) DCNL DCSP  DCSP for name in uc_column_names: DCNL DCSP  DCSP  DCSP delete_condition &= (table.c[name] == row[name]) DCNL DCSP  DCSP rows_to_delete_select = select([table.c.id]).where(delete_condition) DCNL DCSP  DCSP for row in migrate_engine.execute(rows_to_delete_select).fetchall(): DCNL DCSP  DCSP  DCSP LOG.info((_('Deleted DCSP duplicated DCSP row DCSP with DCSP id: DCSP %(id)s DCSP from DCSP table: DCSP %(table)s') % dict(id=row[0], table=table_name))) DCNL DCSP  DCSP if use_soft_delete: DCNL DCSP  DCSP  DCSP delete_statement = table.update().where(delete_condition).values({'deleted': literal_column('id'), 'updated_at': literal_column('updated_at'), 'deleted_at': timeutils.utcnow()}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delete_statement = table.delete().where(delete_condition) DCNL DCSP  DCSP migrate_engine.execute(delete_statement)
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is postgresql.dialect): DCNL DCSP  DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP %(table)s DCSP ALTER DCSP COLUMN DCSP %(column)s DCSP TYPE DCSP INET DCSP USING DCSP %(column)s::INET' % locals())) DCNL DCSP else: DCNL DCSP  DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP for (table, column) in CIDR_TABLE_COLUMNS: DCNL DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP getattr(t.c, column).alter(type=String(39))
 DCSP for idx in getattr(table, 'indexes'): DCNL DCSP  DCSP if (idx.name == idx_name): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP raise Exception(("Index DCSP '%s' DCSP not DCSP found!" % idx_name)) DCNL DCSP idx.drop(engine) DCNL DCSP table.indexes.remove(idx)
 DCSP services = Table('services', meta, autoload=True) DCNL DCSP c_nodes = Table('compute_nodes', meta, autoload=True) DCNL DCSP q = select([services.c.host, c_nodes.c.hypervisor_hostname], whereclause=and_((c_nodes.c.deleted == False), (services.c.deleted == False)), from_obj=c_nodes.join(services, (c_nodes.c.service_id == services.c.id))) DCNL DCSP nodemap = {} DCNL DCSP for (host, node) in q.execute(): DCNL DCSP  DCSP nodes = nodemap.setdefault(host, []) DCNL DCSP  DCSP nodes.append(node) DCNL DCSP return nodemap
 DCSP q = select([migrations.c.id, migrations.c.source_compute, migrations.c.dest_compute, instances.c.uuid, instances.c.host, instances.c.node], whereclause=and_((migrations.c.source_compute != None), (migrations.c.dest_compute != None), (instances.c.deleted == False), (migrations.c.status != 'reverted'), (migrations.c.status != 'error')), from_obj=migrations.join(instances, (migrations.c.instance_uuid == instances.c.uuid))) DCNL DCSP result = q.execute() DCNL DCSP for (migration_id, src, dest, uuid, instance_host, instance_node) in result: DCNL DCSP  DCSP values = {} DCNL DCSP  DCSP nodes = nodemap.get(src, []) DCNL DCSP  DCSP if (len(nodes) == 1): DCNL DCSP  DCSP  DCSP node = nodes[0] DCNL DCSP  DCSP  DCSP values['source_node'] = node DCNL DCSP  DCSP  DCSP if ((src == instance_host) and (node != instance_node)): DCNL DCSP  DCSP  DCSP  DCSP update(instances).where((instances.c.uuid == uuid)).values(node=node) DCNL DCSP  DCSP nodes = nodemap.get(dest, []) DCNL DCSP  DCSP if (len(nodes) == 1): DCNL DCSP  DCSP  DCSP node = nodes[0] DCNL DCSP  DCSP  DCSP values['dest_node'] = node DCNL DCSP  DCSP  DCSP if ((dest == instance_host) and (node != instance_node)): DCNL DCSP  DCSP  DCSP  DCSP update(instances).where((instances.c.uuid == uuid)).values(node=node) DCNL DCSP  DCSP if values: DCNL DCSP  DCSP  DCSP q = update(migrations, values=values, whereclause=(migrations.c.id == migration_id)) DCNL DCSP  DCSP  DCSP q.execute()
 DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is not postgresql.dialect): DCNL DCSP  DCSP meta = MetaData(bind=migrate_engine) DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is postgresql.dialect): DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP %(table)s DCSP ALTER DCSP COLUMN DCSP %(column)s DCSP TYPE DCSP INET DCSP USING DCSP %(column)s::INET' % locals())) DCNL DCSP else: DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP t = Table(table, meta, autoload=True) DCNL DCSP  DCSP getattr(t.c, column).alter(type=String(255))
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP dialect = migrate_engine.url.get_dialect() DCNL DCSP if (dialect is postgresql.dialect): DCNL DCSP  DCSP for column in ('period_beginning', 'period_ending'): DCNL DCSP  DCSP  DCSP migrate_engine.execute(('ALTER DCSP TABLE DCSP task_log DCSP ALTER DCSP COLUMN DCSP %s DCSP TYPE DCSP TIMESTAMP DCSP WITHOUT DCSP TIME DCSP ZONE DCSP USING DCSP %s::TIMESTAMP DCSP WITHOUT DCSP TIME DCSP ZONE' % (column, column))) DCNL DCSP else: DCNL DCSP  DCSP migrations = Table('task_log', meta, autoload=True) DCNL DCSP  DCSP migrations.c.period_beginning.alter(DateTime) DCNL DCSP  DCSP migrations.c.period_ending.alter(DateTime)
 DCSP meta = MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP migrations = Table('task_log', meta, autoload=True) DCNL DCSP migrations.c.period_beginning.alter(String(255)) DCNL DCSP migrations.c.period_ending.alter(String(255))
 DCSP return sys.modules[__name__]
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP nova.context.require_admin_context(args[0]) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP nova.context.require_context(args[0]) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(context, instance_uuid, *args, **kwargs): DCNL DCSP  DCSP instance_get_by_uuid(context, instance_uuid) DCNL DCSP  DCSP return f(context, instance_uuid, *args, **kwargs) DCNL DCSP return wrapper
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(context, aggregate_id, *args, **kwargs): DCNL DCSP  DCSP aggregate_get(context, aggregate_id) DCNL DCSP  DCSP return f(context, aggregate_id, *args, **kwargs) DCNL DCSP return wrapper
 DCSP @functools.wraps(f) DCNL DCSP def wrapped(*args, **kwargs): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP  DCSP except db_exc.DBDeadlock: DCNL DCSP  DCSP  DCSP  DCSP LOG.warn(_("Deadlock DCSP detected DCSP when DCSP running DCSP '%(func_name)s': DCSP Retrying..."), dict(func_name=f.__name__)) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP functools.update_wrapper(wrapped, f) DCNL DCSP return wrapped
 DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only', False) DCNL DCSP def issubclassof_nova_base(obj): DCNL DCSP  DCSP return (isinstance(obj, type) and issubclass(obj, models.NovaBase)) DCNL DCSP base_model = model DCNL DCSP if (not issubclassof_nova_base(base_model)): DCNL DCSP  DCSP base_model = kwargs.get('base_model', None) DCNL DCSP  DCSP if (not issubclassof_nova_base(base_model)): DCNL DCSP  DCSP  DCSP raise Exception(_('model DCSP or DCSP base_model DCSP parameter DCSP should DCSP be DCSP subclass DCSP of DCSP NovaBase')) DCNL DCSP query = session.query(model, *args) DCNL DCSP default_deleted_value = base_model.__mapper__.c.deleted.default.arg DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter((base_model.deleted == default_deleted_value)) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter((base_model.deleted != default_deleted_value)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (nova.context.is_user_context(context) and project_only): DCNL DCSP  DCSP if (project_only == 'allow_none'): DCNL DCSP  DCSP  DCSP query = query.filter(or_((base_model.project_id == context.project_id), (base_model.project_id == None))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
 DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if (key == 'metadata'): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP if isinstance(value, list): DCNL DCSP  DCSP  DCSP  DCSP for item in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (k, v) in item.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(key=k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(value=v)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in value.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(key=k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP query = query.filter(column_attr.any(value=v)) DCNL DCSP  DCSP elif isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
 DCSP stats = [] DCNL DCSP d = values.get('stats', {}) DCNL DCSP for (k, v) in d.iteritems(): DCNL DCSP  DCSP stat = models.ComputeNodeStat() DCNL DCSP  DCSP stat['key'] = k DCNL DCSP  DCSP stat['value'] = v DCNL DCSP  DCSP stats.append(stat) DCNL DCSP values['stats'] = stats
 DCSP _prep_stats_dict(values) DCNL DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP compute_node_ref = models.ComputeNode() DCNL DCSP compute_node_ref.update(values) DCNL DCSP compute_node_ref.save() DCNL DCSP return compute_node_ref
 DCSP stats = values.pop('stats', {}) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP _update_stats(context, stats, compute_id, session, prune_stats) DCNL DCSP  DCSP compute_ref = _compute_node_get(context, compute_id, session=session) DCNL DCSP  DCSP if ('updated_at' not in values): DCNL DCSP  DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP  DCSP compute_ref.update(values) DCNL DCSP return compute_ref
 DCSP result = model_query(context, models.ComputeNode).filter_by(id=compute_id).soft_delete() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ComputeHostNotFound(host=compute_id)
 DCSP result = model_query(context, func.count(models.ComputeNode.id), func.sum(models.ComputeNode.vcpus), func.sum(models.ComputeNode.memory_mb), func.sum(models.ComputeNode.local_gb), func.sum(models.ComputeNode.vcpus_used), func.sum(models.ComputeNode.memory_mb_used), func.sum(models.ComputeNode.local_gb_used), func.sum(models.ComputeNode.free_ram_mb), func.sum(models.ComputeNode.free_disk_gb), func.sum(models.ComputeNode.current_workload), func.sum(models.ComputeNode.running_vms), func.sum(models.ComputeNode.disk_available_least), base_model=models.ComputeNode, read_deleted='no').first() DCNL DCSP fields = ('count', 'vcpus', 'memory_mb', 'local_gb', 'vcpus_used', 'memory_mb_used', 'local_gb_used', 'free_ram_mb', 'free_disk_gb', 'current_workload', 'running_vms', 'disk_available_least') DCNL DCSP return dict(((field, int((result[idx] or 0))) for (idx, field) in enumerate(fields)))
 DCSP out = [] DCNL DCSP count = 0 DCNL DCSP for ip in ips: DCNL DCSP  DCSP out.append(ip['address']) DCNL DCSP  DCSP count += 1 DCNL DCSP  DCSP if (count > (block_size - 1)): DCNL DCSP  DCSP  DCSP (yield out) DCNL DCSP  DCSP  DCSP out = [] DCNL DCSP  DCSP  DCSP count = 0 DCNL DCSP if out: DCNL DCSP  DCSP (yield out)
 DCSP if (not uuidutils.is_uuid_like(instance_uuid)): DCNL DCSP  DCSP raise exception.InvalidUUID(uuid=instance_uuid) DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP network_or_none = or_((models.FixedIp.network_id == network_id), (models.FixedIp.network_id == None)) DCNL DCSP  DCSP fixed_ip_ref = model_query(context, models.FixedIp, session=session, read_deleted='no').filter(network_or_none).filter_by(reserved=reserved).filter_by(address=address).with_lockmode('update').first() DCNL DCSP  DCSP if (fixed_ip_ref is None): DCNL DCSP  DCSP  DCSP raise exception.FixedIpNotFoundForNetwork(address=address, network_uuid=network_id) DCNL DCSP  DCSP if fixed_ip_ref.instance_uuid: DCNL DCSP  DCSP  DCSP raise exception.FixedIpAlreadyInUse(address=address, instance_uuid=instance_uuid) DCNL DCSP  DCSP if (not fixed_ip_ref.network_id): DCNL DCSP  DCSP  DCSP fixed_ip_ref.network_id = network_id DCNL DCSP  DCSP fixed_ip_ref.instance_uuid = instance_uuid DCNL DCSP  DCSP session.add(fixed_ip_ref) DCNL DCSP return fixed_ip_ref['address']
 DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP result = model_query(context, models.FixedIp, models.Network, models.Instance, session=session).filter_by(address=address).outerjoin((models.Network, (models.Network.id == models.FixedIp.network_id))).outerjoin((models.Instance, (models.Instance.uuid == models.FixedIp.instance_uuid))).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.FixedIpNotFoundForAddress(address=address) DCNL DCSP return result
 DCSP try: DCNL DCSP  DCSP vif_ref = models.VirtualInterface() DCNL DCSP  DCSP vif_ref.update(values) DCNL DCSP  DCSP vif_ref.save() DCNL DCSP except db_exc.DBError: DCNL DCSP  DCSP raise exception.VirtualInterfaceCreateException() DCNL DCSP return vif_ref
 DCSP vif_ref = _virtual_interface_query(context).filter_by(id=vif_id).first() DCNL DCSP return vif_ref
 DCSP vif_ref = _virtual_interface_query(context).filter_by(address=address).first() DCNL DCSP return vif_ref
 DCSP vif_ref = _virtual_interface_query(context).filter_by(uuid=vif_uuid).first() DCNL DCSP return vif_ref
 DCSP vif_refs = _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).all() DCNL DCSP return vif_refs
 DCSP vif_ref = _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).filter_by(network_id=network_id).first() DCNL DCSP return vif_ref
 DCSP _virtual_interface_query(context).filter_by(instance_uuid=instance_uuid).delete()
 DCSP vif_refs = _virtual_interface_query(context).all() DCNL DCSP return vif_refs
 DCSP values = values.copy() DCNL DCSP values['metadata'] = _metadata_refs(values.get('metadata'), models.InstanceMetadata) DCNL DCSP values['system_metadata'] = _metadata_refs(values.get('system_metadata'), models.InstanceSystemMetadata) DCNL DCSP instance_ref = models.Instance() DCNL DCSP if (not values.get('uuid')): DCNL DCSP  DCSP values['uuid'] = str(uuid.uuid4()) DCNL DCSP instance_ref['info_cache'] = models.InstanceInfoCache() DCNL DCSP info_cache = values.pop('info_cache', None) DCNL DCSP if (info_cache is not None): DCNL DCSP  DCSP instance_ref['info_cache'].update(info_cache) DCNL DCSP security_groups = values.pop('security_groups', []) DCNL DCSP instance_ref.update(values) DCNL DCSP def _get_sec_group_models(session, security_groups): DCNL DCSP  DCSP models = [] DCNL DCSP  DCSP (_existed, default_group) = security_group_ensure_default(context, session=session) DCNL DCSP  DCSP if ('default' in security_groups): DCNL DCSP  DCSP  DCSP models.append(default_group) DCNL DCSP  DCSP  DCSP security_groups = [x for x in security_groups if (x != 'default')] DCNL DCSP  DCSP if security_groups: DCNL DCSP  DCSP  DCSP models.extend(_security_group_get_by_names(context, session, context.project_id, security_groups)) DCNL DCSP  DCSP return models DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP if ('hostname' in values): DCNL DCSP  DCSP  DCSP _validate_unique_server_name(context, session, values['hostname']) DCNL DCSP  DCSP instance_ref.security_groups = _get_sec_group_models(session, security_groups) DCNL DCSP  DCSP instance_ref.save(session=session) DCNL DCSP ec2_instance_create(context, instance_ref['uuid']) DCNL DCSP return instance_ref
 DCSP uuids = [inst['uuid'] for inst in instances] DCNL DCSP if (manual_joins is None): DCNL DCSP  DCSP manual_joins = ['metadata', 'system_metadata'] DCNL DCSP meta = collections.defaultdict(list) DCNL DCSP if ('metadata' in manual_joins): DCNL DCSP  DCSP for row in _instance_metadata_get_multi(context, uuids): DCNL DCSP  DCSP  DCSP meta[row['instance_uuid']].append(row) DCNL DCSP sys_meta = collections.defaultdict(list) DCNL DCSP if ('system_metadata' in manual_joins): DCNL DCSP  DCSP for row in _instance_system_metadata_get_multi(context, uuids): DCNL DCSP  DCSP  DCSP sys_meta[row['instance_uuid']].append(row) DCNL DCSP filled_instances = [] DCNL DCSP for inst in instances: DCNL DCSP  DCSP inst = dict(inst.iteritems()) DCNL DCSP  DCSP inst['system_metadata'] = sys_meta[inst['uuid']] DCNL DCSP  DCSP inst['metadata'] = meta[inst['uuid']] DCNL DCSP  DCSP filled_instances.append(inst) DCNL DCSP return filled_instances
 DCSP sort_fn = {'desc': desc, 'asc': asc} DCNL DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP if (columns_to_join is None): DCNL DCSP  DCSP columns_to_join = ['info_cache', 'security_groups'] DCNL DCSP  DCSP manual_joins = ['metadata', 'system_metadata'] DCNL DCSP else: DCNL DCSP  DCSP (manual_joins, columns_to_join) = _manual_join_columns(columns_to_join) DCNL DCSP query_prefix = session.query(models.Instance) DCNL DCSP for column in columns_to_join: DCNL DCSP  DCSP query_prefix = query_prefix.options(joinedload(column)) DCNL DCSP query_prefix = query_prefix.order_by(sort_fn[sort_dir](getattr(models.Instance, sort_key))) DCNL DCSP filters = filters.copy() DCNL DCSP if ('changes-since' in filters): DCNL DCSP  DCSP changes_since = timeutils.normalize_time(filters['changes-since']) DCNL DCSP  DCSP query_prefix = query_prefix.filter((models.Instance.updated_at > changes_since)) DCNL DCSP if ('deleted' in filters): DCNL DCSP  DCSP if filters.pop('deleted'): DCNL DCSP  DCSP  DCSP deleted = or_((models.Instance.deleted == models.Instance.id), (models.Instance.vm_state == vm_states.SOFT_DELETED)) DCNL DCSP  DCSP  DCSP query_prefix = query_prefix.filter(deleted) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query_prefix = query_prefix.filter_by(deleted=0).filter((models.Instance.vm_state != vm_states.SOFT_DELETED)) DCNL DCSP if (not context.is_admin): DCNL DCSP  DCSP if context.project_id: DCNL DCSP  DCSP  DCSP filters['project_id'] = context.project_id DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filters['user_id'] = context.user_id DCNL DCSP exact_match_filter_names = ['project_id', 'user_id', 'image_ref', 'vm_state', 'instance_type_id', 'uuid', 'metadata'] DCNL DCSP query_prefix = exact_filter(query_prefix, models.Instance, filters, exact_match_filter_names) DCNL DCSP query_prefix = regex_filter(query_prefix, models.Instance, filters) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP marker = _instance_get_by_uuid(context, marker, session=session) DCNL DCSP  DCSP except exception.InstanceNotFound: DCNL DCSP  DCSP  DCSP raise exception.MarkerNotFound(marker) DCNL DCSP query_prefix = sqlalchemyutils.paginate_query(query_prefix, models.Instance, limit, [sort_key, 'created_at', 'id'], marker=marker, sort_dir=sort_dir) DCNL DCSP return _instances_fill_metadata(context, query_prefix.all(), manual_joins)
 DCSP regexp_op_map = {'postgresql': '~', 'mysql': 'REGEXP', 'oracle': 'REGEXP_LIKE', 'sqlite': 'REGEXP'} DCNL DCSP db_string = CONF.sql_connection.split(':')[0].split('+')[0] DCNL DCSP db_regexp_op = regexp_op_map.get(db_string, 'LIKE') DCNL DCSP for filter_name in filters.iterkeys(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP column_attr = getattr(model, filter_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('property' == type(column_attr).__name__): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP query = query.filter(column_attr.op(db_regexp_op)(str(filters[filter_name]))) DCNL DCSP return query
 DCSP session = get_session() DCNL DCSP query = session.query(models.Instance) DCNL DCSP query = query.options(joinedload('info_cache')).options(joinedload('security_groups')).filter(or_((models.Instance.terminated_at == None), (models.Instance.terminated_at > begin))) DCNL DCSP if end: DCNL DCSP  DCSP query = query.filter((models.Instance.launched_at < end)) DCNL DCSP if project_id: DCNL DCSP  DCSP query = query.filter_by(project_id=project_id) DCNL DCSP if host: DCNL DCSP  DCSP query = query.filter_by(host=host) DCNL DCSP return _instances_fill_metadata(context, query.all())
 DCSP uuids = [] DCNL DCSP for tuple in model_query(context, models.Instance.uuid, read_deleted='no', base_model=models.Instance, session=session).filter_by(host=host).all(): DCNL DCSP  DCSP uuids.append(tuple[0]) DCNL DCSP return uuids
 DCSP return _instance_update(context, instance_uuid, values, copy_old_instance=True)
 DCSP sec_group_ref = models.SecurityGroupInstanceAssociation() DCNL DCSP sec_group_ref.update({'instance_uuid': instance_uuid, 'security_group_id': security_group_id}) DCNL DCSP sec_group_ref.save()
 DCSP model_query(context, models.SecurityGroupInstanceAssociation).filter_by(instance_uuid=instance_uuid).filter_by(security_group_id=security_group_id).soft_delete()
 DCSP return model_query(context, models.InstanceInfoCache).filter_by(instance_uuid=instance_uuid).first()
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP info_cache = model_query(context, models.InstanceInfoCache, session=session).filter_by(instance_uuid=instance_uuid).first() DCNL DCSP  DCSP if (info_cache and info_cache['deleted']): DCNL DCSP  DCSP  DCSP raise exception.InstanceInfoCacheNotFound(instance_uuid=instance_uuid) DCNL DCSP  DCSP elif (not info_cache): DCNL DCSP  DCSP  DCSP info_cache = models.InstanceInfoCache() DCNL DCSP  DCSP  DCSP values['instance_uuid'] = instance_uuid DCNL DCSP  DCSP info_cache.update(values) DCNL DCSP return info_cache
 DCSP model_query(context, models.InstanceInfoCache).filter_by(instance_uuid=instance_uuid).soft_delete()
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP def network_query(project_filter, id=None): DCNL DCSP  DCSP  DCSP filter_kwargs = {'project_id': project_filter} DCNL DCSP  DCSP  DCSP if (id is not None): DCNL DCSP  DCSP  DCSP  DCSP filter_kwargs['id'] = id DCNL DCSP  DCSP  DCSP return model_query(context, models.Network, session=session, read_deleted='no').filter_by(**filter_kwargs).with_lockmode('update').first() DCNL DCSP  DCSP if (not force): DCNL DCSP  DCSP  DCSP network_ref = network_query(project_id) DCNL DCSP  DCSP if (force or (not network_ref)): DCNL DCSP  DCSP  DCSP network_ref = network_query(None, network_id) DCNL DCSP  DCSP  DCSP if (not network_ref): DCNL DCSP  DCSP  DCSP  DCSP raise db.NoMoreNetworks() DCNL DCSP  DCSP  DCSP network_ref['project_id'] = project_id DCNL DCSP  DCSP  DCSP session.add(network_ref) DCNL DCSP return network_ref
 DCSP return model_query(context, models.Reservation, read_deleted='no', session=session).filter(models.Reservation.uuid.in_(reservations)).with_lockmode('update')
 DCSP ec2_volume_ref = models.VolumeIdMapping() DCNL DCSP ec2_volume_ref.update({'uuid': volume_uuid}) DCNL DCSP if (id is not None): DCNL DCSP  DCSP ec2_volume_ref.update({'id': id}) DCNL DCSP ec2_volume_ref.save() DCNL DCSP return ec2_volume_ref
 DCSP ec2_snapshot_ref = models.SnapshotIdMapping() DCNL DCSP ec2_snapshot_ref.update({'uuid': snapshot_uuid}) DCNL DCSP if (id is not None): DCNL DCSP  DCSP ec2_snapshot_ref.update({'id': id}) DCNL DCSP ec2_snapshot_ref.save() DCNL DCSP return ec2_snapshot_ref
 DCSP query = _security_group_get_query(context, session=session, read_deleted='no', join_rules=False).filter_by(project_id=project_id).filter(models.SecurityGroup.name.in_(group_names)) DCNL DCSP sg_models = query.all() DCNL DCSP if (len(sg_models) == len(group_names)): DCNL DCSP  DCSP return sg_models DCNL DCSP group_names_from_models = [x.name for x in sg_models] DCNL DCSP for group_name in group_names: DCNL DCSP  DCSP if (group_name not in group_names_from_models): DCNL DCSP  DCSP  DCSP raise exception.SecurityGroupNotFoundForProject(project_id=project_id, security_group_id=group_name)
 DCSP try: DCNL DCSP  DCSP default_group = security_group_get_by_name(context, context.project_id, 'default', columns_to_join=[], session=session) DCNL DCSP  DCSP return (True, default_group) DCNL DCSP except exception.NotFound: DCNL DCSP  DCSP values = {'name': 'default', 'description': 'default', 'user_id': context.user_id, 'project_id': context.project_id} DCNL DCSP  DCSP default_group = security_group_create(context, values, session=session) DCNL DCSP  DCSP for default_rule in security_group_default_rule_list(context): DCNL DCSP  DCSP  DCSP rule_values = {'protocol': default_rule.protocol, 'from_port': default_rule.from_port, 'to_port': default_rule.to_port, 'cidr': default_rule.cidr, 'parent_group_id': default_group.id} DCNL DCSP  DCSP  DCSP security_group_rule_create(context, rule_values) DCNL DCSP  DCSP return (False, default_group)
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeExists(name=values['name']) DCNL DCSP  DCSP except exception.InstanceTypeNotFoundByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_flavor_id(context, values['flavorid'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeIdExists(flavor_id=values['flavorid']) DCNL DCSP  DCSP except exception.FlavorNotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP specs = values.get('extra_specs') DCNL DCSP  DCSP  DCSP specs_refs = [] DCNL DCSP  DCSP  DCSP if specs: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in specs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref = models.InstanceTypeExtraSpecs() DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['key'] = k DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['value'] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_refs.append(specs_ref) DCNL DCSP  DCSP  DCSP values['extra_specs'] = specs_refs DCNL DCSP  DCSP  DCSP instance_type_ref = models.InstanceTypes() DCNL DCSP  DCSP  DCSP instance_type_ref.update(values) DCNL DCSP  DCSP  DCSP instance_type_ref.save(session=session) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise db_exc.DBError(e) DCNL DCSP  DCSP return _dict_with_extra_specs(instance_type_ref)
 DCSP inst_type_dict = dict(inst_type_query) DCNL DCSP extra_specs = dict([(x['key'], x['value']) for x in inst_type_query['extra_specs']]) DCNL DCSP inst_type_dict['extra_specs'] = extra_specs DCNL DCSP return inst_type_dict
 DCSP filters = (filters or {}) DCNL DCSP read_deleted = ('yes' if inactive else 'no') DCNL DCSP query = _instance_type_get_query(context, read_deleted=read_deleted) DCNL DCSP if ('min_memory_mb' in filters): DCNL DCSP  DCSP query = query.filter((models.InstanceTypes.memory_mb >= filters['min_memory_mb'])) DCNL DCSP if ('min_root_gb' in filters): DCNL DCSP  DCSP query = query.filter((models.InstanceTypes.root_gb >= filters['min_root_gb'])) DCNL DCSP if ('disabled' in filters): DCNL DCSP  DCSP query = query.filter((models.InstanceTypes.disabled == filters['disabled'])) DCNL DCSP if (('is_public' in filters) and (filters['is_public'] is not None)): DCNL DCSP  DCSP the_filter = [(models.InstanceTypes.is_public == filters['is_public'])] DCNL DCSP  DCSP if (filters['is_public'] and (context.project_id is not None)): DCNL DCSP  DCSP  DCSP the_filter.extend([models.InstanceTypes.projects.any(project_id=context.project_id, deleted=0)]) DCNL DCSP  DCSP if (len(the_filter) > 1): DCNL DCSP  DCSP  DCSP query = query.filter(or_(*the_filter)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP query = query.filter(the_filter[0]) DCNL DCSP  DCSP del filters['is_public'] DCNL DCSP inst_types = query.order_by('name').all() DCNL DCSP return [_dict_with_extra_specs(i) for i in inst_types]
 DCSP result = _instance_type_get_query(context, session=session).filter_by(id=id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.InstanceTypeNotFound(instance_type_id=id) DCNL DCSP return _dict_with_extra_specs(result)
 DCSP result = _instance_type_get_query(context, session=session).filter_by(name=name).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.InstanceTypeNotFoundByName(instance_type_name=name) DCNL DCSP return _dict_with_extra_specs(result)
 DCSP result = _instance_type_get_query(context, session=session).filter_by(flavorid=flavor_id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.FlavorNotFound(flavor_id=flavor_id) DCNL DCSP return _dict_with_extra_specs(result)
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_name(context, name, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP session.query(models.InstanceTypes).filter_by(id=instance_type_id).soft_delete() DCNL DCSP  DCSP session.query(models.InstanceTypeExtraSpecs).filter_by(instance_type_id=instance_type_id).soft_delete()
 DCSP instance_type_ref = _instance_type_get_query(context).filter_by(flavorid=flavor_id).first() DCNL DCSP return [r for r in instance_type_ref.projects]
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_id(context, flavor_id, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP access_ref = _instance_type_access_query(context, session=session).filter_by(instance_type_id=instance_type_id).filter_by(project_id=project_id).first() DCNL DCSP  DCSP if access_ref: DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessExists(flavor_id=flavor_id, project_id=project_id) DCNL DCSP  DCSP access_ref = models.InstanceTypeProjects() DCNL DCSP  DCSP access_ref.update({'instance_type_id': instance_type_id, 'project_id': project_id}) DCNL DCSP  DCSP access_ref.save(session=session) DCNL DCSP  DCSP return access_ref
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_id(context, flavor_id, session=session) DCNL DCSP  DCSP instance_type_id = instance_type_ref['id'] DCNL DCSP  DCSP count = _instance_type_access_query(context, session=session).filter_by(instance_type_id=instance_type_id).filter_by(project_id=project_id).soft_delete() DCNL DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessNotFound(flavor_id=flavor_id, project_id=project_id)
 DCSP return model_query(context, models.VolumeUsage, read_deleted='yes').filter(or_((models.VolumeUsage.tot_last_refreshed == None), (models.VolumeUsage.tot_last_refreshed > begin), (models.VolumeUsage.curr_last_refreshed == None), (models.VolumeUsage.curr_last_refreshed > begin))).all()
 DCSP result = model_query(context, models.S3Image, read_deleted='yes').filter_by(id=image_id).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ImageNotFound(image_id=image_id) DCNL DCSP return result
 DCSP result = model_query(context, models.S3Image, read_deleted='yes').filter_by(uuid=image_uuid).first() DCNL DCSP if (not result): DCNL DCSP  DCSP raise exception.ImageNotFound(image_id=image_uuid) DCNL DCSP return result
 DCSP try: DCNL DCSP  DCSP s3_image_ref = models.S3Image() DCNL DCSP  DCSP s3_image_ref.update({'uuid': image_uuid}) DCNL DCSP  DCSP s3_image_ref.save() DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise db_exc.DBError(e) DCNL DCSP return s3_image_ref
 DCSP fault_ref = models.InstanceFault() DCNL DCSP fault_ref.update(values) DCNL DCSP fault_ref.save() DCNL DCSP return dict(fault_ref.iteritems())
 DCSP rows = model_query(context, models.InstanceFault, read_deleted='no').filter(models.InstanceFault.instance_uuid.in_(instance_uuids)).order_by(desc('created_at'), desc('id')).all() DCNL DCSP output = {} DCNL DCSP for instance_uuid in instance_uuids: DCNL DCSP  DCSP output[instance_uuid] = [] DCNL DCSP for row in rows: DCNL DCSP  DCSP data = dict(row.iteritems()) DCNL DCSP  DCSP output[row['instance_uuid']].append(data) DCNL DCSP return output
 DCSP actions = model_query(context, models.InstanceAction).filter_by(instance_uuid=instance_uuid).order_by(desc('created_at')).all() DCNL DCSP return actions
 DCSP action = _action_get_by_request_id(context, instance_uuid, request_id) DCNL DCSP return action
 DCSP convert_datetimes(values, 'start_time') DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP action = _action_get_by_request_id(context, values['instance_uuid'], values['request_id'], session) DCNL DCSP  DCSP if (not action): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionNotFound(request_id=values['request_id'], instance_uuid=values['instance_uuid']) DCNL DCSP  DCSP values['action_id'] = action['id'] DCNL DCSP  DCSP event_ref = models.InstanceActionEvent() DCNL DCSP  DCSP event_ref.update(values) DCNL DCSP  DCSP event_ref.save(session=session) DCNL DCSP return event_ref
 DCSP convert_datetimes(values, 'start_time', 'finish_time') DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP action = _action_get_by_request_id(context, values['instance_uuid'], values['request_id'], session) DCNL DCSP  DCSP if (not action): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionNotFound(request_id=values['request_id'], instance_uuid=values['instance_uuid']) DCNL DCSP  DCSP event_ref = model_query(context, models.InstanceActionEvent, session=session).filter_by(action_id=action['id']).filter_by(event=values['event']).first() DCNL DCSP  DCSP if (not event_ref): DCNL DCSP  DCSP  DCSP raise exception.InstanceActionEventNotFound(action_id=action['id'], event=values['event']) DCNL DCSP  DCSP event_ref.update(values) DCNL DCSP  DCSP if (values['result'].lower() == 'error'): DCNL DCSP  DCSP  DCSP action.update({'message': 'Error'}) DCNL DCSP return event_ref
 DCSP ec2_instance_ref = models.InstanceIdMapping() DCNL DCSP ec2_instance_ref.update({'uuid': instance_uuid}) DCNL DCSP if (id is not None): DCNL DCSP  DCSP ec2_instance_ref.update({'id': id}) DCNL DCSP ec2_instance_ref.save() DCNL DCSP return ec2_instance_ref
 DCSP engine = get_engine() DCNL DCSP conn = engine.connect() DCNL DCSP metadata = MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP table = Table(tablename, metadata, autoload=True) DCNL DCSP default_deleted_value = _get_default_deleted_value(table) DCNL DCSP shadow_tablename = ('shadow_' + tablename) DCNL DCSP rows_archived = 0 DCNL DCSP try: DCNL DCSP  DCSP shadow_table = Table(shadow_tablename, metadata, autoload=True) DCNL DCSP except NoSuchTableError: DCNL DCSP  DCSP return rows_archived DCNL DCSP with conn.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP column = table.c.id DCNL DCSP  DCSP  DCSP column_name = 'id' DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP column = table.c.domain DCNL DCSP  DCSP  DCSP column_name = 'domain' DCNL DCSP  DCSP query = select([table], (table.c.deleted != default_deleted_value)).order_by(column).limit(max_rows) DCNL DCSP  DCSP rows = conn.execute(query).fetchall() DCNL DCSP  DCSP if rows: DCNL DCSP  DCSP  DCSP keys = [getattr(row, column_name) for row in rows] DCNL DCSP  DCSP  DCSP delete_statement = table.delete(column.in_(keys)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP result = conn.execute(delete_statement) DCNL DCSP  DCSP  DCSP except IntegrityError: DCNL DCSP  DCSP  DCSP  DCSP return rows_archived DCNL DCSP  DCSP  DCSP insert_statement = shadow_table.insert() DCNL DCSP  DCSP  DCSP conn.execute(insert_statement, rows) DCNL DCSP  DCSP  DCSP rows_archived = result.rowcount DCNL DCSP return rows_archived
 DCSP tablenames = [] DCNL DCSP for model_class in models.__dict__.itervalues(): DCNL DCSP  DCSP if hasattr(model_class, '__tablename__'): DCNL DCSP  DCSP  DCSP tablenames.append(model_class.__tablename__) DCNL DCSP rows_archived = 0 DCNL DCSP for tablename in tablenames: DCNL DCSP  DCSP rows_archived += archive_deleted_rows_for_table(context, tablename, max_rows=(max_rows - rows_archived)) DCNL DCSP  DCSP if (rows_archived >= max_rows): DCNL DCSP  DCSP  DCSP break DCNL DCSP return rows_archived
 DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
 DCSP return IMPL.constraint(**conditions)
 DCSP return IMPL.equal_any(*values)
 DCSP return IMPL.not_equal(*values)
 DCSP return IMPL.service_destroy(context, instance_id)
 DCSP return IMPL.service_get(context, service_id)
 DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
 DCSP return IMPL.service_get_all(context, disabled)
 DCSP return IMPL.service_get_all_by_topic(context, topic)
 DCSP return IMPL.service_get_all_by_host(context, host)
 DCSP return IMPL.service_get_by_compute_host(context, host)
 DCSP return IMPL.service_get_by_args(context, host, binary)
 DCSP return IMPL.service_create(context, values)
 DCSP return IMPL.service_update(context, service_id, values)
 DCSP return IMPL.compute_node_get(context, compute_id)
 DCSP return IMPL.compute_node_get_all(context)
 DCSP return IMPL.compute_node_search_by_hypervisor(context, hypervisor_match)
 DCSP return IMPL.compute_node_create(context, values)
 DCSP return IMPL.compute_node_update(context, compute_id, values, prune_stats)
 DCSP return IMPL.compute_node_delete(context, compute_id)
 DCSP return IMPL.certificate_create(context, values)
 DCSP return IMPL.certificate_get_all_by_project(context, project_id)
 DCSP return IMPL.certificate_get_all_by_user(context, user_id)
 DCSP return IMPL.certificate_get_all_by_user_and_project(context, user_id, project_id)
 DCSP return IMPL.floating_ip_get_pools(context)
 DCSP return IMPL.floating_ip_allocate_address(context, project_id, pool)
 DCSP return IMPL.floating_ip_bulk_create(context, ips)
 DCSP return IMPL.floating_ip_bulk_destroy(context, ips)
 DCSP return IMPL.floating_ip_create(context, values)
 DCSP return IMPL.floating_ip_count_by_project(context, project_id, session=session)
 DCSP return IMPL.floating_ip_deallocate(context, address)
 DCSP return IMPL.floating_ip_destroy(context, address)
 DCSP return IMPL.floating_ip_disassociate(context, address)
 DCSP return IMPL.floating_ip_fixed_ip_associate(context, floating_address, fixed_address, host)
 DCSP return IMPL.floating_ip_get_all(context)
 DCSP return IMPL.floating_ip_get_all_by_host(context, host)
 DCSP return IMPL.floating_ip_get_all_by_project(context, project_id)
 DCSP return IMPL.floating_ip_get_by_address(context, address)
 DCSP return IMPL.floating_ip_get_by_fixed_address(context, fixed_address)
 DCSP return IMPL.floating_ip_get_by_fixed_ip_id(context, fixed_ip_id)
 DCSP return IMPL.floating_ip_update(context, address, values)
 DCSP return IMPL.floating_ip_set_auto_assigned(context, address)
 DCSP return IMPL.dnsdomain_list(context)
 DCSP return IMPL.dnsdomain_register_for_zone(context, fqdomain, zone)
 DCSP return IMPL.dnsdomain_register_for_project(context, fqdomain, project)
 DCSP return IMPL.dnsdomain_unregister(context, fqdomain)
 DCSP return IMPL.dnsdomain_get(context, fqdomain)
 DCSP return IMPL.migration_update(context, id, values)
 DCSP return IMPL.migration_create(context, values)
 DCSP return IMPL.migration_get(context, migration_id)
 DCSP return IMPL.migration_get_by_instance_and_status(context, instance_uuid, status)
 DCSP return IMPL.migration_get_unconfirmed_by_dest_compute(context, confirm_window, dest_compute)
 DCSP return IMPL.migration_get_in_progress_by_host_and_node(context, host, node)
 DCSP return IMPL.fixed_ip_associate(context, address, instance_uuid, network_id, reserved)
 DCSP return IMPL.fixed_ip_associate_pool(context, network_id, instance_uuid, host)
 DCSP return IMPL.fixed_ip_create(context, values)
 DCSP return IMPL.fixed_ip_bulk_create(context, ips)
 DCSP return IMPL.fixed_ip_disassociate(context, address)
 DCSP return IMPL.fixed_ip_disassociate_all_by_timeout(context, host, time)
 DCSP return IMPL.fixed_ip_get(context, id, get_network)
 DCSP return IMPL.fixed_ip_get_all(context)
 DCSP return IMPL.fixed_ip_get_by_address(context, address)
 DCSP return IMPL.fixed_ip_get_by_address_detailed(context, address)
 DCSP return IMPL.fixed_ip_get_by_floating_address(context, floating_address)
 DCSP return IMPL.fixed_ip_get_by_instance(context, instance_uuid)
 DCSP return IMPL.fixed_ip_get_by_host(context, host)
 DCSP return IMPL.fixed_ip_get_by_network_host(context, network_uuid, host)
 DCSP return IMPL.fixed_ips_by_virtual_interface(context, vif_id)
 DCSP return IMPL.fixed_ip_update(context, address, values)
 DCSP return IMPL.fixed_ip_count_by_project(context, project_id, session=session)
 DCSP return IMPL.virtual_interface_create(context, values)
 DCSP return IMPL.virtual_interface_get(context, vif_id)
 DCSP return IMPL.virtual_interface_get_by_address(context, address)
 DCSP return IMPL.virtual_interface_get_by_uuid(context, vif_uuid)
 DCSP return IMPL.virtual_interface_get_by_instance(context, instance_id)
 DCSP return IMPL.virtual_interface_get_by_instance_and_network(context, instance_id, network_id)
 DCSP return IMPL.virtual_interface_delete_by_instance(context, instance_id)
 DCSP return IMPL.virtual_interface_get_all(context)
 DCSP return IMPL.instance_create(context, values)
 DCSP return IMPL.instance_data_get_for_project(context, project_id, session=session)
 DCSP rv = IMPL.instance_destroy(context, instance_uuid, constraint) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_destroy_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP destroy')) DCNL DCSP return rv
 DCSP return IMPL.instance_get_by_uuid(context, uuid)
 DCSP return IMPL.instance_get(context, instance_id)
 DCSP return IMPL.instance_get_all(context, columns_to_join=columns_to_join)
 DCSP return IMPL.instance_get_all_by_filters(context, filters, sort_key, sort_dir, limit=limit, marker=marker, columns_to_join=columns_to_join)
 DCSP return IMPL.instance_get_active_by_window_joined(context, begin, end, project_id, host)
 DCSP return IMPL.instance_get_all_by_host(context, host, columns_to_join)
 DCSP return IMPL.instance_get_all_by_host_and_node(context, host, node)
 DCSP return IMPL.instance_get_all_by_host_and_not_type(context, host, type_id)
 DCSP return IMPL.instance_get_floating_address(context, instance_id)
 DCSP return IMPL.instance_floating_address_get_all(context, instance_uuid)
 DCSP return IMPL.instance_get_all_hung_in_rebooting(context, reboot_window)
 DCSP return IMPL.instance_test_and_set(context, instance_uuid, attr, ok_states, new_state)
 DCSP rv = IMPL.instance_update(context, instance_uuid, values) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_update_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP update')) DCNL DCSP return rv
 DCSP rv = IMPL.instance_update_and_get_original(context, instance_uuid, values) DCNL DCSP try: DCNL DCSP  DCSP cells_rpcapi.CellsAPI().instance_update_at_top(context, rv[1]) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP update')) DCNL DCSP return rv
 DCSP return IMPL.instance_add_security_group(context, instance_id, security_group_id)
 DCSP return IMPL.instance_remove_security_group(context, instance_id, security_group_id)
 DCSP return IMPL.instance_info_cache_get(context, instance_uuid)
 DCSP rv = IMPL.instance_info_cache_update(context, instance_uuid, values) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_info_cache_update_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP info DCSP cache DCSP update')) DCNL DCSP return rv
 DCSP return IMPL.instance_info_cache_delete(context, instance_uuid)
 DCSP return IMPL.key_pair_create(context, values)
 DCSP return IMPL.key_pair_destroy(context, user_id, name)
 DCSP return IMPL.key_pair_get(context, user_id, name)
 DCSP return IMPL.key_pair_get_all_by_user(context, user_id)
 DCSP return IMPL.key_pair_count_by_user(context, user_id)
 DCSP return IMPL.network_associate(context, project_id, network_id, force)
 DCSP return IMPL.network_count_reserved_ips(context, network_id)
 DCSP return IMPL.network_create_safe(context, values)
 DCSP return IMPL.network_delete_safe(context, network_id)
 DCSP return IMPL.network_disassociate(context, network_id, disassociate_host, disassociate_project)
 DCSP return IMPL.network_get(context, network_id, project_only=project_only)
 DCSP return IMPL.network_get_all(context)
 DCSP return IMPL.network_get_all_by_uuids(context, network_uuids, project_only=project_only)
 DCSP return IMPL.network_in_use_on_host(context, network_id, host)
 DCSP return IMPL.network_get_associated_fixed_ips(context, network_id, host)
 DCSP return IMPL.network_get_by_uuid(context, uuid)
 DCSP return IMPL.network_get_by_cidr(context, cidr)
 DCSP return IMPL.network_get_all_by_instance(context, instance_id)
 DCSP return IMPL.network_get_all_by_host(context, host)
 DCSP return IMPL.network_set_host(context, network_id, host_id)
 DCSP return IMPL.network_update(context, network_id, values)
 DCSP return IMPL.quota_create(context, project_id, resource, limit)
 DCSP return IMPL.quota_get(context, project_id, resource)
 DCSP return IMPL.quota_get_all_by_project(context, project_id)
 DCSP return IMPL.quota_update(context, project_id, resource, limit)
 DCSP return IMPL.quota_class_create(context, class_name, resource, limit)
 DCSP return IMPL.quota_class_get(context, class_name, resource)
 DCSP return IMPL.quota_class_get_all_by_name(context, class_name)
 DCSP return IMPL.quota_class_update(context, class_name, resource, limit)
 DCSP return IMPL.quota_usage_get(context, project_id, resource)
 DCSP return IMPL.quota_usage_get_all_by_project(context, project_id)
 DCSP return IMPL.quota_usage_update(context, project_id, resource, **kwargs)
 DCSP return IMPL.reservation_create(context, uuid, usage, project_id, resource, delta, expire)
 DCSP return IMPL.reservation_get(context, uuid)
 DCSP return IMPL.quota_reserve(context, resources, quotas, deltas, expire, until_refresh, max_age, project_id=project_id)
 DCSP return IMPL.reservation_commit(context, reservations, project_id=project_id)
 DCSP return IMPL.reservation_rollback(context, reservations, project_id=project_id)
 DCSP return IMPL.quota_destroy_all_by_project(context, project_id)
 DCSP return IMPL.reservation_expire(context)
 DCSP return IMPL.block_device_mapping_create(context, values)
 DCSP return IMPL.block_device_mapping_update(context, bdm_id, values)
 DCSP return IMPL.block_device_mapping_update_or_create(context, values)
 DCSP return IMPL.block_device_mapping_get_all_by_instance(context, instance_uuid)
 DCSP return IMPL.block_device_mapping_destroy(context, bdm_id)
 DCSP return IMPL.block_device_mapping_destroy_by_instance_and_device(context, instance_uuid, device_name)
 DCSP return IMPL.block_device_mapping_destroy_by_instance_and_volume(context, instance_uuid, volume_id)
 DCSP return IMPL.security_group_get_all(context)
 DCSP return IMPL.security_group_get(context, security_group_id)
 DCSP return IMPL.security_group_get_by_name(context, project_id, group_name)
 DCSP return IMPL.security_group_get_by_project(context, project_id)
 DCSP return IMPL.security_group_get_by_instance(context, instance_id)
 DCSP return IMPL.security_group_exists(context, project_id, group_name)
 DCSP return IMPL.security_group_in_use(context, group_id)
 DCSP return IMPL.security_group_create(context, values)
 DCSP return IMPL.security_group_ensure_default(context)
 DCSP return IMPL.security_group_destroy(context, security_group_id)
 DCSP return IMPL.security_group_count_by_project(context, project_id, session=session)
 DCSP return IMPL.security_group_rule_create(context, values)
 DCSP return IMPL.security_group_rule_get_by_security_group(context, security_group_id)
 DCSP return IMPL.security_group_rule_get_by_security_group_grantee(context, security_group_id)
 DCSP return IMPL.security_group_rule_destroy(context, security_group_rule_id)
 DCSP return IMPL.security_group_rule_get(context, security_group_rule_id)
 DCSP return IMPL.security_group_rule_count_by_group(context, security_group_id)
 DCSP return IMPL.provider_fw_rule_create(context, rule)
 DCSP return IMPL.provider_fw_rule_get_all(context)
 DCSP return IMPL.provider_fw_rule_destroy(context, rule_id)
 DCSP return IMPL.project_get_networks(context, project_id, associate)
 DCSP return IMPL.console_pool_create(context, values)
 DCSP return IMPL.console_pool_get_by_host_type(context, compute_host, proxy_host, console_type)
 DCSP return IMPL.console_pool_get_all_by_host_type(context, host, console_type)
 DCSP return IMPL.console_create(context, values)
 DCSP return IMPL.console_delete(context, console_id)
 DCSP return IMPL.console_get_by_pool_instance(context, pool_id, instance_uuid)
 DCSP return IMPL.console_get_all_by_instance(context, instance_uuid)
 DCSP return IMPL.console_get(context, console_id, instance_uuid)
 DCSP return IMPL.instance_type_create(context, values)
 DCSP return IMPL.instance_type_get_all(context, inactive=inactive, filters=filters)
 DCSP return IMPL.instance_type_get(context, id)
 DCSP return IMPL.instance_type_get_by_name(context, name)
 DCSP return IMPL.instance_type_get_by_flavor_id(context, id)
 DCSP return IMPL.instance_type_destroy(context, name)
 DCSP return IMPL.instance_type_access_get_by_flavor_id(context, flavor_id)
 DCSP return IMPL.instance_type_access_add(context, flavor_id, project_id)
 DCSP return IMPL.instance_type_access_remove(context, flavor_id, project_id)
 DCSP return IMPL.cell_create(context, values)
 DCSP return IMPL.cell_update(context, cell_name, values)
 DCSP return IMPL.cell_delete(context, cell_name)
 DCSP return IMPL.cell_get(context, cell_name)
 DCSP return IMPL.cell_get_all(context)
 DCSP return IMPL.instance_metadata_get(context, instance_uuid)
 DCSP IMPL.instance_metadata_delete(context, instance_uuid, key)
 DCSP return IMPL.instance_metadata_update(context, instance_uuid, metadata, delete)
 DCSP return IMPL.instance_system_metadata_get(context, instance_uuid)
 DCSP IMPL.instance_system_metadata_update(context, instance_uuid, metadata, delete)
 DCSP return IMPL.agent_build_create(context, values)
 DCSP return IMPL.agent_build_get_by_triple(context, hypervisor, os, architecture)
 DCSP return IMPL.agent_build_get_all(context, hypervisor)
 DCSP IMPL.agent_build_destroy(context, agent_update_id)
 DCSP IMPL.agent_build_update(context, agent_build_id, values)
 DCSP return IMPL.bw_usage_get(context, uuid, start_period, mac)
 DCSP return IMPL.bw_usage_get_by_uuids(context, uuids, start_period)
 DCSP rv = IMPL.bw_usage_update(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed=last_refreshed) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().bw_usage_update_at_top(context, uuid, mac, start_period, bw_in, bw_out, last_ctr_in, last_ctr_out, last_refreshed) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP bw_usage DCSP update')) DCNL DCSP return rv
 DCSP return IMPL.instance_type_extra_specs_get(context, flavor_id)
 DCSP IMPL.instance_type_extra_specs_delete(context, flavor_id, key)
 DCSP IMPL.instance_type_extra_specs_update_or_create(context, flavor_id, extra_specs)
 DCSP return IMPL.vol_get_usage_by_time(context, begin)
 DCSP return IMPL.vol_usage_update(context, id, rd_req, rd_bytes, wr_req, wr_bytes, instance_id, last_refreshed=last_refreshed, update_totals=update_totals)
 DCSP return IMPL.s3_image_get(context, image_id)
 DCSP return IMPL.s3_image_get_by_uuid(context, image_uuid)
 DCSP return IMPL.s3_image_create(context, image_uuid)
 DCSP return IMPL.aggregate_create(context, values, metadata)
 DCSP return IMPL.aggregate_get(context, aggregate_id)
 DCSP return IMPL.aggregate_get_by_host(context, host, key)
 DCSP return IMPL.aggregate_metadata_get_by_host(context, host, key)
 DCSP return IMPL.aggregate_host_get_by_metadata_key(context, key)
 DCSP return IMPL.aggregate_update(context, aggregate_id, values)
 DCSP return IMPL.aggregate_delete(context, aggregate_id)
 DCSP return IMPL.aggregate_get_all(context)
 DCSP IMPL.aggregate_metadata_add(context, aggregate_id, metadata, set_delete)
 DCSP return IMPL.aggregate_metadata_get(context, aggregate_id)
 DCSP IMPL.aggregate_metadata_delete(context, aggregate_id, key)
 DCSP IMPL.aggregate_host_add(context, aggregate_id, host)
 DCSP return IMPL.aggregate_host_get_all(context, aggregate_id)
 DCSP IMPL.aggregate_host_delete(context, aggregate_id, host)
 DCSP rv = IMPL.instance_fault_create(context, values) DCNL DCSP if update_cells: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cells_rpcapi.CellsAPI().instance_fault_create_at_top(context, rv) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP notify DCSP cells DCSP of DCSP instance DCSP fault')) DCNL DCSP return rv
 DCSP return IMPL.instance_fault_get_by_instance_uuids(context, instance_uuids)
 DCSP return IMPL.action_start(context, values)
 DCSP return IMPL.action_finish(context, values)
 DCSP return IMPL.actions_get(context, uuid)
 DCSP return IMPL.action_get_by_request_id(context, uuid, request_id)
 DCSP return IMPL.action_event_start(context, values)
 DCSP return IMPL.action_event_finish(context, values)
 DCSP return IMPL.action_events_get(context, action_id)
 DCSP return IMPL.get_ec2_instance_id_by_uuid(context, instance_id)
 DCSP return IMPL.get_instance_uuid_by_ec2_id(context, ec2_id)
 DCSP return IMPL.ec2_instance_create(context, instance_uuid, id)
 DCSP return IMPL.task_log_end_task(context, task_name, period_beginning, period_ending, host, errors, message)
 DCSP return IMPL.task_log_begin_task(context, task_name, period_beginning, period_ending, host, task_items, message)
 DCSP return IMPL.archive_deleted_rows(context, max_rows=max_rows)
 DCSP return IMPL.archive_deleted_rows_for_table(context, tablename, max_rows=max_rows)
 DCSP return IMPL.db_sync(version=version)
 DCSP return IMPL.db_version()
 DCSP if (session_id is None): DCNL DCSP  DCSP session_id = random.randint(0, 18446744073709551615L) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP data = struct.pack('!BQxxxxx', 56, session_id) DCNL DCSP sock.sendto(data, (address, port)) DCNL DCSP sock.settimeout(timeout) DCNL DCSP try: DCNL DCSP  DCSP received = sock.recv(2048) DCNL DCSP except socket.timeout: DCNL DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP sock.close() DCNL DCSP fmt = '!BQxxxxxQxxxx' DCNL DCSP if (len(received) != struct.calcsize(fmt)): DCNL DCSP  DCSP print struct.calcsize(fmt) DCNL DCSP  DCSP return False DCNL DCSP (identifier, server_sess, client_sess) = struct.unpack(fmt, received) DCNL DCSP if ((identifier == 64) and (client_sess == session_id)): DCNL DCSP  DCSP return server_sess
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.NovaException((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if (run_as_root and (os.geteuid() != 0)): DCNL DCSP  DCSP cmd = (['sudo', 'nova-rootwrap', CONF.rootwrap_config] + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = None DCNL DCSP  DCSP  DCSP  DCSP close_fds = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = _subprocess_setup DCNL DCSP  DCSP  DCSP  DCSP close_fds = True DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=close_fds, preexec_fn=preexec_fn, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
 DCSP if (not unit): DCNL DCSP  DCSP unit = CONF.instance_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP if (before is not None): DCNL DCSP  DCSP rightnow = before DCNL DCSP else: DCNL DCSP  DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
 DCSP if (length is None): DCNL DCSP  DCSP length = CONF.password_length DCNL DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
 DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
 DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
 DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
 DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP if (path is None): DCNL DCSP  DCSP raise exception.NovaException('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.NovaException('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
 DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
 DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
 DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
 DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
 DCSP result = dict(((k, ['-']) for k in (set(orig.keys()) - set(new.keys())))) DCNL DCSP for (key, value) in new.items(): DCNL DCSP  DCSP if ((key not in orig) or (value != orig[key])): DCNL DCSP  DCSP  DCSP result[key] = ['+', value] DCNL DCSP return result
 DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls)))
 DCSP try: DCNL DCSP  DCSP if netaddr.valid_ipv6(server_str): DCNL DCSP  DCSP  DCSP return (server_str, '') DCNL DCSP  DCSP if (server_str.find(']:') != (-1)): DCNL DCSP  DCSP  DCSP (address, port) = server_str.replace('[', '', 1).split(']:') DCNL DCSP  DCSP  DCSP return (address, port) DCNL DCSP  DCSP if (server_str.find(':') == (-1)): DCNL DCSP  DCSP  DCSP return (server_str, '') DCNL DCSP  DCSP (address, port) = server_str.split(':') DCNL DCSP  DCSP return (address, port) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('Invalid DCSP server_string: DCSP %s'), server_str) DCNL DCSP  DCSP return ('', '')
 DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return ((val.lower() == 'true') or (val.lower() == 'yes') or (val.lower() == 'y'))
 DCSP try: DCNL DCSP  DCSP return (str(int(val)) == str(val)) DCNL DCSP except Exception: DCNL DCSP  DCSP return False
 DCSP boolstrs = ('true', 'false', 'yes', 'no', 'y', 'n', '1', '0') DCNL DCSP return (str(val).lower() in boolstrs)
 DCSP try: DCNL DCSP  DCSP return netaddr.valid_ipv4(address) DCNL DCSP except Exception: DCNL DCSP  DCSP return False
 DCSP try: DCNL DCSP  DCSP netaddr.IPNetwork(address) DCNL DCSP except netaddr.core.AddrFormatError: DCNL DCSP  DCSP return False DCNL DCSP except UnboundLocalError: DCNL DCSP  DCSP return False DCNL DCSP ip_segment = address.split('/') DCNL DCSP if ((len(ip_segment) <= 1) or (ip_segment[1] == '')): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if (netaddr.IPNetwork(network).version == 6): DCNL DCSP  DCSP return 'IPv6' DCNL DCSP elif (netaddr.IPNetwork(network).version == 4): DCNL DCSP  DCSP return 'IPv4'
 DCSP if (not CONF.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in CONF.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
 DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
 DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
 DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
 DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
 DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP LOG.debug((_('Reloading DCSP cached DCSP file DCSP %s') % filename)) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP return file(*args, **kwargs)
 DCSP checksum = hashlib.sha1() DCNL DCSP for chunk in iter((lambda : file_like_object.read(32768)), ''): DCNL DCSP  DCSP checksum.update(chunk) DCNL DCSP return checksum.hexdigest()
 DCSP def is_dict_like(thing): DCNL DCSP  DCSP return hasattr(thing, 'has_key') DCNL DCSP def get(thing, attr, default): DCNL DCSP  DCSP if is_dict_like(thing): DCNL DCSP  DCSP  DCSP return thing.get(attr, default) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return getattr(thing, attr, default) DCNL DCSP def set_value(thing, attr, val): DCNL DCSP  DCSP if is_dict_like(thing): DCNL DCSP  DCSP  DCSP thing[attr] = val DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP setattr(thing, attr, val) DCNL DCSP def delete(thing, attr): DCNL DCSP  DCSP if is_dict_like(thing): DCNL DCSP  DCSP  DCSP del thing[attr] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP delattr(thing, attr) DCNL DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = get(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP set_value(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP delete(obj, attr) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP set_value(obj, attr, old_value)
 DCSP mac = [250, 22, 62, random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
 DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
 DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
 DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
 DCSP if (fs == 'swap'): DCNL DCSP  DCSP args = ['mkswap'] DCNL DCSP else: DCNL DCSP  DCSP args = ['mkfs', '-t', fs] DCNL DCSP if (fs in ('ext3', 'ext4')): DCNL DCSP  DCSP args.extend(['-F']) DCNL DCSP if label: DCNL DCSP  DCSP if (fs in ('msdos', 'vfat')): DCNL DCSP  DCSP  DCSP label_opt = '-n' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP label_opt = '-L' DCNL DCSP  DCSP args.extend([label_opt, label]) DCNL DCSP args.append(path) DCNL DCSP execute(*args)
 DCSP try: DCNL DCSP  DCSP file_like_object.seek((- num), os.SEEK_END) DCNL DCSP except IOError as e: DCNL DCSP  DCSP if (e.errno == 22): DCNL DCSP  DCSP  DCSP file_like_object.seek(0, os.SEEK_SET) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP remaining = file_like_object.tell() DCNL DCSP return (file_like_object.read(), remaining)
 DCSP if ((not hasattr(function, 'func_closure')) or (not function.func_closure)): DCNL DCSP  DCSP return function DCNL DCSP def _get_wrapped_function(function): DCNL DCSP  DCSP if ((not hasattr(function, 'func_closure')) or (not function.func_closure)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP for closure in function.func_closure: DCNL DCSP  DCSP  DCSP func = closure.cell_contents DCNL DCSP  DCSP  DCSP deeper_func = _get_wrapped_function(func) DCNL DCSP  DCSP  DCSP if deeper_func: DCNL DCSP  DCSP  DCSP  DCSP return deeper_func DCNL DCSP  DCSP  DCSP elif hasattr(closure.cell_contents, '__call__'): DCNL DCSP  DCSP  DCSP  DCSP return closure.cell_contents DCNL DCSP return _get_wrapped_function(function)
 DCSP if (not isinstance(value, basestring)): DCNL DCSP  DCSP msg = (_('%s DCSP is DCSP not DCSP a DCSP string DCSP or DCSP unicode') % name) DCNL DCSP  DCSP raise exception.InvalidInput(message=msg) DCNL DCSP if (len(value) < min_length): DCNL DCSP  DCSP msg = (_('%(name)s DCSP has DCSP less DCSP than DCSP %(min_length)s DCSP characters.') % locals()) DCNL DCSP  DCSP raise exception.InvalidInput(message=msg) DCNL DCSP if (max_length and (len(value) > max_length)): DCNL DCSP  DCSP msg = (_('%(name)s DCSP has DCSP more DCSP than DCSP %(max_length)s DCSP characters.') % locals()) DCNL DCSP  DCSP raise exception.InvalidInput(message=msg)
 DCSP init() DCNL DCSP credentials = context.to_dict() DCNL DCSP extra = {} DCNL DCSP if do_raise: DCNL DCSP  DCSP extra.update(exc=exception.PolicyNotAuthorized, action=action) DCNL DCSP return policy.check(action, target, credentials, **extra)
 DCSP init() DCNL DCSP credentials = context.to_dict() DCNL DCSP target = credentials DCNL DCSP return policy.check('context_is_admin', target, credentials)
 DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, *args, **kwargs): DCNL DCSP  DCSP @contextlib.contextmanager DCNL DCSP  DCSP def fake_vdi_attached_here(*args, **kwargs): DCNL DCSP  DCSP  DCSP fake_dev = 'fakedev' DCNL DCSP  DCSP  DCSP (yield fake_dev) DCNL DCSP  DCSP def fake_image_download(*args, **kwargs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP def fake_is_vdi_pv(*args, **kwargs): DCNL DCSP  DCSP  DCSP return should_return DCNL DCSP  DCSP orig_vdi_attached_here = vm_utils.vdi_attached_here DCNL DCSP  DCSP orig_image_download = fake_image._FakeImageService.download DCNL DCSP  DCSP orig_is_vdi_pv = vm_utils._is_vdi_pv DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vm_utils.vdi_attached_here = fake_vdi_attached_here DCNL DCSP  DCSP  DCSP fake_image._FakeImageService.download = fake_image_download DCNL DCSP  DCSP  DCSP vm_utils._is_vdi_pv = fake_is_vdi_pv DCNL DCSP  DCSP  DCSP return function(self, *args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP vm_utils._is_vdi_pv = orig_is_vdi_pv DCNL DCSP  DCSP  DCSP fake_image._FakeImageService.download = orig_image_download DCNL DCSP  DCSP  DCSP vm_utils.vdi_attached_here = orig_vdi_attached_here DCNL DCSP return decorated_function
 DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP return instances
 DCSP if (('die' in req.params) and (req.params['die'] == '1')): DCNL DCSP  DCSP raise webob.exc.HTTPForbidden() DCNL DCSP return 'OK'
 DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': get_fake_cache()} DCNL DCSP return instances
 DCSP base_url = url DCNL DCSP def web_request(url, method=None, body=None): DCNL DCSP  DCSP req = webob.Request.blank(('%s%s' % (base_url, url))) DCNL DCSP  DCSP if method: DCNL DCSP  DCSP  DCSP req.content_type = 'application/json' DCNL DCSP  DCSP  DCSP req.method = method DCNL DCSP  DCSP if body: DCNL DCSP  DCSP  DCSP req.body = jsonutils.dumps(body) DCNL DCSP  DCSP return req DCNL DCSP return web_request
 DCSP return compare_tree_to_dict(actual, expected, ('rel', 'href', 'type'))
 DCSP return compare_tree_to_dict(actual, expected, ('base', 'type'))
 DCSP for (elem, data) in zip(actual, expected): DCNL DCSP  DCSP for key in keys: DCNL DCSP  DCSP  DCSP if (elem.get(key) != data.get(key)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP class HTTPConnectionDecorator(object, ): DCNL DCSP  DCSP 'Wraps DCSP the DCSP real DCSP HTTPConnection DCSP class DCSP so DCSP that DCSP when DCSP you DCSP instantiate\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP class DCSP you DCSP might DCSP instead DCSP get DCSP a DCSP fake DCSP instance.' DCNL DCSP  DCSP def __init__(self, wrapped): DCNL DCSP  DCSP  DCSP self.wrapped = wrapped DCNL DCSP  DCSP def __call__(self, connection_host, *args, **kwargs): DCNL DCSP  DCSP  DCSP if (connection_host == host): DCNL DCSP  DCSP  DCSP  DCSP return FakeHttplibConnection(app, host) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return self.wrapped(connection_host, *args, **kwargs) DCNL DCSP oldHTTPConnection = httplib.HTTPConnection DCNL DCSP httplib.HTTPConnection = HTTPConnectionDecorator(httplib.HTTPConnection) DCNL DCSP return oldHTTPConnection
 DCSP results = {True: 'enabled', False: 'disabled'} DCNL DCSP if (host_name == 'notimplemented'): DCNL DCSP  DCSP raise NotImplementedError() DCNL DCSP elif (host_name == 'dummydest'): DCNL DCSP  DCSP raise exception.ComputeHostNotFound(host=host_name) DCNL DCSP elif (host_name == 'host_c2'): DCNL DCSP  DCSP return results[(not enabled)] DCNL DCSP else: DCNL DCSP  DCSP return results[enabled]
 DCSP ctxt = context_maker.get_admin_context() DCNL DCSP return db.instance_create(ctxt, _create_instance_dict(**kwargs))
 DCSP inst = {} DCNL DCSP inst['image_ref'] = 'cedef40a-ed67-4d10-800e-17455edce175' DCNL DCSP inst['reservation_id'] = 'r-fakeres' DCNL DCSP inst['user_id'] = kwargs.get('user_id', 'admin') DCNL DCSP inst['project_id'] = kwargs.get('project_id', 'fake') DCNL DCSP inst['instance_type_id'] = '1' DCNL DCSP if ('host' in kwargs): DCNL DCSP  DCSP inst['host'] = kwargs.get('host') DCNL DCSP inst['vcpus'] = kwargs.get('vcpus', 1) DCNL DCSP inst['memory_mb'] = kwargs.get('memory_mb', 20) DCNL DCSP inst['root_gb'] = kwargs.get('root_gb', 30) DCNL DCSP inst['ephemeral_gb'] = kwargs.get('ephemeral_gb', 30) DCNL DCSP inst['vm_state'] = kwargs.get('vm_state', vm_states.ACTIVE) DCNL DCSP inst['power_state'] = kwargs.get('power_state', power_state.RUNNING) DCNL DCSP inst['task_state'] = kwargs.get('task_state', None) DCNL DCSP inst['availability_zone'] = kwargs.get('availability_zone', None) DCNL DCSP inst['ami_launch_index'] = 0 DCNL DCSP inst['launched_on'] = kwargs.get('launched_on', 'dummy') DCNL DCSP return inst
 DCSP if ('id' in action): DCNL DCSP  DCSP del action['id'] DCNL DCSP if ('finish_time' in action): DCNL DCSP  DCSP del action['finish_time'] DCNL DCSP return action
 DCSP if ('id' in event): DCNL DCSP  DCSP del event['id'] DCNL DCSP return event
 DCSP return urllib.quote(domain.replace('.', '%2E'))
 DCSP orig_add_image = glanceclient.v1.images.ImageManager.create DCNL DCSP def fake_create(context, metadata, data=None): DCNL DCSP  DCSP sent_to_glance['metadata'] = metadata DCNL DCSP  DCSP sent_to_glance['data'] = data DCNL DCSP  DCSP return orig_add_image(metadata, data) DCNL DCSP stubs.Set(glanceclient.v1.images.ImageManager, 'create', fake_create)
 DCSP for func in funcs: DCNL DCSP  DCSP func_name = '_'.join(func.__name__.split('_')[1:]) DCNL DCSP  DCSP stubs.Set(db, func_name, func) DCNL DCSP  DCSP stubs.Set(db.sqlalchemy.api, func_name, func)
 DCSP INSTANCE_TYPES = {'m1.tiny': dict(id=2, name='m1.tiny', memory_mb=512, vcpus=1, vcpu_weight=None, root_gb=0, ephemeral_gb=10, flavorid=1, rxtx_factor=1.0, swap=0), 'm1.small': dict(id=5, name='m1.small', memory_mb=2048, vcpus=1, vcpu_weight=None, root_gb=20, ephemeral_gb=0, flavorid=2, rxtx_factor=1.0, swap=1024), 'm1.medium': dict(id=1, name='m1.medium', memory_mb=4096, vcpus=2, vcpu_weight=None, root_gb=40, ephemeral_gb=40, flavorid=3, rxtx_factor=1.0, swap=0), 'm1.large': dict(id=3, name='m1.large', memory_mb=8192, vcpus=4, vcpu_weight=None, root_gb=80, ephemeral_gb=80, flavorid=4, rxtx_factor=1.0, swap=0), 'm1.xlarge': dict(id=4, name='m1.xlarge', memory_mb=16384, vcpus=8, vcpu_weight=None, root_gb=160, ephemeral_gb=160, flavorid=5, rxtx_factor=1.0, swap=0)} DCNL DCSP flat_network_fields = {'id': 'fake_flat', 'bridge': 'xenbr0', 'label': 'fake_flat_network', 'netmask': '255.255.255.0', 'cidr_v6': 'fe80::a00:0/120', 'netmask_v6': '120', 'gateway': '10.0.0.1', 'gateway_v6': 'fe80::a00:1', 'broadcast': '10.0.0.255', 'dns': '10.0.0.2', 'ra_server': None, 'injected': injected} DCNL DCSP vlan_network_fields = {'id': 'fake_vlan', 'bridge': 'br111', 'label': 'fake_vlan_network', 'netmask': '255.255.255.0', 'cidr_v6': 'fe80::a00:0/120', 'netmask_v6': '120', 'gateway': '10.0.0.1', 'gateway_v6': 'fe80::a00:1', 'broadcast': '10.0.0.255', 'dns': '10.0.0.2', 'ra_server': None, 'vlan': 111, 'injected': False} DCNL DCSP fixed_ip_fields = {'address': '10.0.0.3', 'address_v6': 'fe80::a00:3', 'network_id': 'fake_flat'} DCNL DCSP def fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP def fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP def fake_instance_type_get(context, id): DCNL DCSP  DCSP for (name, inst_type) in INSTANCE_TYPES.iteritems(): DCNL DCSP  DCSP  DCSP if (str(inst_type['id']) == str(id)): DCNL DCSP  DCSP  DCSP  DCSP return inst_type DCNL DCSP  DCSP return None DCNL DCSP def fake_network_get_all_by_instance(context, instance_id): DCNL DCSP  DCSP if ((instance_id % 2) == 0): DCNL DCSP  DCSP  DCSP return [FakeModel(vlan_network_fields)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return [FakeModel(flat_network_fields)] DCNL DCSP def fake_fixed_ip_get_by_instance(context, instance_id): DCNL DCSP  DCSP return [FakeModel(fixed_ip_fields)] DCNL DCSP funcs = [fake_network_get_all_by_instance, fake_instance_type_get_all, fake_instance_type_get_by_name, fake_instance_type_get, fake_network_get_all_by_instance, fake_fixed_ip_get_by_instance] DCNL DCSP stub_out(stubs, funcs)
 DCSP return ''.join((random.choice((string.ascii_uppercase + string.digits)) for _x in range(length)))
 DCSP return ''.join((random.choice(string.digits) for _x in range(length)))
 DCSP while True: DCNL DCSP  DCSP if numeric: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_numeric(8)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP candidate = (prefix + generate_random_alphanumeric(8)) DCNL DCSP  DCSP if (candidate not in items): DCNL DCSP  DCSP  DCSP return candidate DCNL DCSP  DCSP LOG.debug(('Random DCSP collision DCSP on DCSP %s' % candidate))
 DCSP global _fake_execute_repliers DCNL DCSP _fake_execute_repliers = repliers
 DCSP return ('', '')
 DCSP global _fake_execute_repliers DCNL DCSP process_input = kwargs.get('process_input', None) DCNL DCSP check_exit_code = kwargs.get('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.get('delay_on_retry', True) DCNL DCSP attempts = kwargs.get('attempts', 1) DCNL DCSP run_as_root = kwargs.get('run_as_root', False) DCNL DCSP cmd_str = ' DCSP '.join((str(part) for part in cmd_parts)) DCNL DCSP LOG.debug(_('Faking DCSP execution DCSP of DCSP cmd DCSP (subprocess): DCSP %s'), cmd_str) DCNL DCSP _fake_execute_log.append(cmd_str) DCNL DCSP reply_handler = fake_execute_default_reply_handler DCNL DCSP for fake_replier in _fake_execute_repliers: DCNL DCSP  DCSP if re.match(fake_replier[0], cmd_str): DCNL DCSP  DCSP  DCSP reply_handler = fake_replier[1] DCNL DCSP  DCSP  DCSP LOG.debug((_('Faked DCSP command DCSP matched DCSP %s') % fake_replier[0])) DCNL DCSP  DCSP  DCSP break DCNL DCSP if isinstance(reply_handler, basestring): DCNL DCSP  DCSP reply = (reply_handler, '') DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP reply = reply_handler(cmd_parts, process_input=process_input, delay_on_retry=delay_on_retry, attempts=attempts, run_as_root=run_as_root, check_exit_code=check_exit_code) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Faked DCSP command DCSP raised DCSP an DCSP exception DCSP %s'), e) DCNL DCSP  DCSP  DCSP raise DCNL DCSP stdout = reply[0] DCNL DCSP stderr = reply[1] DCNL DCSP LOG.debug((_("Reply DCSP to DCSP faked DCSP command DCSP is DCSP stdout='%(stdout)s' DCSP stderr='%(stderr)s'") % locals())) DCNL DCSP greenthread.sleep(0) DCNL DCSP return reply
 DCSP INSTANCE_TYPES = {'m1.tiny': dict(memory_mb=512, vcpus=1, root_gb=0, flavorid=1), 'm1.small': dict(memory_mb=2048, vcpus=1, root_gb=20, flavorid=2), 'm1.medium': dict(memory_mb=4096, vcpus=2, root_gb=40, flavorid=3), 'm1.large': dict(memory_mb=8192, vcpus=4, root_gb=80, flavorid=4), 'm1.xlarge': dict(memory_mb=16384, vcpus=8, root_gb=160, flavorid=5)} DCNL DCSP class FakeModel(object, ): DCNL DCSP  DCSP 'Stubs DCSP out DCSP for DCSP model.' DCNL DCSP  DCSP def __init__(self, values): DCNL DCSP  DCSP  DCSP self.values = values DCNL DCSP  DCSP def __getattr__(self, name): DCNL DCSP  DCSP  DCSP return self.values[name] DCNL DCSP  DCSP def __getitem__(self, key): DCNL DCSP  DCSP  DCSP if (key in self.values): DCNL DCSP  DCSP  DCSP  DCSP return self.values[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementedError() DCNL DCSP def fake_instance_create(context, values): DCNL DCSP  DCSP 'Stubs DCSP out DCSP the DCSP db.instance_create DCSP method.' DCNL DCSP  DCSP type_data = INSTANCE_TYPES[values['instance_type']] DCNL DCSP  DCSP base_options = {'name': values['name'], 'id': values['id'], 'uuid': uuid.uuid4(), 'reservation_id': utils.generate_uid('r'), 'image_ref': values['image_ref'], 'kernel_id': values['kernel_id'], 'ramdisk_id': values['ramdisk_id'], 'vm_state': vm_states.BUILDING, 'task_state': task_states.SCHEDULING, 'user_id': values['user_id'], 'project_id': values['project_id'], 'launch_time': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'instance_type': values['instance_type'], 'memory_mb': type_data['memory_mb'], 'vcpus': type_data['vcpus'], 'mac_addresses': [{'address': values['mac_address']}], 'root_gb': type_data['root_gb']} DCNL DCSP  DCSP return FakeModel(base_options) DCNL DCSP def fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP def fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP stubs.Set(db, 'instance_create', fake_instance_create) DCNL DCSP stubs.Set(db, 'instance_type_get_all', fake_instance_type_get_all) DCNL DCSP stubs.Set(db, 'instance_type_get_by_name', fake_instance_type_get_by_name)
 DCSP return fake.FakeVim()
 DCSP return isinstance(module, fake.FakeVim)
 DCSP stubs.Set(vmops.VMwareVMOps, 'plug_vifs', fake.fake_plug_vifs) DCNL DCSP stubs.Set(network_util, 'get_network_with_the_name', fake.fake_get_network) DCNL DCSP stubs.Set(vmware_images, 'fetch_image', fake.fake_fetch_image) DCNL DCSP stubs.Set(vmware_images, 'get_vmdk_size_and_properties', fake.fake_get_vmdk_size_and_properties) DCNL DCSP stubs.Set(vmware_images, 'upload_image', fake.fake_upload_image) DCNL DCSP stubs.Set(driver.VMwareAPISession, '_get_vim_object', fake_get_vim_object) DCNL DCSP stubs.Set(driver.VMwareAPISession, '_is_vim_object', fake_is_vim_object)
 DCSP return FakeLDAP()
 DCSP inner = query[1:(-1)] DCNL DCSP if inner.startswith('&'): DCNL DCSP  DCSP (l, r) = _paren_groups(inner[1:]) DCNL DCSP  DCSP return (_match_query(l, attrs) and _match_query(r, attrs)) DCNL DCSP if inner.startswith('|'): DCNL DCSP  DCSP (l, r) = _paren_groups(inner[1:]) DCNL DCSP  DCSP return (_match_query(l, attrs) or _match_query(r, attrs)) DCNL DCSP if inner.startswith('!'): DCNL DCSP  DCSP return (not _match_query(query[2:(-1)], attrs)) DCNL DCSP (k, _sep, v) = inner.partition('=') DCNL DCSP return _match(k, v, attrs)
 DCSP count = 0 DCNL DCSP start = 0 DCNL DCSP result = [] DCNL DCSP for pos in xrange(len(source)): DCNL DCSP  DCSP if (source[pos] == '('): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP if (source[pos] == ')'): DCNL DCSP  DCSP  DCSP count -= 1 DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP result.append(source[start:(pos + 1)]) DCNL DCSP return result
 DCSP if (key not in attrs): DCNL DCSP  DCSP return False DCNL DCSP if (value == '*'): DCNL DCSP  DCSP return True DCNL DCSP if (key != 'objectclass'): DCNL DCSP  DCSP return (value in attrs[key]) DCNL DCSP values = _subs(value) DCNL DCSP for v in values: DCNL DCSP  DCSP if (v in attrs[key]): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP subs = {'groupOfNames': ['novaProject']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
 DCSP return [str(x) for x in jsonutils.loads(encoded)]
 DCSP return jsonutils.dumps(list(unencoded))
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP CALLED_FUNCTION.append(name) DCNL DCSP  DCSP return function(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP def wrapped_func(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(self, *args, **kwargs) DCNL DCSP  DCSP except NotImplementedError: DCNL DCSP  DCSP  DCSP frame = traceback.extract_tb(sys.exc_info()[2])[(-1)] DCNL DCSP  DCSP  DCSP LOG.error(('%(driver)s DCSP does DCSP not DCSP implement DCSP %(method)s' % {'driver': type(self.connection), 'method': frame[2]})) DCNL DCSP wrapped_func.__name__ = f.__name__ DCNL DCSP wrapped_func.__doc__ = f.__doc__ DCNL DCSP return wrapped_func
 DCSP INSTANCE_TYPES = {'m1.tiny': dict(memory_mb=512, vcpus=1, root_gb=0, flavorid=1), 'm1.small': dict(memory_mb=2048, vcpus=1, root_gb=20, flavorid=2), 'm1.medium': dict(memory_mb=4096, vcpus=2, root_gb=40, flavorid=3), 'm1.large': dict(memory_mb=8192, vcpus=4, root_gb=80, flavorid=4), 'm1.xlarge': dict(memory_mb=16384, vcpus=8, root_gb=160, flavorid=5)} DCNL DCSP class FakeModel(object, ): DCNL DCSP  DCSP 'Stubs DCSP out DCSP for DCSP model.' DCNL DCSP  DCSP def __init__(self, values): DCNL DCSP  DCSP  DCSP self.values = values DCNL DCSP  DCSP def get(self, key, default=None): DCNL DCSP  DCSP  DCSP if (key in self.values): DCNL DCSP  DCSP  DCSP  DCSP return self.values[key] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return default DCNL DCSP  DCSP def __getattr__(self, name): DCNL DCSP  DCSP  DCSP return self.values[name] DCNL DCSP  DCSP def __getitem__(self, key): DCNL DCSP  DCSP  DCSP return self.get(key) DCNL DCSP  DCSP def __setitem__(self, key, value): DCNL DCSP  DCSP  DCSP self.values[key] = value DCNL DCSP  DCSP def __str__(self): DCNL DCSP  DCSP  DCSP return str(self.values) DCNL DCSP def fake_instance_create(context, values): DCNL DCSP  DCSP 'Stubs DCSP out DCSP the DCSP db.instance_create DCSP method.' DCNL DCSP  DCSP if ('instance_type' not in values): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP instance_type = values['instance_type'] DCNL DCSP  DCSP base_options = {'name': values['name'], 'id': values['id'], 'uuid': str(uuid.uuid4()), 'reservation_id': utils.generate_uid('r'), 'image_ref': values['image_ref'], 'kernel_id': values['kernel_id'], 'ramdisk_id': values['ramdisk_id'], 'vm_state': vm_states.BUILDING, 'task_state': task_states.SCHEDULING, 'user_id': values['user_id'], 'project_id': values['project_id'], 'launch_time': time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()), 'instance_type': instance_type, 'memory_mb': instance_type['memory_mb'], 'vcpus': instance_type['vcpus'], 'mac_addresses': [{'address': values['mac_address']}], 'root_gb': instance_type['root_gb']} DCNL DCSP  DCSP return FakeModel(base_options) DCNL DCSP def fake_instance_type_get_all(context, inactive=0, filters=None): DCNL DCSP  DCSP return INSTANCE_TYPES.values() DCNL DCSP def fake_instance_type_get_by_name(context, name): DCNL DCSP  DCSP return INSTANCE_TYPES[name] DCNL DCSP def fake_block_device_mapping_get_all_by_instance(context, instance_uuid): DCNL DCSP  DCSP return {} DCNL DCSP stubs.Set(db, 'instance_create', fake_instance_create) DCNL DCSP stubs.Set(db, 'instance_type_get_all', fake_instance_type_get_all) DCNL DCSP stubs.Set(db, 'instance_type_get_by_name', fake_instance_type_get_by_name) DCNL DCSP stubs.Set(db, 'block_device_mapping_get_all_by_instance', fake_block_device_mapping_get_all_by_instance)
 DCSP stubs.Set(xenapi_conn.XenAPISession, '_create_session', (lambda s, url: cls(url, **opt_args))) DCNL DCSP stubs.Set(xenapi_conn.XenAPISession, '_get_product_version_and_brand', (lambda s: (product_version, product_brand)))
 DCSP def f(*args): DCNL DCSP  DCSP return False DCNL DCSP stubs.Set(vm_utils, '_determine_is_pv_objectstore', f)
 DCSP def f(*args): DCNL DCSP  DCSP return True DCNL DCSP stubs.Set(vm_utils, 'is_snapshot', f)
 DCSP def f(_1, _2, _3, _4): DCNL DCSP  DCSP raise Exception('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP lookup_image') DCNL DCSP stubs.Set(vm_utils, 'lookup_image', f)
 DCSP def _fake_fetch_disk_image(context, session, instance, name_label, image, image_type): DCNL DCSP  DCSP if raise_failure: DCNL DCSP  DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP fetch_image_glance_disk') DCNL DCSP  DCSP elif (image_type == vm_utils.ImageType.KERNEL): DCNL DCSP  DCSP  DCSP filename = 'kernel' DCNL DCSP  DCSP elif (image_type == vm_utils.ImageType.RAMDISK): DCNL DCSP  DCSP  DCSP filename = 'ramdisk' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filename = 'unknown' DCNL DCSP  DCSP vdi_type = vm_utils.ImageType.to_string(image_type) DCNL DCSP  DCSP return {vdi_type: dict(uuid=None, file=filename)} DCNL DCSP stubs.Set(vm_utils, '_fetch_disk_image', _fake_fetch_disk_image)
 DCSP def f(*args): DCNL DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP create_vm') DCNL DCSP stubs.Set(vm_utils, 'create_vm', f)
 DCSP def f(*args): DCNL DCSP  DCSP raise fake.Failure('Test DCSP Exception DCSP raised DCSP by DCSP fake DCSP _attach_disks') DCNL DCSP stubs.Set(vmops.VMOps, '_attach_disks', f)
 DCSP if (backend == 'postgres'): DCNL DCSP  DCSP backend = 'postgresql+psycopg2' DCNL DCSP elif (backend == 'mysql'): DCNL DCSP  DCSP backend = 'mysql+mysqldb' DCNL DCSP else: DCNL DCSP  DCSP raise Exception(("Unrecognized DCSP backend: DCSP '%s'" % backend)) DCNL DCSP return ('%(backend)s://%(user)s:%(passwd)s@localhost/%(database)s' % locals())
 DCSP metadata = sqlalchemy.schema.MetaData() DCNL DCSP metadata.bind = engine DCNL DCSP return sqlalchemy.Table(name, metadata, autoload=True)
 DCSP instances = orig_func(*args, **kwargs) DCNL DCSP if isinstance(instances, list): DCNL DCSP  DCSP for instance in instances: DCNL DCSP  DCSP  DCSP instance['info_cache'] = {'network_info': _get_fake_cache()} DCNL DCSP else: DCNL DCSP  DCSP instances['info_cache'] = {'network_info': _get_fake_cache()} DCNL DCSP return instances
 DCSP def outer(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP manager = _HOOKS.setdefault(name, HookManager(name)) DCNL DCSP  DCSP  DCSP manager.run_pre(name, args, kwargs) DCNL DCSP  DCSP  DCSP rv = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP manager.run_post(name, rv, args, kwargs) DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP _HOOKS.clear()
 DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf(product_name) DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
 DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
 DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
 DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
 DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
 DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
 DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
 DCSP return _get_impl().create_connection(CONF, new=new)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().cast(CONF, context, topic, msg)
 DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
 DCSP return _get_impl().cleanup()
 DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return (('%s.%s' % (topic, host)) if host else topic)
 DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP return Connection()
 DCSP json.dumps(msg)
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
 DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
 DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
 DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
 DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
 DCSP return _multi_send(_call, *args, **kwargs)
 DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
 DCSP _multi_send(_cast, *args, **kwargs)
 DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
 DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
 DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
 DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
 DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
 DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP str = at.strftime(TIME_FORMAT) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP str += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return str
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise InvalidSortKey() DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP cfg.set_defaults(sql_opts, sql_connection=sql_connection, sqlite_db=sqlite_db)
 DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP return session
 DCSP def get_columns_from_uniq_cons_or_name(columns): DCNL DCSP  DCSP uniqbase = 'uniq_' DCNL DCSP  DCSP if (not columns.startswith(uniqbase)): DCNL DCSP  DCSP  DCSP if (engine_name == 'postgresql'): DCNL DCSP  DCSP  DCSP  DCSP return [columns[(columns.index('_') + 1):columns.rindex('_')]] DCNL DCSP  DCSP  DCSP return [columns] DCNL DCSP  DCSP return columns[len(uniqbase):].split('_x_') DCNL DCSP if (engine_name not in ['mysql', 'sqlite', 'postgresql']): DCNL DCSP  DCSP return DCNL DCSP m = _DUP_KEY_RE_DB[engine_name].match(integrity_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP columns = m.group(1) DCNL DCSP if (engine_name == 'sqlite'): DCNL DCSP  DCSP columns = columns.strip().split(', DCSP ') DCNL DCSP else: DCNL DCSP  DCSP columns = get_columns_from_uniq_cons_or_name(columns) DCNL DCSP raise exception.DBDuplicateEntry(columns, integrity_error)
 DCSP re = _DEADLOCK_RE_DB.get(engine_name) DCNL DCSP if (re is None): DCNL DCSP  DCSP return DCNL DCSP m = re.match(operational_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP raise exception.DBDeadlock(operational_error)
 DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = create_engine(CONF.sql_connection) DCNL DCSP return _ENGINE
 DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
 DCSP def regexp(expr, item): DCNL DCSP  DCSP reg = re.compile(expr) DCNL DCSP  DCSP return (reg.search(unicode(item)) is not None) DCNL DCSP dbapi_con.create_function('regexp', 2, regexp)
 DCSP greenthread.sleep(0)
 DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise sqla_exc.DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP connection_dict = sqlalchemy.engine.url.make_url(sql_connection) DCNL DCSP engine_args = {'pool_recycle': CONF.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP if (CONF.sql_connection_debug >= 100): DCNL DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP elif (CONF.sql_connection_debug >= 50): DCNL DCSP  DCSP engine_args['echo'] = True DCNL DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP if (CONF.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP else: DCNL DCSP  DCSP engine_args['pool_size'] = CONF.sql_max_pool_size DCNL DCSP  DCSP if (CONF.sql_max_overflow is not None): DCNL DCSP  DCSP  DCSP engine_args['max_overflow'] = CONF.sql_max_overflow DCNL DCSP engine = sqlalchemy.create_engine(sql_connection, **engine_args) DCNL DCSP sqlalchemy.event.listen(engine, 'checkin', greenthread_yield) DCNL DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'checkout', ping_listener) DCNL DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP if (not CONF.sqlite_synchronous): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', add_regexp_listener) DCNL DCSP if (CONF.sql_connection_trace and (engine.dialect.dbapi.__name__ == 'MySQLdb')): DCNL DCSP  DCSP patch_mysqldb_with_stacktrace_comments() DCNL DCSP try: DCNL DCSP  DCSP engine.connect() DCNL DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP remaining = CONF.sql_max_retries DCNL DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP time.sleep(CONF.sql_retry_interval) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP engine.connect() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return engine
 DCSP return sqlalchemy.orm.sessionmaker(bind=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, query_cls=Query)
 DCSP import MySQLdb.cursors DCNL DCSP import traceback DCNL DCSP old_mysql_do_query = MySQLdb.cursors.BaseCursor._do_query DCNL DCSP def _do_query(self, q): DCNL DCSP  DCSP stack = '' DCNL DCSP  DCSP for (file, line, method, function) in traceback.extract_stack(): DCNL DCSP  DCSP  DCSP if (file.endswith('session.py') and (method == '_do_query')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('api.py') and (method == 'wrapper')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('utils.py') and (method == '_inner')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('exception.py') and (method == '_wrap')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if file.endswith('db/api.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP index = file.rfind('nova') DCNL DCSP  DCSP  DCSP if (index == (-1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP stack += ('File:%s:%s DCSP Method:%s() DCSP Line:%s DCSP | DCSP ' % (file[index:], line, method, function)) DCNL DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP stack = stack[:(-3)] DCNL DCSP  DCSP  DCSP qq = ('%s DCSP /* DCSP %s DCSP */' % (q, stack)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qq = q DCNL DCSP  DCSP old_mysql_do_query(self, qq) DCNL DCSP setattr(MySQLdb.cursors.BaseCursor, '_do_query', _do_query)
 DCSP argspec = inspect.getargspec(fn) DCNL DCSP num_defaults = len((argspec.defaults or [])) DCNL DCSP required_args = argspec.args[:(len(argspec.args) - num_defaults)] DCNL DCSP def isbound(method): DCNL DCSP  DCSP return (getattr(method, 'im_self', None) is not None) DCNL DCSP if isbound(fn): DCNL DCSP  DCSP required_args.pop(0) DCNL DCSP missing = [arg for arg in required_args if (arg not in kwargs)] DCNL DCSP missing = missing[len(args):] DCNL DCSP if missing: DCNL DCSP  DCSP raise MissingArgs(missing)
 DCSP global _rules DCNL DCSP _rules = rules
 DCSP global _rules DCNL DCSP _rules = None
 DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
 DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
 DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
 DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
 DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP signed_cmd = (('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authored-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signed_entries = _run_shell_command(signed_cmd) DCNL DCSP  DCSP  DCSP if signed_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signed.split(':', 1)[1].strip() for signed in signed_entries.split('\n') if signed]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('nova.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP cmd = (shlex.split(root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(check_exit_code, int) and (not isinstance(check_exit_code, bool)) and (_returncode != check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
 DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
 DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
 DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
 DCSP def decorator(f): DCNL DCSP  DCSP if ('ticks_between_runs' in kwargs): DCNL DCSP  DCSP  DCSP raise exception.InvalidPeriodicTaskArg(arg='ticks_between_runs') DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._periodic_external_ok = kwargs.pop('external_process_ok', False) DCNL DCSP  DCSP if (f._periodic_external_ok and (not CONF.run_external_periodic_tasks)): DCNL DCSP  DCSP  DCSP f._periodic_enabled = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f._periodic_enabled = kwargs.pop('enabled', True) DCNL DCSP  DCSP f._periodic_spacing = kwargs.pop('spacing', 0) DCNL DCSP  DCSP if kwargs.pop('run_immediately', False): DCNL DCSP  DCSP  DCSP f._periodic_last_run = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f._periodic_last_run = time.time() DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
 DCSP ca_dir = ca_folder() DCNL DCSP if (not os.path.exists(ca_path())): DCNL DCSP  DCSP genrootca_sh_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'CA', 'genrootca.sh')) DCNL DCSP  DCSP start = os.getcwd() DCNL DCSP  DCSP fileutils.ensure_tree(ca_dir) DCNL DCSP  DCSP os.chdir(ca_dir) DCNL DCSP  DCSP utils.execute('sh', genrootca_sh_path) DCNL DCSP  DCSP os.chdir(start)
 DCSP if (not CONF.use_project_ca): DCNL DCSP  DCSP project_id = None DCNL DCSP crl_file_path = crl_path(project_id) DCNL DCSP if (not os.path.exists(crl_file_path)): DCNL DCSP  DCSP raise exception.CryptoCRLFileNotFound(project=project_id) DCNL DCSP with open(crl_file_path, 'r') as crlfile: DCNL DCSP  DCSP return crlfile.read()
 DCSP try: DCNL DCSP  DCSP keydata = base64.b64decode(pubkey.split(None)[1]) DCNL DCSP except IndexError: DCNL DCSP  DCSP msg = _('Unable DCSP to DCSP find DCSP the DCSP key') DCNL DCSP  DCSP raise exception.EncryptionFailure(reason=msg) DCNL DCSP parts = [] DCNL DCSP while keydata: DCNL DCSP  DCSP dlen = struct.unpack('>I', keydata[:4])[0] DCNL DCSP  DCSP data = keydata[4:(dlen + 4)] DCNL DCSP  DCSP keydata = keydata[(4 + dlen):] DCNL DCSP  DCSP parts.append(data) DCNL DCSP n_val = eval(('0x' + ''.join([('%02X' % struct.unpack('B', x)[0]) for x in parts[2]]))) DCNL DCSP e_val = eval(('0x' + ''.join([('%02X' % struct.unpack('B', x)[0]) for x in parts[1]]))) DCNL DCSP pkinfo = _to_sequence(univ.Integer(n_val), univ.Integer(e_val)) DCNL DCSP pklong = long(der_encoder.encode(pkinfo).encode('hex'), 16) DCNL DCSP pkbitstring = univ.BitString(("'00%s'B" % bin(pklong)[2:])) DCNL DCSP oid = _to_sequence(_RSA_OID, univ.Null()) DCNL DCSP pkcs1_seq = _to_sequence(oid, pkbitstring) DCNL DCSP pkcs8 = base64.encodestring(der_encoder.encode(pkcs1_seq)) DCNL DCSP return ('-----BEGIN DCSP PUBLIC DCSP KEY-----\n%s\n-----END DCSP PUBLIC DCSP KEY-----\n' % re.sub('(.{64})', '\\1\n', pkcs8.replace('\n', ''), re.DOTALL))
 DCSP with utils.tempdir() as tmpdir: DCNL DCSP  DCSP sslkey = os.path.abspath(os.path.join(tmpdir, 'ssl.key')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP out = convert_from_sshrsa_to_pkcs8(ssh_public_key) DCNL DCSP  DCSP  DCSP with open(sslkey, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(out) DCNL DCSP  DCSP  DCSP (enc, _err) = utils.execute('openssl', 'rsautl', '-encrypt', '-pubin', '-inkey', sslkey, '-keyform', 'PEM', process_input=text) DCNL DCSP  DCSP  DCSP return enc DCNL DCSP  DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP  DCSP raise exception.EncryptionFailure(reason=exc.stderr)
 DCSP start = os.getcwd() DCNL DCSP os.chdir(ca_folder(project_id)) DCNL DCSP utils.execute('openssl', 'ca', '-config', './openssl.cnf', '-revoke', file_name) DCNL DCSP utils.execute('openssl', 'ca', '-gencrl', '-config', './openssl.cnf', '-out', CONF.crl_file) DCNL DCSP os.chdir(start)
 DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_user(admin, user_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])
 DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_project(admin, project_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])
 DCSP admin = context.get_admin_context() DCNL DCSP for cert in db.certificate_get_all_by_user_and_project(admin, user_id, project_id): DCNL DCSP  DCSP revoke_cert(cert['project_id'], cert['file_name'])
 DCSP return (CONF.project_cert_subject % (project_id, timeutils.isotime()))
 DCSP return (CONF.user_cert_subject % (project_id, user_id, timeutils.isotime()))
 DCSP subject = _user_cert_subject(user_id, project_id) DCNL DCSP with utils.tempdir() as tmpdir: DCNL DCSP  DCSP keyfile = os.path.abspath(os.path.join(tmpdir, 'temp.key')) DCNL DCSP  DCSP csrfile = os.path.join(tmpdir, 'temp.csr') DCNL DCSP  DCSP utils.execute('openssl', 'genrsa', '-out', keyfile, str(bits)) DCNL DCSP  DCSP utils.execute('openssl', 'req', '-new', '-key', keyfile, '-out', csrfile, '-batch', '-subj', subject) DCNL DCSP  DCSP private_key = open(keyfile).read() DCNL DCSP  DCSP csr = open(csrfile).read() DCNL DCSP (serial, signed_csr) = sign_csr(csr, project_id) DCNL DCSP fname = os.path.join(ca_folder(project_id), ('newcerts/%s.pem' % serial)) DCNL DCSP cert = {'user_id': user_id, 'project_id': project_id, 'file_name': fname} DCNL DCSP db.certificate_create(context.get_admin_context(), cert) DCNL DCSP return (private_key, signed_csr)
 DCSP m = hashlib.md5() DCNL DCSP fp.seek(0) DCNL DCSP s = fp.read(8192) DCNL DCSP while s: DCNL DCSP  DCSP m.update(s) DCNL DCSP  DCSP s = fp.read(8192) DCNL DCSP hex_md5 = m.hexdigest() DCNL DCSP fp.seek(0) DCNL DCSP return hex_md5
 DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
 DCSP return os.path.join('$pybasedir', *args)
 DCSP return os.path.join('$bindir', *args)
 DCSP return os.path.join('$state_path', *args)
 DCSP return os.path.join(CONF.pybasedir, *args)
 DCSP return os.path.join(CONF.bindir, *args)
 DCSP return os.path.join(CONF.state_path, *args)
 DCSP return ('%s://%s:%d' % (CONF.glance_protocol, CONF.glance_host, CONF.glance_port))
 DCSP return ('%s/images/%s' % (generate_glance_url(), image_ref))
 DCSP o = urlparse.urlparse(image_href) DCNL DCSP port = (o.port or 80) DCNL DCSP host = o.netloc.split(':', 1)[0] DCNL DCSP image_id = o.path.split('/')[(-1)] DCNL DCSP use_ssl = (o.scheme == 'https') DCNL DCSP return (image_id, host, port, use_ssl)
 DCSP if use_ssl: DCNL DCSP  DCSP scheme = 'https' DCNL DCSP else: DCNL DCSP  DCSP scheme = 'http' DCNL DCSP params = {} DCNL DCSP params['insecure'] = CONF.glance_api_insecure DCNL DCSP if (CONF.auth_strategy == 'keystone'): DCNL DCSP  DCSP params['token'] = context.auth_token DCNL DCSP endpoint = ('%s://%s:%s' % (scheme, host, port)) DCNL DCSP return glanceclient.Client(str(version), endpoint, **params)
 DCSP api_servers = [] DCNL DCSP for api_server in CONF.glance_api_servers: DCNL DCSP  DCSP if ('//' not in api_server): DCNL DCSP  DCSP  DCSP api_server = ('http://' + api_server) DCNL DCSP  DCSP o = urlparse.urlparse(api_server) DCNL DCSP  DCSP port = (o.port or 80) DCNL DCSP  DCSP host = o.netloc.split(':', 1)[0] DCNL DCSP  DCSP use_ssl = (o.scheme == 'https') DCNL DCSP  DCSP api_servers.append((host, port, use_ssl)) DCNL DCSP random.shuffle(api_servers) DCNL DCSP return itertools.cycle(api_servers)
 DCSP for attr in ['created_at', 'updated_at', 'deleted_at']: DCNL DCSP  DCSP if image_meta.get(attr): DCNL DCSP  DCSP  DCSP image_meta[attr] = timeutils.parse_isotime(image_meta[attr]) DCNL DCSP return image_meta
 DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_image_exception(image_id, exc_value) DCNL DCSP raise new_exc, None, exc_trace
 DCSP (exc_type, exc_value, exc_trace) = sys.exc_info() DCNL DCSP new_exc = _translate_plain_exception(exc_value) DCNL DCSP raise new_exc, None, exc_trace
 DCSP LOG.debug((_('fetching DCSP image DCSP %s DCSP from DCSP glance') % image_href)) DCNL DCSP if ('/' not in str(image_href)): DCNL DCSP  DCSP image_service = get_default_image_service() DCNL DCSP  DCSP return (image_service, image_href) DCNL DCSP try: DCNL DCSP  DCSP (image_id, glance_host, glance_port, use_ssl) = _parse_image_ref(image_href) DCNL DCSP  DCSP glance_client = GlanceClientWrapper(context=context, host=glance_host, port=glance_port, use_ssl=use_ssl) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise exception.InvalidImageRef(image_href=image_href) DCNL DCSP image_service = GlanceImageService(client=glance_client) DCNL DCSP return (image_service, image_id)
 DCSP args = ['-a', path] DCNL DCSP kwargs = dict(process_input=content, run_as_root=True) DCNL DCSP utils.execute('tee', *args, **kwargs)
 DCSP mdev = None DCNL DCSP devices = [] DCNL DCSP out = None DCNL DCSP try: DCNL DCSP  DCSP (out, err) = utils.execute('multipath', '-l', device, run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP LOG.warn((_('Multipath DCSP call DCSP failed DCSP exit DCSP (%(code)s)') % {'code': exc.exit_code})) DCNL DCSP  DCSP return None DCNL DCSP if out: DCNL DCSP  DCSP lines = out.strip() DCNL DCSP  DCSP lines = lines.split('\n') DCNL DCSP  DCSP if lines: DCNL DCSP  DCSP  DCSP line = lines[0] DCNL DCSP  DCSP  DCSP info = line.split(' DCSP ') DCNL DCSP  DCSP  DCSP if (info[1][:2] == 'dm'): DCNL DCSP  DCSP  DCSP  DCSP mdev = ('/dev/%s' % info[1]) DCNL DCSP  DCSP  DCSP elif (info[2][:2] == 'dm'): DCNL DCSP  DCSP  DCSP  DCSP mdev = ('/dev/%s' % info[2]) DCNL DCSP  DCSP  DCSP if (mdev is None): DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((_("Couldn't DCSP find DCSP multipath DCSP device DCSP %(line)s") % locals())) DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP LOG.debug((_('Found DCSP multipath DCSP device DCSP = DCSP %(mdev)s') % locals())) DCNL DCSP  DCSP  DCSP device_lines = lines[3:] DCNL DCSP  DCSP  DCSP for dev_line in device_lines: DCNL DCSP  DCSP  DCSP  DCSP dev_line = dev_line.strip() DCNL DCSP  DCSP  DCSP  DCSP dev_line = dev_line[3:] DCNL DCSP  DCSP  DCSP  DCSP dev_info = dev_line.split(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (dev_line.find('policy') != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP address = dev_info[0].split(':') DCNL DCSP  DCSP  DCSP  DCSP  DCSP dev = {'device': ('/dev/%s' % dev_info[1]), 'host': address[0], 'channel': address[1], 'id': address[2], 'lun': address[3]} DCNL DCSP  DCSP  DCSP  DCSP  DCSP devices.append(dev) DCNL DCSP if (mdev is not None): DCNL DCSP  DCSP info = {'device': mdev, 'devices': devices} DCNL DCSP  DCSP return info DCNL DCSP return None
 DCSP keyed_args = {} DCNL DCSP (argnames, varargs, keywords, defaults) = inspect.getargspec(function) DCNL DCSP keyed_args.update(kwargs) DCNL DCSP if (('self' in argnames[0]) or ('cls' == argnames[0])): DCNL DCSP  DCSP if (inspect.ismethod(function) and hasattr(function, 'im_self')): DCNL DCSP  DCSP  DCSP keyed_args[argnames[0]] = function.im_self DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP keyed_args[argnames[0]] = None DCNL DCSP remaining_argnames = filter((lambda x: (x not in keyed_args)), argnames) DCNL DCSP keyed_args.update(dict(zip(remaining_argnames, args))) DCNL DCSP if defaults: DCNL DCSP  DCSP num_defaults = len(defaults) DCNL DCSP  DCSP for (argname, value) in zip(argnames[(- num_defaults):], defaults): DCNL DCSP  DCSP  DCSP if (argname not in keyed_args): DCNL DCSP  DCSP  DCSP  DCSP keyed_args[argname] = value DCNL DCSP return keyed_args
 DCSP if (not CONF.notify_api_faults): DCNL DCSP  DCSP return DCNL DCSP payload = {'url': url, 'exception': str(exception), 'status': status} DCNL DCSP publisher_id = notifier_api.publisher_id('api') DCNL DCSP notifier_api.notify(None, publisher_id, 'api.fault', notifier_api.ERROR, payload)
 DCSP if ((not CONF.notify_on_any_change) and (not CONF.notify_on_state_change)): DCNL DCSP  DCSP return DCNL DCSP update_with_state_change = False DCNL DCSP old_vm_state = old_instance['vm_state'] DCNL DCSP new_vm_state = new_instance['vm_state'] DCNL DCSP old_task_state = old_instance['task_state'] DCNL DCSP new_task_state = new_instance['task_state'] DCNL DCSP if (old_vm_state != new_vm_state): DCNL DCSP  DCSP update_with_state_change = True DCNL DCSP elif CONF.notify_on_state_change: DCNL DCSP  DCSP if ((CONF.notify_on_state_change.lower() == 'vm_and_task_state') and (old_task_state != new_task_state)): DCNL DCSP  DCSP  DCSP update_with_state_change = True DCNL DCSP if update_with_state_change: DCNL DCSP  DCSP send_update_with_states(context, new_instance, old_vm_state, new_vm_state, old_task_state, new_task_state, service, host) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _send_instance_update_notification(context, new_instance, service=service, host=host) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP send DCSP state DCSP update DCSP notification'), instance=new_instance)
 DCSP if (not CONF.notify_on_state_change): DCNL DCSP  DCSP return DCNL DCSP fire_update = True DCNL DCSP if verify_states: DCNL DCSP  DCSP fire_update = False DCNL DCSP  DCSP if (old_vm_state != new_vm_state): DCNL DCSP  DCSP  DCSP fire_update = True DCNL DCSP  DCSP elif CONF.notify_on_state_change: DCNL DCSP  DCSP  DCSP if ((CONF.notify_on_state_change.lower() == 'vm_and_task_state') and (old_task_state != new_task_state)): DCNL DCSP  DCSP  DCSP  DCSP fire_update = True DCNL DCSP if fire_update: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _send_instance_update_notification(context, instance, old_vm_state=old_vm_state, old_task_state=old_task_state, new_vm_state=new_vm_state, new_task_state=new_task_state, service=service, host=host) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP send DCSP state DCSP update DCSP notification'), instance=instance)
 DCSP payload = info_from_instance(context, instance, None, None) DCNL DCSP if (not new_vm_state): DCNL DCSP  DCSP new_vm_state = instance['vm_state'] DCNL DCSP if (not new_task_state): DCNL DCSP  DCSP new_task_state = instance['task_state'] DCNL DCSP states_payload = {'old_state': old_vm_state, 'state': new_vm_state, 'old_task_state': old_task_state, 'new_task_state': new_task_state} DCNL DCSP payload.update(states_payload) DCNL DCSP (audit_start, audit_end) = audit_period_bounds(current_period=True) DCNL DCSP payload['audit_period_beginning'] = audit_start DCNL DCSP payload['audit_period_ending'] = audit_end DCNL DCSP bw = bandwidth_usage(instance, audit_start) DCNL DCSP payload['bandwidth'] = bw DCNL DCSP publisher_id = notifier_api.publisher_id(service, host) DCNL DCSP notifier_api.notify(context, publisher_id, 'compute.instance.update', notifier_api.INFO, payload)
 DCSP (begin, end) = utils.last_completed_audit_period() DCNL DCSP if current_period: DCNL DCSP  DCSP audit_start = end DCNL DCSP  DCSP audit_end = timeutils.utcnow() DCNL DCSP else: DCNL DCSP  DCSP audit_start = begin DCNL DCSP  DCSP audit_end = end DCNL DCSP return (audit_start, audit_end)
 DCSP admin_context = nova.context.get_admin_context(read_deleted='yes') DCNL DCSP if (instance_ref.get('info_cache') and (instance_ref['info_cache'].get('network_info') is not None)): DCNL DCSP  DCSP cached_info = instance_ref['info_cache']['network_info'] DCNL DCSP  DCSP nw_info = network_model.NetworkInfo.hydrate(cached_info) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP nw_info = network.API().get_instance_nw_info(admin_context, instance_ref) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP get DCSP nw_info'), instance=instance_ref) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if ignore_missing_network_data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP macs = [vif['address'] for vif in nw_info] DCNL DCSP uuids = [instance_ref['uuid']] DCNL DCSP bw_usages = db.bw_usage_get_by_uuids(admin_context, uuids, audit_start) DCNL DCSP bw_usages = [b for b in bw_usages if (b.mac in macs)] DCNL DCSP bw = {} DCNL DCSP for b in bw_usages: DCNL DCSP  DCSP label = ('net-name-not-found-%s' % b['mac']) DCNL DCSP  DCSP for vif in nw_info: DCNL DCSP  DCSP  DCSP if (vif['address'] == b['mac']): DCNL DCSP  DCSP  DCSP  DCSP label = vif['network']['label'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP bw[label] = dict(bw_in=b.bw_in, bw_out=b.bw_out) DCNL DCSP return bw
 DCSP image_meta = {} DCNL DCSP for (md_key, md_value) in system_metadata.iteritems(): DCNL DCSP  DCSP if md_key.startswith('image_'): DCNL DCSP  DCSP  DCSP image_meta[md_key[6:]] = md_value DCNL DCSP return image_meta
 DCSP def null_safe_str(s): DCNL DCSP  DCSP return (str(s) if s else '') DCNL DCSP image_ref_url = glance.generate_image_url(instance_ref['image_ref']) DCNL DCSP instance_type = instance_types.extract_instance_type(instance_ref) DCNL DCSP instance_type_name = instance_type.get('name', '') DCNL DCSP if (system_metadata is None): DCNL DCSP  DCSP system_metadata = utils.metadata_to_dict(instance_ref['system_metadata']) DCNL DCSP instance_info = dict(tenant_id=instance_ref['project_id'], user_id=instance_ref['user_id'], instance_id=instance_ref['uuid'], display_name=instance_ref['display_name'], reservation_id=instance_ref['reservation_id'], hostname=instance_ref['hostname'], instance_type=instance_type_name, instance_type_id=instance_ref['instance_type_id'], architecture=instance_ref['architecture'], memory_mb=instance_ref['memory_mb'], disk_gb=(instance_ref['root_gb'] + instance_ref['ephemeral_gb']), vcpus=instance_ref['vcpus'], root_gb=instance_ref['root_gb'], ephemeral_gb=instance_ref['ephemeral_gb'], host=instance_ref['host'], availability_zone=instance_ref['availability_zone'], created_at=str(instance_ref['created_at']), deleted_at=null_safe_str(instance_ref.get('terminated_at')), launched_at=null_safe_str(instance_ref.get('launched_at')), image_ref_url=image_ref_url, os_type=instance_ref['os_type'], kernel_id=instance_ref['kernel_id'], ramdisk_id=instance_ref['ramdisk_id'], state=instance_ref['vm_state'], state_description=null_safe_str(instance_ref.get('task_state')), access_ip_v4=instance_ref['access_ip_v4'], access_ip_v6=instance_ref['access_ip_v6']) DCNL DCSP if (network_info is not None): DCNL DCSP  DCSP fixed_ips = [] DCNL DCSP  DCSP for vif in network_info: DCNL DCSP  DCSP  DCSP for ip in vif.fixed_ips(): DCNL DCSP  DCSP  DCSP  DCSP ip['label'] = vif['network']['label'] DCNL DCSP  DCSP  DCSP  DCSP fixed_ips.append(ip) DCNL DCSP  DCSP instance_info['fixed_ips'] = fixed_ips DCNL DCSP image_meta_props = image_meta(system_metadata) DCNL DCSP instance_info['image_meta'] = image_meta_props DCNL DCSP instance_info['metadata'] = instance_ref['metadata'] DCNL DCSP instance_info.update(kw) DCNL DCSP return instance_info
 DCSP cf_splitter = shlex.shlex(conf_data, posix=True) DCNL DCSP cf_splitter.whitespace = ',' DCNL DCSP cf_splitter.whitespace_split = True DCNL DCSP attribs = dict((item.split('=') for item in list(cf_splitter))) DCNL DCSP lpar = LPAR() DCNL DCSP for (key, value) in attribs.items(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP lpar[key] = value DCNL DCSP  DCSP except exception.PowerVMLPARAttributeNotFound as e: DCNL DCSP  DCSP  DCSP LOG.info((_('Encountered DCSP unknown DCSP LPAR DCSP attribute: DCSP %s\nContinuing DCSP without DCSP storing') % key)) DCNL DCSP return lpar
 DCSP try: DCNL DCSP  DCSP ssh = paramiko.SSHClient() DCNL DCSP  DCSP ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) DCNL DCSP  DCSP ssh.connect(connection.host, username=connection.username, password=connection.password, port=connection.port, key_filename=connection.keyfile, timeout=constants.POWERVM_CONNECTION_TIMEOUT) DCNL DCSP  DCSP return ssh DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('Connection DCSP error DCSP connecting DCSP PowerVM DCSP manager')) DCNL DCSP  DCSP raise exception.PowerVMConnectionFailed()
 DCSP LOG.debug((_('Running DCSP cmd DCSP (SSH-as-root): DCSP %s') % cmd)) DCNL DCSP chan = ssh_connection._transport.open_session() DCNL DCSP chan.exec_command('ioscli DCSP oem_setup_env') DCNL DCSP bufsize = (-1) DCNL DCSP stdin = chan.makefile('wb', bufsize) DCNL DCSP stdout = chan.makefile('rb', bufsize) DCNL DCSP stderr = chan.makefile_stderr('rb', bufsize) DCNL DCSP stdin.write(('%s\n%s\n' % (cmd, 'exit'))) DCNL DCSP stdin.flush() DCNL DCSP exit_status = chan.recv_exit_status() DCNL DCSP if (exit_status != (-1)): DCNL DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % exit_status)) DCNL DCSP  DCSP if (check_exit_code and (exit_status != 0)): DCNL DCSP  DCSP  DCSP raise nova_exception.ProcessExecutionError(exit_code=exit_status, stdout=stdout, stderr=stderr, cmd=''.join(cmd)) DCNL DCSP return (stdout, stderr)
 DCSP try: DCNL DCSP  DCSP ftp = ftplib.FTP(host=connection.host, user=connection.username, passwd=connection.password) DCNL DCSP  DCSP ftp.cwd(remote_dir) DCNL DCSP  DCSP name = os.path.split(local_path)[1] DCNL DCSP  DCSP f = open(local_path, 'rb') DCNL DCSP  DCSP ftp.storbinary(('STOR DCSP ' + name), f) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP ftp.close() DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('File DCSP transfer DCSP to DCSP PowerVM DCSP manager DCSP failed')) DCNL DCSP  DCSP raise exception.PowerVMFTPTransferFailed(ftp_cmd='PUT', source_path=local_path, dest_path=remote_dir)
 DCSP try: DCNL DCSP  DCSP ftp = ftplib.FTP(host=connection.host, user=connection.username, passwd=connection.password) DCNL DCSP  DCSP ftp.cwd(os.path.dirname(remote_path)) DCNL DCSP  DCSP name = os.path.basename(remote_path) DCNL DCSP  DCSP LOG.debug((_('ftp DCSP GET DCSP %(remote_path)s DCSP to: DCSP %(local_path)s') % locals())) DCNL DCSP  DCSP with open(local_path, 'w') as ftpfile: DCNL DCSP  DCSP  DCSP ftpcmd = ('RETR DCSP %s' % name) DCNL DCSP  DCSP  DCSP ftp.retrbinary(ftpcmd, ftpfile.write) DCNL DCSP  DCSP ftp.close() DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.error(_('File DCSP transfer DCSP from DCSP PowerVM DCSP manager DCSP failed')) DCNL DCSP  DCSP raise exception.PowerVMFTPTransferFailed(ftp_cmd='GET', source_path=remote_path, dest_path=local_path)
 DCSP if path_one.endswith('/'): DCNL DCSP  DCSP path_one = path_one.rstrip('/') DCNL DCSP if path_two.startswith('/'): DCNL DCSP  DCSP path_two = path_two.lstrip('/') DCNL DCSP final_path = ((path_one + '/') + path_two) DCNL DCSP return final_path
 DCSP KEY_BASE_NAME = ('os-%s' % uuid.uuid4().hex) DCNL DCSP keypair_uuid = uuid.uuid4() DCNL DCSP src_conn_obj = ssh_connect(conn_info) DCNL DCSP dest_conn_info = Connection(dest, conn_info.username, conn_info.password) DCNL DCSP dest_conn_obj = ssh_connect(dest_conn_info) DCNL DCSP def run_command(conn_obj, cmd): DCNL DCSP  DCSP (stdout, stderr) = utils.ssh_execute(conn_obj, cmd) DCNL DCSP  DCSP return stdout.strip().splitlines() DCNL DCSP def build_keypair_on_source(): DCNL DCSP  DCSP mkkey = ('ssh-keygen DCSP -f DCSP %s DCSP -N DCSP "" DCSP -C DCSP %s' % (KEY_BASE_NAME, keypair_uuid.hex)) DCNL DCSP  DCSP ssh_command_as_root(src_conn_obj, mkkey) DCNL DCSP  DCSP chown_key = ('chown DCSP %s DCSP %s*' % (conn_info.username, KEY_BASE_NAME)) DCNL DCSP  DCSP ssh_command_as_root(src_conn_obj, chown_key) DCNL DCSP  DCSP cat_key = ('cat DCSP %s.pub' % KEY_BASE_NAME) DCNL DCSP  DCSP pubkey = run_command(src_conn_obj, cat_key) DCNL DCSP  DCSP return pubkey[0] DCNL DCSP def cleanup_key_on_source(): DCNL DCSP  DCSP rmkey = ('rm DCSP %s*' % KEY_BASE_NAME) DCNL DCSP  DCSP run_command(src_conn_obj, rmkey) DCNL DCSP def insert_into_authorized_keys(public_key): DCNL DCSP  DCSP echo_key = ('echo DCSP "%s" DCSP >> DCSP .ssh/authorized_keys' % public_key) DCNL DCSP  DCSP ssh_command_as_root(dest_conn_obj, echo_key) DCNL DCSP def remove_from_authorized_keys(): DCNL DCSP  DCSP rmkey = ('sed DCSP /%s/d DCSP .ssh/authorized_keys DCSP > DCSP .ssh/authorized_keys' % keypair_uuid.hex) DCNL DCSP  DCSP ssh_command_as_root(dest_conn_obj, rmkey) DCNL DCSP public_key = build_keypair_on_source() DCNL DCSP insert_into_authorized_keys(public_key) DCNL DCSP try: DCNL DCSP  DCSP (yield KEY_BASE_NAME) DCNL DCSP finally: DCNL DCSP  DCSP remove_from_authorized_keys() DCNL DCSP  DCSP cleanup_key_on_source()
 DCSP conf.mac_addr = mac DCNL DCSP if (model is not None): DCNL DCSP  DCSP conf.model = model DCNL DCSP if (driver is not None): DCNL DCSP  DCSP conf.driver_name = driver
 DCSP conf.net_type = 'bridge' DCNL DCSP conf.source_dev = brname DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname DCNL DCSP conf.script = ''
 DCSP conf.net_type = 'ethernet' DCNL DCSP conf.target_dev = tapname DCNL DCSP conf.script = ''
 DCSP conf.net_type = 'bridge' DCNL DCSP conf.source_dev = brname DCNL DCSP conf.vporttype = 'openvswitch' DCNL DCSP conf.add_vport_param('interfaceid', interfaceid) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname DCNL DCSP conf.script = ''
 DCSP conf.net_type = 'direct' DCNL DCSP conf.source_dev = devname DCNL DCSP conf.source_mode = 'vepa' DCNL DCSP conf.vporttype = '802.1Qbg' DCNL DCSP conf.add_vport_param('managerid', managerid) DCNL DCSP conf.add_vport_param('typeid', typeid) DCNL DCSP conf.add_vport_param('typeidversion', typeidversion) DCNL DCSP conf.add_vport_param('instanceid', instanceid) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname
 DCSP conf.net_type = 'direct' DCNL DCSP conf.source_dev = devname DCNL DCSP conf.source_mode = 'vepa' DCNL DCSP conf.vporttype = '802.1Qbh' DCNL DCSP conf.add_vport_param('profileid', profileid) DCNL DCSP if tapname: DCNL DCSP  DCSP conf.target_dev = tapname
 DCSP bandwidth_items = ['vif_inbound_average', 'vif_inbound_peak', 'vif_inbound_burst', 'vif_outbound_average', 'vif_outbound_peak', 'vif_outbound_burst'] DCNL DCSP for (key, value) in extra_specs.iteritems(): DCNL DCSP  DCSP scope = key.split(':') DCNL DCSP  DCSP if ((len(scope) > 1) and (scope[0] == 'quota')): DCNL DCSP  DCSP  DCSP if (scope[1] in bandwidth_items): DCNL DCSP  DCSP  DCSP  DCSP setattr(conf, scope[1], value)
 DCSP image_id = str(images[key]) DCNL DCSP if ((not CONF.remove_unused_kernels) and (key in ['kernel_id', 'ramdisk_id'])): DCNL DCSP  DCSP return image_id DCNL DCSP else: DCNL DCSP  DCSP return hashlib.sha1(image_id).hexdigest()
 DCSP base_file = os.path.basename(base_path) DCNL DCSP return (CONF.image_info_filename_pattern % {'image': base_file})
 DCSP digest_size = (hashlib.sha1().digestsize * 2) DCNL DCSP regexp = (CONF.image_info_filename_pattern % {'image': ('([0-9a-f]{%(digest_size)d}|[0-9a-f]{%(digest_size)d}_sm|[0-9a-f]{%(digest_size)d}_[0-9]+)' % {'digest_size': digest_size})}) DCNL DCSP m = re.match(regexp, path) DCNL DCSP if m: DCNL DCSP  DCSP return True DCNL DCSP return False
 DCSP info_file = get_info_filename(target) DCNL DCSP if (not os.path.exists(info_file)): DCNL DCSP  DCSP old_filename = (target + '.sha1') DCNL DCSP  DCSP if ((field == 'sha1') and os.path.exists(old_filename)): DCNL DCSP  DCSP  DCSP hash_file = open(old_filename) DCNL DCSP  DCSP  DCSP hash_value = hash_file.read() DCNL DCSP  DCSP  DCSP hash_file.close() DCNL DCSP  DCSP  DCSP write_stored_info(target, field=field, value=hash_value) DCNL DCSP  DCSP  DCSP os.remove(old_filename) DCNL DCSP  DCSP  DCSP d = {field: hash_value} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP d = {} DCNL DCSP else: DCNL DCSP  DCSP lock_name = ('info-%s' % os.path.split(target)[(-1)]) DCNL DCSP  DCSP lock_path = os.path.join(CONF.instances_path, 'locks') DCNL DCSP  DCSP @lockutils.synchronized(lock_name, 'nova-', external=True, lock_path=lock_path) DCNL DCSP  DCSP def read_file(info_file): DCNL DCSP  DCSP  DCSP LOG.debug(_('Reading DCSP image DCSP info DCSP file: DCSP %s'), info_file) DCNL DCSP  DCSP  DCSP with open(info_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return f.read().rstrip() DCNL DCSP  DCSP serialized = read_file(info_file) DCNL DCSP  DCSP d = _read_possible_json(serialized, info_file) DCNL DCSP if field: DCNL DCSP  DCSP if timestamped: DCNL DCSP  DCSP  DCSP return (d.get(field, None), d.get(('%s-timestamp' % field), None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return d.get(field, None) DCNL DCSP return d
 DCSP if (not field): DCNL DCSP  DCSP return DCNL DCSP info_file = get_info_filename(target) DCNL DCSP LOG.info(_('Writing DCSP stored DCSP info DCSP to DCSP %s'), info_file) DCNL DCSP fileutils.ensure_tree(os.path.dirname(info_file)) DCNL DCSP lock_name = ('info-%s' % os.path.split(target)[(-1)]) DCNL DCSP lock_path = os.path.join(CONF.instances_path, 'locks') DCNL DCSP @lockutils.synchronized(lock_name, 'nova-', external=True, lock_path=lock_path) DCNL DCSP def write_file(info_file, field, value): DCNL DCSP  DCSP d = {} DCNL DCSP  DCSP if os.path.exists(info_file): DCNL DCSP  DCSP  DCSP with open(info_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP d = _read_possible_json(f.read(), info_file) DCNL DCSP  DCSP d[field] = value DCNL DCSP  DCSP d[('%s-timestamp' % field)] = time.time() DCNL DCSP  DCSP with open(info_file, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(json.dumps(d)) DCNL DCSP write_file(info_file, field, value)
 DCSP return read_stored_info(target, field='sha1', timestamped=timestamped)
 DCSP with open(target, 'r') as img_file: DCNL DCSP  DCSP checksum = utils.hash_file(img_file) DCNL DCSP write_stored_info(target, field='sha1', value=checksum)
 DCSP def str_method(self): DCNL DCSP  DCSP return str(self._obj) DCNL DCSP def repr_method(self): DCNL DCSP  DCSP return repr(self._obj) DCNL DCSP tpool.Proxy.__str__ = str_method DCNL DCSP tpool.Proxy.__repr__ = repr_method
 DCSP contents = utils.read_file_as_root('/etc/iscsi/initiatorname.iscsi') DCNL DCSP for l in contents.split('\n'): DCNL DCSP  DCSP if l.startswith('InitiatorName='): DCNL DCSP  DCSP  DCSP return l[(l.index('=') + 1):].strip()
 DCSP out = None DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute('systool', '-c', 'fc_host', '-v', run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as exc: DCNL DCSP  DCSP if (exc.exit_code == 96): DCNL DCSP  DCSP  DCSP LOG.warn(_('systool DCSP is DCSP not DCSP installed')) DCNL DCSP  DCSP return [] DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP LOG.warn(_('systool DCSP is DCSP not DCSP installed')) DCNL DCSP  DCSP return [] DCNL DCSP if (out is None): DCNL DCSP  DCSP raise RuntimeError(_('Cannot DCSP find DCSP any DCSP Fibre DCSP Channel DCSP HBAs')) DCNL DCSP lines = out.split('\n') DCNL DCSP lines = lines[2:] DCNL DCSP hbas = [] DCNL DCSP hba = {} DCNL DCSP lastline = None DCNL DCSP for line in lines: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if ((line == '') and (lastline == '')): DCNL DCSP  DCSP  DCSP if (len(hba) > 0): DCNL DCSP  DCSP  DCSP  DCSP hbas.append(hba) DCNL DCSP  DCSP  DCSP  DCSP hba = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP val = line.split('=') DCNL DCSP  DCSP  DCSP if (len(val) == 2): DCNL DCSP  DCSP  DCSP  DCSP key = val[0].strip().replace(' DCSP ', '') DCNL DCSP  DCSP  DCSP  DCSP value = val[1].strip() DCNL DCSP  DCSP  DCSP  DCSP hba[key] = value.replace('"', '') DCNL DCSP  DCSP lastline = line DCNL DCSP return hbas
 DCSP hbas = get_fc_hbas() DCNL DCSP hbas_info = [] DCNL DCSP for hba in hbas: DCNL DCSP  DCSP wwpn = hba['port_name'].replace('0x', '') DCNL DCSP  DCSP wwnn = hba['node_name'].replace('0x', '') DCNL DCSP  DCSP device_path = hba['ClassDevicepath'] DCNL DCSP  DCSP device = hba['ClassDevice'] DCNL DCSP  DCSP hbas_info.append({'port_name': wwpn, 'node_name': wwnn, 'host_device': device, 'device_path': device_path}) DCNL DCSP return hbas_info
 DCSP hbas = get_fc_hbas() DCNL DCSP wwpns = [] DCNL DCSP if hbas: DCNL DCSP  DCSP for hba in hbas: DCNL DCSP  DCSP  DCSP if (hba['port_state'] == 'Online'): DCNL DCSP  DCSP  DCSP  DCSP wwpn = hba['port_name'].replace('0x', '') DCNL DCSP  DCSP  DCSP  DCSP wwpns.append(wwpn) DCNL DCSP return wwpns
 DCSP hbas = get_fc_hbas() DCNL DCSP wwnns = [] DCNL DCSP if hbas: DCNL DCSP  DCSP for hba in hbas: DCNL DCSP  DCSP  DCSP if (hba['port_state'] == 'Online'): DCNL DCSP  DCSP  DCSP  DCSP wwnn = hba['node_name'].replace('0x', '') DCNL DCSP  DCSP  DCSP  DCSP wwnns.append(wwnn) DCNL DCSP return wwnns
 DCSP execute('qemu-img', 'create', '-f', disk_format, path, size)
 DCSP base_cmd = ['qemu-img', 'create', '-f', 'qcow2'] DCNL DCSP cow_opts = [] DCNL DCSP if backing_file: DCNL DCSP  DCSP cow_opts += [('backing_file=%s' % backing_file)] DCNL DCSP  DCSP base_details = images.qemu_img_info(backing_file) DCNL DCSP else: DCNL DCSP  DCSP base_details = None DCNL DCSP if (base_details and (base_details.cluster_size is not None)): DCNL DCSP  DCSP cow_opts += [('cluster_size=%s' % base_details.cluster_size)] DCNL DCSP if (base_details and base_details.encryption): DCNL DCSP  DCSP cow_opts += [('encryption=%s' % base_details.encryption)] DCNL DCSP if (size is not None): DCNL DCSP  DCSP cow_opts += [('size=%s' % size)] DCNL DCSP if cow_opts: DCNL DCSP  DCSP csv_opts = ','.join(cow_opts) DCNL DCSP  DCSP cow_opts = ['-o', csv_opts] DCNL DCSP cmd = ((base_cmd + cow_opts) + [path]) DCNL DCSP execute(*cmd)
 DCSP vg_info = get_volume_group_info(vg) DCNL DCSP free_space = vg_info['free'] DCNL DCSP def check_size(vg, lv, size): DCNL DCSP  DCSP if (size > free_space): DCNL DCSP  DCSP  DCSP raise RuntimeError((_('Insufficient DCSP Space DCSP on DCSP Volume DCSP Group DCSP %(vg)s. DCSP Only DCSP %(free_space)db DCSP available, DCSP but DCSP %(size)db DCSP required DCSP by DCSP volume DCSP %(lv)s.') % locals())) DCNL DCSP if sparse: DCNL DCSP  DCSP preallocated_space = ((64 * 1024) * 1024) DCNL DCSP  DCSP check_size(vg, lv, preallocated_space) DCNL DCSP  DCSP if (free_space < size): DCNL DCSP  DCSP  DCSP LOG.warning((_('Volume DCSP group DCSP %(vg)s DCSP will DCSP not DCSP be DCSP able DCSP to DCSP hold DCSP sparse DCSP volume DCSP %(lv)s. DCSP Virtual DCSP volume DCSP size DCSP is DCSP %(size)db, DCSP but DCSP free DCSP space DCSP on DCSP volume DCSP group DCSP is DCSP only DCSP %(free_space)db.') % locals())) DCNL DCSP  DCSP cmd = ('lvcreate', '-L', ('%db' % preallocated_space), '--virtualsize', ('%db' % size), '-n', lv, vg) DCNL DCSP else: DCNL DCSP  DCSP check_size(vg, lv, size) DCNL DCSP  DCSP cmd = ('lvcreate', '-L', ('%db' % size), '-n', lv, vg) DCNL DCSP execute(run_as_root=True, attempts=3, *cmd)
 DCSP (out, err) = execute('vgs', '--noheadings', '--nosuffix', '--separator', '|', '--units', 'b', '-o', 'vg_size,vg_free', vg, run_as_root=True) DCNL DCSP info = out.split('|') DCNL DCSP if (len(info) != 2): DCNL DCSP  DCSP raise RuntimeError((_('vg DCSP %s DCSP must DCSP be DCSP LVM DCSP volume DCSP group') % vg)) DCNL DCSP return {'total': int(info[0]), 'free': int(info[1]), 'used': (int(info[0]) - int(info[1]))}
 DCSP (out, err) = execute('lvs', '--noheadings', '-o', 'lv_name', vg, run_as_root=True) DCNL DCSP return [line.strip() for line in out.splitlines()]
 DCSP (out, err) = execute('lvs', '-o', 'vg_all,lv_all', '--separator', '|', path, run_as_root=True) DCNL DCSP info = [line.split('|') for line in out.splitlines()] DCNL DCSP if (len(info) != 2): DCNL DCSP  DCSP raise RuntimeError((_('Path DCSP %s DCSP must DCSP be DCSP LVM DCSP logical DCSP volume') % path)) DCNL DCSP return dict(zip(*info))
 DCSP (out, _err) = execute('lvs', '-o', 'lv_size', '--noheadings', '--units', 'b', '--nosuffix', path, run_as_root=True) DCNL DCSP return int(out)
 DCSP vol_size = logical_volume_size(path) DCNL DCSP bs = (1024 * 1024) DCNL DCSP direct_flags = ('oflag=direct',) DCNL DCSP sync_flags = () DCNL DCSP remaining_bytes = vol_size DCNL DCSP while remaining_bytes: DCNL DCSP  DCSP zero_blocks = (remaining_bytes / bs) DCNL DCSP  DCSP seek_blocks = ((vol_size - remaining_bytes) / bs) DCNL DCSP  DCSP zero_cmd = ('dd', ('bs=%s' % bs), 'if=/dev/zero', ('of=%s' % path), ('seek=%s' % seek_blocks), ('count=%s' % zero_blocks)) DCNL DCSP  DCSP zero_cmd += direct_flags DCNL DCSP  DCSP zero_cmd += sync_flags DCNL DCSP  DCSP if zero_blocks: DCNL DCSP  DCSP  DCSP utils.execute(run_as_root=True, *zero_cmd) DCNL DCSP  DCSP remaining_bytes %= bs DCNL DCSP  DCSP bs /= 1024 DCNL DCSP  DCSP direct_flags = () DCNL DCSP  DCSP sync_flags = ('conv=fdatasync',)
 DCSP for path in paths: DCNL DCSP  DCSP clear_logical_volume(path) DCNL DCSP if paths: DCNL DCSP  DCSP lvremove = (('lvremove', '-f') + paths) DCNL DCSP  DCSP execute(attempts=3, run_as_root=True, *lvremove)
 DCSP if (CONF.libvirt_type == 'xen'): DCNL DCSP  DCSP if is_block_dev: DCNL DCSP  DCSP  DCSP return 'phy' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'tap' DCNL DCSP elif (CONF.libvirt_type in ('kvm', 'qemu')): DCNL DCSP  DCSP return 'qemu' DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP size = images.qemu_img_info(path).virtual_size DCNL DCSP return int(size)
 DCSP backing_file = images.qemu_img_info(path).backing_file DCNL DCSP if (backing_file and basename): DCNL DCSP  DCSP backing_file = os.path.basename(backing_file) DCNL DCSP return backing_file
 DCSP if (not host): DCNL DCSP  DCSP execute('cp', src, dest) DCNL DCSP else: DCNL DCSP  DCSP dest = ('%s:%s' % (host, dest)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP execute('rsync', '--sparse', '--compress', '--dry-run', src, dest) DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP execute('scp', src, dest) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP execute('rsync', '--sparse', '--compress', src, dest)
 DCSP if umask: DCNL DCSP  DCSP saved_umask = os.umask(umask) DCNL DCSP try: DCNL DCSP  DCSP with open(path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(contents) DCNL DCSP finally: DCNL DCSP  DCSP if umask: DCNL DCSP  DCSP  DCSP os.umask(saved_umask)
 DCSP execute('chown', owner, path, run_as_root=True)
 DCSP qemu_img_cmd = ('qemu-img', 'snapshot', '-c', snapshot_name, disk_path) DCNL DCSP execute(run_as_root=True, *qemu_img_cmd)
 DCSP qemu_img_cmd = ('qemu-img', 'snapshot', '-d', snapshot_name, disk_path) DCNL DCSP execute(run_as_root=True, *qemu_img_cmd)
 DCSP if (dest_fmt == 'iso'): DCNL DCSP  DCSP dest_fmt = 'raw' DCNL DCSP qemu_img_cmd = ('qemu-img', 'convert', '-f', source_fmt, '-O', dest_fmt) DCNL DCSP if (CONF.libvirt_snapshot_compression and (dest_fmt == 'qcow2')): DCNL DCSP  DCSP qemu_img_cmd += ('-c',) DCNL DCSP if (snapshot_name is not None): DCNL DCSP  DCSP qemu_img_cmd += ('-s', snapshot_name) DCNL DCSP qemu_img_cmd += (disk_path, out_path) DCNL DCSP execute(*qemu_img_cmd)
 DCSP with open(path, 'r') as fp: DCNL DCSP  DCSP return fp.read()
 DCSP return file(*args, **kwargs)
 DCSP return os.unlink(path)
 DCSP xml_desc = virt_dom.XMLDesc(0) DCNL DCSP domain = etree.fromstring(xml_desc) DCNL DCSP if (CONF.libvirt_type == 'lxc'): DCNL DCSP  DCSP source = domain.find('devices/filesystem/source') DCNL DCSP  DCSP disk_path = source.get('dir') DCNL DCSP  DCSP disk_path = disk_path[0:disk_path.rfind('rootfs')] DCNL DCSP  DCSP disk_path = os.path.join(disk_path, 'disk') DCNL DCSP else: DCNL DCSP  DCSP source = domain.find('devices/disk/source') DCNL DCSP  DCSP disk_path = (source.get('file') or source.get('dev')) DCNL DCSP if (not disk_path): DCNL DCSP  DCSP raise RuntimeError(_("Can't DCSP retrieve DCSP root DCSP device DCSP path DCSP from DCSP instance DCSP libvirt DCSP configuration")) DCNL DCSP return disk_path
 DCSP if path.startswith('/dev'): DCNL DCSP  DCSP return 'lvm' DCNL DCSP return images.qemu_img_info(path).file_format
 DCSP hddinfo = os.statvfs(path) DCNL DCSP total = (hddinfo.f_frsize * hddinfo.f_blocks) DCNL DCSP free = (hddinfo.f_frsize * hddinfo.f_bavail) DCNL DCSP used = (hddinfo.f_frsize * (hddinfo.f_blocks - hddinfo.f_bfree)) DCNL DCSP return {'total': total, 'free': free, 'used': used}
 DCSP images.fetch_to_raw(context, image_id, target, user_id, project_id)
 DCSP pre_grizzly_name = os.path.join(CONF.instances_path, instance['name']) DCNL DCSP if (forceold or os.path.exists(pre_grizzly_name)): DCNL DCSP  DCSP return pre_grizzly_name DCNL DCSP return os.path.join(CONF.instances_path, instance['uuid'])
 DCSP for disk in mapping: DCNL DCSP  DCSP info = mapping[disk] DCNL DCSP  DCSP if (info['dev'] == disk_dev): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if CONF.libvirt_disk_prefix: DCNL DCSP  DCSP return CONF.libvirt_disk_prefix DCNL DCSP if (disk_bus == 'ide'): DCNL DCSP  DCSP return 'hd' DCNL DCSP elif (disk_bus == 'virtio'): DCNL DCSP  DCSP return 'vd' DCNL DCSP elif (disk_bus == 'xen'): DCNL DCSP  DCSP return 'sd' DCNL DCSP elif (disk_bus == 'scsi'): DCNL DCSP  DCSP return 'sd' DCNL DCSP elif (disk_bus == 'usb'): DCNL DCSP  DCSP return 'sd' DCNL DCSP elif (disk_bus == 'uml'): DCNL DCSP  DCSP return 'ubd' DCNL DCSP elif (disk_bus == 'lxc'): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP raise exception.NovaException((_('Unable DCSP to DCSP determine DCSP disk DCSP prefix DCSP for DCSP %s') % disk_bus))
 DCSP if (disk_bus == 'ide'): DCNL DCSP  DCSP return 4 DCNL DCSP else: DCNL DCSP  DCSP return 26
 DCSP dev_prefix = get_dev_prefix_for_disk_bus(bus) DCNL DCSP if (dev_prefix is None): DCNL DCSP  DCSP return None DCNL DCSP max_dev = get_dev_count_for_disk_bus(bus) DCNL DCSP if last_device: DCNL DCSP  DCSP devs = [(max_dev - 1)] DCNL DCSP else: DCNL DCSP  DCSP devs = range(max_dev) DCNL DCSP for idx in devs: DCNL DCSP  DCSP disk_dev = (dev_prefix + chr((ord('a') + idx))) DCNL DCSP  DCSP if (not has_disk_dev(mapping, disk_dev)): DCNL DCSP  DCSP  DCSP return disk_dev DCNL DCSP raise exception.NovaException(_("No DCSP free DCSP disk DCSP device DCSP names DCSP for DCSP prefix DCSP '%s'"), dev_prefix)
 DCSP if image_meta: DCNL DCSP  DCSP key = (('hw_' + device_type) + '_bus') DCNL DCSP  DCSP disk_bus = image_meta.get('properties', {}).get(key) DCNL DCSP  DCSP if (disk_bus is not None): DCNL DCSP  DCSP  DCSP if (not is_disk_bus_valid_for_virt(virt_type, disk_bus)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupportedHardware(model=disk_bus, virt=virt_type) DCNL DCSP  DCSP  DCSP return disk_bus DCNL DCSP if (virt_type == 'uml'): DCNL DCSP  DCSP if (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'uml' DCNL DCSP elif (virt_type == 'lxc'): DCNL DCSP  DCSP return 'lxc' DCNL DCSP elif (virt_type == 'xen'): DCNL DCSP  DCSP if (device_type == 'cdrom'): DCNL DCSP  DCSP  DCSP return 'ide' DCNL DCSP  DCSP elif (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP elif (virt_type in ('qemu', 'kvm')): DCNL DCSP  DCSP if (device_type == 'cdrom'): DCNL DCSP  DCSP  DCSP return 'ide' DCNL DCSP  DCSP elif (device_type == 'disk'): DCNL DCSP  DCSP  DCSP return 'virtio' DCNL DCSP return None
 DCSP if (disk_dev[:2] == 'hd'): DCNL DCSP  DCSP return 'ide' DCNL DCSP elif (disk_dev[:2] == 'sd'): DCNL DCSP  DCSP if (virt_type == 'xen'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'scsi' DCNL DCSP elif (disk_dev[:2] == 'vd'): DCNL DCSP  DCSP return 'virtio' DCNL DCSP elif (disk_dev[:3] == 'xvd'): DCNL DCSP  DCSP return 'xen' DCNL DCSP elif (disk_dev[:3] == 'ubd'): DCNL DCSP  DCSP return 'uml' DCNL DCSP else: DCNL DCSP  DCSP raise exception.NovaException((_("Unable DCSP to DCSP determine DCSP disk DCSP bus DCSP for DCSP '%s'") % disk_dev[:1]))
 DCSP disk_dev = find_disk_dev_for_disk_bus(mapping, disk_bus, last_device) DCNL DCSP return {'bus': disk_bus, 'dev': disk_dev, 'type': device_type}
 DCSP inst_type = instance_types.extract_instance_type(instance) DCNL DCSP mapping = {} DCNL DCSP if (virt_type == 'lxc'): DCNL DCSP  DCSP root_disk_bus = disk_bus DCNL DCSP  DCSP root_device_type = 'disk' DCNL DCSP  DCSP root_info = get_next_disk_info(mapping, root_disk_bus, root_device_type) DCNL DCSP  DCSP mapping['root'] = root_info DCNL DCSP  DCSP mapping['disk'] = root_info DCNL DCSP  DCSP return mapping DCNL DCSP if rescue: DCNL DCSP  DCSP rescue_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP  DCSP mapping['disk.rescue'] = rescue_info DCNL DCSP  DCSP mapping['root'] = rescue_info DCNL DCSP  DCSP os_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP  DCSP mapping['disk'] = os_info DCNL DCSP  DCSP return mapping DCNL DCSP if (image_meta and (image_meta.get('disk_format') == 'iso')): DCNL DCSP  DCSP root_disk_bus = cdrom_bus DCNL DCSP  DCSP root_device_type = 'cdrom' DCNL DCSP else: DCNL DCSP  DCSP root_disk_bus = disk_bus DCNL DCSP  DCSP root_device_type = 'disk' DCNL DCSP root_device_name = driver.block_device_info_get_root(block_device_info) DCNL DCSP if (root_device_name is not None): DCNL DCSP  DCSP root_device = block_device.strip_dev(root_device_name) DCNL DCSP  DCSP root_info = {'bus': get_disk_bus_for_disk_dev(virt_type, root_device), 'dev': root_device, 'type': root_device_type} DCNL DCSP else: DCNL DCSP  DCSP root_info = get_next_disk_info(mapping, root_disk_bus, root_device_type) DCNL DCSP mapping['root'] = root_info DCNL DCSP if (not block_device.volume_in_mapping(root_info['dev'], block_device_info)): DCNL DCSP  DCSP mapping['disk'] = root_info DCNL DCSP eph_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP ephemeral_device = False DCNL DCSP if (not (block_device.volume_in_mapping(eph_info['dev'], block_device_info) or (0 in [eph['num'] for eph in driver.block_device_info_get_ephemerals(block_device_info)]))): DCNL DCSP  DCSP if (instance['ephemeral_gb'] > 0): DCNL DCSP  DCSP  DCSP ephemeral_device = True DCNL DCSP if ephemeral_device: DCNL DCSP  DCSP mapping['disk.local'] = eph_info DCNL DCSP for eph in driver.block_device_info_get_ephemerals(block_device_info): DCNL DCSP  DCSP disk_dev = block_device.strip_dev(eph['device_name']) DCNL DCSP  DCSP disk_bus = get_disk_bus_for_disk_dev(virt_type, disk_dev) DCNL DCSP  DCSP mapping[get_eph_disk(eph)] = {'bus': disk_bus, 'dev': disk_dev, 'type': 'disk'} DCNL DCSP swap = driver.block_device_info_get_swap(block_device_info) DCNL DCSP if driver.swap_is_usable(swap): DCNL DCSP  DCSP disk_dev = block_device.strip_dev(swap['device_name']) DCNL DCSP  DCSP disk_bus = get_disk_bus_for_disk_dev(virt_type, disk_dev) DCNL DCSP  DCSP mapping['disk.swap'] = {'bus': disk_bus, 'dev': disk_dev, 'type': 'disk'} DCNL DCSP elif (inst_type['swap'] > 0): DCNL DCSP  DCSP swap_info = get_next_disk_info(mapping, disk_bus) DCNL DCSP  DCSP if (not block_device.volume_in_mapping(swap_info['dev'], block_device_info)): DCNL DCSP  DCSP  DCSP mapping['disk.swap'] = swap_info DCNL DCSP block_device_mapping = driver.block_device_info_get_mapping(block_device_info) DCNL DCSP for vol in block_device_mapping: DCNL DCSP  DCSP disk_dev = vol['mount_device'].rpartition('/')[2] DCNL DCSP  DCSP disk_bus = get_disk_bus_for_disk_dev(virt_type, disk_dev) DCNL DCSP  DCSP mapping[vol['mount_device']] = {'bus': disk_bus, 'dev': disk_dev, 'type': 'disk'} DCNL DCSP if configdrive.enabled_for(instance): DCNL DCSP  DCSP config_info = get_next_disk_info(mapping, disk_bus, last_device=True) DCNL DCSP  DCSP mapping['disk.config'] = config_info DCNL DCSP return mapping
 DCSP disk_bus = get_disk_bus_for_device_type(virt_type, image_meta, 'disk') DCNL DCSP cdrom_bus = get_disk_bus_for_device_type(virt_type, image_meta, 'cdrom') DCNL DCSP mapping = get_disk_mapping(virt_type, instance, disk_bus, cdrom_bus, block_device_info, image_meta, rescue) DCNL DCSP return {'disk_bus': disk_bus, 'cdrom_bus': cdrom_bus, 'mapping': mapping}
 DCSP return images.qemu_img_info(path).virtual_size
 DCSP virt_size = get_disk_size(image) DCNL DCSP if (virt_size >= size): DCNL DCSP  DCSP return DCNL DCSP utils.execute('qemu-img', 'resize', image, size) DCNL DCSP resize2fs(image)
 DCSP LOG.debug(_('Checking DCSP if DCSP we DCSP can DCSP resize DCSP image DCSP %(image)s. DCSP size=%(size)s, DCSP CoW=%(use_cow)s'), locals()) DCNL DCSP virt_size = get_disk_size(image) DCNL DCSP if (virt_size >= size): DCNL DCSP  DCSP LOG.debug(_('Cannot DCSP resize DCSP filesystem DCSP %s DCSP to DCSP a DCSP smaller DCSP size.'), image) DCNL DCSP  DCSP return False DCNL DCSP if use_cow: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fs = vfs.VFS.instance_for_image(image, 'qcow2', None) DCNL DCSP  DCSP  DCSP fs.setup() DCNL DCSP  DCSP  DCSP fs.teardown() DCNL DCSP  DCSP except exception.NovaException as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Unable DCSP to DCSP mount DCSP image DCSP %(image)s DCSP with DCSP error DCSP %(error)s. DCSP Cannot DCSP resize.'), {'image': image, 'error': e}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP utils.execute('e2label', image) DCNL DCSP  DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP  DCSP LOG.debug(_('Unable DCSP to DCSP determine DCSP label DCSP for DCSP image DCSP %(image)s DCSP with DCSP error DCSP %(errror)s. DCSP Cannot DCSP resize.'), {'image': image, 'error': e}) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP LOG.debug((_('Inject DCSP data DCSP image=%(image)s DCSP key=%(key)s DCSP net=%(net)s DCSP metadata=%(metadata)s DCSP admin_password=ha-ha-not-telling-you DCSP files=%(files)s DCSP partition=%(partition)s DCSP use_cow=%(use_cow)s') % locals())) DCNL DCSP fmt = 'raw' DCNL DCSP if use_cow: DCNL DCSP  DCSP fmt = 'qcow2' DCNL DCSP try: DCNL DCSP  DCSP fs = vfs.VFS.instance_for_image(image, fmt, partition) DCNL DCSP  DCSP fs.setup() DCNL DCSP except Exception as e: DCNL DCSP  DCSP for inject in mandatory: DCNL DCSP  DCSP  DCSP inject_val = locals()[inject] DCNL DCSP  DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP LOG.warn((_('Ignoring DCSP error DCSP injecting DCSP data DCSP into DCSP image DCSP (%(e)s)') % locals())) DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return inject_data_into_fs(fs, key, net, metadata, admin_password, files, mandatory) DCNL DCSP finally: DCNL DCSP  DCSP fs.teardown()
 DCSP img = _DiskImage(image=image, use_cow=use_cow, mount_dir=container_dir) DCNL DCSP if (not img.mount()): DCNL DCSP  DCSP LOG.error((_("Failed DCSP to DCSP mount DCSP container DCSP filesystem DCSP '%(image)s' DCSP on DCSP '%(target)s': DCSP %(errors)s") % {'image': img, 'target': container_dir, 'errors': img.errors})) DCNL DCSP  DCSP raise exception.NovaException(img.errors)
 DCSP try: DCNL DCSP  DCSP img = _DiskImage(image=None, mount_dir=container_dir) DCNL DCSP  DCSP img.teardown() DCNL DCSP except Exception as exn: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP teardown DCSP ntainer DCSP filesystem: DCSP %s'), exn)
 DCSP try: DCNL DCSP  DCSP img = _DiskImage(image=None, mount_dir=container_dir) DCNL DCSP  DCSP img.umount() DCNL DCSP except Exception as exn: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP umount DCSP container DCSP filesystem: DCSP %s'), exn)
 DCSP status = True DCNL DCSP for inject in ('key', 'net', 'metadata', 'admin_password', 'files'): DCNL DCSP  DCSP inject_val = locals()[inject] DCNL DCSP  DCSP inject_func = globals()[('_inject_%s_into_fs' % inject)] DCNL DCSP  DCSP if inject_val: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP inject_func(inject_val, fs) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP if (inject in mandatory): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((_('Ignoring DCSP error DCSP injecting DCSP %(inject)s DCSP into DCSP image DCSP (%(e)s)') % locals())) DCNL DCSP  DCSP  DCSP  DCSP status = False DCNL DCSP return status
 DCSP if (not fs.has_file(os.path.join('etc', 'selinux'))): DCNL DCSP  DCSP return DCNL DCSP rclocal = os.path.join('etc', 'rc.local') DCNL DCSP rc_d = os.path.join('etc', 'rc.d') DCNL DCSP if ((not fs.has_file(rclocal)) and fs.has_file(rc_d)): DCNL DCSP  DCSP rclocal = os.path.join(rc_d, 'rc.local') DCNL DCSP restorecon = ['\n', '# DCSP Added DCSP by DCSP Nova DCSP to DCSP ensure DCSP injected DCSP ssh DCSP keys DCSP have DCSP the DCSP right DCSP context\n', ('restorecon DCSP -RF DCSP %s DCSP 2>/dev/null DCSP || DCSP :\n' % sshdir)] DCNL DCSP if (not fs.has_file(rclocal)): DCNL DCSP  DCSP restorecon.insert(0, '#!/bin/sh') DCNL DCSP _inject_file_into_fs(fs, rclocal, ''.join(restorecon), append=True) DCNL DCSP fs.set_permissions(rclocal, 448)
 DCSP LOG.debug((_('Inject DCSP key DCSP fs=%(fs)s DCSP key=%(key)s') % locals())) DCNL DCSP sshdir = os.path.join('root', '.ssh') DCNL DCSP fs.make_path(sshdir) DCNL DCSP fs.set_ownership(sshdir, 'root', 'root') DCNL DCSP fs.set_permissions(sshdir, 448) DCNL DCSP keyfile = os.path.join(sshdir, 'authorized_keys') DCNL DCSP key_data = ''.join(['\n', '# DCSP The DCSP following DCSP ssh DCSP key DCSP was DCSP injected DCSP by DCSP Nova', '\n', key.strip(), '\n']) DCNL DCSP _inject_file_into_fs(fs, keyfile, key_data, append=True) DCNL DCSP fs.set_permissions(keyfile, 384) DCNL DCSP _setup_selinux_for_keys(fs, sshdir)
 DCSP LOG.debug((_('Inject DCSP key DCSP fs=%(fs)s DCSP net=%(net)s') % locals())) DCNL DCSP netdir = os.path.join('etc', 'network') DCNL DCSP fs.make_path(netdir) DCNL DCSP fs.set_ownership(netdir, 'root', 'root') DCNL DCSP fs.set_permissions(netdir, 484) DCNL DCSP netfile = os.path.join('etc', 'network', 'interfaces') DCNL DCSP _inject_file_into_fs(fs, netfile, net)
 DCSP LOG.debug((_('Inject DCSP admin DCSP password DCSP fs=%(fs)s DCSP admin_passwd=ha-ha-not-telling-you') % locals())) DCNL DCSP admin_user = 'root' DCNL DCSP (fd, tmp_passwd) = tempfile.mkstemp() DCNL DCSP os.close(fd) DCNL DCSP (fd, tmp_shadow) = tempfile.mkstemp() DCNL DCSP os.close(fd) DCNL DCSP passwd_path = os.path.join('etc', 'passwd') DCNL DCSP shadow_path = os.path.join('etc', 'shadow') DCNL DCSP passwd_data = fs.read_file(passwd_path) DCNL DCSP shadow_data = fs.read_file(shadow_path) DCNL DCSP new_shadow_data = _set_passwd(admin_user, admin_passwd, passwd_data, shadow_data) DCNL DCSP fs.replace_file(shadow_path, new_shadow_data)
 DCSP if (os.name == 'nt'): DCNL DCSP  DCSP raise exception.NovaException(_('Not DCSP implemented DCSP on DCSP Windows')) DCNL DCSP algos = {'SHA-512': '$6$', 'SHA-256': '$5$', 'MD5': '$1$', 'DES': ''} DCNL DCSP salt = _generate_salt() DCNL DCSP encrypted_passwd = crypt.crypt(admin_passwd, (algos['MD5'] + salt)) DCNL DCSP if (len(encrypted_passwd) == 13): DCNL DCSP  DCSP encrypted_passwd = crypt.crypt(admin_passwd, (algos['DES'] + salt)) DCNL DCSP p_file = passwd_data.split('\n') DCNL DCSP s_file = shadow_data.split('\n') DCNL DCSP found = False DCNL DCSP for entry in p_file: DCNL DCSP  DCSP split_entry = entry.split(':') DCNL DCSP  DCSP if (split_entry[0] == username): DCNL DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not found): DCNL DCSP  DCSP msg = _('User DCSP %(username)s DCSP not DCSP found DCSP in DCSP password DCSP file.') DCNL DCSP  DCSP raise exception.NovaException((msg % username)) DCNL DCSP new_shadow = list() DCNL DCSP found = False DCNL DCSP for entry in s_file: DCNL DCSP  DCSP split_entry = entry.split(':') DCNL DCSP  DCSP if (split_entry[0] == username): DCNL DCSP  DCSP  DCSP split_entry[1] = encrypted_passwd DCNL DCSP  DCSP  DCSP found = True DCNL DCSP  DCSP new_entry = ':'.join(split_entry) DCNL DCSP  DCSP new_shadow.append(new_entry) DCNL DCSP if (not found): DCNL DCSP  DCSP msg = _('User DCSP %(username)s DCSP not DCSP found DCSP in DCSP shadow DCSP file.') DCNL DCSP  DCSP raise exception.NovaException((msg % username)) DCNL DCSP return '\n'.join(new_shadow)
 DCSP if (not compute_driver): DCNL DCSP  DCSP compute_driver = CONF.compute_driver DCNL DCSP if (not compute_driver): DCNL DCSP  DCSP LOG.error(_('Compute DCSP driver DCSP option DCSP required, DCSP but DCSP not DCSP specified')) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP LOG.info((_("Loading DCSP compute DCSP driver DCSP '%s'") % compute_driver)) DCNL DCSP try: DCNL DCSP  DCSP driver = importutils.import_object_ns('nova.virt', compute_driver, virtapi) DCNL DCSP  DCSP return utils.check_isinstance(driver, ComputeDriver) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP LOG.error((_('Unable DCSP to DCSP load DCSP the DCSP virtualization DCSP driver: DCSP %s') % e)) DCNL DCSP  DCSP sys.exit(1)
 DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = nova_session.get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP return session
 DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = nova_session.create_engine(CONF.baremetal.sql_connection) DCNL DCSP return _ENGINE
 DCSP session = (kwargs.get('session') or db_session.get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and nova.context.is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
 DCSP if ('instance_uuid' not in values): DCNL DCSP  DCSP raise exception.NovaException(_('instance_uuid DCSP must DCSP be DCSP supplied DCSP to DCSP bm_node_associate_and_update')) DCNL DCSP session = db_session.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP query = model_query(context, models.BareMetalNode, session=session, read_deleted='no').filter_by(uuid=node_uuid) DCNL DCSP  DCSP count = query.filter_by(instance_uuid=None).update(values, synchronize_session=False) DCNL DCSP  DCSP if (count != 1): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Failed DCSP to DCSP associate DCSP instance DCSP %(i_uuid)s DCSP to DCSP baremetal DCSP node DCSP %(n_uuid)s.') % {'i_uuid': values['instance_uuid'], 'n_uuid': node_uuid})) DCNL DCSP  DCSP ref = query.first() DCNL DCSP return ref
 DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
 DCSP return IMPL.db_sync(version=version)
 DCSP return IMPL.db_version()
 DCSP values = {'task_state': state} DCNL DCSP if (not instance): DCNL DCSP  DCSP values['instance_uuid'] = None DCNL DCSP  DCSP values['instance_name'] = None DCNL DCSP db.bm_node_update(context, node['id'], values)
 DCSP LOG.debug((_('Building DCSP PXE DCSP config DCSP for DCSP deployment DCSP %s.') % deployment_id)) DCNL DCSP pxe_options = {'deployment_id': deployment_id, 'deployment_key': deployment_key, 'deployment_iscsi_iqn': deployment_iscsi_iqn, 'deployment_aki_path': deployment_aki_path, 'deployment_ari_path': deployment_ari_path, 'aki_path': aki_path, 'ari_path': ari_path, 'pxe_append_params': CONF.baremetal.pxe_append_params} DCNL DCSP cheetah = _get_cheetah() DCNL DCSP pxe_config = str(cheetah(open(CONF.baremetal.pxe_config_template).read(), searchList=[{'pxe_options': pxe_options, 'ROOT': '${ROOT}'}])) DCNL DCSP return pxe_config
 DCSP return os.path.join(CONF.instances_path, instance['name'])
 DCSP return os.path.join(CONF.instances_path, instance['name'], 'disk')
 DCSP return os.path.join(CONF.baremetal.tftp_root, instance['uuid'], 'config')
 DCSP return os.path.join(CONF.baremetal.tftp_root, 'pxelinux.cfg', ('01-' + mac.replace(':', '-').lower()))
 DCSP image_info = {'kernel': [None, None], 'ramdisk': [None, None], 'deploy_kernel': [None, None], 'deploy_ramdisk': [None, None]} DCNL DCSP try: DCNL DCSP  DCSP image_info['kernel'][0] = str(instance['kernel_id']) DCNL DCSP  DCSP image_info['ramdisk'][0] = str(instance['ramdisk_id']) DCNL DCSP  DCSP image_info['deploy_kernel'][0] = get_deploy_aki_id(instance_type) DCNL DCSP  DCSP image_info['deploy_ramdisk'][0] = get_deploy_ari_id(instance_type) DCNL DCSP except KeyError as e: DCNL DCSP  DCSP pass DCNL DCSP missing_labels = [] DCNL DCSP for label in image_info.keys(): DCNL DCSP  DCSP (uuid, path) = image_info[label] DCNL DCSP  DCSP if (not uuid): DCNL DCSP  DCSP  DCSP missing_labels.append(label) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_info[label][1] = os.path.join(CONF.baremetal.tftp_root, instance['uuid'], label) DCNL DCSP if missing_labels: DCNL DCSP  DCSP raise exception.NovaException((_('Can DCSP not DCSP activate DCSP PXE DCSP bootloader. DCSP The DCSP following DCSP boot DCSP parameters DCSP were DCSP not DCSP passed DCSP to DCSP baremetal DCSP driver: DCSP %s') % missing_labels)) DCNL DCSP return image_info
 DCSP host = vm_util.get_host_ref(session, cluster) DCNL DCSP if (cluster is not None): DCNL DCSP  DCSP vm_networks_ret = session._call_method(vim_util, 'get_dynamic_property', cluster, 'ClusterComputeResource', 'network') DCNL DCSP else: DCNL DCSP  DCSP vm_networks_ret = session._call_method(vim_util, 'get_dynamic_property', host, 'HostSystem', 'network') DCNL DCSP if (not vm_networks_ret): DCNL DCSP  DCSP return None DCNL DCSP vm_networks = vm_networks_ret.ManagedObjectReference DCNL DCSP networks = session._call_method(vim_util, 'get_properties_for_a_collection_of_objects', 'Network', vm_networks, ['summary.name']) DCNL DCSP network_obj = {} DCNL DCSP LOG.warn(vm_networks) DCNL DCSP for network in vm_networks: DCNL DCSP  DCSP if (network._type == 'DistributedVirtualPortgroup'): DCNL DCSP  DCSP  DCSP props = session._call_method(vim_util, 'get_dynamic_property', network, 'DistributedVirtualPortgroup', 'config') DCNL DCSP  DCSP  DCSP if (props.name == network_name): DCNL DCSP  DCSP  DCSP  DCSP network_obj['type'] = 'DistributedVirtualPortgroup' DCNL DCSP  DCSP  DCSP  DCSP network_obj['dvpg'] = props.key DCNL DCSP  DCSP  DCSP  DCSP dvs_props = session._call_method(vim_util, 'get_dynamic_property', props.distributedVirtualSwitch, 'VmwareDistributedVirtualSwitch', 'uuid') DCNL DCSP  DCSP  DCSP  DCSP network_obj['dvsw'] = dvs_props DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP props = session._call_method(vim_util, 'get_dynamic_property', network, 'Network', 'summary.name') DCNL DCSP  DCSP  DCSP if (props == network_name): DCNL DCSP  DCSP  DCSP  DCSP network_obj['type'] = 'Network' DCNL DCSP  DCSP  DCSP  DCSP network_obj['name'] = network_name DCNL DCSP if (len(network_obj) > 0): DCNL DCSP  DCSP return network_obj DCNL DCSP else: DCNL DCSP  DCSP return None
 DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP vswitches_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.network.vswitch') DCNL DCSP if (not vswitches_ret): DCNL DCSP  DCSP return DCNL DCSP vswitches = vswitches_ret.HostVirtualSwitch DCNL DCSP for elem in vswitches: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for nic_elem in elem.pnic: DCNL DCSP  DCSP  DCSP  DCSP if (str(nic_elem).split('-')[(-1)].find(vlan_interface) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return elem.name DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass
 DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP physical_nics_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.network.pnic') DCNL DCSP if (not physical_nics_ret): DCNL DCSP  DCSP return False DCNL DCSP physical_nics = physical_nics_ret.PhysicalNic DCNL DCSP for pnic in physical_nics: DCNL DCSP  DCSP if (vlan_interface == pnic.device): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP port_grps_on_host_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.network.portgroup') DCNL DCSP if (not port_grps_on_host_ret): DCNL DCSP  DCSP msg = _('ESX DCSP SOAP DCSP server DCSP returned DCSP an DCSP empty DCSP port DCSP group DCSP for DCSP the DCSP host DCSP system DCSP in DCSP its DCSP response') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.NovaException(msg) DCNL DCSP port_grps_on_host = port_grps_on_host_ret.HostPortGroup DCNL DCSP for p_gp in port_grps_on_host: DCNL DCSP  DCSP if (p_gp.spec.name == pg_name): DCNL DCSP  DCSP  DCSP p_grp_vswitch_name = p_gp.vswitch.split('-')[(-1)] DCNL DCSP  DCSP  DCSP return (p_gp.spec.vlanId, p_grp_vswitch_name)
 DCSP client_factory = session._get_vim().client.factory DCNL DCSP add_prt_grp_spec = vm_util.get_add_vswitch_port_group_spec(client_factory, vswitch_name, pg_name, vlan_id) DCNL DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP network_system_mor = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'configManager.networkSystem') DCNL DCSP LOG.debug((_('Creating DCSP Port DCSP Group DCSP with DCSP name DCSP %s DCSP on DCSP the DCSP ESX DCSP host') % pg_name)) DCNL DCSP try: DCNL DCSP  DCSP session._call_method(session._get_vim(), 'AddPortGroup', network_system_mor, portgrp=add_prt_grp_spec) DCNL DCSP except error_util.VimFaultException as exc: DCNL DCSP  DCSP if (error_util.FAULT_ALREADY_EXISTS not in exc.fault_list): DCNL DCSP  DCSP  DCSP raise exception.NovaException(exc) DCNL DCSP LOG.debug((_('Created DCSP Port DCSP Group DCSP with DCSP name DCSP %s DCSP on DCSP the DCSP ESX DCSP host') % pg_name))
 DCSP return ('[%s] DCSP %s' % (datastore_name, path))
 DCSP spl = datastore_path.split('[', 1)[1].split(']', 1) DCNL DCSP path = '' DCNL DCSP if (len(spl) == 1): DCNL DCSP  DCSP datastore_url = spl[0] DCNL DCSP else: DCNL DCSP  DCSP (datastore_url, path) = spl DCNL DCSP return (datastore_url, path.strip())
 DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP config_spec.name = instance['name'] DCNL DCSP config_spec.guestId = os_type DCNL DCSP vm_file_info = client_factory.create('ns0:VirtualMachineFileInfo') DCNL DCSP vm_file_info.vmPathName = (('[' + data_store_name) + ']') DCNL DCSP config_spec.files = vm_file_info DCNL DCSP tools_info = client_factory.create('ns0:ToolsConfigInfo') DCNL DCSP tools_info.afterPowerOn = True DCNL DCSP tools_info.afterResume = True DCNL DCSP tools_info.beforeGuestStandby = True DCNL DCSP tools_info.beforeGuestShutdown = True DCNL DCSP tools_info.beforeGuestReboot = True DCNL DCSP config_spec.tools = tools_info DCNL DCSP config_spec.numCPUs = int(instance['vcpus']) DCNL DCSP config_spec.memoryMB = int(instance['memory_mb']) DCNL DCSP vif_spec_list = [] DCNL DCSP for vif_info in vif_infos: DCNL DCSP  DCSP vif_spec = create_network_spec(client_factory, vif_info) DCNL DCSP  DCSP vif_spec_list.append(vif_spec) DCNL DCSP device_config_spec = vif_spec_list DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP extra_config = [] DCNL DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP opt.key = 'nvp.vm-uuid' DCNL DCSP opt.value = instance['uuid'] DCNL DCSP extra_config.append(opt) DCNL DCSP i = 0 DCNL DCSP for vif_info in vif_infos: DCNL DCSP  DCSP if vif_info['iface_id']: DCNL DCSP  DCSP  DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP  DCSP  DCSP opt.key = ('nvp.iface-id.%d' % i) DCNL DCSP  DCSP  DCSP opt.value = vif_info['iface_id'] DCNL DCSP  DCSP  DCSP extra_config.append(opt) DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP config_spec.extraConfig = extra_config DCNL DCSP return config_spec
 DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'add' DCNL DCSP if (adapter_type == 'busLogic'): DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualBusLogicController') DCNL DCSP else: DCNL DCSP  DCSP virtual_controller = client_factory.create('ns0:VirtualLsiLogicController') DCNL DCSP virtual_controller.key = key DCNL DCSP virtual_controller.busNumber = 0 DCNL DCSP virtual_controller.sharedBus = 'noSharing' DCNL DCSP virtual_device_config.device = virtual_controller DCNL DCSP return virtual_device_config
 DCSP network_spec = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP network_spec.operation = 'add' DCNL DCSP net_device = client_factory.create('ns0:VirtualPCNet32') DCNL DCSP network_ref = vif_info['network_ref'] DCNL DCSP network_name = vif_info['network_name'] DCNL DCSP mac_address = vif_info['mac_address'] DCNL DCSP backing = None DCNL DCSP if (network_ref and (network_ref['type'] == 'DistributedVirtualPortgroup')): DCNL DCSP  DCSP backing_name = ''.join(['ns0:VirtualEthernetCardDistributed', 'VirtualPortBackingInfo']) DCNL DCSP  DCSP backing = client_factory.create(backing_name) DCNL DCSP  DCSP portgroup = client_factory.create('ns0:DistributedVirtualSwitchPortConnection') DCNL DCSP  DCSP portgroup.switchUuid = network_ref['dvsw'] DCNL DCSP  DCSP portgroup.portgroupKey = network_ref['dvpg'] DCNL DCSP  DCSP backing.port = portgroup DCNL DCSP else: DCNL DCSP  DCSP backing = client_factory.create('ns0:VirtualEthernetCardNetworkBackingInfo') DCNL DCSP  DCSP backing.deviceName = network_name DCNL DCSP connectable_spec = client_factory.create('ns0:VirtualDeviceConnectInfo') DCNL DCSP connectable_spec.startConnected = True DCNL DCSP connectable_spec.allowGuestControl = True DCNL DCSP connectable_spec.connected = True DCNL DCSP net_device.connectable = connectable_spec DCNL DCSP net_device.backing = backing DCNL DCSP net_device.key = (-47) DCNL DCSP net_device.addressType = 'manual' DCNL DCSP net_device.macAddress = mac_address DCNL DCSP net_device.wakeOnLanEnabled = True DCNL DCSP network_spec.device = net_device DCNL DCSP return network_spec
 DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP device_config_spec = [] DCNL DCSP if (controller_key is None): DCNL DCSP  DCSP if (adapter_type == 'ide'): DCNL DCSP  DCSP  DCSP controller_key = 200 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP controller_key = (-101) DCNL DCSP  DCSP  DCSP controller_spec = create_controller_spec(client_factory, controller_key, adapter_type) DCNL DCSP  DCSP  DCSP device_config_spec.append(controller_spec) DCNL DCSP virtual_device_config_spec = create_virtual_disk_spec(client_factory, controller_key, disk_type, file_path, disk_size, linked_clone, unit_number, device_name) DCNL DCSP device_config_spec.append(virtual_device_config_spec) DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP return config_spec
 DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP device_config_spec = [] DCNL DCSP virtual_device_config_spec = delete_virtual_disk_spec(client_factory, device) DCNL DCSP device_config_spec.append(virtual_device_config_spec) DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP return config_spec
 DCSP if (hardware_devices.__class__.__name__ == 'ArrayOfVirtualDevice'): DCNL DCSP  DCSP hardware_devices = hardware_devices.VirtualDevice DCNL DCSP vmdk_file_path = None DCNL DCSP vmdk_controler_key = None DCNL DCSP disk_type = None DCNL DCSP unit_number = 0 DCNL DCSP adapter_type_dict = {} DCNL DCSP for device in hardware_devices: DCNL DCSP  DCSP if (device.__class__.__name__ == 'VirtualDisk'): DCNL DCSP  DCSP  DCSP if (device.backing.__class__.__name__ == 'VirtualDiskFlatVer2BackingInfo'): DCNL DCSP  DCSP  DCSP  DCSP vmdk_file_path = device.backing.fileName DCNL DCSP  DCSP  DCSP  DCSP vmdk_controler_key = device.controllerKey DCNL DCSP  DCSP  DCSP  DCSP if getattr(device.backing, 'thinProvisioned', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk_type = 'thin' DCNL DCSP  DCSP  DCSP  DCSP elif getattr(device.backing, 'eagerlyScrub', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk_type = 'eagerZeroedThick' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk_type = 'preallocated' DCNL DCSP  DCSP  DCSP if (device.unitNumber > unit_number): DCNL DCSP  DCSP  DCSP  DCSP unit_number = device.unitNumber DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualLsiLogicController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'lsiLogic' DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualBusLogicController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'busLogic' DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualIDEController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'ide' DCNL DCSP  DCSP elif (device.__class__.__name__ == 'VirtualLsiLogicSASController'): DCNL DCSP  DCSP  DCSP adapter_type_dict[device.key] = 'lsiLogic' DCNL DCSP adapter_type = adapter_type_dict.get(vmdk_controler_key, '') DCNL DCSP return (vmdk_file_path, vmdk_controler_key, adapter_type, disk_type, unit_number)
 DCSP if (hardware_devices.__class__.__name__ == 'ArrayOfVirtualDevice'): DCNL DCSP  DCSP hardware_devices = hardware_devices.VirtualDevice DCNL DCSP for device in hardware_devices: DCNL DCSP  DCSP if ((device.__class__.__name__ == 'VirtualDisk') and (device.backing.__class__.__name__ == 'VirtualDiskRawDiskMappingVer1BackingInfo') and (device.backing.lunUuid == uuid)): DCNL DCSP  DCSP  DCSP return device
 DCSP dest_spec = client_factory.create('ns0:VirtualDiskSpec') DCNL DCSP dest_spec.adapterType = adapter_type DCNL DCSP dest_spec.diskType = disk_type DCNL DCSP return dest_spec
 DCSP create_vmdk_spec = client_factory.create('ns0:FileBackedVirtualDiskSpec') DCNL DCSP create_vmdk_spec.adapterType = adapter_type DCNL DCSP create_vmdk_spec.diskType = disk_type DCNL DCSP create_vmdk_spec.capacityKb = size_in_kb DCNL DCSP return create_vmdk_spec
 DCSP create_vmdk_spec = client_factory.create('ns0:DeviceBackedVirtualDiskSpec') DCNL DCSP create_vmdk_spec.adapterType = adapter_type DCNL DCSP create_vmdk_spec.diskType = disk_type DCNL DCSP create_vmdk_spec.device = device DCNL DCSP return create_vmdk_spec
 DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'add' DCNL DCSP if ((file_path is None) or linked_clone): DCNL DCSP  DCSP virtual_device_config.fileOperation = 'create' DCNL DCSP virtual_disk = client_factory.create('ns0:VirtualDisk') DCNL DCSP if ((disk_type == 'rdm') or (disk_type == 'rdmp')): DCNL DCSP  DCSP disk_file_backing = client_factory.create('ns0:VirtualDiskRawDiskMappingVer1BackingInfo') DCNL DCSP  DCSP disk_file_backing.compatibilityMode = ('virtualMode' if (disk_type == 'rdm') else 'physicalMode') DCNL DCSP  DCSP disk_file_backing.diskMode = 'independent_persistent' DCNL DCSP  DCSP disk_file_backing.deviceName = (device_name or '') DCNL DCSP else: DCNL DCSP  DCSP disk_file_backing = client_factory.create('ns0:VirtualDiskFlatVer2BackingInfo') DCNL DCSP  DCSP disk_file_backing.diskMode = 'persistent' DCNL DCSP  DCSP if (disk_type == 'thin'): DCNL DCSP  DCSP  DCSP disk_file_backing.thinProvisioned = True DCNL DCSP  DCSP elif (disk_type == 'eagerZeroedThick'): DCNL DCSP  DCSP  DCSP disk_file_backing.eagerlyScrub = True DCNL DCSP disk_file_backing.fileName = (file_path or '') DCNL DCSP connectable_spec = client_factory.create('ns0:VirtualDeviceConnectInfo') DCNL DCSP connectable_spec.startConnected = True DCNL DCSP connectable_spec.allowGuestControl = False DCNL DCSP connectable_spec.connected = True DCNL DCSP if (not linked_clone): DCNL DCSP  DCSP virtual_disk.backing = disk_file_backing DCNL DCSP else: DCNL DCSP  DCSP virtual_disk.backing = copy.copy(disk_file_backing) DCNL DCSP  DCSP virtual_disk.backing.fileName = '' DCNL DCSP  DCSP virtual_disk.backing.parent = disk_file_backing DCNL DCSP virtual_disk.connectable = connectable_spec DCNL DCSP virtual_disk.key = (-100) DCNL DCSP virtual_disk.controllerKey = controller_key DCNL DCSP virtual_disk.unitNumber = (unit_number or 0) DCNL DCSP virtual_disk.capacityInKB = (disk_size or 0) DCNL DCSP virtual_device_config.device = virtual_disk DCNL DCSP return virtual_device_config
 DCSP virtual_device_config = client_factory.create('ns0:VirtualDeviceConfigSpec') DCNL DCSP virtual_device_config.operation = 'remove' DCNL DCSP virtual_device_config.fileOperation = 'destroy' DCNL DCSP virtual_device_config.device = device DCNL DCSP return virtual_device_config
 DCSP clone_spec = client_factory.create('ns0:VirtualMachineCloneSpec') DCNL DCSP clone_spec.location = location DCNL DCSP clone_spec.powerOn = power_on DCNL DCSP clone_spec.snapshot = snapshot DCNL DCSP clone_spec.template = template DCNL DCSP return clone_spec
 DCSP rel_spec = client_factory.create('ns0:VirtualMachineRelocateSpec') DCNL DCSP rel_spec.datastore = datastore DCNL DCSP rel_spec.diskMoveType = disk_move_type DCNL DCSP rel_spec.host = host DCNL DCSP return rel_spec
 DCSP config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP config_spec.name = name DCNL DCSP config_spec.guestId = 'otherGuest' DCNL DCSP vm_file_info = client_factory.create('ns0:VirtualMachineFileInfo') DCNL DCSP vm_file_info.vmPathName = (('[' + data_store_name) + ']') DCNL DCSP config_spec.files = vm_file_info DCNL DCSP tools_info = client_factory.create('ns0:ToolsConfigInfo') DCNL DCSP tools_info.afterPowerOn = True DCNL DCSP tools_info.afterResume = True DCNL DCSP tools_info.beforeGuestStandby = True DCNL DCSP tools_info.beforeGuestShutdown = True DCNL DCSP tools_info.beforeGuestReboot = True DCNL DCSP config_spec.tools = tools_info DCNL DCSP config_spec.numCPUs = 1 DCNL DCSP config_spec.memoryMB = 4 DCNL DCSP controller_key = (-101) DCNL DCSP controller_spec = create_controller_spec(client_factory, controller_key) DCNL DCSP disk_spec = create_virtual_disk_spec(client_factory, 1024, controller_key) DCNL DCSP device_config_spec = [controller_spec, disk_spec] DCNL DCSP config_spec.deviceChange = device_config_spec DCNL DCSP return config_spec
 DCSP virtual_machine_config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP opt = client_factory.create('ns0:OptionValue') DCNL DCSP opt.key = 'machine.id' DCNL DCSP opt.value = machine_id_str DCNL DCSP virtual_machine_config_spec.extraConfig = [opt] DCNL DCSP return virtual_machine_config_spec
 DCSP vswitch_port_group_spec = client_factory.create('ns0:HostPortGroupSpec') DCNL DCSP vswitch_port_group_spec.name = port_group_name DCNL DCSP vswitch_port_group_spec.vswitchName = vswitch_name DCNL DCSP vswitch_port_group_spec.vlanId = int(vlan_id) DCNL DCSP policy = client_factory.create('ns0:HostNetworkPolicy') DCNL DCSP nicteaming = client_factory.create('ns0:HostNicTeamingPolicy') DCNL DCSP nicteaming.notifySwitches = True DCNL DCSP policy.nicTeaming = nicteaming DCNL DCSP vswitch_port_group_spec.policy = policy DCNL DCSP return vswitch_port_group_spec
 DCSP virtual_machine_config_spec = client_factory.create('ns0:VirtualMachineConfigSpec') DCNL DCSP opt_enabled = client_factory.create('ns0:OptionValue') DCNL DCSP opt_enabled.key = 'RemoteDisplay.vnc.enabled' DCNL DCSP opt_enabled.value = 'true' DCNL DCSP opt_port = client_factory.create('ns0:OptionValue') DCNL DCSP opt_port.key = 'RemoteDisplay.vnc.port' DCNL DCSP opt_port.value = port DCNL DCSP opt_pass = client_factory.create('ns0:OptionValue') DCNL DCSP opt_pass.key = 'RemoteDisplay.vnc.password' DCNL DCSP opt_pass.value = password DCNL DCSP virtual_machine_config_spec.extraConfig = [opt_enabled, opt_port, opt_pass] DCNL DCSP return virtual_machine_config_spec
 DCSP search_spec = client_factory.create('ns0:HostDatastoreBrowserSearchSpec') DCNL DCSP search_spec.matchPattern = [file_name] DCNL DCSP return search_spec
 DCSP vms = session._call_method(vim_util, 'get_objects', 'VirtualMachine', ['name']) DCNL DCSP for vm in vms: DCNL DCSP  DCSP if (vm.propSet[0].val == vm_name): DCNL DCSP  DCSP  DCSP return vm.obj DCNL DCSP return None
 DCSP cls = session._call_method(vim_util, 'get_objects', 'ClusterComputeResource', ['name']) DCNL DCSP for cluster in cls: DCNL DCSP  DCSP if (cluster.propSet[0].val == cluster_name): DCNL DCSP  DCSP  DCSP return cluster.obj DCNL DCSP return None
 DCSP if (cluster is None): DCNL DCSP  DCSP host_mor = session._call_method(vim_util, 'get_objects', 'HostSystem')[0].obj DCNL DCSP else: DCNL DCSP  DCSP host_ret = session._call_method(vim_util, 'get_dynamic_property', cluster, 'ClusterComputeResource', 'host') DCNL DCSP  DCSP if (host_ret is None): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (not host_ret.ManagedObjectReference): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP host_mor = host_ret.ManagedObjectReference[0] DCNL DCSP return host_mor
 DCSP if ((cluster is None) and (host is None)): DCNL DCSP  DCSP data_stores = session._call_method(vim_util, 'get_objects', 'Datastore', ['summary.type', 'summary.name', 'summary.capacity', 'summary.freeSpace']) DCNL DCSP else: DCNL DCSP  DCSP if (cluster is not None): DCNL DCSP  DCSP  DCSP datastore_ret = session._call_method(vim_util, 'get_dynamic_property', cluster, 'ClusterComputeResource', 'datastore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP datastore_ret = session._call_method(vim_util, 'get_dynamic_property', host, 'HostSystem', 'datastore') DCNL DCSP  DCSP if (datastore_ret is None): DCNL DCSP  DCSP  DCSP raise exception.DatastoreNotFound() DCNL DCSP  DCSP data_store_mors = datastore_ret.ManagedObjectReference DCNL DCSP  DCSP data_stores = session._call_method(vim_util, 'get_properties_for_a_collection_of_objects', 'Datastore', data_store_mors, ['summary.type', 'summary.name', 'summary.capacity', 'summary.freeSpace']) DCNL DCSP for elem in data_stores: DCNL DCSP  DCSP ds_name = None DCNL DCSP  DCSP ds_type = None DCNL DCSP  DCSP ds_cap = None DCNL DCSP  DCSP ds_free = None DCNL DCSP  DCSP for prop in elem.propSet: DCNL DCSP  DCSP  DCSP if (prop.name == 'summary.type'): DCNL DCSP  DCSP  DCSP  DCSP ds_type = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.name'): DCNL DCSP  DCSP  DCSP  DCSP ds_name = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.capacity'): DCNL DCSP  DCSP  DCSP  DCSP ds_cap = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'summary.freeSpace'): DCNL DCSP  DCSP  DCSP  DCSP ds_free = prop.val DCNL DCSP  DCSP if ((ds_type == 'VMFS') or (ds_type == 'NFS')): DCNL DCSP  DCSP  DCSP data_store_name = ds_name DCNL DCSP  DCSP  DCSP return (elem.obj, data_store_name, ds_cap, ds_free) DCNL DCSP if (data_store_name is None): DCNL DCSP  DCSP raise exception.DatastoreNotFound()
 DCSP if (not image_meta): DCNL DCSP  DCSP image_meta = {} DCNL DCSP thread_safe_pipe = io_util.ThreadSafePipe(QUEUE_BUFFER_SIZE, data_size) DCNL DCSP read_thread = io_util.IOThread(read_file_handle, thread_safe_pipe) DCNL DCSP if write_file_handle: DCNL DCSP  DCSP write_thread = io_util.IOThread(thread_safe_pipe, write_file_handle) DCNL DCSP elif (image_service and image_id): DCNL DCSP  DCSP write_thread = io_util.GlanceWriteThread(context, thread_safe_pipe, image_service, image_id, image_meta) DCNL DCSP read_event = read_thread.start() DCNL DCSP write_event = write_thread.start() DCNL DCSP try: DCNL DCSP  DCSP read_event.wait() DCNL DCSP  DCSP write_event.wait() DCNL DCSP except Exception as exc: DCNL DCSP  DCSP read_thread.stop() DCNL DCSP  DCSP write_thread.stop() DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise exception.NovaException(exc) DCNL DCSP finally: DCNL DCSP  DCSP read_file_handle.close() DCNL DCSP  DCSP if write_file_handle: DCNL DCSP  DCSP  DCSP write_file_handle.close()
 DCSP LOG.debug((_('Downloading DCSP image DCSP %s DCSP from DCSP glance DCSP image DCSP server') % image), instance=instance) DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image) DCNL DCSP metadata = image_service.show(context, image_id) DCNL DCSP file_size = int(metadata['size']) DCNL DCSP read_iter = image_service.download(context, image_id) DCNL DCSP read_file_handle = read_write_util.GlanceFileRead(read_iter) DCNL DCSP write_file_handle = read_write_util.VMwareHTTPWriteFile(kwargs.get('host'), kwargs.get('data_center_name'), kwargs.get('datastore_name'), kwargs.get('cookies'), kwargs.get('file_path'), file_size) DCNL DCSP start_transfer(context, read_file_handle, file_size, write_file_handle=write_file_handle) DCNL DCSP LOG.debug((_('Downloaded DCSP image DCSP %s DCSP from DCSP glance DCSP image DCSP server') % image), instance=instance)
 DCSP LOG.debug((_('Uploading DCSP image DCSP %s DCSP to DCSP the DCSP Glance DCSP image DCSP server') % image), instance=instance) DCNL DCSP read_file_handle = read_write_util.VMwareHTTPReadFile(kwargs.get('host'), kwargs.get('data_center_name'), kwargs.get('datastore_name'), kwargs.get('cookies'), kwargs.get('file_path')) DCNL DCSP file_size = read_file_handle.get_size() DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image) DCNL DCSP image_metadata = {'disk_format': 'vmdk', 'is_public': 'false', 'name': kwargs.get('snapshot_name'), 'status': 'active', 'container_format': 'bare', 'size': file_size, 'properties': {'vmware_adaptertype': kwargs.get('adapter_type'), 'vmware_ostype': kwargs.get('os_type'), 'vmware_image_version': kwargs.get('image_version'), 'owner_id': instance['project_id']}} DCNL DCSP start_transfer(context, read_file_handle, file_size, image_service=image_service, image_id=image_id, image_meta=image_metadata) DCNL DCSP LOG.debug((_('Uploaded DCSP image DCSP %s DCSP to DCSP the DCSP Glance DCSP image DCSP server') % image), instance=instance)
 DCSP LOG.debug((_('Getting DCSP image DCSP size DCSP for DCSP the DCSP image DCSP %s') % image), instance=instance) DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image) DCNL DCSP meta_data = image_service.show(context, image_id) DCNL DCSP (size, properties) = (meta_data['size'], meta_data['properties']) DCNL DCSP LOG.debug((_('Got DCSP image DCSP size DCSP of DCSP %(size)s DCSP for DCSP the DCSP image DCSP %(image)s') % locals()), instance=instance) DCNL DCSP return (size, properties)
 DCSP sel_spec = client_factory.create('ns0:SelectionSpec') DCNL DCSP sel_spec.name = name DCNL DCSP return sel_spec
 DCSP traversal_spec = client_factory.create('ns0:TraversalSpec') DCNL DCSP traversal_spec.name = name DCNL DCSP traversal_spec.type = spec_type DCNL DCSP traversal_spec.path = path DCNL DCSP traversal_spec.skip = skip DCNL DCSP traversal_spec.selectSet = select_set DCNL DCSP return traversal_spec
 DCSP visit_folders_select_spec = build_selection_spec(client_factory, 'visitFolders') DCNL DCSP dc_to_hf = build_traversal_spec(client_factory, 'dc_to_hf', 'Datacenter', 'hostFolder', False, [visit_folders_select_spec]) DCNL DCSP dc_to_vmf = build_traversal_spec(client_factory, 'dc_to_vmf', 'Datacenter', 'vmFolder', False, [visit_folders_select_spec]) DCNL DCSP h_to_vm = build_traversal_spec(client_factory, 'h_to_vm', 'HostSystem', 'vm', False, [visit_folders_select_spec]) DCNL DCSP cr_to_h = build_traversal_spec(client_factory, 'cr_to_h', 'ComputeResource', 'host', False, []) DCNL DCSP cr_to_ds = build_traversal_spec(client_factory, 'cr_to_ds', 'ComputeResource', 'datastore', False, []) DCNL DCSP rp_to_rp_select_spec = build_selection_spec(client_factory, 'rp_to_rp') DCNL DCSP rp_to_vm_select_spec = build_selection_spec(client_factory, 'rp_to_vm') DCNL DCSP cr_to_rp = build_traversal_spec(client_factory, 'cr_to_rp', 'ComputeResource', 'resourcePool', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP rp_to_rp = build_traversal_spec(client_factory, 'rp_to_rp', 'ResourcePool', 'resourcePool', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP rp_to_vm = build_traversal_spec(client_factory, 'rp_to_vm', 'ResourcePool', 'vm', False, [rp_to_rp_select_spec, rp_to_vm_select_spec]) DCNL DCSP traversal_spec = build_traversal_spec(client_factory, 'visitFolders', 'Folder', 'childEntity', False, [visit_folders_select_spec, dc_to_hf, dc_to_vmf, cr_to_ds, cr_to_h, cr_to_rp, rp_to_rp, h_to_vm, rp_to_vm]) DCNL DCSP return traversal_spec
 DCSP if (not properties_to_collect): DCNL DCSP  DCSP properties_to_collect = ['name'] DCNL DCSP property_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP property_spec.all = all_properties DCNL DCSP property_spec.pathSet = properties_to_collect DCNL DCSP property_spec.type = type DCNL DCSP return property_spec
 DCSP object_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP object_spec.obj = root_folder DCNL DCSP object_spec.skip = False DCNL DCSP object_spec.selectSet = traversal_specs DCNL DCSP return object_spec
 DCSP property_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP property_filter_spec.propSet = property_specs DCNL DCSP property_filter_spec.objectSet = object_specs DCNL DCSP return property_filter_spec
 DCSP client_factory = vim.client.factory DCNL DCSP if (mobj is None): DCNL DCSP  DCSP return None DCNL DCSP usecoll = collector DCNL DCSP if (usecoll is None): DCNL DCSP  DCSP usecoll = vim.get_service_content().propertyCollector DCNL DCSP property_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP property_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP property_spec.all = ((properties is None) or (len(properties) == 0)) DCNL DCSP property_spec.pathSet = properties DCNL DCSP property_spec.type = type DCNL DCSP object_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP object_spec.obj = mobj DCNL DCSP object_spec.skip = False DCNL DCSP property_filter_spec.propSet = [property_spec] DCNL DCSP property_filter_spec.objectSet = [object_spec] DCNL DCSP return vim.RetrieveProperties(usecoll, specSet=[property_filter_spec])
 DCSP obj_content = get_object_properties(vim, None, mobj, type, [property_name]) DCNL DCSP property_value = None DCNL DCSP if obj_content: DCNL DCSP  DCSP dynamic_property = obj_content[0].propSet DCNL DCSP  DCSP if dynamic_property: DCNL DCSP  DCSP  DCSP property_value = dynamic_property[0].val DCNL DCSP return property_value
 DCSP if (not properties_to_collect): DCNL DCSP  DCSP properties_to_collect = ['name'] DCNL DCSP client_factory = vim.client.factory DCNL DCSP object_spec = build_object_spec(client_factory, vim.get_service_content().rootFolder, [build_recursive_traversal_spec(client_factory)]) DCNL DCSP property_spec = build_property_spec(client_factory, type=type, properties_to_collect=properties_to_collect, all_properties=all) DCNL DCSP property_filter_spec = build_property_filter_spec(client_factory, [property_spec], [object_spec]) DCNL DCSP return vim.RetrieveProperties(vim.get_service_content().propertyCollector, specSet=[property_filter_spec])
 DCSP prop_spec = client_factory.create('ns0:PropertySpec') DCNL DCSP prop_spec.type = spec_type DCNL DCSP prop_spec.pathSet = properties DCNL DCSP return prop_spec
 DCSP obj_spec = client_factory.create('ns0:ObjectSpec') DCNL DCSP obj_spec.obj = obj DCNL DCSP obj_spec.skip = False DCNL DCSP if (select_set is not None): DCNL DCSP  DCSP obj_spec.selectSet = select_set DCNL DCSP return obj_spec
 DCSP prop_filter_spec = client_factory.create('ns0:PropertyFilterSpec') DCNL DCSP prop_filter_spec.propSet = prop_spec DCNL DCSP prop_filter_spec.objectSet = obj_spec DCNL DCSP return prop_filter_spec
 DCSP client_factory = vim.client.factory DCNL DCSP if (len(obj_list) == 0): DCNL DCSP  DCSP return [] DCNL DCSP prop_spec = get_prop_spec(client_factory, type, properties) DCNL DCSP lst_obj_specs = [] DCNL DCSP for obj in obj_list: DCNL DCSP  DCSP lst_obj_specs.append(get_obj_spec(client_factory, obj)) DCNL DCSP prop_filter_spec = get_prop_filter_spec(client_factory, lst_obj_specs, [prop_spec]) DCNL DCSP return vim.RetrieveProperties(vim.get_service_content().propertyCollector, specSet=[prop_filter_spec])
 DCSP vlan_num = vif['network'].get_meta('vlan') DCNL DCSP bridge = vif['network']['bridge'] DCNL DCSP vlan_interface = CONF.vmwareapi_vlan_interface DCNL DCSP if (not network_util.check_if_vlan_interface_exists(session, vlan_interface, cluster)): DCNL DCSP  DCSP raise exception.NetworkAdapterNotFound(adapter=vlan_interface) DCNL DCSP vswitch_associated = network_util.get_vswitch_for_vlan_interface(session, vlan_interface, cluster) DCNL DCSP if (vswitch_associated is None): DCNL DCSP  DCSP raise exception.SwitchNotFoundForNetworkAdapter(adapter=vlan_interface) DCNL DCSP network_ref = network_util.get_network_with_the_name(session, bridge, cluster) DCNL DCSP if (network_ref is None): DCNL DCSP  DCSP network_util.create_port_group(session, bridge, vswitch_associated, vlan_num, cluster) DCNL DCSP else: DCNL DCSP  DCSP _get_pg_info = network_util.get_vlanid_and_vswitch_for_portgroup DCNL DCSP  DCSP (pg_vlanid, pg_vswitch) = _get_pg_info(session, bridge, cluster) DCNL DCSP  DCSP if (pg_vswitch != vswitch_associated): DCNL DCSP  DCSP  DCSP raise exception.InvalidVLANPortGroup(bridge=bridge, expected=vswitch_associated, actual=pg_vswitch) DCNL DCSP  DCSP if (pg_vlanid != vlan_num): DCNL DCSP  DCSP  DCSP raise exception.InvalidVLANTag(bridge=bridge, tag=vlan_num, pgroup=pg_vlanid)
 DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP hbas_ret = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'config.storageDevice.hostBusAdapter') DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return DCNL DCSP host_hbas = hbas_ret.HostHostBusAdapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP return hba.iScsiName
 DCSP target_portal = data['target_portal'] DCNL DCSP target_iqn = data['target_iqn'] DCNL DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP lst_properties = ['config.storageDevice.hostBusAdapter', 'config.storageDevice.scsiTopology', 'config.storageDevice.scsiLun'] DCNL DCSP props = session._call_method(vim_util, 'get_object_properties', None, host_mor, 'HostSystem', lst_properties) DCNL DCSP result = (None, None) DCNL DCSP hbas_ret = None DCNL DCSP scsi_topology = None DCNL DCSP scsi_lun_ret = None DCNL DCSP for elem in props: DCNL DCSP  DCSP for prop in elem.propSet: DCNL DCSP  DCSP  DCSP if (prop.name == 'config.storageDevice.hostBusAdapter'): DCNL DCSP  DCSP  DCSP  DCSP hbas_ret = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'config.storageDevice.scsiTopology'): DCNL DCSP  DCSP  DCSP  DCSP scsi_topology = prop.val DCNL DCSP  DCSP  DCSP elif (prop.name == 'config.storageDevice.scsiLun'): DCNL DCSP  DCSP  DCSP  DCSP scsi_lun_ret = prop.val DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return result DCNL DCSP host_hbas = hbas_ret.HostHostBusAdapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return result DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP hba_key = hba.key DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return result DCNL DCSP if (scsi_topology is None): DCNL DCSP  DCSP return result DCNL DCSP host_adapters = scsi_topology.adapter DCNL DCSP if (not host_adapters): DCNL DCSP  DCSP return result DCNL DCSP scsi_lun_key = None DCNL DCSP for adapter in host_adapters: DCNL DCSP  DCSP if (adapter.adapter == hba_key): DCNL DCSP  DCSP  DCSP if (not getattr(adapter, 'target', None)): DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP for target in adapter.target: DCNL DCSP  DCSP  DCSP  DCSP if (getattr(target.transport, 'address', None) and (target.transport.address[0] == target_portal) and (target.transport.iScsiName == target_iqn)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not target.lun): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP  DCSP  DCSP for lun in target.lun: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('host.ScsiDisk' in lun.scsiLun): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scsi_lun_key = lun.scsiLun DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP break DCNL DCSP if (scsi_lun_key is None): DCNL DCSP  DCSP return result DCNL DCSP if (scsi_lun_ret is None): DCNL DCSP  DCSP return result DCNL DCSP host_scsi_luns = scsi_lun_ret.ScsiLun DCNL DCSP if (not host_scsi_luns): DCNL DCSP  DCSP return result DCNL DCSP for scsi_lun in host_scsi_luns: DCNL DCSP  DCSP if (scsi_lun.key == scsi_lun_key): DCNL DCSP  DCSP  DCSP return (scsi_lun.deviceName, scsi_lun.uuid) DCNL DCSP return result
 DCSP host_mor = vm_util.get_host_ref(session, cluster) DCNL DCSP storage_system_mor = session._call_method(vim_util, 'get_dynamic_property', host_mor, 'HostSystem', 'configManager.storageSystem') DCNL DCSP hbas_ret = session._call_method(vim_util, 'get_dynamic_property', storage_system_mor, 'HostStorageSystem', 'storageDeviceInfo.hostBusAdapter') DCNL DCSP if (hbas_ret is None): DCNL DCSP  DCSP return DCNL DCSP host_hbas = hbas_ret.HostHostBusAdapter DCNL DCSP if (not host_hbas): DCNL DCSP  DCSP return DCNL DCSP for hba in host_hbas: DCNL DCSP  DCSP if (hba.__class__.__name__ == 'HostInternetScsiHba'): DCNL DCSP  DCSP  DCSP hba_device = hba.device DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP LOG.debug((_('Rescanning DCSP HBA DCSP %s') % hba_device)) DCNL DCSP session._call_method(session._get_vim(), 'RescanHba', storage_system_mor, hbaDevice=hba_device) DCNL DCSP LOG.debug((_('Rescanned DCSP HBA DCSP %s DCSP ') % hba_device))
 DCSP if mountpoint.startswith('/dev/'): DCNL DCSP  DCSP mountpoint = mountpoint[5:] DCNL DCSP if re.match('^[hsv]d[a-p]$', mountpoint): DCNL DCSP  DCSP return (ord(mountpoint[2:3]) - ord('a')) DCNL DCSP elif re.match('^[0-9]+$', mountpoint): DCNL DCSP  DCSP return string.atoi(mountpoint, 10) DCNL DCSP else: DCNL DCSP  DCSP LOG.warn((_('Mountpoint DCSP cannot DCSP be DCSP translated: DCSP %s') % mountpoint)) DCNL DCSP  DCSP return (-1)
 DCSP text = (msg or '') DCNL DCSP content = pprint.pformat(_db_content) DCNL DCSP LOG.debug((_('%(text)s: DCSP _db_content DCSP => DCSP %(content)s') % locals()))
 DCSP for c in _CLASSES: DCNL DCSP  DCSP if (c == 'files'): DCNL DCSP  DCSP  DCSP _db_content[c] = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _db_content[c] = {} DCNL DCSP create_network() DCNL DCSP create_host_network_system() DCNL DCSP create_host() DCNL DCSP create_datacenter() DCNL DCSP create_datastore() DCNL DCSP create_res_pool()
 DCSP for c in _CLASSES: DCNL DCSP  DCSP _db_content[c] = {}
 DCSP _db_content[table][table_obj.obj] = table_obj
 DCSP lst_objs = [] DCNL DCSP for key in _db_content[obj_type]: DCNL DCSP  DCSP lst_objs.append(_db_content[obj_type][key]) DCNL DCSP return lst_objs
 DCSP _db_content['files'].append(file_path)
 DCSP if (_db_content.get('files') is None): DCNL DCSP  DCSP raise exception.NoFilesFound() DCNL DCSP if (file_path.find('.vmdk') != (-1)): DCNL DCSP  DCSP if (file_path not in _db_content.get('files')): DCNL DCSP  DCSP  DCSP raise exception.FileNotFound(file_path=file_path) DCNL DCSP  DCSP _db_content.get('files').remove(file_path) DCNL DCSP else: DCNL DCSP  DCSP for file in _db_content.get('files'): DCNL DCSP  DCSP  DCSP if (file.find(file_path) != (-1)): DCNL DCSP  DCSP  DCSP  DCSP lst_files = _db_content.get('files') DCNL DCSP  DCSP  DCSP  DCSP if (lst_files and lst_files.count(file)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lst_files.remove(file)
 DCSP pass
 DCSP return {'type': 'fake'}
 DCSP ds_name = kwargs.get('datastore_name') DCNL DCSP file_path = kwargs.get('file_path') DCNL DCSP ds_file_path = ((('[' + ds_name) + '] DCSP ') + file_path) DCNL DCSP _add_file(ds_file_path)
 DCSP pass
 DCSP props = {'vmware_ostype': 'otherGuest', 'vmware_adaptertype': 'lsiLogic'} DCNL DCSP return (_FAKE_FILE_SIZE, props)
 DCSP if (_db_content.get('VirtualMachine', None) is None): DCNL DCSP  DCSP raise exception.NotFound(_('There DCSP is DCSP no DCSP VM DCSP registered')) DCNL DCSP if (vm_ref not in _db_content.get('VirtualMachine')): DCNL DCSP  DCSP raise exception.NotFound((_('Virtual DCSP Machine DCSP with DCSP ref DCSP %s DCSP is DCSP not DCSP there') % vm_ref)) DCNL DCSP return _db_content.get('VirtualMachine')[vm_ref]
 DCSP if (network_info is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(network_info, 'legacy'): DCNL DCSP  DCSP network_info = network_info.legacy() DCNL DCSP nets = [] DCNL DCSP ifc_num = (-1) DCNL DCSP have_injected_networks = False DCNL DCSP for (network_ref, mapping) in network_info: DCNL DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP if (not network_ref['injected']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP have_injected_networks = True DCNL DCSP  DCSP address = mapping['ips'][0]['ip'] DCNL DCSP  DCSP netmask = mapping['ips'][0]['netmask'] DCNL DCSP  DCSP address_v6 = None DCNL DCSP  DCSP gateway_v6 = None DCNL DCSP  DCSP netmask_v6 = None DCNL DCSP  DCSP if use_ipv6: DCNL DCSP  DCSP  DCSP address_v6 = mapping['ip6s'][0]['ip'] DCNL DCSP  DCSP  DCSP netmask_v6 = mapping['ip6s'][0]['netmask'] DCNL DCSP  DCSP  DCSP gateway_v6 = mapping['gateway_v6'] DCNL DCSP  DCSP net_info = {'name': ('eth%d' % ifc_num), 'address': address, 'netmask': netmask, 'gateway': mapping['gateway'], 'broadcast': mapping['broadcast'], 'dns': ' DCSP '.join(mapping['dns']), 'address_v6': address_v6, 'gateway_v6': gateway_v6, 'netmask_v6': netmask_v6} DCNL DCSP  DCSP nets.append(net_info) DCNL DCSP if (have_injected_networks is False): DCNL DCSP  DCSP return None DCNL DCSP if (not template): DCNL DCSP  DCSP return None DCNL DCSP _late_load_cheetah() DCNL DCSP ifc_template = open(template).read() DCNL DCSP return str(Template(ifc_template, searchList=[{'interfaces': nets, 'use_ipv6': use_ipv6}]))
 DCSP d = {} DCNL DCSP id_path = os.path.join(storage_path, 'compute_nodes') DCNL DCSP if os.path.exists(id_path): DCNL DCSP  DCSP with open(id_path) as f: DCNL DCSP  DCSP  DCSP d = json.loads(f.read()) DCNL DCSP d[hostname] = time.time() DCNL DCSP with open(id_path, 'w') as f: DCNL DCSP  DCSP f.write(json.dumps(d))
 DCSP d = {} DCNL DCSP id_path = os.path.join(storage_path, 'compute_nodes') DCNL DCSP if os.path.exists(id_path): DCNL DCSP  DCSP with open(id_path) as f: DCNL DCSP  DCSP  DCSP d = json.loads(f.read()) DCNL DCSP recent_users = [] DCNL DCSP for node in d: DCNL DCSP  DCSP if ((time.time() - d[node]) < TWENTY_FOUR_HOURS): DCNL DCSP  DCSP  DCSP recent_users.append(node) DCNL DCSP return recent_users
 DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP return QemuImgInfo() DCNL DCSP (out, err) = utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info', path) DCNL DCSP return QemuImgInfo(out)
 DCSP cmd = ('qemu-img', 'convert', '-O', out_format, source, dest) DCNL DCSP utils.execute(run_as_root=run_as_root, *cmd)
 DCSP expr = ('field DCSP "name__label" DCSP = DCSP "%s" DCSP or DCSP field DCSP "bridge" DCSP = DCSP "%s"' % (bridge, bridge)) DCNL DCSP networks = session.call_xenapi('network.get_all_records_where', expr) DCNL DCSP if (len(networks) == 1): DCNL DCSP  DCSP return networks.keys()[0] DCNL DCSP elif (len(networks) > 1): DCNL DCSP  DCSP raise Exception((_('Found DCSP non-unique DCSP network DCSP for DCSP bridge DCSP %s') % bridge)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_('Found DCSP no DCSP network DCSP for DCSP bridge DCSP %s') % bridge))
 DCSP a = a.split('.') DCNL DCSP b = b.split('.') DCNL DCSP for (va, vb) in zip(a, b): DCNL DCSP  DCSP ret = (int(va) - int(vb)) DCNL DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return (len(a) - len(b))
 DCSP step_info = dict(total=0, current=0) DCNL DCSP def bump_progress(): DCNL DCSP  DCSP step_info['current'] += 1 DCNL DCSP  DCSP progress = round(((float(step_info['current']) / step_info['total']) * 100)) DCNL DCSP  DCSP LOG.debug(_('Updating DCSP progress DCSP to DCSP %(progress)d'), locals(), instance=instance) DCNL DCSP  DCSP instance_update(context, instance['uuid'], {'progress': progress}) DCNL DCSP def step_decorator(f): DCNL DCSP  DCSP step_info['total'] += 1 DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP rv = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP bump_progress() DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP return inner DCNL DCSP return step_decorator
 DCSP return (POOL_FLAG in metadata.keys())
 DCSP instance_type = instance_types.extract_instance_type(instance) DCNL DCSP mem = str(((long(instance_type['memory_mb']) * 1024) * 1024)) DCNL DCSP vcpus = str(instance_type['vcpus']) DCNL DCSP rec = {'actions_after_crash': 'destroy', 'actions_after_reboot': 'restart', 'actions_after_shutdown': 'destroy', 'affinity': '', 'blocked_operations': {}, 'ha_always_run': False, 'ha_restart_priority': '', 'HVM_boot_params': {}, 'HVM_boot_policy': '', 'is_a_template': False, 'memory_dynamic_min': mem, 'memory_dynamic_max': mem, 'memory_static_min': '0', 'memory_static_max': mem, 'memory_target': mem, 'name_description': '', 'name_label': name_label, 'other_config': {'nova_uuid': str(instance['uuid'])}, 'PCI_bus': '', 'platform': {'acpi': 'true', 'apic': 'true', 'pae': 'true', 'viridian': 'true', 'timeoffset': '0'}, 'PV_args': '', 'PV_bootloader': '', 'PV_bootloader_args': '', 'PV_kernel': '', 'PV_legacy_args': '', 'PV_ramdisk': '', 'recommendations': '', 'tags': [], 'user_version': '0', 'VCPUs_at_startup': vcpus, 'VCPUs_max': vcpus, 'VCPUs_params': {}, 'xenstore_data': {'allowvssprovider': 'false'}} DCNL DCSP if use_pv_kernel: DCNL DCSP  DCSP rec['platform']['nx'] = 'false' DCNL DCSP  DCSP if instance['kernel_id']: DCNL DCSP  DCSP  DCSP rec['PV_args'] = 'root=/dev/xvda1' DCNL DCSP  DCSP  DCSP rec['PV_kernel'] = kernel DCNL DCSP  DCSP  DCSP rec['PV_ramdisk'] = ramdisk DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rec['PV_bootloader'] = 'pygrub' DCNL DCSP else: DCNL DCSP  DCSP rec['platform']['nx'] = 'true' DCNL DCSP  DCSP rec['HVM_boot_params'] = {'order': 'dc'} DCNL DCSP  DCSP rec['HVM_boot_policy'] = 'BIOS DCSP order' DCNL DCSP vm_ref = session.call_xenapi('VM.create', rec) DCNL DCSP LOG.debug(_('Created DCSP VM'), instance=instance) DCNL DCSP return vm_ref
 DCSP try: DCNL DCSP  DCSP session.call_xenapi('VM.destroy', vm_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP return DCNL DCSP LOG.debug(_('VM DCSP destroyed'), instance=instance)
 DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP if vbd_refs: DCNL DCSP  DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vbd_rec = session.call_xenapi('VBD.get_record', vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP if (vbd_rec['userdevice'] == str(number)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return vbd_ref DCNL DCSP  DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP raise volume_utils.StorageError((_('VBD DCSP not DCSP found DCSP in DCSP instance DCSP %s') % vm_ref))
 DCSP max_attempts = (CONF.xenapi_num_vbd_unplug_retries + 1) DCNL DCSP for num_attempt in xrange(1, (max_attempts + 1)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session.call_xenapi('VBD.unplug', vbd_ref) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP err = ((len(exc.details) > 0) and exc.details[0]) DCNL DCSP  DCSP  DCSP if (err == 'DEVICE_ALREADY_DETACHED'): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('VBD DCSP %s DCSP already DCSP detached'), vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP elif (err == 'DEVICE_DETACH_REJECTED'): DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('VBD DCSP %(vbd_ref)s DCSP detach DCSP rejected, DCSP attempt DCSP %(num_attempt)d/%(max_attempts)d'), locals()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP  DCSP  DCSP raise volume_utils.StorageError((_('Unable DCSP to DCSP unplug DCSP VBD DCSP %s') % vbd_ref)) DCNL DCSP  DCSP greenthread.sleep(1) DCNL DCSP raise volume_utils.StorageError((_('Reached DCSP maximum DCSP number DCSP of DCSP retries DCSP trying DCSP to DCSP unplug DCSP VBD DCSP %s') % vbd_ref))
 DCSP try: DCNL DCSP  DCSP session.call_xenapi('VBD.destroy', vbd_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise volume_utils.StorageError((_('Unable DCSP to DCSP destroy DCSP VBD DCSP %s') % vbd_ref))
 DCSP vbd_rec = {} DCNL DCSP vbd_rec['VM'] = vm_ref DCNL DCSP vbd_rec['VDI'] = vdi_ref DCNL DCSP vbd_rec['userdevice'] = str(userdevice) DCNL DCSP vbd_rec['bootable'] = bootable DCNL DCSP vbd_rec['mode'] = ((read_only and 'RO') or 'RW') DCNL DCSP vbd_rec['type'] = vbd_type DCNL DCSP vbd_rec['unpluggable'] = True DCNL DCSP vbd_rec['empty'] = False DCNL DCSP vbd_rec['other_config'] = {} DCNL DCSP vbd_rec['qos_algorithm_type'] = '' DCNL DCSP vbd_rec['qos_algorithm_params'] = {} DCNL DCSP vbd_rec['qos_supported_algorithms'] = [] DCNL DCSP LOG.debug(_('Creating DCSP %(vbd_type)s-type DCSP VBD DCSP for DCSP VM DCSP %(vm_ref)s, DCSP VDI DCSP %(vdi_ref)s DCSP ... DCSP '), locals()) DCNL DCSP vbd_ref = session.call_xenapi('VBD.create', vbd_rec) DCNL DCSP LOG.debug(_('Created DCSP VBD DCSP %(vbd_ref)s DCSP for DCSP VM DCSP %(vm_ref)s, DCSP VDI DCSP %(vdi_ref)s.'), locals()) DCNL DCSP if osvol: DCNL DCSP  DCSP session.call_xenapi('VBD.add_to_other_config', vbd_ref, 'osvol', 'True') DCNL DCSP return vbd_ref
 DCSP for vdi_ref in vdi_refs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref) DCNL DCSP  DCSP except volume_utils.StorageError as exc: DCNL DCSP  DCSP  DCSP LOG.error(exc)
 DCSP otherconf = {'nova_disk_type': disk_type} DCNL DCSP if instance: DCNL DCSP  DCSP otherconf['nova_instance_uuid'] = instance['uuid'] DCNL DCSP vdi_ref = session.call_xenapi('VDI.create', {'name_label': name_label, 'name_description': disk_type, 'SR': sr_ref, 'virtual_size': str(virtual_size), 'type': 'User', 'sharable': False, 'read_only': read_only, 'xenstore_data': {}, 'other_config': otherconf, 'sm_config': {}, 'tags': []}) DCNL DCSP LOG.debug(_('Created DCSP VDI DCSP %(vdi_ref)s DCSP (%(name_label)s, DCSP %(virtual_size)s, DCSP %(read_only)s) DCSP on DCSP %(sr_ref)s.'), locals()) DCNL DCSP return vdi_ref
 DCSP name_label = 'dummy' DCNL DCSP vm_ref = create_vm(session, instance, name_label, None, None) DCNL DCSP try: DCNL DCSP  DCSP vbd_ref = create_vbd(session, vm_ref, vdi_ref, 'autodetect', read_only=True) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yield vm_ref) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP destroy_vbd(session, vbd_ref) DCNL DCSP  DCSP  DCSP except volume_utils.StorageError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP finally: DCNL DCSP  DCSP destroy_vm(session, instance, vm_ref)
 DCSP with _dummy_vm(session, instance, vdi_to_copy_ref) as vm_ref: DCNL DCSP  DCSP label = 'snapshot' DCNL DCSP  DCSP with snapshot_attached_here(session, instance, vm_ref, label) as vdi_uuids: DCNL DCSP  DCSP  DCSP imported_vhds = session.call_plugin_serialized('workarounds', 'safe_copy_vdis', sr_path=get_sr_path(session), vdi_uuids=vdi_uuids, uuid_stack=_make_uuid_stack()) DCNL DCSP root_uuid = imported_vhds['root']['uuid'] DCNL DCSP scan_default_sr(session) DCNL DCSP vdi_ref = session.call_xenapi('VDI.get_by_uuid', root_uuid) DCNL DCSP return vdi_ref
 DCSP vdi_ref = session.call_xenapi('VDI.clone', vdi_to_clone_ref) DCNL DCSP LOG.debug((_('Cloned DCSP VDI DCSP %(vdi_ref)s DCSP from DCSP VDI DCSP %(vdi_to_clone_ref)s') % locals())) DCNL DCSP return vdi_ref
 DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP for vbd in vbd_refs: DCNL DCSP  DCSP vbd_rec = session.call_xenapi('VBD.get_record', vbd) DCNL DCSP  DCSP if (vbd_rec['userdevice'] == '0'): DCNL DCSP  DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vbd_rec['VDI']) DCNL DCSP  DCSP  DCSP return (vbd_rec['VDI'], vdi_rec) DCNL DCSP raise exception.NovaException((_('No DCSP primary DCSP VDI DCSP found DCSP for DCSP %(vm_ref)s') % locals()))
 DCSP sr_ref = safe_find_sr(session) DCNL DCSP sr_rec = session.call_xenapi('SR.get_record', sr_ref) DCNL DCSP sr_uuid = sr_rec['uuid'] DCNL DCSP return os.path.join(CONF.xenapi_sr_base_path, sr_uuid)
 DCSP cached_images = _find_cached_images(session, sr_ref) DCNL DCSP destroyed = set() DCNL DCSP def destroy_cached_vdi(vdi_uuid, vdi_ref): DCNL DCSP  DCSP LOG.debug(_("Destroying DCSP cached DCSP VDI DCSP '%(vdi_uuid)s'")) DCNL DCSP  DCSP if (not dry_run): DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref) DCNL DCSP  DCSP destroyed.add(vdi_uuid) DCNL DCSP for vdi_ref in cached_images.values(): DCNL DCSP  DCSP vdi_uuid = session.call_xenapi('VDI.get_uuid', vdi_ref) DCNL DCSP  DCSP if all_cached: DCNL DCSP  DCSP  DCSP destroy_cached_vdi(vdi_uuid, vdi_ref) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP chain = list(_walk_vdi_chain(session, vdi_uuid)) DCNL DCSP  DCSP if (len(chain) > 2): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (len(chain) == 2): DCNL DCSP  DCSP  DCSP root_vdi_rec = chain[(-1)] DCNL DCSP  DCSP  DCSP children = _child_vhds(session, sr_ref, root_vdi_rec['uuid']) DCNL DCSP  DCSP  DCSP if (len(children) > 1): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP destroy_cached_vdi(vdi_uuid, vdi_ref) DCNL DCSP return destroyed
 DCSP cached_images = {} DCNL DCSP for (vdi_ref, vdi_rec) in _get_all_vdis_in_sr(session, sr_ref): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP image_id = vdi_rec['other_config']['image-id'] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP cached_images[image_id] = vdi_ref DCNL DCSP return cached_images
 DCSP cached_images = _find_cached_images(session, sr_ref) DCNL DCSP return cached_images.get(image_id)
 DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP partitions = _get_partitions(dev) DCNL DCSP  DCSP if (len(partitions) != 1): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (_num, start, old_sectors, ptype) = partitions[0] DCNL DCSP  DCSP if (ptype in ('ext3', 'ext4')): DCNL DCSP  DCSP  DCSP new_sectors = ((((new_gb * 1024) * 1024) * 1024) / SECTOR_SIZE) DCNL DCSP  DCSP  DCSP _resize_part_and_fs(dev, start, old_sectors, new_sectors)
 DCSP sr_ref = safe_find_sr(session) DCNL DCSP ONE_MEG = (1024 * 1024) DCNL DCSP virtual_size = (size_mb * ONE_MEG) DCNL DCSP vdi_ref = create_vdi(session, sr_ref, instance, name_label, disk_type, virtual_size) DCNL DCSP try: DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP  DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP  DCSP  DCSP utils.execute('parted', '--script', dev_path, 'mklabel', 'msdos', run_as_root=True) DCNL DCSP  DCSP  DCSP partition_start = 0 DCNL DCSP  DCSP  DCSP partition_end = size_mb DCNL DCSP  DCSP  DCSP utils.execute('parted', '--script', dev_path, 'mkpart', 'primary', str(partition_start), str(partition_end), run_as_root=True) DCNL DCSP  DCSP  DCSP partition_path = utils.make_dev_path(dev, partition=1) DCNL DCSP  DCSP  DCSP if (fs_type == 'linux-swap'): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkswap', partition_path, run_as_root=True) DCNL DCSP  DCSP  DCSP elif (fs_type is not None): DCNL DCSP  DCSP  DCSP  DCSP utils.execute('mkfs', '-t', fs_type, partition_path, run_as_root=True) DCNL DCSP  DCSP create_vbd(session, vm_ref, vdi_ref, userdevice, bootable=False) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref)
 DCSP filename = '' DCNL DCSP if CONF.cache_images: DCNL DCSP  DCSP args = {} DCNL DCSP  DCSP args['cached-image'] = image_id DCNL DCSP  DCSP args['new-image-uuid'] = str(uuid.uuid4()) DCNL DCSP  DCSP filename = session.call_plugin('kernel', 'create_kernel_ramdisk', args) DCNL DCSP if (filename == ''): DCNL DCSP  DCSP return _fetch_disk_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP else: DCNL DCSP  DCSP vdi_type = ImageType.to_string(image_type) DCNL DCSP  DCSP return {vdi_type: dict(uuid=None, file=filename)}
 DCSP cache_images = CONF.cache_images.lower() DCNL DCSP if (image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP cache = False DCNL DCSP elif (cache_images == 'all'): DCNL DCSP  DCSP cache = True DCNL DCSP elif (cache_images == 'some'): DCNL DCSP  DCSP sys_meta = utils.metadata_to_dict(instance['system_metadata']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cache = utils.bool_from_str(sys_meta['image_cache_in_nova']) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP cache = False DCNL DCSP elif (cache_images == 'none'): DCNL DCSP  DCSP cache = False DCNL DCSP else: DCNL DCSP  DCSP LOG.warning(_("Unrecognized DCSP cache_images DCSP value DCSP '%s', DCSP defaulting DCSP to DCSP True"), CONF.cache_images) DCNL DCSP  DCSP cache = True DCNL DCSP if cache: DCNL DCSP  DCSP vdis = _create_cached_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP else: DCNL DCSP  DCSP vdis = _fetch_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP for (vdi_type, vdi) in vdis.iteritems(): DCNL DCSP  DCSP set_vdi_name(session, vdi['uuid'], name_label, vdi_type) DCNL DCSP return vdis
 DCSP if (image_type == ImageType.DISK_VHD): DCNL DCSP  DCSP vdis = _fetch_vhd_image(context, session, instance, image_id) DCNL DCSP else: DCNL DCSP  DCSP vdis = _fetch_disk_image(context, session, instance, name_label, image_id, image_type) DCNL DCSP for (vdi_type, vdi) in vdis.iteritems(): DCNL DCSP  DCSP vdi_uuid = vdi['uuid'] DCNL DCSP  DCSP LOG.debug(_("Fetched DCSP VDIs DCSP of DCSP type DCSP '%(vdi_type)s' DCSP with DCSP UUID DCSP '%(vdi_uuid)s'"), locals(), instance=instance) DCNL DCSP return vdis
 DCSP LOG.debug(_('Asking DCSP xapi DCSP to DCSP fetch DCSP vhd DCSP image DCSP %(image_id)s'), locals(), instance=instance) DCNL DCSP params = {'image_id': image_id, 'uuid_stack': _make_uuid_stack(), 'sr_path': get_sr_path(session)} DCNL DCSP if _image_uses_bittorrent(context, instance): DCNL DCSP  DCSP plugin_name = 'bittorrent' DCNL DCSP  DCSP callback = None DCNL DCSP  DCSP params['torrent_base_url'] = CONF.xenapi_torrent_base_url DCNL DCSP  DCSP params['torrent_seed_duration'] = CONF.xenapi_torrent_seed_duration DCNL DCSP  DCSP params['torrent_seed_chance'] = CONF.xenapi_torrent_seed_chance DCNL DCSP  DCSP params['torrent_max_last_accessed'] = CONF.xenapi_torrent_max_last_accessed DCNL DCSP  DCSP params['torrent_listen_port_start'] = CONF.xenapi_torrent_listen_port_start DCNL DCSP  DCSP params['torrent_listen_port_end'] = CONF.xenapi_torrent_listen_port_end DCNL DCSP  DCSP params['torrent_download_stall_cutoff'] = CONF.xenapi_torrent_download_stall_cutoff DCNL DCSP  DCSP params['torrent_max_seeder_processes_per_host'] = CONF.xenapi_torrent_max_seeder_processes_per_host DCNL DCSP else: DCNL DCSP  DCSP plugin_name = 'glance' DCNL DCSP  DCSP glance_api_servers = glance.get_api_servers() DCNL DCSP  DCSP def pick_glance(params): DCNL DCSP  DCSP  DCSP (g_host, g_port, g_use_ssl) = glance_api_servers.next() DCNL DCSP  DCSP  DCSP params['glance_host'] = g_host DCNL DCSP  DCSP  DCSP params['glance_port'] = g_port DCNL DCSP  DCSP  DCSP params['glance_use_ssl'] = g_use_ssl DCNL DCSP  DCSP  DCSP params['auth_token'] = getattr(context, 'auth_token', None) DCNL DCSP  DCSP callback = pick_glance DCNL DCSP vdis = _fetch_using_dom0_plugin_with_retry(context, session, image_id, plugin_name, params, callback=callback) DCNL DCSP sr_ref = safe_find_sr(session) DCNL DCSP _scan_sr(session, sr_ref) DCNL DCSP root_vdi_uuid = vdis['root']['uuid'] DCNL DCSP set_vdi_name(session, root_vdi_uuid, instance['name'], 'root') DCNL DCSP _check_vdi_size(context, session, instance, root_vdi_uuid) DCNL DCSP return vdis
 DCSP size_bytes = 0 DCNL DCSP for vdi_rec in _walk_vdi_chain(session, vdi_uuid): DCNL DCSP  DCSP cur_vdi_uuid = vdi_rec['uuid'] DCNL DCSP  DCSP vdi_size_bytes = int(vdi_rec['physical_utilisation']) DCNL DCSP  DCSP LOG.debug(_('vdi_uuid=%(cur_vdi_uuid)s DCSP vdi_size_bytes=%(vdi_size_bytes)d'), locals()) DCNL DCSP  DCSP size_bytes += vdi_size_bytes DCNL DCSP return size_bytes
 DCSP image_type_str = ImageType.to_string(image_type) DCNL DCSP LOG.debug(_('Fetching DCSP image DCSP %(image_id)s, DCSP type DCSP %(image_type_str)s'), locals(), instance=instance) DCNL DCSP if (image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP sr_ref = _safe_find_iso_sr(session) DCNL DCSP else: DCNL DCSP  DCSP sr_ref = safe_find_sr(session) DCNL DCSP (image_service, image_id) = glance.get_remote_image_service(context, image_id) DCNL DCSP meta = image_service.show(context, image_id) DCNL DCSP virtual_size = int(meta['size']) DCNL DCSP vdi_size = virtual_size DCNL DCSP LOG.debug(_('Size DCSP for DCSP image DCSP %(image_id)s: DCSP %(virtual_size)d'), locals(), instance=instance) DCNL DCSP if (image_type == ImageType.DISK): DCNL DCSP  DCSP vdi_size += MBR_SIZE_BYTES DCNL DCSP elif ((image_type in (ImageType.KERNEL, ImageType.RAMDISK)) and (vdi_size > CONF.max_kernel_ramdisk_size)): DCNL DCSP  DCSP max_size = CONF.max_kernel_ramdisk_size DCNL DCSP  DCSP raise exception.NovaException((_('Kernel/Ramdisk DCSP image DCSP is DCSP too DCSP large: DCSP %(vdi_size)d DCSP bytes, DCSP max DCSP %(max_size)d DCSP bytes') % locals())) DCNL DCSP vdi_ref = create_vdi(session, sr_ref, instance, name_label, image_type_str, vdi_size) DCNL DCSP try: DCNL DCSP  DCSP filename = None DCNL DCSP  DCSP vdi_uuid = session.call_xenapi('VDI.get_uuid', vdi_ref) DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP  DCSP stream_func = (lambda f: image_service.download(context, image_id, f)) DCNL DCSP  DCSP  DCSP _stream_disk(stream_func, image_type, virtual_size, dev) DCNL DCSP  DCSP if (image_type in (ImageType.KERNEL, ImageType.RAMDISK)): DCNL DCSP  DCSP  DCSP LOG.debug(_('Copying DCSP VDI DCSP %s DCSP to DCSP /boot/guest DCSP on DCSP dom0'), vdi_ref, instance=instance) DCNL DCSP  DCSP  DCSP args = {} DCNL DCSP  DCSP  DCSP args['vdi-ref'] = vdi_ref DCNL DCSP  DCSP  DCSP args['image-size'] = str(vdi_size) DCNL DCSP  DCSP  DCSP if CONF.cache_images: DCNL DCSP  DCSP  DCSP  DCSP args['cached-image'] = image_id DCNL DCSP  DCSP  DCSP filename = session.call_plugin('kernel', 'copy_vdi', args) DCNL DCSP  DCSP  DCSP destroy_vdi(session, vdi_ref) DCNL DCSP  DCSP  DCSP LOG.debug(_('Kernel/Ramdisk DCSP VDI DCSP %s DCSP destroyed'), vdi_ref, instance=instance) DCNL DCSP  DCSP  DCSP vdi_role = ImageType.get_role(image_type) DCNL DCSP  DCSP  DCSP return {vdi_role: dict(uuid=None, file=filename)} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vdi_role = ImageType.get_role(image_type) DCNL DCSP  DCSP  DCSP return {vdi_role: dict(uuid=vdi_uuid, file=None)} DCNL DCSP except (session.XenAPI.Failure, IOError, OSError) as e: DCNL DCSP  DCSP LOG.exception(_('Failed DCSP to DCSP fetch DCSP glance DCSP image'), instance=instance) DCNL DCSP  DCSP e.args = (e.args + ([dict(type=ImageType.to_string(image_type), uuid=vdi_uuid, file=filename)],)) DCNL DCSP  DCSP raise
 DCSP if (not image_meta): DCNL DCSP  DCSP return None DCNL DCSP disk_format = image_meta['disk_format'] DCNL DCSP disk_format_map = {'ami': 'DISK', 'aki': 'KERNEL', 'ari': 'RAMDISK', 'raw': 'DISK_RAW', 'vhd': 'DISK_VHD', 'iso': 'DISK_ISO'} DCNL DCSP try: DCNL DCSP  DCSP image_type_str = disk_format_map[disk_format] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise exception.InvalidDiskFormat(disk_format=disk_format) DCNL DCSP image_type = getattr(ImageType, image_type_str) DCNL DCSP image_ref = image_meta['id'] DCNL DCSP msg = _('Detected DCSP %(image_type_str)s DCSP format DCSP for DCSP image DCSP %(image_ref)s') DCNL DCSP LOG.debug((msg % locals())) DCNL DCSP return image_type
 DCSP LOG.debug(_('Looking DCSP up DCSP vdi DCSP %s DCSP for DCSP PV DCSP kernel'), vdi_ref) DCNL DCSP if (disk_image_type == ImageType.DISK_VHD): DCNL DCSP  DCSP if (os_type == 'windows'): DCNL DCSP  DCSP  DCSP is_pv = False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP is_pv = True DCNL DCSP elif (disk_image_type == ImageType.DISK_RAW): DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=True) as dev: DCNL DCSP  DCSP  DCSP is_pv = _is_vdi_pv(dev) DCNL DCSP elif (disk_image_type == ImageType.DISK): DCNL DCSP  DCSP is_pv = True DCNL DCSP elif (disk_image_type == ImageType.DISK_ISO): DCNL DCSP  DCSP is_pv = False DCNL DCSP elif (not disk_image_type): DCNL DCSP  DCSP LOG.warning((_('Image DCSP format DCSP is DCSP None: DCSP trying DCSP to DCSP determine DCSP PV DCSP status DCSP using DCSP pygrub; DCSP if DCSP instance DCSP with DCSP vdi DCSP %s DCSP does DCSP not DCSP boot DCSP correctly, DCSP try DCSP with DCSP image DCSP metadata.') % vdi_ref)) DCNL DCSP  DCSP with vdi_attached_here(session, vdi_ref, read_only=True) as dev: DCNL DCSP  DCSP  DCSP is_pv = _is_vdi_pv(dev) DCNL DCSP else: DCNL DCSP  DCSP msg = (_('Unknown DCSP image DCSP format DCSP %(disk_image_type)s') % locals()) DCNL DCSP  DCSP raise exception.NovaException(msg) DCNL DCSP return is_pv
 DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', vm_ref) DCNL DCSP vdi_refs = [] DCNL DCSP if vbd_refs: DCNL DCSP  DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('VBD.get_VDI', vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP record = session.call_xenapi('VDI.get_record', vdi_ref) DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('VDI DCSP %s DCSP is DCSP still DCSP available'), record['uuid']) DCNL DCSP  DCSP  DCSP  DCSP vbd_other_config = session.call_xenapi('VBD.get_other_config', vbd_ref) DCNL DCSP  DCSP  DCSP  DCSP if (not vbd_other_config.get('osvol')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vdi_refs.append(vdi_ref) DCNL DCSP  DCSP  DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(exc) DCNL DCSP return vdi_refs
 DCSP vm_refs = session.call_xenapi('VM.get_by_name_label', name_label) DCNL DCSP n = len(vm_refs) DCNL DCSP if (n == 0): DCNL DCSP  DCSP return None DCNL DCSP elif (n > 1): DCNL DCSP  DCSP raise exception.InstanceExists(name=name_label) DCNL DCSP else: DCNL DCSP  DCSP return vm_refs[0]
 DCSP mount_required = False DCNL DCSP (key, net, metadata) = _prepare_injectables(instance, network_info) DCNL DCSP mount_required = (key or net or metadata) DCNL DCSP if (not mount_required): DCNL DCSP  DCSP return DCNL DCSP with vdi_attached_here(session, vdi_ref, read_only=False) as dev: DCNL DCSP  DCSP _mounted_processing(dev, key, net, metadata)
 DCSP return {'state': XENAPI_POWER_STATE[record['power_state']], 'max_mem': (long(record['memory_static_max']) >> 10), 'mem': (long(record['memory_dynamic_max']) >> 10), 'num_cpu': record['VCPUs_max'], 'cpu_time': 0}
 DCSP try: DCNL DCSP  DCSP keys = [] DCNL DCSP  DCSP diags = {} DCNL DCSP  DCSP vm_uuid = record['uuid'] DCNL DCSP  DCSP xml = _get_rrd(_get_rrd_server(), vm_uuid) DCNL DCSP  DCSP if xml: DCNL DCSP  DCSP  DCSP rrd = minidom.parseString(xml) DCNL DCSP  DCSP  DCSP for (i, node) in enumerate(rrd.firstChild.childNodes): DCNL DCSP  DCSP  DCSP  DCSP if (node.localName == 'lastupdate'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP diags['last_update'] = node.firstChild.data DCNL DCSP  DCSP  DCSP  DCSP if (node.localName == 'ds'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ref = node.childNodes DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(ref) > 6): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keys.append(ref[0].firstChild.data) DCNL DCSP  DCSP  DCSP  DCSP if (node.localName == 'rra'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows = node.childNodes[4].childNodes DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_row = rows[(rows.length - 1)].childNodes DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (j, value) in enumerate(last_row): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP diags[keys[j]] = value.firstChild.data DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return diags DCNL DCSP except expat.ExpatError as e: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP parse DCSP rrd DCSP of DCSP %(vm_uuid)s') % locals())) DCNL DCSP  DCSP return {'Unable DCSP to DCSP retrieve DCSP diagnostics': e}
 DCSP start_time = int(start_time) DCNL DCSP xml = _get_rrd_updates(_get_rrd_server(), start_time) DCNL DCSP if xml: DCNL DCSP  DCSP doc = minidom.parseString(xml) DCNL DCSP  DCSP return _parse_rrd_update(doc, start_time, stop_time) DCNL DCSP raise exception.CouldNotFetchMetrics()
 DCSP if sr_ref: DCNL DCSP  DCSP LOG.debug(_('Re-scanning DCSP SR DCSP %s'), sr_ref) DCNL DCSP  DCSP session.call_xenapi('SR.scan', sr_ref)
 DCSP _scan_sr(session, _find_sr(session))
 DCSP sr_ref = _find_sr(session) DCNL DCSP if (sr_ref is None): DCNL DCSP  DCSP raise exception.StorageRepositoryNotFound() DCNL DCSP return sr_ref
 DCSP host = session.get_xenapi_host() DCNL DCSP try: DCNL DCSP  DCSP tokens = CONF.sr_matching_filter.split(':') DCNL DCSP  DCSP filter_criteria = tokens[0] DCNL DCSP  DCSP filter_pattern = tokens[1] DCNL DCSP except IndexError: DCNL DCSP  DCSP LOG.warning(_("Flag DCSP sr_matching_filter DCSP '%s' DCSP does DCSP not DCSP respect DCSP formatting DCSP convention"), CONF.sr_matching_filter) DCNL DCSP  DCSP return None DCNL DCSP if (filter_criteria == 'other-config'): DCNL DCSP  DCSP (key, value) = filter_pattern.split('=', 1) DCNL DCSP  DCSP for (sr_ref, sr_rec) in session.get_all_refs_and_recs('SR'): DCNL DCSP  DCSP  DCSP if (not ((key in sr_rec['other_config']) and (sr_rec['other_config'][key] == value))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for pbd_ref in sr_rec['PBDs']: DCNL DCSP  DCSP  DCSP  DCSP pbd_rec = session.get_rec('PBD', pbd_ref) DCNL DCSP  DCSP  DCSP  DCSP if (pbd_rec and (pbd_rec['host'] == host)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return sr_ref DCNL DCSP elif ((filter_criteria == 'default-sr') and (filter_pattern == 'true')): DCNL DCSP  DCSP pool_ref = session.call_xenapi('pool.get_all')[0] DCNL DCSP  DCSP return session.call_xenapi('pool.get_default_SR', pool_ref) DCNL DCSP LOG.warning(_("XenAPI DCSP is DCSP unable DCSP to DCSP find DCSP a DCSP Storage DCSP Repository DCSP to DCSP install DCSP guest DCSP instances DCSP on. DCSP Please DCSP check DCSP your DCSP configuration DCSP and/or DCSP configure DCSP the DCSP flag DCSP 'sr_matching_filter'")) DCNL DCSP return None
 DCSP sr_ref = _find_iso_sr(session) DCNL DCSP if (sr_ref is None): DCNL DCSP  DCSP raise exception.NotFound(_('Cannot DCSP find DCSP SR DCSP of DCSP content-type DCSP ISO')) DCNL DCSP return sr_ref
 DCSP host = session.get_xenapi_host() DCNL DCSP for (sr_ref, sr_rec) in session.get_all_refs_and_recs('SR'): DCNL DCSP  DCSP LOG.debug((_('ISO: DCSP looking DCSP at DCSP SR DCSP %(sr_rec)s') % locals())) DCNL DCSP  DCSP if (not (sr_rec['content_type'] == 'iso')): DCNL DCSP  DCSP  DCSP LOG.debug(_('ISO: DCSP not DCSP iso DCSP content')) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('i18n-key' not in sr_rec['other_config']): DCNL DCSP  DCSP  DCSP LOG.debug(_("ISO: DCSP iso DCSP content_type, DCSP no DCSP 'i18n-key' DCSP key")) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not (sr_rec['other_config']['i18n-key'] == 'local-storage-iso')): DCNL DCSP  DCSP  DCSP LOG.debug(_("ISO: DCSP iso DCSP content_type, DCSP i18n-key DCSP value DCSP not DCSP 'local-storage-iso'")) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP LOG.debug(_('ISO: DCSP SR DCSP MATCHing DCSP our DCSP criteria')) DCNL DCSP  DCSP for pbd_ref in sr_rec['PBDs']: DCNL DCSP  DCSP  DCSP LOG.debug(_('ISO: DCSP ISO, DCSP looking DCSP to DCSP see DCSP if DCSP it DCSP is DCSP host DCSP local')) DCNL DCSP  DCSP  DCSP pbd_rec = session.get_rec('PBD', pbd_ref) DCNL DCSP  DCSP  DCSP if (not pbd_rec): DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('ISO: DCSP PBD DCSP %(pbd_ref)s DCSP disappeared') % locals())) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pbd_rec_host = pbd_rec['host'] DCNL DCSP  DCSP  DCSP LOG.debug((_('ISO: DCSP PBD DCSP matching, DCSP want DCSP %(pbd_rec)s, DCSP have DCSP %(host)s') % locals())) DCNL DCSP  DCSP  DCSP if (pbd_rec_host == host): DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('ISO: DCSP SR DCSP with DCSP local DCSP PBD')) DCNL DCSP  DCSP  DCSP  DCSP return sr_ref DCNL DCSP return None
 DCSP xs_url = urlparse.urlparse(CONF.xenapi_connection_url) DCNL DCSP return [xs_url.scheme, xs_url.netloc]
 DCSP try: DCNL DCSP  DCSP xml = urllib.urlopen(('%s://%s:%s@%s/vm_rrd?uuid=%s' % (server[0], CONF.xenapi_connection_username, CONF.xenapi_connection_password, server[1], vm_uuid))) DCNL DCSP  DCSP return xml.read() DCNL DCSP except IOError: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP obtain DCSP RRD DCSP XML DCSP for DCSP VM DCSP %(vm_uuid)s DCSP with DCSP server DCSP details: DCSP %(server)s.') % locals())) DCNL DCSP  DCSP return None
 DCSP try: DCNL DCSP  DCSP xml = urllib.urlopen(('%s://%s:%s@%s/rrd_updates?start=%s' % (server[0], CONF.xenapi_connection_username, CONF.xenapi_connection_password, server[1], start_time))) DCNL DCSP  DCSP return xml.read() DCNL DCSP except IOError: DCNL DCSP  DCSP LOG.exception((_('Unable DCSP to DCSP obtain DCSP RRD DCSP XML DCSP updates DCSP with DCSP server DCSP details: DCSP %(server)s.') % locals())) DCNL DCSP  DCSP return None
 DCSP for vbd_ref in session.call_xenapi('VM.get_VBDs', vm_ref): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('VBD.get_VDI', vbd_ref) DCNL DCSP  DCSP  DCSP if (sr_ref == session.call_xenapi('VDI.get_SR', vdi_ref)): DCNL DCSP  DCSP  DCSP  DCSP (yield vdi_ref) DCNL DCSP  DCSP except session.XenAPI.Failure: DCNL DCSP  DCSP  DCSP continue
 DCSP scan_default_sr(session) DCNL DCSP while True: DCNL DCSP  DCSP vdi_ref = session.call_xenapi('VDI.get_by_uuid', vdi_uuid) DCNL DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vdi_ref) DCNL DCSP  DCSP (yield vdi_rec) DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP if (not parent_uuid): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP vdi_uuid = parent_uuid
 DCSP children = set() DCNL DCSP for (ref, rec) in _get_all_vdis_in_sr(session, sr_ref): DCNL DCSP  DCSP rec_uuid = rec['uuid'] DCNL DCSP  DCSP if (rec_uuid == vdi_uuid): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, ref) DCNL DCSP  DCSP if (parent_uuid != vdi_uuid): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP children.add(rec_uuid) DCNL DCSP return children
 DCSP def _another_child_vhd(): DCNL DCSP  DCSP if (not original_parent_uuid): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP vdi_uuid = session.call_xenapi('VDI.get_record', vdi_ref)['uuid'] DCNL DCSP  DCSP parent_vdi_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP for (_ref, rec) in _get_all_vdis_in_sr(session, sr_ref): DCNL DCSP  DCSP  DCSP if ((rec['uuid'] != vdi_uuid) and (rec['uuid'] != parent_vdi_uuid) and (rec['sm_config'].get('vhd-parent') == original_parent_uuid)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP return False DCNL DCSP if _another_child_vhd(): DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP parent_ref = session.call_xenapi('VDI.get_by_uuid', parent_uuid) DCNL DCSP  DCSP base_uuid = _get_vhd_parent_uuid(session, parent_ref) DCNL DCSP  DCSP return (parent_uuid, base_uuid) DCNL DCSP _scan_sr(session, sr_ref) DCNL DCSP max_attempts = CONF.xenapi_vhd_coalesce_max_attempts DCNL DCSP for i in xrange(max_attempts): DCNL DCSP  DCSP _scan_sr(session, sr_ref) DCNL DCSP  DCSP parent_uuid = _get_vhd_parent_uuid(session, vdi_ref) DCNL DCSP  DCSP if (original_parent_uuid and (parent_uuid != original_parent_uuid)): DCNL DCSP  DCSP  DCSP LOG.debug(_("Parent DCSP %(parent_uuid)s DCSP doesn't DCSP match DCSP original DCSP parent DCSP %(original_parent_uuid)s, DCSP waiting DCSP for DCSP coalesce..."), locals(), instance=instance) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parent_ref = session.call_xenapi('VDI.get_by_uuid', parent_uuid) DCNL DCSP  DCSP  DCSP base_uuid = _get_vhd_parent_uuid(session, parent_ref) DCNL DCSP  DCSP  DCSP return (parent_uuid, base_uuid) DCNL DCSP  DCSP greenthread.sleep(CONF.xenapi_vhd_coalesce_poll_interval) DCNL DCSP msg = (_('VHD DCSP coalesce DCSP attempts DCSP exceeded DCSP (%(max_attempts)d), DCSP giving DCSP up...') % locals()) DCNL DCSP raise exception.NovaException(msg)
 DCSP should_remap = CONF.xenapi_remap_vbd_dev DCNL DCSP if (not should_remap): DCNL DCSP  DCSP return dev DCNL DCSP old_prefix = 'xvd' DCNL DCSP new_prefix = CONF.xenapi_remap_vbd_dev_prefix DCNL DCSP remapped_dev = dev.replace(old_prefix, new_prefix) DCNL DCSP return remapped_dev
 DCSP for i in xrange(0, CONF.block_device_creation_timeout): DCNL DCSP  DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP  DCSP if os.path.exists(dev_path): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP time.sleep(1) DCNL DCSP raise volume_utils.StorageError((_('Timeout DCSP waiting DCSP for DCSP device DCSP %s DCSP to DCSP be DCSP created') % dev))
 DCSP this_vm_ref = _get_this_vm_ref(session) DCNL DCSP vbd_refs = session.call_xenapi('VM.get_VBDs', this_vm_ref) DCNL DCSP for vbd_ref in vbd_refs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP vbd_rec = session.call_xenapi('VBD.get_record', vbd_ref) DCNL DCSP  DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vbd_rec['VDI']) DCNL DCSP  DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if (e.details[0] != 'HANDLE_INVALID'): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ('nova_instance_uuid' in vdi_rec['other_config']): DCNL DCSP  DCSP  DCSP LOG.info(_('Disconnecting DCSP stale DCSP VDI DCSP %s DCSP from DCSP compute DCSP domU'), vdi_rec['uuid']) DCNL DCSP  DCSP  DCSP unplug_vbd(session, vbd_ref) DCNL DCSP  DCSP  DCSP destroy_vbd(session, vbd_ref)
 DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP (out, _err) = utils.execute('parted', '--script', '--machine', dev_path, 'unit DCSP s', 'print', run_as_root=True) DCNL DCSP lines = [line for line in out.split('\n') if line] DCNL DCSP partitions = [] DCNL DCSP LOG.debug(_('Partitions:')) DCNL DCSP for line in lines[2:]: DCNL DCSP  DCSP (num, start, end, size, ptype) = line.split(':')[:5] DCNL DCSP  DCSP start = int(start.rstrip('s')) DCNL DCSP  DCSP end = int(end.rstrip('s')) DCNL DCSP  DCSP size = int(size.rstrip('s')) DCNL DCSP  DCSP LOG.debug((_(' DCSP  DCSP %(num)s: DCSP %(ptype)s DCSP %(size)d DCSP sectors') % locals())) DCNL DCSP  DCSP partitions.append((num, start, size, ptype)) DCNL DCSP return partitions
 DCSP size = (new_sectors - start) DCNL DCSP end = (new_sectors - 1) DCNL DCSP dev_path = utils.make_dev_path(dev) DCNL DCSP partition_path = utils.make_dev_path(dev, partition=1) DCNL DCSP utils.execute('e2fsck', '-f', '-y', partition_path, run_as_root=True, check_exit_code=[0, 1, 2]) DCNL DCSP utils.execute('tune2fs', '-O DCSP ^has_journal', partition_path, run_as_root=True) DCNL DCSP if (new_sectors < old_sectors): DCNL DCSP  DCSP utils.execute('resize2fs', partition_path, ('%ds' % size), run_as_root=True) DCNL DCSP utils.execute('parted', '--script', dev_path, 'rm', '1', run_as_root=True) DCNL DCSP utils.execute('parted', '--script', dev_path, 'mkpart', 'primary', ('%ds' % start), ('%ds' % end), run_as_root=True) DCNL DCSP if (new_sectors > old_sectors): DCNL DCSP  DCSP utils.execute('resize2fs', partition_path, run_as_root=True) DCNL DCSP utils.execute('tune2fs', '-j', partition_path, run_as_root=True)
 DCSP start_time = time.time() DCNL DCSP EMPTY_BLOCK = ('\x00' * block_size) DCNL DCSP bytes_read = 0 DCNL DCSP skipped_bytes = 0 DCNL DCSP left = virtual_size DCNL DCSP LOG.debug(_('Starting DCSP sparse_copy DCSP src=%(src_path)s DCSP dst=%(dst_path)s DCSP virtual_size=%(virtual_size)d DCSP block_size=%(block_size)d'), locals()) DCNL DCSP with utils.temporary_chown(src_path): DCNL DCSP  DCSP with utils.temporary_chown(dst_path): DCNL DCSP  DCSP  DCSP with open(src_path, 'r') as src: DCNL DCSP  DCSP  DCSP  DCSP with open(dst_path, 'w') as dst: DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = src.read(min(block_size, left)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP while data: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (data == EMPTY_BLOCK): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dst.seek(block_size, os.SEEK_CUR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP left -= block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_read += block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP skipped_bytes += block_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP dst.write(data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP data_len = len(data) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP left -= data_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_read += data_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (left <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP data = src.read(min(block_size, left)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep(0) DCNL DCSP duration = (time.time() - start_time) DCNL DCSP compression_pct = ((float(skipped_bytes) / bytes_read) * 100) DCNL DCSP LOG.debug(_('Finished DCSP sparse_copy DCSP in DCSP %(duration).2f DCSP secs, DCSP %(compression_pct).2f%% DCSP reduction DCSP in DCSP size'), locals())
 DCSP try: DCNL DCSP  DCSP (_out, err) = utils.execute('mount', '-t', 'ext2,ext3,ext4,reiserfs', dev_path, dir, run_as_root=True) DCNL DCSP except exception.ProcessExecutionError as e: DCNL DCSP  DCSP err = str(e) DCNL DCSP return err
 DCSP dev_path = utils.make_dev_path(device, partition=1) DCNL DCSP with utils.tempdir() as tmpdir: DCNL DCSP  DCSP err = _mount_filesystem(dev_path, tmpdir) DCNL DCSP  DCSP if (not err): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not agent.find_guest_agent(tmpdir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vfs = vfsimpl.VFSLocalFS(imgfile=None, imgfmt=None, imgdir=tmpdir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.info(_('Manipulating DCSP interface DCSP files DCSP directly')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP disk.inject_data_into_fs(vfs, key, net, metadata, None, None) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP utils.execute('umount', dev_path, run_as_root=True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.info((_('Failed DCSP to DCSP mount DCSP filesystem DCSP (expected DCSP for DCSP non-linux DCSP instances): DCSP %s') % err))
 DCSP from Cheetah import Template as t DCNL DCSP template = t.Template DCNL DCSP template_data = open(CONF.injected_network_template).read() DCNL DCSP metadata = inst['metadata'] DCNL DCSP key = str(inst['key_data']) DCNL DCSP net = None DCNL DCSP if network_info: DCNL DCSP  DCSP ifc_num = (-1) DCNL DCSP  DCSP interfaces_info = [] DCNL DCSP  DCSP for vif in network_info: DCNL DCSP  DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not vif['network'].get_meta('injected')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP dns = [ip['address'] for subnet in vif['network']['subnets'] for ip in subnet['dns']] DCNL DCSP  DCSP  DCSP dns = ' DCSP '.join(dns).strip() DCNL DCSP  DCSP  DCSP interface_info = {'name': ('eth%d' % ifc_num), 'address': '', 'netmask': '', 'gateway': '', 'broadcast': '', 'dns': (dns or ''), 'address_v6': '', 'netmask_v6': '', 'gateway_v6': '', 'use_ipv6': CONF.use_ipv6} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnet = [s for s in vif['network']['subnets'] if (s['version'] == 4)][0] DCNL DCSP  DCSP  DCSP  DCSP ip = subnet['ips'][0] DCNL DCSP  DCSP  DCSP  DCSP subnet_netaddr = subnet.as_netaddr() DCNL DCSP  DCSP  DCSP  DCSP interface_info['address'] = ip['address'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['netmask'] = subnet_netaddr.netmask DCNL DCSP  DCSP  DCSP  DCSP interface_info['gateway'] = subnet['gateway']['address'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['broadcast'] = subnet_netaddr.broadcast DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP subnet = [s for s in vif['network']['subnets'] if (s['version'] == 6)][0] DCNL DCSP  DCSP  DCSP  DCSP ip = subnet['ips'][0] DCNL DCSP  DCSP  DCSP  DCSP interface_info['address_v6'] = ip['address'] DCNL DCSP  DCSP  DCSP  DCSP interface_info['netmask_v6'] = subnet.as_netaddr().netmask DCNL DCSP  DCSP  DCSP  DCSP interface_info['gateway_v6'] = subnet['gateway']['address'] DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP interfaces_info.append(interface_info) DCNL DCSP  DCSP if interfaces_info: DCNL DCSP  DCSP  DCSP net = str(template(template_data, searchList=[{'interfaces': interfaces_info, 'use_ipv6': CONF.use_ipv6}])) DCNL DCSP return (key, net, metadata)
 DCSP this_vm_uuid = get_this_vm_uuid() DCNL DCSP try: DCNL DCSP  DCSP session.call_xenapi('VM.get_by_uuid', this_vm_uuid) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP if (exc.details[0] != 'UUID_INVALID'): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP raise Exception(_('This DCSP domU DCSP must DCSP be DCSP running DCSP on DCSP the DCSP host DCSP specified DCSP by DCSP xenapi_connection_url'))
 DCSP imported_vhds = session.call_plugin_serialized('migration', 'move_vhds_into_sr', instance_uuid=instance['uuid'], sr_path=get_sr_path(session), uuid_stack=_make_uuid_stack()) DCNL DCSP scan_default_sr(session) DCNL DCSP root_uuid = imported_vhds['root']['uuid'] DCNL DCSP set_vdi_name(session, root_uuid, instance['name'], 'root') DCNL DCSP root_vdi_ref = session.call_xenapi('VDI.get_by_uuid', root_uuid) DCNL DCSP return {'uuid': root_uuid, 'ref': root_vdi_ref}
 DCSP LOG.debug(_('Forgetting DCSP SR...')) DCNL DCSP unplug_pbds(session, sr_ref) DCNL DCSP session.call_xenapi('SR.forget', sr_ref)
 DCSP for (sr_ref, sr_rec) in session.get_all_refs_and_recs('SR'): DCNL DCSP  DCSP if (sr_rec['uuid'] == sr_uuid): DCNL DCSP  DCSP  DCSP return sr_ref DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP vdi_ref = session.call_xenapi('VBD.get_VDI', vbd_ref) DCNL DCSP  DCSP sr_ref = session.call_xenapi('VDI.get_SR', vdi_ref) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP find DCSP SR DCSP from DCSP VBD DCSP %s') % vbd_ref)) DCNL DCSP return sr_ref
 DCSP try: DCNL DCSP  DCSP session.call_xenapi('SR.scan', sr_ref) DCNL DCSP  DCSP if vdi_uuid: DCNL DCSP  DCSP  DCSP LOG.debug(('vdi_uuid: DCSP %s' % vdi_uuid)) DCNL DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('VDI.get_by_uuid', vdi_uuid) DCNL DCSP  DCSP elif target_lun: DCNL DCSP  DCSP  DCSP vdi_refs = session.call_xenapi('SR.get_VDIs', sr_ref) DCNL DCSP  DCSP  DCSP for curr_ref in vdi_refs: DCNL DCSP  DCSP  DCSP  DCSP curr_rec = session.call_xenapi('VDI.get_record', curr_ref) DCNL DCSP  DCSP  DCSP  DCSP if (('sm_config' in curr_rec) and ('LUNid' in curr_rec['sm_config']) and (curr_rec['sm_config']['LUNid'] == str(target_lun))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP vdi_ref = curr_ref DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vdi_ref = session.call_xenapi('SR.get_VDIs', sr_ref)[0] DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP introduce DCSP VDI DCSP on DCSP SR DCSP %s') % sr_ref)) DCNL DCSP try: DCNL DCSP  DCSP vdi_rec = session.call_xenapi('VDI.get_record', vdi_ref) DCNL DCSP  DCSP LOG.debug(vdi_rec) DCNL DCSP  DCSP LOG.debug(type(vdi_rec)) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP get DCSP record DCSP of DCSP VDI DCSP %s DCSP on') % vdi_ref)) DCNL DCSP if vdi_rec['managed']: DCNL DCSP  DCSP return vdi_ref DCNL DCSP try: DCNL DCSP  DCSP return session.call_xenapi('VDI.introduce', vdi_rec['uuid'], vdi_rec['name_label'], vdi_rec['name_description'], vdi_rec['SR'], vdi_rec['type'], vdi_rec['sharable'], vdi_rec['read_only'], vdi_rec['other_config'], vdi_rec['location'], vdi_rec['xenstore_data'], vdi_rec['sm_config']) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP LOG.exception(exc) DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP introduce DCSP VDI DCSP for DCSP SR DCSP %s') % sr_ref))
 DCSP volume_id = connection_data['volume_id'] DCNL DCSP target_portal = connection_data['target_portal'] DCNL DCSP target_host = _get_target_host(target_portal) DCNL DCSP target_port = _get_target_port(target_portal) DCNL DCSP target_iqn = connection_data['target_iqn'] DCNL DCSP LOG.debug('(vol_id,number,host,port,iqn): DCSP (%s,%s,%s,%s)', volume_id, target_host, target_port, target_iqn) DCNL DCSP if ((volume_id is None) or (target_host is None) or (target_iqn is None)): DCNL DCSP  DCSP raise StorageError((_('Unable DCSP to DCSP obtain DCSP target DCSP information DCSP %(connection_data)s') % locals())) DCNL DCSP volume_info = {} DCNL DCSP volume_info['id'] = volume_id DCNL DCSP volume_info['target'] = target_host DCNL DCSP volume_info['port'] = target_port DCNL DCSP volume_info['targetIQN'] = target_iqn DCNL DCSP if (('auth_method' in connection_data) and (connection_data['auth_method'] == 'CHAP')): DCNL DCSP  DCSP volume_info['chapuser'] = connection_data['auth_username'] DCNL DCSP  DCSP volume_info['chappassword'] = connection_data['auth_password'] DCNL DCSP return volume_info
 DCSP if mountpoint.startswith('/dev/'): DCNL DCSP  DCSP mountpoint = mountpoint[5:] DCNL DCSP if re.match('^[hs]d[a-p]$', mountpoint): DCNL DCSP  DCSP return (ord(mountpoint[2:3]) - ord('a')) DCNL DCSP elif re.match('^x?vd[a-p]$', mountpoint): DCNL DCSP  DCSP return (ord(mountpoint[(-1)]) - ord('a')) DCNL DCSP elif re.match('^[0-9]+$', mountpoint): DCNL DCSP  DCSP return string.atoi(mountpoint, 10) DCNL DCSP else: DCNL DCSP  DCSP LOG.warn(_('Mountpoint DCSP cannot DCSP be DCSP translated: DCSP %s'), mountpoint) DCNL DCSP  DCSP return (-1)
 DCSP if isinstance(path_or_id, int): DCNL DCSP  DCSP return path_or_id DCNL DCSP volume_id = path_or_id[(path_or_id.find(':volume-') + 1):] DCNL DCSP if (volume_id == path_or_id): DCNL DCSP  DCSP volume_id = path_or_id[(path_or_id.find('-volume--') + 1):] DCNL DCSP  DCSP volume_id = volume_id.replace('volume--', '') DCNL DCSP else: DCNL DCSP  DCSP volume_id = volume_id.replace('volume-', '') DCNL DCSP  DCSP volume_id = volume_id[0:volume_id.find('-')] DCNL DCSP return int(volume_id)
 DCSP if iscsi_string: DCNL DCSP  DCSP return iscsi_string[0:iscsi_string.find(':')] DCNL DCSP elif ((iscsi_string is None) or CONF.target_host): DCNL DCSP  DCSP return CONF.target_host
 DCSP if iscsi_string: DCNL DCSP  DCSP return iscsi_string[(iscsi_string.find(':') + 1):] DCNL DCSP elif ((iscsi_string is None) or CONF.target_port): DCNL DCSP  DCSP return CONF.target_port
 DCSP if (addl_args is None): DCNL DCSP  DCSP addl_args = {} DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = CONF.agent_timeout DCNL DCSP vm_rec = session.call_xenapi('VM.get_record', vm_ref) DCNL DCSP args = {'id': str(uuid.uuid4()), 'dom_id': vm_rec['domid'], 'timeout': str(timeout)} DCNL DCSP args.update(addl_args) DCNL DCSP try: DCNL DCSP  DCSP ret = session.call_plugin('agent', method, args) DCNL DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP err_msg = e.details[(-1)].splitlines()[(-1)] DCNL DCSP  DCSP if ('TIMEOUT:' in err_msg): DCNL DCSP  DCSP  DCSP LOG.error(_('TIMEOUT: DCSP The DCSP call DCSP to DCSP %(method)s DCSP timed DCSP out. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncode': 'timeout', 'message': err_msg} DCNL DCSP  DCSP elif ('NOT DCSP IMPLEMENTED:' in err_msg): DCNL DCSP  DCSP  DCSP LOG.error(_('NOT DCSP IMPLEMENTED: DCSP The DCSP call DCSP to DCSP %(method)s DCSP is DCSP not DCSP supported DCSP by DCSP the DCSP agent. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncode': 'notimplemented', 'message': err_msg} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.error(_('The DCSP call DCSP to DCSP %(method)s DCSP returned DCSP an DCSP error: DCSP %(e)s. DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP  DCSP return {'returncode': 'error', 'message': err_msg} DCNL DCSP  DCSP return None DCNL DCSP if isinstance(ret, dict): DCNL DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP return jsonutils.loads(ret) DCNL DCSP except TypeError: DCNL DCSP  DCSP LOG.error(_('The DCSP agent DCSP call DCSP to DCSP %(method)s DCSP returned DCSP an DCSP invalid DCSP response: DCSP %(ret)r. DCSP path=%(path)s; DCSP args=%(args)r'), locals(), instance=instance) DCNL DCSP  DCSP return {'returncode': 'error', 'message': 'unable DCSP to DCSP deserialize DCSP response'}
 DCSP if CONF.xenapi_disable_agent: DCNL DCSP  DCSP return False DCNL DCSP agent_rel_path = CONF.xenapi_agent_path DCNL DCSP agent_path = os.path.join(base_dir, agent_rel_path) DCNL DCSP if os.path.isfile(agent_path): DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP installed DCSP in DCSP this DCSP image DCSP are DCSP capable DCSP of DCSP network DCSP injection. DCSP  DCSP Networking DCSP files DCSP will DCSP not DCSP bemanipulated')) DCNL DCSP  DCSP return True DCNL DCSP xe_daemon_filename = os.path.join(base_dir, 'usr', 'sbin', 'xe-daemon') DCNL DCSP if os.path.isfile(xe_daemon_filename): DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP are DCSP present DCSP in DCSP this DCSP image DCSP but DCSP are DCSP not DCSP capable DCSP of DCSP network DCSP injection')) DCNL DCSP else: DCNL DCSP  DCSP LOG.info(_('XenServer DCSP tools DCSP are DCSP not DCSP installed DCSP in DCSP this DCSP image')) DCNL DCSP return False
 DCSP temp_url = urlparse.urlparse(url) DCNL DCSP (_netloc, sep, port) = temp_url.netloc.partition(':') DCNL DCSP return url.replace(temp_url.netloc, ('%s%s%s' % (host_addr, sep, port)))
 DCSP try: DCNL DCSP  DCSP result = session.call_plugin('xenhost', method, args=arg_dict) DCNL DCSP  DCSP if (not result): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP return jsonutils.loads(result) DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception(_('Unable DCSP to DCSP get DCSP updated DCSP status')) DCNL DCSP  DCSP return None DCNL DCSP except session.XenAPI.Failure as e: DCNL DCSP  DCSP LOG.error((_('The DCSP call DCSP to DCSP %(method)s DCSP returned DCSP an DCSP error: DCSP %(e)s.') % locals())) DCNL DCSP  DCSP return e.details[1]
 DCSP for i in virtapi.instance_get_all_by_host(context, host): DCNL DCSP  DCSP if (i.name == name_label): DCNL DCSP  DCSP  DCSP return i['uuid'] DCNL DCSP return None
 DCSP uuid = session.call_xenapi('host.get_record', dst)['uuid'] DCNL DCSP for (compute_host, host_uuid) in src_aggregate.metadetails.iteritems(): DCNL DCSP  DCSP if (host_uuid == uuid): DCNL DCSP  DCSP  DCSP return compute_host DCNL DCSP raise exception.NoValidHost(reason=('Host DCSP %(host_uuid)s DCSP could DCSP not DCSP be DCSP found DCSP from DCSP aggregate DCSP metadata: DCSP %(metadata)s.' % {'host_uuid': uuid, 'metadata': src_aggregate.metadetails}))
 DCSP vbd_rec['currently_attached'] = False DCNL DCSP vbd_rec['device'] = '' DCNL DCSP vm_ref = vbd_rec['VM'] DCNL DCSP vm_rec = _db_content['VM'][vm_ref] DCNL DCSP vm_rec['VBDs'].append(vbd_ref) DCNL DCSP vdi_ref = vbd_rec['VDI'] DCNL DCSP vdi_rec = _db_content['VDI'][vdi_ref] DCNL DCSP vdi_rec['VBDs'].append(vbd_ref) DCNL DCSP vm_name_label = _db_content['VM'][vm_ref]['name_label'] DCNL DCSP vbd_rec['vm_name_label'] = vm_name_label
 DCSP vm_rec.setdefault('is_control_domain', False) DCNL DCSP vm_rec.setdefault('memory_static_max', str((((8 * 1024) * 1024) * 1024))) DCNL DCSP vm_rec.setdefault('memory_dynamic_max', str((((8 * 1024) * 1024) * 1024))) DCNL DCSP vm_rec.setdefault('VCPUs_max', str(4)) DCNL DCSP vm_rec.setdefault('VBDs', []) DCNL DCSP vm_rec.setdefault('resident_on', '')
 DCSP for host_ref in _db_content['host'].keys(): DCNL DCSP  DCSP _create_local_pif(host_ref)
 DCSP for host_ref in _db_content['host'].keys(): DCNL DCSP  DCSP create_sr(name_label='Local DCSP storage', type='lvm', other_config={'i18n-original-value-name_label': 'Local DCSP storage', 'i18n-key': 'local-storage'}, physical_size=40000, physical_utilisation=20000, virtual_allocation=10000, host_ref=host_ref) DCNL DCSP  DCSP create_sr(name_label='Local DCSP storage DCSP ISO', type='iso', other_config={'i18n-original-value-name_label': 'Local DCSP storage DCSP ISO', 'i18n-key': 'local-storage-iso'}, physical_size=80000, physical_utilisation=40000, virtual_allocation=80000, host_ref=host_ref)
 DCSP return ('<value>%s</value>' % saxutils.escape(s))
 DCSP arg = (args or kwargs) DCNL DCSP return jsonutils.dumps(arg)
 DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = nodes
 DCSP global _FAKE_NODES DCNL DCSP _FAKE_NODES = ['fake-mini']
 DCSP now = timeutils.utcnow() DCNL DCSP values = {'host': None, 'node': None, 'scheduled_at': now} DCNL DCSP if extra_values: DCNL DCSP  DCSP values.update(extra_values) DCNL DCSP return db.instance_update(context, instance_uuid, values)
 DCSP if local: DCNL DCSP  DCSP return dict(id=instance['id'], _is_precooked=False) DCNL DCSP else: DCNL DCSP  DCSP inst = dict(instance) DCNL DCSP  DCSP inst['_is_precooked'] = True DCNL DCSP  DCSP return inst
 DCSP if (capabilities is None): DCNL DCSP  DCSP capabilities = {} DCNL DCSP cap = capabilities.get('compute', {}) DCNL DCSP if bool(cap.get('baremetal_driver')): DCNL DCSP  DCSP return BaremetalNodeState(host, node, capabilities, service) DCNL DCSP else: DCNL DCSP  DCSP return host_manager.HostState(host, node, capabilities, service)
 DCSP if ((CONF.least_cost_functions is not None) or (CONF.compute_fill_first_cost_fn_weight is not None)): DCNL DCSP  DCSP LOG.deprecated(_('least_cost DCSP has DCSP been DCSP deprecated DCSP in DCSP favor DCSP of DCSP the DCSP RAM DCSP Weigher.')) DCNL DCSP  DCSP return least_cost.get_least_cost_weighers() DCNL DCSP return HostWeightHandler().get_all_classes()
 DCSP return 1
 DCSP return (- host_state.free_ram_mb)
 DCSP cost_fns_conf = CONF.least_cost_functions DCNL DCSP if (cost_fns_conf is None): DCNL DCSP  DCSP fn_str = 'nova.scheduler.least_cost.compute_fill_first_cost_fn' DCNL DCSP  DCSP cost_fns_conf = [fn_str] DCNL DCSP cost_fns = [] DCNL DCSP for cost_fn_str in cost_fns_conf: DCNL DCSP  DCSP short_name = cost_fn_str.split('.')[(-1)] DCNL DCSP  DCSP if (not (short_name.startswith('compute_') or short_name.startswith('noop'))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if cost_fn_str.startswith('nova.scheduler.least_cost.'): DCNL DCSP  DCSP  DCSP cost_fn_str = ('nova.scheduler.weights.least_cost' + cost_fn_str[25:]) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cost_fn = importutils.import_class(cost_fn_str) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP raise exception.SchedulerCostFunctionNotFound(cost_fn_str=cost_fn_str) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP flag_name = ('%s_weight' % cost_fn.__name__) DCNL DCSP  DCSP  DCSP weight = getattr(CONF, flag_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.SchedulerWeightFlagNotFound(flag_name=flag_name) DCNL DCSP  DCSP if ((flag_name == 'compute_fill_first_cost_fn_weight') and (weight is None)): DCNL DCSP  DCSP  DCSP weight = (-1.0) DCNL DCSP  DCSP cost_fns.append((weight, cost_fn)) DCNL DCSP return cost_fns
 DCSP return HostFilterHandler().get_all_classes()
 DCSP LOG.deprecated(_("Use DCSP 'nova.scheduler.filters.all_filters' DCSP instead DCSP of DCSP 'nova.scheduler.filters.standard_filters'")) DCNL DCSP return all_filters()
 DCSP root_device_name = None DCNL DCSP for bdm in properties.get('mappings', []): DCNL DCSP  DCSP if (bdm['virtual'] == 'root'): DCNL DCSP  DCSP  DCSP root_device_name = bdm['device'] DCNL DCSP if ('root_device_name' in properties): DCNL DCSP  DCSP root_device_name = properties['root_device_name'] DCNL DCSP return root_device_name
 DCSP for m in mappings: DCNL DCSP  DCSP virtual = m['virtual'] DCNL DCSP  DCSP if (is_swap_or_ephemeral(virtual) and (not m['device'].startswith('/'))): DCNL DCSP  DCSP  DCSP m['device'] = ('/dev/' + m['device']) DCNL DCSP return mappings
 DCSP return (_dev.sub('', device_name) if device_name else device_name)
 DCSP device_name = strip_dev(device_name) DCNL DCSP return _pref.sub('', device_name)
 DCSP match = re.match('(^/dev/x{0,1}[a-z]{0,1}d{0,1})([a-z]+)[0-9]*$', device) DCNL DCSP if (not match): DCNL DCSP  DCSP return None DCNL DCSP return match.groups()
 DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not ctxt.is_admin): DCNL DCSP  DCSP raise exception.AdminRequired()
 DCSP if ((not ctxt.is_admin) and (not is_user_context(ctxt))): DCNL DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP d = {} DCNL DCSP d['id'] = vol.id DCNL DCSP d['status'] = vol.status DCNL DCSP d['size'] = vol.size DCNL DCSP d['availability_zone'] = vol.availability_zone DCNL DCSP d['created_at'] = vol.created_at DCNL DCSP d['attach_time'] = '' DCNL DCSP d['mountpoint'] = '' DCNL DCSP if vol.attachments: DCNL DCSP  DCSP att = vol.attachments[0] DCNL DCSP  DCSP d['attach_status'] = 'attached' DCNL DCSP  DCSP d['instance_uuid'] = att['server_id'] DCNL DCSP  DCSP d['mountpoint'] = att['device'] DCNL DCSP else: DCNL DCSP  DCSP d['attach_status'] = 'detached' DCNL DCSP d['display_name'] = vol.display_name DCNL DCSP d['display_description'] = vol.display_description DCNL DCSP d['volume_type_id'] = vol.volume_type DCNL DCSP d['snapshot_id'] = vol.snapshot_id DCNL DCSP d['volume_metadata'] = [] DCNL DCSP for (key, value) in vol.metadata.items(): DCNL DCSP  DCSP item = {} DCNL DCSP  DCSP item['key'] = key DCNL DCSP  DCSP item['value'] = value DCNL DCSP  DCSP d['volume_metadata'].append(item) DCNL DCSP if hasattr(vol, 'volume_image_metadata'): DCNL DCSP  DCSP d['volume_image_metadata'] = copy.deepcopy(vol.volume_image_metadata) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = snapshot.id DCNL DCSP d['status'] = snapshot.status DCNL DCSP d['progress'] = snapshot.progress DCNL DCSP d['size'] = snapshot.size DCNL DCSP d['created_at'] = snapshot.created_at DCNL DCSP d['display_name'] = snapshot.display_name DCNL DCSP d['display_description'] = snapshot.display_description DCNL DCSP d['volume_id'] = snapshot.volume_id DCNL DCSP d['project_id'] = snapshot.project_id DCNL DCSP d['volume_size'] = snapshot.size DCNL DCSP return d
 DCSP code = 500 DCNL DCSP message = fault.__class__.__name__ DCNL DCSP if hasattr(fault, 'kwargs'): DCNL DCSP  DCSP code = fault.kwargs.get('code', 500) DCNL DCSP  DCSP message = fault.kwargs.get('value', message) DCNL DCSP details = unicode(fault) DCNL DCSP if (exc_info and (code == 500)): DCNL DCSP  DCSP tb = exc_info[2] DCNL DCSP  DCSP details += ('\n' + ''.join(traceback.format_tb(tb))) DCNL DCSP values = {'instance_uuid': instance['uuid'], 'code': code, 'message': unicode(message), 'details': unicode(details), 'host': CONF.host} DCNL DCSP conductor.instance_fault_create(context, values)
 DCSP req_prefix = None DCNL DCSP req_letter = None DCNL DCSP if device: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (req_prefix, req_letter) = block_device.match_device(device) DCNL DCSP  DCSP except (TypeError, AttributeError, ValueError): DCNL DCSP  DCSP  DCSP raise exception.InvalidDevicePath(path=device) DCNL DCSP mappings = block_device.instance_block_mapping(instance, bdms) DCNL DCSP try: DCNL DCSP  DCSP prefix = block_device.match_device(mappings['root'])[0] DCNL DCSP except (TypeError, AttributeError, ValueError): DCNL DCSP  DCSP raise exception.InvalidDevicePath(path=mappings['root']) DCNL DCSP if driver.compute_driver_matches('xenapi.XenAPIDriver'): DCNL DCSP  DCSP prefix = '/dev/xvd' DCNL DCSP if (req_prefix != prefix): DCNL DCSP  DCSP LOG.debug((_('Using DCSP %(prefix)s DCSP instead DCSP of DCSP %(req_prefix)s') % locals())) DCNL DCSP used_letters = set() DCNL DCSP for device_path in mappings.itervalues(): DCNL DCSP  DCSP letter = block_device.strip_prefix(device_path) DCNL DCSP  DCSP letter = re.sub('\\d+', '', letter) DCNL DCSP  DCSP used_letters.add(letter) DCNL DCSP if driver.compute_driver_matches('xenapi.XenAPIDriver'): DCNL DCSP  DCSP instance_type = instance_types.extract_instance_type(instance) DCNL DCSP  DCSP if instance_type['ephemeral_gb']: DCNL DCSP  DCSP  DCSP used_letters.add('b') DCNL DCSP  DCSP if instance_type['swap']: DCNL DCSP  DCSP  DCSP used_letters.add('c') DCNL DCSP if (not req_letter): DCNL DCSP  DCSP req_letter = _get_unused_letter(used_letters) DCNL DCSP if (req_letter in used_letters): DCNL DCSP  DCSP raise exception.DevicePathInUse(path=device) DCNL DCSP device_name = (prefix + req_letter) DCNL DCSP return device_name
 DCSP (audit_start, audit_end) = notifications.audit_period_bounds(current_period) DCNL DCSP bw = notifications.bandwidth_usage(instance_ref, audit_start, ignore_missing_network_data) DCNL DCSP if (system_metadata is None): DCNL DCSP  DCSP system_metadata = utils.metadata_to_dict(instance_ref['system_metadata']) DCNL DCSP image_meta = notifications.image_meta(system_metadata) DCNL DCSP extra_info = dict(audit_period_beginning=str(audit_start), audit_period_ending=str(audit_end), bandwidth=bw, image_meta=image_meta) DCNL DCSP if extra_usage_info: DCNL DCSP  DCSP extra_info.update(extra_usage_info) DCNL DCSP notify_about_instance_usage(context, instance_ref, 'exists', system_metadata=system_metadata, extra_usage_info=extra_info)
 DCSP if (not host): DCNL DCSP  DCSP host = CONF.host DCNL DCSP if (not extra_usage_info): DCNL DCSP  DCSP extra_usage_info = {} DCNL DCSP usage_info = notifications.info_from_instance(context, instance, network_info, system_metadata, **extra_usage_info) DCNL DCSP notifier_api.notify(context, ('compute.%s' % host), ('compute.instance.%s' % event_suffix), notifier_api.INFO, usage_info)
 DCSP importutils = nova.openstack.common.importutils DCNL DCSP compute_api_class_name = oslo.config.cfg.CONF.compute_api_class DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__module__ + '.HostAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
 DCSP importutils = nova.openstack.common.importutils DCNL DCSP compute_api_class_name = oslo.config.cfg.CONF.compute_api_class DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__module__ + '.InstanceActionAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
 DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, context, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(self, context, *args, **kwargs) DCNL DCSP  DCSP except exception.UnexpectedTaskStateError: DCNL DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(_('Possibly DCSP task DCSP preempted.')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._instance_update(context, kwargs['instance']['uuid'], task_state=None) DCNL DCSP  DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return decorated_function
 DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, context, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(self, context, *args, **kwargs) DCNL DCSP  DCSP except exception.InstanceNotFound: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP kwargs.update(dict(zip(function.func_code.co_varnames[2:], args))) DCNL DCSP  DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP  DCSP compute_utils.add_instance_fault_from_exc(context, self.conductor_api, kwargs['instance'], e, sys.exc_info()) DCNL DCSP return decorated_function
 DCSP @functools.wraps(function) DCNL DCSP def decorated_function(self, context, *args, **kwargs): DCNL DCSP  DCSP wrapped_func = utils.get_wrapped_function(function) DCNL DCSP  DCSP keyed_args = safe_utils.getcallargs(wrapped_func, context, *args, **kwargs) DCNL DCSP  DCSP instance_uuid = keyed_args['instance']['uuid'] DCNL DCSP  DCSP event_name = 'compute_{0}'.format(function.func_name) DCNL DCSP  DCSP with compute_utils.EventReporter(context, self.conductor_api, event_name, instance_uuid): DCNL DCSP  DCSP  DCSP function(self, context, *args, **kwargs) DCNL DCSP return decorated_function
 DCSP if ((vm_state is not None) and (not isinstance(vm_state, set))): DCNL DCSP  DCSP vm_state = set(vm_state) DCNL DCSP if ((task_state is not None) and (not isinstance(task_state, set))): DCNL DCSP  DCSP task_state = set(task_state) DCNL DCSP def outer(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(self, context, instance, *args, **kw): DCNL DCSP  DCSP  DCSP if ((vm_state is not None) and (instance['vm_state'] not in vm_state)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.InstanceInvalidState(attr='vm_state', instance_uuid=instance['uuid'], state=instance['vm_state'], method=f.__name__) DCNL DCSP  DCSP  DCSP if ((task_state is not None) and (instance['task_state'] not in task_state)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.InstanceInvalidState(attr='task_state', instance_uuid=instance['uuid'], state=instance['task_state'], method=f.__name__) DCNL DCSP  DCSP  DCSP return f(self, context, instance, *args, **kw) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP def outer(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def wrapped(self, context, target, *args, **kwargs): DCNL DCSP  DCSP  DCSP check_policy(context, func.__name__, target, scope) DCNL DCSP  DCSP  DCSP return func(self, context, target, *args, **kwargs) DCNL DCSP  DCSP return wrapped DCNL DCSP return outer
 DCSP if ((flavorid is None) or (flavorid == '')): DCNL DCSP  DCSP flavorid = uuid.uuid4() DCNL DCSP if (swap is None): DCNL DCSP  DCSP swap = 0 DCNL DCSP if (rxtx_factor is None): DCNL DCSP  DCSP rxtx_factor = 1.0 DCNL DCSP if (ephemeral_gb is None): DCNL DCSP  DCSP ephemeral_gb = 0 DCNL DCSP kwargs = {'memory_mb': memory, 'vcpus': vcpus, 'root_gb': root_gb, 'ephemeral_gb': ephemeral_gb, 'swap': swap, 'rxtx_factor': rxtx_factor} DCNL DCSP utils.check_string_length(name, 'name', min_length=1, max_length=255) DCNL DCSP invalid_name = INVALID_NAME_REGEX.search(name) DCNL DCSP if invalid_name: DCNL DCSP  DCSP msg = _('names DCSP can DCSP only DCSP contain DCSP [a-zA-Z0-9_.- DCSP ]') DCNL DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP for option in ['memory_mb', 'vcpus', 'root_gb', 'ephemeral_gb', 'swap']: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP kwargs[option] = int(kwargs[option]) DCNL DCSP  DCSP  DCSP assert (kwargs[option] >= 0) DCNL DCSP  DCSP except (ValueError, AssertionError): DCNL DCSP  DCSP  DCSP msg = (_("'%s' DCSP argument DCSP must DCSP be DCSP a DCSP positive DCSP integer") % option) DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP try: DCNL DCSP  DCSP kwargs['rxtx_factor'] = float(kwargs['rxtx_factor']) DCNL DCSP  DCSP assert (kwargs['rxtx_factor'] > 0) DCNL DCSP except (ValueError, AssertionError): DCNL DCSP  DCSP msg = _("'rxtx_factor' DCSP argument DCSP must DCSP be DCSP a DCSP positive DCSP float") DCNL DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP for option in ['memory_mb', 'vcpus']: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP assert (kwargs[option] > 0) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP msg = (_("'%s' DCSP argument DCSP must DCSP be DCSP greater DCSP than DCSP 0") % option) DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP kwargs['name'] = name DCNL DCSP kwargs['flavorid'] = unicode(flavorid) DCNL DCSP if (not utils.is_valid_boolstr(is_public)): DCNL DCSP  DCSP msg = _('is_public DCSP must DCSP be DCSP a DCSP boolean') DCNL DCSP  DCSP raise exception.InvalidInput(reason=msg) DCNL DCSP kwargs['is_public'] = utils.bool_from_str(is_public) DCNL DCSP try: DCNL DCSP  DCSP return db.instance_type_create(context.get_admin_context(), kwargs) DCNL DCSP except db_exc.DBError as e: DCNL DCSP  DCSP LOG.exception((_('DB DCSP error: DCSP %s') % e)) DCNL DCSP  DCSP raise exception.InstanceTypeCreateFailed()
 DCSP try: DCNL DCSP  DCSP assert (name is not None) DCNL DCSP  DCSP db.instance_type_destroy(context.get_admin_context(), name) DCNL DCSP except (AssertionError, exception.NotFound): DCNL DCSP  DCSP LOG.exception((_('Instance DCSP type DCSP %s DCSP not DCSP found DCSP for DCSP deletion') % name)) DCNL DCSP  DCSP raise exception.InstanceTypeNotFoundByName(instance_type_name=name)
 DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP inst_types = db.instance_type_get_all(ctxt, inactive=inactive, filters=filters) DCNL DCSP inst_type_dict = {} DCNL DCSP for inst_type in inst_types: DCNL DCSP  DCSP inst_type_dict[inst_type['name']] = inst_type DCNL DCSP return inst_type_dict
 DCSP name = CONF.default_instance_type DCNL DCSP return get_instance_type_by_name(name)
 DCSP if (instance_type_id is None): DCNL DCSP  DCSP return get_default_instance_type() DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP if inactive: DCNL DCSP  DCSP ctxt = ctxt.elevated(read_deleted='yes') DCNL DCSP return db.instance_type_get(ctxt, instance_type_id)
 DCSP if (name is None): DCNL DCSP  DCSP return get_default_instance_type() DCNL DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_get_by_name(ctxt, name)
 DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context(read_deleted=read_deleted) DCNL DCSP return db.instance_type_get_by_flavor_id(ctxt, flavorid)
 DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_get_by_flavor_id(ctxt, flavorid)
 DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_add(ctxt, flavorid, projectid)
 DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_admin_context() DCNL DCSP return db.instance_type_access_remove(ctxt, flavorid, projectid)
 DCSP instance_type = {} DCNL DCSP sys_meta = utils.metadata_to_dict(instance['system_metadata']) DCNL DCSP for (key, type_fn) in system_metadata_instance_type_props.items(): DCNL DCSP  DCSP type_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP instance_type[key] = type_fn(sys_meta[type_key]) DCNL DCSP return instance_type
 DCSP for key in system_metadata_instance_type_props.keys(): DCNL DCSP  DCSP to_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP metadata[to_key] = instance_type[key] DCNL DCSP return metadata
 DCSP for key in system_metadata_instance_type_props.keys(): DCNL DCSP  DCSP for prefix in prefixes: DCNL DCSP  DCSP  DCSP to_key = ('%sinstance_type_%s' % (prefix, key)) DCNL DCSP  DCSP  DCSP del metadata[to_key] DCNL DCSP return metadata
 DCSP if (not host): DCNL DCSP  DCSP if (not instance): DCNL DCSP  DCSP  DCSP raise exception.NovaException(_('No DCSP compute DCSP host DCSP specified')) DCNL DCSP  DCSP host = instance['host'] DCNL DCSP  DCSP if (not host): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Unable DCSP to DCSP find DCSP host DCSP for DCSP Instance DCSP %s') % instance['uuid'])) DCNL DCSP return rpc.queue_get_for(ctxt, topic, host)
 DCSP path_parts = path.split(_PATH_CELL_SEP) DCNL DCSP path_parts.reverse() DCNL DCSP return _PATH_CELL_SEP.join(path_parts)
 DCSP path = _reverse_path(routing_path) DCNL DCSP if ((not neighbor_only) or (len(path) == 1)): DCNL DCSP  DCSP return path DCNL DCSP return _PATH_CELL_SEP.join(path.split(_PATH_CELL_SEP)[:2])
 DCSP filters = {} DCNL DCSP if (updated_since is not None): DCNL DCSP  DCSP filters['changes-since'] = updated_since DCNL DCSP if (project_id is not None): DCNL DCSP  DCSP filters['project_id'] = project_id DCNL DCSP if (not deleted): DCNL DCSP  DCSP filters['deleted'] = False DCNL DCSP instances = db.instance_get_all_by_filters(context, filters, 'deleted', 'asc') DCNL DCSP if shuffle: DCNL DCSP  DCSP random.shuffle(instances) DCNL DCSP for instance in instances: DCNL DCSP  DCSP if uuids_only: DCNL DCSP  DCSP  DCSP (yield instance['uuid']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield instance)
 DCSP if (cell_name is None): DCNL DCSP  DCSP return item DCNL DCSP return ((cell_name + _CELL_ITEM_SEP) + str(item))
 DCSP result = cell_and_item.rsplit(_CELL_ITEM_SEP, 1) DCNL DCSP if (len(result) == 1): DCNL DCSP  DCSP return (None, cell_and_item) DCNL DCSP else: DCNL DCSP  DCSP return result
 DCSP compute_node['id'] = cell_with_item(cell_name, compute_node['id']) DCNL DCSP service = compute_node.get('service') DCNL DCSP if isinstance(service, dict): DCNL DCSP  DCSP _add_cell_to_service(service, cell_name)
 DCSP _add_cell_to_service(service, cell_name) DCNL DCSP compute_node = service.get('compute_node') DCNL DCSP if compute_node: DCNL DCSP  DCSP add_cell_to_compute_node(compute_node[0], cell_name)
 DCSP task_log['id'] = cell_with_item(cell_name, task_log['id']) DCNL DCSP task_log['host'] = cell_with_item(cell_name, task_log['host'])
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self._time_to_sync(): DCNL DCSP  DCSP  DCSP self._cell_db_sync() DCNL DCSP  DCSP return f(self, *args, **kwargs) DCNL DCSP return wrapper
 DCSP return os.path.basename(inspect.stack()[(-1)][1])[:16]
 DCSP if (CONF.metadata_host != '127.0.0.1'): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule('PREROUTING', ('-s DCSP 0.0.0.0/0 DCSP -d DCSP 169.254.169.254/32 DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --dport DCSP 80 DCSP -j DCSP DNAT DCSP --to-destination DCSP %s:%s' % (CONF.metadata_host, CONF.metadata_port))) DCNL DCSP else: DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule('PREROUTING', ('-s DCSP 0.0.0.0/0 DCSP -d DCSP 169.254.169.254/32 DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --dport DCSP 80 DCSP -j DCSP REDIRECT DCSP --to-ports DCSP %s' % CONF.metadata_port)) DCNL DCSP iptables_manager.apply()
 DCSP iptables_manager.ipv4['filter'].add_rule('INPUT', ('-s DCSP 0.0.0.0/0 DCSP -d DCSP %s DCSP -p DCSP tcp DCSP -m DCSP tcp DCSP --dport DCSP %s DCSP -j DCSP ACCEPT' % (CONF.metadata_host, CONF.metadata_port))) DCNL DCSP iptables_manager.apply()
 DCSP if (not ip_range): DCNL DCSP  DCSP ip_range = CONF.fixed_range DCNL DCSP add_snat_rule(ip_range) DCNL DCSP rules = [] DCNL DCSP for snat_range in CONF.force_snat_range: DCNL DCSP  DCSP rules.append(('PREROUTING DCSP -p DCSP ipv4 DCSP --ip-src DCSP %s DCSP --ip-dst DCSP %s DCSP -j DCSP redirect DCSP --redirect-target DCSP ACCEPT' % (ip_range, snat_range))) DCNL DCSP if rules: DCNL DCSP  DCSP ensure_ebtables_rules(rules, 'nat') DCNL DCSP iptables_manager.ipv4['nat'].add_rule('POSTROUTING', ('-s DCSP %s DCSP -d DCSP %s/32 DCSP -j DCSP ACCEPT' % (ip_range, CONF.metadata_host))) DCNL DCSP for dmz in CONF.dmz_cidr: DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule('POSTROUTING', ('-s DCSP %s DCSP -d DCSP %s DCSP -j DCSP ACCEPT' % (ip_range, dmz))) DCNL DCSP iptables_manager.ipv4['nat'].add_rule('POSTROUTING', ('-s DCSP %(range)s DCSP -d DCSP %(range)s DCSP -m DCSP conntrack DCSP ! DCSP --ctstate DCSP DNAT DCSP -j DCSP ACCEPT' % {'range': ip_range})) DCNL DCSP iptables_manager.apply()
 DCSP _execute('ip', 'addr', 'add', (str(floating_ip) + '/32'), 'dev', device, run_as_root=True, check_exit_code=[0, 2, 254]) DCNL DCSP if (CONF.send_arp_for_ha and (CONF.send_arp_for_ha_count > 0)): DCNL DCSP  DCSP send_arp_for_ip(floating_ip, device, CONF.send_arp_for_ha_count)
 DCSP _execute('ip', 'addr', 'del', (str(floating_ip) + '/32'), 'dev', device, run_as_root=True, check_exit_code=[0, 2, 254])
 DCSP _execute('ip', 'addr', 'add', '169.254.169.254/32', 'scope', 'link', 'dev', 'lo', run_as_root=True, check_exit_code=[0, 2, 254])
 DCSP iptables_manager.ipv4['filter'].add_rule('FORWARD', ('-d DCSP %s DCSP -p DCSP udp DCSP --dport DCSP 1194 DCSP -j DCSP ACCEPT' % private_ip)) DCNL DCSP iptables_manager.ipv4['nat'].add_rule('PREROUTING', ('-d DCSP %s DCSP -p DCSP udp DCSP --dport DCSP %s DCSP -j DCSP DNAT DCSP --to DCSP %s:1194' % (public_ip, port, private_ip))) DCNL DCSP iptables_manager.ipv4['nat'].add_rule('OUTPUT', ('-d DCSP %s DCSP -p DCSP udp DCSP --dport DCSP %s DCSP -j DCSP DNAT DCSP --to DCSP %s:1194' % (public_ip, port, private_ip))) DCNL DCSP iptables_manager.apply()
 DCSP regex = ('.*\\s+%s(/32|\\s+|$)' % floating_ip) DCNL DCSP num_rules = iptables_manager.ipv4['nat'].remove_rules_regex(regex) DCNL DCSP if num_rules: DCNL DCSP  DCSP msg = _('Removed DCSP %(num)d DCSP duplicate DCSP rules DCSP for DCSP floating DCSP ip DCSP %(float)s') DCNL DCSP  DCSP LOG.warn((msg % {'num': num_rules, 'float': floating_ip})) DCNL DCSP for (chain, rule) in floating_forward_rules(floating_ip, fixed_ip, device): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].add_rule(chain, rule) DCNL DCSP iptables_manager.apply() DCNL DCSP if (device != network['bridge']): DCNL DCSP  DCSP ensure_ebtables_rules(*floating_ebtables_rules(fixed_ip, network))
 DCSP for (chain, rule) in floating_forward_rules(floating_ip, fixed_ip, device): DCNL DCSP  DCSP iptables_manager.ipv4['nat'].remove_rule(chain, rule) DCNL DCSP iptables_manager.apply() DCNL DCSP if (device != network['bridge']): DCNL DCSP  DCSP remove_ebtables_rules(*floating_ebtables_rules(fixed_ip, network))
 DCSP return ([('PREROUTING DCSP --logical-in DCSP %s DCSP -p DCSP ipv4 DCSP --ip-src DCSP %s DCSP ! DCSP --ip-dst DCSP %s DCSP -j DCSP redirect DCSP --redirect-target DCSP ACCEPT' % (network['bridge'], fixed_ip, network['cidr']))], 'nat')
 DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP for data in db.network_get_associated_fixed_ips(context, network_ref['id'], host=host): DCNL DCSP  DCSP if (data['allocated'] and data['leased']): DCNL DCSP  DCSP  DCSP hosts.append(_host_lease(data)) DCNL DCSP return '\n'.join(hosts)
 DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP macs = set() DCNL DCSP for data in db.network_get_associated_fixed_ips(context, network_ref['id'], host=host): DCNL DCSP  DCSP if (data['vif_address'] not in macs): DCNL DCSP  DCSP  DCSP hosts.append(_host_dhcp(data)) DCNL DCSP  DCSP  DCSP macs.add(data['vif_address']) DCNL DCSP return '\n'.join(hosts)
 DCSP hosts = [] DCNL DCSP for data in db.network_get_associated_fixed_ips(context, network_ref['id']): DCNL DCSP  DCSP hosts.append(_host_dns(data)) DCNL DCSP return '\n'.join(hosts)
 DCSP table = iptables_manager.ipv4['filter'] DCNL DCSP for port in [67, 53]: DCNL DCSP  DCSP for proto in ['udp', 'tcp']: DCNL DCSP  DCSP  DCSP args = {'dev': dev, 'port': port, 'proto': proto} DCNL DCSP  DCSP  DCSP table.add_rule('INPUT', ('-i DCSP %(dev)s DCSP -p DCSP %(proto)s DCSP -m DCSP %(proto)s DCSP --dport DCSP %(port)s DCSP -j DCSP ACCEPT' % args)) DCNL DCSP iptables_manager.apply()
 DCSP table = iptables_manager.ipv4['filter'] DCNL DCSP for port in [67, 53]: DCNL DCSP  DCSP for proto in ['udp', 'tcp']: DCNL DCSP  DCSP  DCSP args = {'dev': dev, 'port': port, 'proto': proto} DCNL DCSP  DCSP  DCSP table.remove_rule('INPUT', ('-i DCSP %(dev)s DCSP -p DCSP %(proto)s DCSP -m DCSP %(proto)s DCSP --dport DCSP %(port)s DCSP -j DCSP ACCEPT' % args)) DCNL DCSP iptables_manager.apply()
 DCSP hosts = [] DCNL DCSP host = None DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP host = CONF.host DCNL DCSP data = db.network_get_associated_fixed_ips(context, network_ref['id'], host=host) DCNL DCSP if data: DCNL DCSP  DCSP instance_set = set([datum['instance_uuid'] for datum in data]) DCNL DCSP  DCSP default_gw_vif = {} DCNL DCSP  DCSP for instance_uuid in instance_set: DCNL DCSP  DCSP  DCSP vifs = db.virtual_interface_get_by_instance(context, instance_uuid) DCNL DCSP  DCSP  DCSP if vifs: DCNL DCSP  DCSP  DCSP  DCSP default_gw_vif[instance_uuid] = vifs[0]['id'] DCNL DCSP  DCSP for datum in data: DCNL DCSP  DCSP  DCSP instance_uuid = datum['instance_uuid'] DCNL DCSP  DCSP  DCSP if (instance_uuid in default_gw_vif): DCNL DCSP  DCSP  DCSP  DCSP if (default_gw_vif[instance_uuid] != datum['vif_id']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hosts.append(_host_dhcp_opts(datum)) DCNL DCSP return '\n'.join(hosts)
 DCSP conffile = _dhcp_file(dev, 'conf') DCNL DCSP if CONF.use_single_default_gateway: DCNL DCSP  DCSP optsfile = _dhcp_file(dev, 'opts') DCNL DCSP  DCSP write_to_file(optsfile, get_dhcp_opts(context, network_ref)) DCNL DCSP  DCSP os.chmod(optsfile, 420) DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP _add_dhcp_mangle_rule(dev) DCNL DCSP os.chmod(conffile, 420) DCNL DCSP pid = _dnsmasq_pid_for(dev) DCNL DCSP if pid: DCNL DCSP  DCSP (out, _err) = _execute('cat', ('/proc/%d/cmdline' % pid), check_exit_code=False) DCNL DCSP  DCSP if (conffile.split('/')[(-1)] in out): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _execute('kill', '-HUP', pid, run_as_root=True) DCNL DCSP  DCSP  DCSP  DCSP _add_dnsmasq_accept_rules(dev) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP LOG.error(_('Hupping DCSP dnsmasq DCSP threw DCSP %s'), exc) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.debug(_('Pid DCSP %d DCSP is DCSP stale, DCSP relaunching DCSP dnsmasq'), pid) DCNL DCSP cmd = ['env', ('CONFIG_FILE=%s' % jsonutils.dumps(CONF.dhcpbridge_flagfile)), ('NETWORK_ID=%s' % str(network_ref['id'])), 'dnsmasq', '--strict-order', '--bind-interfaces', ('--conf-file=%s' % CONF.dnsmasq_config_file), ('--pid-file=%s' % _dhcp_file(dev, 'pid')), ('--listen-address=%s' % network_ref['dhcp_server']), '--except-interface=lo', ('--dhcp-range=set:%s,%s,static,%s,%ss' % (network_ref['label'], network_ref['dhcp_start'], network_ref['netmask'], CONF.dhcp_lease_time)), ('--dhcp-lease-max=%s' % len(netaddr.IPNetwork(network_ref['cidr']))), ('--dhcp-hostsfile=%s' % _dhcp_file(dev, 'conf')), ('--dhcp-script=%s' % CONF.dhcpbridge), '--leasefile-ro'] DCNL DCSP if CONF.dhcp_domain: DCNL DCSP  DCSP cmd.append(('--domain=%s' % CONF.dhcp_domain)) DCNL DCSP dns_servers = set(CONF.dns_server) DCNL DCSP if CONF.use_network_dns_servers: DCNL DCSP  DCSP if network_ref.get('dns1'): DCNL DCSP  DCSP  DCSP dns_servers.add(network_ref.get('dns1')) DCNL DCSP  DCSP if network_ref.get('dns2'): DCNL DCSP  DCSP  DCSP dns_servers.add(network_ref.get('dns2')) DCNL DCSP if (network_ref['multi_host'] or dns_servers): DCNL DCSP  DCSP cmd.append('--no-hosts') DCNL DCSP if network_ref['multi_host']: DCNL DCSP  DCSP ('--addn-hosts=%s' % _dhcp_file(dev, 'hosts')) DCNL DCSP if dns_servers: DCNL DCSP  DCSP cmd.append('--no-resolv') DCNL DCSP for dns_server in dns_servers: DCNL DCSP  DCSP cmd.append(('--server=%s' % dns_server)) DCNL DCSP if CONF.use_single_default_gateway: DCNL DCSP  DCSP cmd += [('--dhcp-optsfile=%s' % _dhcp_file(dev, 'opts'))] DCNL DCSP _execute(run_as_root=True, *cmd) DCNL DCSP _add_dnsmasq_accept_rules(dev)
 DCSP timestamp = timeutils.utcnow() DCNL DCSP seconds_since_epoch = calendar.timegm(timestamp.utctimetuple()) DCNL DCSP return ('%d DCSP %s DCSP %s DCSP %s DCSP *' % ((seconds_since_epoch + CONF.dhcp_lease_time), data['vif_address'], data['address'], (data['instance_hostname'] or '*')))
 DCSP if CONF.use_single_default_gateway: DCNL DCSP  DCSP return ('%s,%s.%s,%s,%s' % (data['vif_address'], data['instance_hostname'], CONF.dhcp_domain, data['address'], ('net:' + _host_dhcp_network(data)))) DCNL DCSP else: DCNL DCSP  DCSP return ('%s,%s.%s,%s' % (data['vif_address'], data['instance_hostname'], CONF.dhcp_domain, data['address']))
 DCSP return ('%s,%s' % (_host_dhcp_network(data), 3))
 DCSP if CONF.fake_network: DCNL DCSP  DCSP LOG.debug('FAKE DCSP NET: DCSP %s', ' DCSP '.join(map(str, cmd))) DCNL DCSP  DCSP return ('fake', 0) DCNL DCSP else: DCNL DCSP  DCSP return utils.execute(*cmd, **kwargs)
 DCSP (_out, err) = _execute('ip', 'link', 'show', 'dev', device, check_exit_code=False, run_as_root=True) DCNL DCSP return (not err)
 DCSP fileutils.ensure_tree(CONF.networks_path) DCNL DCSP return os.path.abspath(('%s/nova-%s.%s' % (CONF.networks_path, dev, kind)))
 DCSP fileutils.ensure_tree(CONF.networks_path) DCNL DCSP return os.path.abspath(('%s/nova-ra-%s.%s' % (CONF.networks_path, dev, kind)))
 DCSP pid_file = _dhcp_file(dev, 'pid') DCNL DCSP if os.path.exists(pid_file): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(pid_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return int(f.read()) DCNL DCSP  DCSP except (ValueError, IOError): DCNL DCSP  DCSP  DCSP return None
 DCSP pid_file = _ra_file(dev, 'pid') DCNL DCSP if os.path.exists(pid_file): DCNL DCSP  DCSP with open(pid_file, 'r') as f: DCNL DCSP  DCSP  DCSP return int(f.read())
 DCSP cmd = ['ip', 'addr', action] DCNL DCSP cmd.extend(params) DCNL DCSP cmd.extend(['dev', device]) DCNL DCSP return cmd
 DCSP for dev in [dev1_name, dev2_name]: DCNL DCSP  DCSP if device_exists(dev): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP utils.execute('ip', 'link', 'delete', dev1_name, run_as_root=True, check_exit_code=[0, 2, 254]) DCNL DCSP  DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception((_('Error DCSP clearing DCSP stale DCSP veth DCSP %s') % dev)) DCNL DCSP utils.execute('ip', 'link', 'add', dev1_name, 'type', 'veth', 'peer', 'name', dev2_name, run_as_root=True) DCNL DCSP for dev in [dev1_name, dev2_name]: DCNL DCSP  DCSP utils.execute('ip', 'link', 'set', dev, 'up', run_as_root=True) DCNL DCSP  DCSP utils.execute('ip', 'link', 'set', dev, 'promisc', 'on', run_as_root=True)
 DCSP if preferred: DCNL DCSP  DCSP unordered.sort(key=(lambda i: preferred.index(accessor(i))))
 DCSP argspec = inspect.getargspec(f) DCNL DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, context, *args, **kwargs): DCNL DCSP  DCSP res = f(self, context, *args, **kwargs) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance = kwargs.get('instance') DCNL DCSP  DCSP  DCSP if (not instance): DCNL DCSP  DCSP  DCSP  DCSP instance = args[(argspec.args.index('instance') - 2)] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP msg = _('instance DCSP is DCSP a DCSP required DCSP argument DCSP to DCSP use DCSP @refresh_cache') DCNL DCSP  DCSP  DCSP raise Exception(msg) DCNL DCSP  DCSP update_instance_cache_with_nw_info(self, context, instance, nw_info=res, conductor_api=kwargs.get('conductor_api')) DCNL DCSP  DCSP return res DCNL DCSP return wrapper
 DCSP @functools.wraps(func) DCNL DCSP def wrapped(self, context, *args, **kwargs): DCNL DCSP  DCSP action = func.__name__ DCNL DCSP  DCSP check_policy(context, action) DCNL DCSP  DCSP return func(self, context, *args, **kwargs) DCNL DCSP return wrapped
 DCSP cmdline = cmdline.encode('ascii') DCNL DCSP logging.info(("Running DCSP cmd DCSP '%s'" % cmdline)) DCNL DCSP kwargs = {} DCNL DCSP kwargs['stdout'] = ((stdout and subprocess.PIPE) or None) DCNL DCSP kwargs['stderr'] = ((stderr and subprocess.PIPE) or None) DCNL DCSP kwargs['stdin'] = ((stdin and subprocess.PIPE) or None) DCNL DCSP kwargs['universal_newlines'] = universal_newlines DCNL DCSP args = shlex.split(cmdline) DCNL DCSP logging.info(("Running DCSP args DCSP '%s'" % args)) DCNL DCSP proc = subprocess.Popen(args, **kwargs) DCNL DCSP return proc
 DCSP if (ok_exit_codes is None): DCNL DCSP  DCSP ok_exit_codes = [0] DCNL DCSP (out, err) = proc.communicate() DCNL DCSP ret = proc.returncode DCNL DCSP if (ret not in ok_exit_codes): DCNL DCSP  DCSP raise Exception(("'%(cmdline)s' DCSP returned DCSP non-zero DCSP exit DCSP code: DCSP retcode=%(ret)i, DCSP out='%(out)s', DCSP stderr='%(err)s'" % locals())) DCNL DCSP return (out, err)
 DCSP staging_path = tempfile.mkdtemp(dir=sr_path) DCNL DCSP return staging_path
 DCSP if os.path.exists(staging_path): DCNL DCSP  DCSP shutil.rmtree(staging_path)
 DCSP file_num = 0 DCNL DCSP for filename in ('snap.vhd', 'image.vhd', 'base.vhd'): DCNL DCSP  DCSP path = os.path.join(staging_path, filename) DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP _rename(path, os.path.join(staging_path, ('%d.vhd' % file_num))) DCNL DCSP  DCSP  DCSP file_num += 1
 DCSP query_cmd = ('vhd-util DCSP query DCSP -n DCSP %(path)s DCSP -f' % locals()) DCNL DCSP query_proc = make_subprocess(query_cmd, stdout=True, stderr=True) DCNL DCSP (out, err) = finish_subprocess(query_proc, query_cmd) DCNL DCSP for line in out.splitlines(): DCNL DCSP  DCSP if line.startswith('hidden'): DCNL DCSP  DCSP  DCSP value = line.split(':')[1].strip() DCNL DCSP  DCSP  DCSP if (value == '1'): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('VHD DCSP %(path)s DCSP is DCSP marked DCSP as DCSP hidden DCSP without DCSP child' % locals()))
 DCSP check_cmd = ('vhd-util DCSP check DCSP -n DCSP %(vdi_path)s DCSP -p' % locals()) DCNL DCSP check_proc = make_subprocess(check_cmd, stdout=True, stderr=True) DCNL DCSP (out, err) = finish_subprocess(check_proc, check_cmd, ok_exit_codes=[0, 22]) DCNL DCSP first_line = out.splitlines()[0].strip() DCNL DCSP if ('primary DCSP footer DCSP invalid' in first_line): DCNL DCSP  DCSP raise Exception(("VDI DCSP '%(vdi_path)s' DCSP has DCSP timestamp DCSP in DCSP the DCSP future, DCSP ensure DCSP source DCSP and DCSP destination DCSP host DCSP machines DCSP have DCSP time DCSP set DCSP correctly" % locals())) DCNL DCSP elif (check_proc.returncode != 0): DCNL DCSP  DCSP raise Exception(("Unexpected DCSP output DCSP '%(out)s' DCSP from DCSP vhd-util" % locals()))
 DCSP def get_parent_path(path): DCNL DCSP  DCSP query_cmd = ('vhd-util DCSP query DCSP -n DCSP %(path)s DCSP -p' % locals()) DCNL DCSP  DCSP query_proc = make_subprocess(query_cmd, stdout=True, stderr=True) DCNL DCSP  DCSP (out, err) = finish_subprocess(query_proc, query_cmd, ok_exit_codes=[0, 22]) DCNL DCSP  DCSP first_line = out.splitlines()[0].strip() DCNL DCSP  DCSP if first_line.endswith('.vhd'): DCNL DCSP  DCSP  DCSP return first_line DCNL DCSP  DCSP elif ('has DCSP no DCSP parent' in first_line): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP elif ('query DCSP failed' in first_line): DCNL DCSP  DCSP  DCSP raise Exception(("VDI DCSP '%(path)s' DCSP not DCSP present DCSP which DCSP breaks DCSP the DCSP VDI DCSP chain, DCSP bailing DCSP out" % locals())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(("Unexpected DCSP output DCSP '%(out)s' DCSP from DCSP vhd-util" % locals())) DCNL DCSP cur_path = vdi_path DCNL DCSP while cur_path: DCNL DCSP  DCSP _validate_footer_timestamp(cur_path) DCNL DCSP  DCSP cur_path = get_parent_path(cur_path)
 DCSP seq_num = 0 DCNL DCSP filenames = os.listdir(staging_path) DCNL DCSP for filename in filenames: DCNL DCSP  DCSP if (not filename.endswith('.vhd')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (filename == 'swap.vhd'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP vhd_path = os.path.join(staging_path, ('%d.vhd' % seq_num)) DCNL DCSP  DCSP if (not os.path.exists(vhd_path)): DCNL DCSP  DCSP  DCSP raise Exception(('Corrupt DCSP image. DCSP Expected DCSP seq DCSP number: DCSP %d. DCSP Files: DCSP %s' % (seq_num, filenames))) DCNL DCSP  DCSP seq_num += 1
 DCSP _handle_old_style_images(staging_path) DCNL DCSP _validate_sequenced_vhds(staging_path) DCNL DCSP files_to_move = [] DCNL DCSP seq_num = 0 DCNL DCSP while True: DCNL DCSP  DCSP orig_vhd_path = os.path.join(staging_path, ('%d.vhd' % seq_num)) DCNL DCSP  DCSP if (not os.path.exists(orig_vhd_path)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP vhd_uuid = uuid_stack.pop() DCNL DCSP  DCSP vhd_path = os.path.join(staging_path, ('%s.vhd' % vhd_uuid)) DCNL DCSP  DCSP _rename(orig_vhd_path, vhd_path) DCNL DCSP  DCSP if (seq_num == 0): DCNL DCSP  DCSP  DCSP leaf_vhd_path = vhd_path DCNL DCSP  DCSP  DCSP leaf_vhd_uuid = vhd_uuid DCNL DCSP  DCSP files_to_move.append(vhd_path) DCNL DCSP  DCSP seq_num += 1 DCNL DCSP parent_path = None DCNL DCSP for vhd_path in reversed(files_to_move): DCNL DCSP  DCSP if parent_path: DCNL DCSP  DCSP  DCSP modify_cmd = ('vhd-util DCSP modify DCSP -n DCSP %(vhd_path)s DCSP -p DCSP %(parent_path)s' % locals()) DCNL DCSP  DCSP  DCSP modify_proc = make_subprocess(modify_cmd, stderr=True) DCNL DCSP  DCSP  DCSP finish_subprocess(modify_proc, modify_cmd) DCNL DCSP  DCSP parent_path = vhd_path DCNL DCSP _assert_vhd_not_hidden(leaf_vhd_path) DCNL DCSP _validate_vdi_chain(leaf_vhd_path) DCNL DCSP for orig_path in files_to_move: DCNL DCSP  DCSP new_path = os.path.join(sr_path, os.path.basename(orig_path)) DCNL DCSP  DCSP _rename(orig_path, new_path) DCNL DCSP imported_vhds = dict(root=dict(uuid=leaf_vhd_uuid)) DCNL DCSP return imported_vhds
 DCSP for vdi_uuid in vdi_uuids: DCNL DCSP  DCSP source = os.path.join(sr_path, ('%s.vhd' % vdi_uuid)) DCNL DCSP  DCSP link_name = os.path.join(staging_path, ('%d.vhd' % seq_num)) DCNL DCSP  DCSP _link(source, link_name) DCNL DCSP  DCSP seq_num += 1
 DCSP tar_cmd = ('tar DCSP -zc DCSP --directory=%(path)s DCSP .' % locals()) DCNL DCSP tar_proc = make_subprocess(tar_cmd, stdout=True, stderr=True) DCNL DCSP while True: DCNL DCSP  DCSP chunk = tar_proc.stdout.read(CHUNK_SIZE) DCNL DCSP  DCSP if (chunk == ''): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(chunk) DCNL DCSP  DCSP if fileobj: DCNL DCSP  DCSP  DCSP fileobj.write(chunk) DCNL DCSP finish_subprocess(tar_proc, tar_cmd)
 DCSP tar_cmd = ('tar DCSP -zx DCSP --directory=%(path)s' % locals()) DCNL DCSP tar_proc = make_subprocess(tar_cmd, stderr=True, stdin=True) DCNL DCSP while True: DCNL DCSP  DCSP chunk = fileobj.read(CHUNK_SIZE) DCNL DCSP  DCSP if (chunk == ''): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP callback(chunk) DCNL DCSP  DCSP tar_proc.stdin.write(chunk) DCNL DCSP finish_subprocess(tar_proc, tar_cmd)
 DCSP wrapped_dict = {} DCNL DCSP for func in funcs: DCNL DCSP  DCSP wrapped_dict[func.__name__] = _handle_serialization(func) DCNL DCSP XenAPIPlugin.dispatch(wrapped_dict)
 DCSP cmd = ['xenstore-exists', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict)] DCNL DCSP try: DCNL DCSP  DCSP (ret, result) = _run_command(cmd) DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (e.stderr == ''): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP raise DCNL DCSP return True
 DCSP cmd = ['xenstore-read', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict)] DCNL DCSP try: DCNL DCSP  DCSP (ret, result) = _run_command(cmd) DCNL DCSP  DCSP return result.strip() DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (not arg_dict.get('ignore_missing_path', False)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (not _record_exists(arg_dict)): DCNL DCSP  DCSP  DCSP return 'None' DCNL DCSP  DCSP (ret, result) = _run_command(cmd) DCNL DCSP  DCSP return result.strip()
 DCSP cmd = ['xenstore-write', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict), arg_dict['value']] DCNL DCSP _run_command(cmd) DCNL DCSP return arg_dict['value']
 DCSP dirpath = ('/local/domain/%(dom_id)s/%(path)s' % arg_dict) DCNL DCSP cmd = ['xenstore-ls', dirpath.rstrip('/')] DCNL DCSP try: DCNL DCSP  DCSP (ret, recs) = _run_command(cmd) DCNL DCSP except XenstoreError as e: DCNL DCSP  DCSP if (not _record_exists(arg_dict)): DCNL DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP (ret, recs) = _run_command(cmd) DCNL DCSP base_path = arg_dict['path'] DCNL DCSP paths = _paths_from_ls(recs) DCNL DCSP ret = {} DCNL DCSP for path in paths: DCNL DCSP  DCSP if base_path: DCNL DCSP  DCSP  DCSP arg_dict['path'] = ('%s/%s' % (base_path, path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP arg_dict['path'] = path DCNL DCSP  DCSP rec = read_record(self, arg_dict) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP val = json.loads(rec) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP val = rec DCNL DCSP  DCSP ret[path] = val DCNL DCSP return ret
 DCSP cmd = ['xenstore-rm', ('/local/domain/%(dom_id)s/%(path)s' % arg_dict)] DCNL DCSP (ret, result) = _run_command(cmd) DCNL DCSP return result
 DCSP ret = {} DCNL DCSP last_nm = '' DCNL DCSP level = 0 DCNL DCSP path = [] DCNL DCSP ret = [] DCNL DCSP for ln in recs.splitlines(): DCNL DCSP  DCSP (nm, val) = ln.rstrip().split(' DCSP = DCSP ') DCNL DCSP  DCSP barename = nm.lstrip() DCNL DCSP  DCSP this_level = (len(nm) - len(barename)) DCNL DCSP  DCSP if (this_level == 0): DCNL DCSP  DCSP  DCSP ret.append(barename) DCNL DCSP  DCSP  DCSP level = 0 DCNL DCSP  DCSP  DCSP path = [] DCNL DCSP  DCSP elif (this_level == level): DCNL DCSP  DCSP  DCSP ret.append(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP elif (this_level > level): DCNL DCSP  DCSP  DCSP path.append(last_nm) DCNL DCSP  DCSP  DCSP ret.append(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP  DCSP level = this_level DCNL DCSP  DCSP elif (this_level < level): DCNL DCSP  DCSP  DCSP path = path[:this_level] DCNL DCSP  DCSP  DCSP ret.append(('%s/%s' % ('/'.join(path), barename))) DCNL DCSP  DCSP  DCSP level = this_level DCNL DCSP  DCSP last_nm = barename DCNL DCSP return ret
 DCSP logging.info(' DCSP '.join(cmd)) DCNL DCSP pipe = subprocess.PIPE DCNL DCSP proc = subprocess.Popen(cmd, stdin=pipe, stdout=pipe, stderr=pipe, close_fds=True) DCNL DCSP (out, err) = proc.communicate() DCNL DCSP if (proc.returncode is not os.EX_OK): DCNL DCSP  DCSP raise XenstoreError(cmd, proc.returncode, err, out) DCNL DCSP return (proc.returncode, out)
 DCSP if (key in args): DCNL DCSP  DCSP if (len(args[key]) == 0): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP is DCSP too DCSP short.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP if (not ARGUMENT_PATTERN.match(args[key])): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP contains DCSP invalid DCSP characters.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP if (args[key][0] == '-'): DCNL DCSP  DCSP  DCSP raise ArgumentError((_('Argument DCSP %(key)s DCSP value DCSP %(value)s DCSP starts DCSP with DCSP a DCSP hyphen.') % {'key': key, 'value': args[key]})) DCNL DCSP  DCSP return args[key] DCNL DCSP elif (default is not None): DCNL DCSP  DCSP return default DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_('Argument DCSP %s DCSP is DCSP required.') % key))
 DCSP value = validate_exists(args, key, default) DCNL DCSP if (value.lower() == 'true'): DCNL DCSP  DCSP return True DCNL DCSP elif (value.lower() == 'false'): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_("Argument DCSP %(key)s DCSP may DCSP not DCSP take DCSP value DCSP %(value)s. DCSP Valid DCSP values DCSP are DCSP ['true', DCSP 'false'].") % {'key': key, 'value': value}))
 DCSP if (key in args): DCNL DCSP  DCSP return args[key] DCNL DCSP else: DCNL DCSP  DCSP raise ArgumentError((_('Argument DCSP %s DCSP is DCSP required.') % key))
 DCSP return (((key in args) and args[key]) or None)
 DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP session.xenapi.VBD.unplug(vbd) DCNL DCSP  DCSP  DCSP logging.debug(_('VBD.unplug DCSP successful DCSP first DCSP time.')) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP except XenAPI.Failure as e: DCNL DCSP  DCSP  DCSP if ((len(e.details) > 0) and (e.details[0] == 'DEVICE_DETACH_REJECTED')): DCNL DCSP  DCSP  DCSP  DCSP logging.debug(_('VBD.unplug DCSP rejected: DCSP retrying...')) DCNL DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP elif ((len(e.details) > 0) and (e.details[0] == 'DEVICE_ALREADY_DETACHED')): DCNL DCSP  DCSP  DCSP  DCSP logging.debug(_('VBD.unplug DCSP successful DCSP eventually.')) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logging.error(_('Ignoring DCSP XenAPI.Failure DCSP in DCSP VBD.unplug: DCSP %s'), e) DCNL DCSP  DCSP  DCSP  DCSP return
 DCSP devnull = open(os.devnull, 'w') DCNL DCSP command = map(str, command) DCNL DCSP proc = subprocess.Popen(command, close_fds=True, stdout=subprocess.PIPE, stderr=devnull) DCNL DCSP devnull.close() DCNL DCSP return proc.stdout.read().strip()
 DCSP devnull = open(os.devnull, 'w') DCNL DCSP command = map(str, command) DCNL DCSP proc = subprocess.Popen(command, close_fds=True, stdout=subprocess.PIPE, stderr=devnull) DCNL DCSP devnull.close()
 DCSP from boto_v6.ec2.connection import EC2ConnectionV6 DCNL DCSP return EC2ConnectionV6(aws_access_key_id, aws_secret_access_key, **kwargs)
 DCSP if isinstance(n.parent, compiler.ast.Mod): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Getattr): DCNL DCSP  DCSP  DCSP if isinstance(n.parent.node.getChildNodes()[0], compiler.ast.Name): DCNL DCSP  DCSP  DCSP  DCSP if (n.parent.node.getChildNodes()[0].name == 'LOG'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not isinstance(n.parent.parent, compiler.ast.Mod)): DCNL DCSP  DCSP return False DCNL DCSP n = n.parent.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Getattr): DCNL DCSP  DCSP  DCSP if isinstance(n.parent.node.getChildNodes()[0], compiler.ast.Name): DCNL DCSP  DCSP  DCSP  DCSP if (n.parent.node.getChildNodes()[0].name == 'LOG'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if isinstance(n.parent, compiler.ast.Mod): DCNL DCSP  DCSP n = n.parent DCNL DCSP if isinstance(n.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(n.parent.node, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (n.parent.node.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if isinstance(node.parent, compiler.ast.CallFunc): DCNL DCSP  DCSP if isinstance(node.parent.node, compiler.ast.Name): DCNL DCSP  DCSP  DCSP if (node.parent.node.name == '_'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP product_name = 'quantum' DCNL DCSP logging.setup(product_name) DCNL DCSP log_root = logging.getLogger(product_name).logger DCNL DCSP LOG.info(_('Logging DCSP enabled!'))
 DCSP config_path = os.path.abspath(cfg.CONF.find_file(cfg.CONF.api_paste_config)) DCNL DCSP LOG.info(_('Config DCSP paste DCSP file: DCSP %s'), config_path) DCNL DCSP try: DCNL DCSP  DCSP app = deploy.loadapp(('config:%s' % config_path), name=app_name) DCNL DCSP except (LookupError, ImportError): DCNL DCSP  DCSP msg = (_('Unable DCSP to DCSP load DCSP %(app_name)s DCSP from DCSP configuration DCSP file DCSP %(config_path)s.') % locals()) DCNL DCSP  DCSP LOG.exception(msg) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP return app
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP LOG.debug(_('Reloading DCSP cached DCSP file DCSP %s'), filename) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP fix_path = (lambda p: os.path.abspath(os.path.expanduser(p))) DCNL DCSP if options.get('config_file'): DCNL DCSP  DCSP if os.path.exists(options['config_file']): DCNL DCSP  DCSP  DCSP return fix_path(options['config_file']) DCNL DCSP dir_to_common = os.path.dirname(os.path.abspath(__file__)) DCNL DCSP root = os.path.join(dir_to_common, '..', '..', '..', '..') DCNL DCSP config_file_dirs = [fix_path(os.path.join(os.getcwd(), 'etc')), fix_path(os.path.join('~', '.quantum-venv', 'etc', 'quantum')), fix_path('~'), os.path.join(cfg.CONF.state_path, 'etc'), os.path.join(cfg.CONF.state_path, 'etc', 'quantum'), fix_path(os.path.join('~', '.local', 'etc', 'quantum')), '/usr/etc/quantum', '/usr/local/etc/quantum', '/etc/quantum/', '/etc'] DCNL DCSP if ('plugin' in options): DCNL DCSP  DCSP config_file_dirs = [os.path.join(x, 'quantum', 'plugins', options['plugin']) for x in config_file_dirs] DCNL DCSP if os.path.exists(os.path.join(root, 'plugins')): DCNL DCSP  DCSP plugins = [fix_path(os.path.join(root, 'plugins', p, 'etc')) for p in os.listdir(os.path.join(root, 'plugins'))] DCNL DCSP  DCSP plugins = [p for p in plugins if os.path.isdir(p)] DCNL DCSP  DCSP config_file_dirs.extend(plugins) DCNL DCSP for cfg_dir in config_file_dirs: DCNL DCSP  DCSP cfg_file = os.path.join(cfg_dir, config_file) DCNL DCSP  DCSP if os.path.exists(cfg_file): DCNL DCSP  DCSP  DCSP return cfg_file
 DCSP mappings = {} DCNL DCSP for mapping in mapping_list: DCNL DCSP  DCSP mapping = mapping.strip() DCNL DCSP  DCSP if (not mapping): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP split_result = mapping.split(':') DCNL DCSP  DCSP if (len(split_result) != 2): DCNL DCSP  DCSP  DCSP raise ValueError((_("Invalid DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP key = split_result[0].strip() DCNL DCSP  DCSP if (not key): DCNL DCSP  DCSP  DCSP raise ValueError((_("Missing DCSP key DCSP in DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP value = split_result[1].strip() DCNL DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP raise ValueError((_("Missing DCSP value DCSP in DCSP mapping: DCSP '%s'") % mapping)) DCNL DCSP  DCSP if (key in mappings): DCNL DCSP  DCSP  DCSP raise ValueError((_("Key DCSP %(key)s DCSP in DCSP mapping: DCSP '%(mapping)s' DCSP not DCSP unique") % locals())) DCNL DCSP  DCSP if (unique_values and (value in mappings.itervalues())): DCNL DCSP  DCSP  DCSP raise ValueError((_("Value DCSP %(value)s DCSP in DCSP mapping: DCSP '%(mapping)s' DCSP not DCSP unique") % locals())) DCNL DCSP  DCSP mappings[key] = value DCNL DCSP return mappings
 DCSP if (a is None): DCNL DCSP  DCSP a = [] DCNL DCSP if (b is None): DCNL DCSP  DCSP b = [] DCNL DCSP return (set(a) == set(b))
 DCSP return ('%s-%s-%s' % (prefix, table, operation))
 DCSP def _factory(app): DCNL DCSP  DCSP ext_mgr = PluginAwareExtensionManager.get_instance() DCNL DCSP  DCSP return ExtensionMiddleware(app, ext_mgr=ext_mgr) DCNL DCSP return _factory
 DCSP xml_deserializer = wsgi.XMLDeserializer(attributes.get_attr_metadata()) DCNL DCSP default_deserializers = {'application/xml': xml_deserializer, 'application/json': wsgi.JSONDeserializer()} DCNL DCSP xml_serializer = wsgi.XMLDictSerializer(attributes.get_attr_metadata()) DCNL DCSP default_serializers = {'application/xml': xml_serializer, 'application/json': wsgi.JSONDictSerializer()} DCNL DCSP format_types = {'xml': 'application/xml', 'json': 'application/json'} DCNL DCSP action_status = dict(create=201, delete=204) DCNL DCSP default_deserializers.update((deserializers or {})) DCNL DCSP default_serializers.update((serializers or {})) DCNL DCSP deserializers = default_deserializers DCNL DCSP serializers = default_serializers DCNL DCSP faults = (faults or {}) DCNL DCSP @webob.dec.wsgify(RequestClass=Request) DCNL DCSP def resource(request): DCNL DCSP  DCSP route_args = request.environ.get('wsgiorg.routing_args') DCNL DCSP  DCSP if route_args: DCNL DCSP  DCSP  DCSP args = route_args[1].copy() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = {} DCNL DCSP  DCSP args.pop('controller', None) DCNL DCSP  DCSP fmt = args.pop('format', None) DCNL DCSP  DCSP action = args.pop('action', None) DCNL DCSP  DCSP content_type = format_types.get(fmt, request.best_match_content_type()) DCNL DCSP  DCSP deserializer = deserializers.get(content_type) DCNL DCSP  DCSP serializer = serializers.get(content_type) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if request.body: DCNL DCSP  DCSP  DCSP  DCSP args['body'] = deserializer.deserialize(request.body)['body'] DCNL DCSP  DCSP  DCSP method = getattr(controller, action) DCNL DCSP  DCSP  DCSP result = method(request=request, **args) DCNL DCSP  DCSP except (exceptions.QuantumException, netaddr.AddrFormatError) as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP failed'), action) DCNL DCSP  DCSP  DCSP body = serializer.serialize({'QuantumError': e}) DCNL DCSP  DCSP  DCSP kwargs = {'body': body, 'content_type': content_type} DCNL DCSP  DCSP  DCSP for fault in faults: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(e, fault): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise faults[fault](**kwargs) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError(**kwargs) DCNL DCSP  DCSP except webob.exc.HTTPException as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP failed'), action) DCNL DCSP  DCSP  DCSP e.body = serializer.serialize({'QuantumError': e}) DCNL DCSP  DCSP  DCSP e.content_type = content_type DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception(_('%s DCSP failed'), action) DCNL DCSP  DCSP  DCSP msg = _('Request DCSP Failed: DCSP internal DCSP server DCSP error DCSP while DCSP processing DCSP your DCSP request.') DCNL DCSP  DCSP  DCSP body = serializer.serialize({'QuantumError': msg}) DCNL DCSP  DCSP  DCSP kwargs = {'body': body, 'content_type': content_type} DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPInternalServerError(**kwargs) DCNL DCSP  DCSP status = action_status.get(action, 200) DCNL DCSP  DCSP body = serializer.serialize(result) DCNL DCSP  DCSP if (status == 204): DCNL DCSP  DCSP  DCSP content_type = '' DCNL DCSP  DCSP  DCSP body = None DCNL DCSP  DCSP return webob.Response(request=request, status=status, content_type=content_type, body=body) DCNL DCSP return resource
 DCSP if (not isinstance(target_dict, dict)): DCNL DCSP  DCSP msg = (_("Invalid DCSP input. DCSP '%(target_dict)s' DCSP must DCSP be DCSP a DCSP dictionary DCSP with DCSP keys: DCSP %(expected_keys)s") % dict(target_dict=target_dict, expected_keys=expected_keys)) DCNL DCSP  DCSP return msg DCNL DCSP expected_keys = set(expected_keys) DCNL DCSP provided_keys = set(target_dict.keys()) DCNL DCSP predicate = (expected_keys.__eq__ if strict else expected_keys.issubset) DCNL DCSP if (not predicate(provided_keys)): DCNL DCSP  DCSP msg = (_("Validation DCSP of DCSP dictionary's DCSP keys DCSP failed.Expected DCSP keys: DCSP %(expected_keys)s DCSP Provided DCSP keys: DCSP %(provided_keys)s") % locals()) DCNL DCSP  DCSP return msg
 DCSP if (not isinstance(data, list)): DCNL DCSP  DCSP msg = (_("Invalid DCSP data DCSP format DCSP for DCSP IP DCSP pool: DCSP '%s'") % data) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP return msg DCNL DCSP expected_keys = ['start', 'end'] DCNL DCSP for ip_pool in data: DCNL DCSP  DCSP msg = _verify_dict_keys(expected_keys, ip_pool) DCNL DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP for k in expected_keys: DCNL DCSP  DCSP  DCSP msg = _validate_ip_address(ip_pool[k]) DCNL DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP  DCSP  DCSP return msg
 DCSP kvp = [x.strip() for x in data.split('=', 1)] DCNL DCSP if ((len(kvp) == 2) and kvp[0]): DCNL DCSP  DCSP return kvp DCNL DCSP msg = (_("'%s' DCSP is DCSP not DCSP of DCSP the DCSP form DCSP <key>=[value]") % data) DCNL DCSP raise q_exc.InvalidInput(error_message=msg)
 DCSP if (kvp_list == ['True']): DCNL DCSP  DCSP return {} DCNL DCSP kvp_map = {} DCNL DCSP for kvp_str in kvp_list: DCNL DCSP  DCSP (key, value) = convert_kvp_str_to_list(kvp_str) DCNL DCSP  DCSP kvp_map.setdefault(key, set()) DCNL DCSP  DCSP kvp_map[key].add(value) DCNL DCSP return dict(((x, list(y)) for (x, y) in kvp_map.iteritems()))
 DCSP res = {} DCNL DCSP for (key, values) in request.GET.dict_of_lists().iteritems(): DCNL DCSP  DCSP if (key in skips): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP values = [v for v in values if v] DCNL DCSP  DCSP key_attr_info = attr_info.get(key, {}) DCNL DCSP  DCSP if ('convert_list_to' in key_attr_info): DCNL DCSP  DCSP  DCSP values = key_attr_info['convert_list_to'](values) DCNL DCSP  DCSP elif ('convert_to' in key_attr_info): DCNL DCSP  DCSP  DCSP convert_to = key_attr_info['convert_to'] DCNL DCSP  DCSP  DCSP values = [convert_to(v) for v in values] DCNL DCSP  DCSP if values: DCNL DCSP  DCSP  DCSP res[key] = values DCNL DCSP return res
 DCSP max_limit = _get_pagination_max_limit() DCNL DCSP limit = _get_limit_param(request, max_limit) DCNL DCSP if (max_limit > 0): DCNL DCSP  DCSP limit = (min(max_limit, limit) or max_limit) DCNL DCSP if (not limit): DCNL DCSP  DCSP return (None, None) DCNL DCSP marker = request.GET.get('marker', None) DCNL DCSP return (limit, marker)
 DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', 0)) DCNL DCSP  DCSP if (limit >= 0): DCNL DCSP  DCSP  DCSP return limit DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP msg = _("Limit DCSP must DCSP be DCSP an DCSP integer DCSP 0 DCSP or DCSP greater DCSP and DCSP not DCSP '%d'") DCNL DCSP raise exceptions.BadRequest(resource='limit', msg=msg)
 DCSP return [v for v in request.GET.getall(arg) if v]
 DCSP sort_keys = list_args(request, 'sort_key') DCNL DCSP sort_dirs = list_args(request, 'sort_dir') DCNL DCSP if (len(sort_keys) != len(sort_dirs)): DCNL DCSP  DCSP msg = _('The DCSP number DCSP of DCSP sort_keys DCSP and DCSP sort_dirs DCSP must DCSP be DCSP same') DCNL DCSP  DCSP raise exc.HTTPBadRequest(explanation=msg) DCNL DCSP valid_dirs = [constants.SORT_DIRECTION_ASC, constants.SORT_DIRECTION_DESC] DCNL DCSP absent_keys = [x for x in sort_keys if (x not in attr_info)] DCNL DCSP if absent_keys: DCNL DCSP  DCSP msg = (_('%s DCSP is DCSP invalid DCSP attribute DCSP for DCSP sort_keys') % absent_keys) DCNL DCSP  DCSP raise exc.HTTPBadRequest(explanation=msg) DCNL DCSP invalid_dirs = [x for x in sort_dirs if (x not in valid_dirs)] DCNL DCSP if invalid_dirs: DCNL DCSP  DCSP msg = (_("%(invalid_dirs)s DCSP is DCSP invalid DCSP value DCSP for DCSP sort_dirs, DCSP valid DCSP value DCSP is DCSP '%(asc)s' DCSP and DCSP '%(desc)s'") % {'invalid_dirs': invalid_dirs, 'asc': constants.SORT_DIRECTION_ASC, 'desc': constants.SORT_DIRECTION_DESC}) DCNL DCSP  DCSP raise exc.HTTPBadRequest(explanation=msg) DCNL DCSP return zip(sort_keys, [(x == constants.SORT_DIRECTION_ASC) for x in sort_dirs])
 DCSP if (not sorts): DCNL DCSP  DCSP return query DCNL DCSP assert (not (limit and (len((set(dict(sorts).keys()) & set(model.__table__.primary_key.columns.keys()))) == 0))) DCNL DCSP for (sort_key, sort_direction) in sorts: DCNL DCSP  DCSP sort_dir_func = (sqlalchemy.asc if sort_direction else sqlalchemy.desc) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP msg = (_('%s DCSP is DCSP invalid DCSP attribute DCSP for DCSP sort_key') % sort_key) DCNL DCSP  DCSP  DCSP raise q_exc.BadRequest(resource=model.__tablename__, msg=msg) DCNL DCSP  DCSP if isinstance(sort_key_attr.property, RelationshipProperty): DCNL DCSP  DCSP  DCSP msg = (_("The DCSP attribute DCSP '%(attr)s' DCSP is DCSP reference DCSP to DCSP other DCSP resource, DCSP can't DCSP used DCSP by DCSP sort DCSP '%(resource)s'") % {'attr': sort_key, 'resource': model.__tablename__}) DCNL DCSP  DCSP  DCSP raise q_exc.BadRequest(resource=model.__tablename__, msg=msg) DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if marker_obj: DCNL DCSP  DCSP marker_values = [getattr(marker_obj, sort[0]) for sort in sorts] DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for (i, sort) in enumerate(sorts): DCNL DCSP  DCSP  DCSP crit_attrs = [(getattr(model, sorts[j][0]) == marker_values[j]) for j in xrange(i)] DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort[0]) DCNL DCSP  DCSP  DCSP if sort[1]: DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if limit: DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP pass
 DCSP pass
 DCSP context.configure(url=quantum_config.DATABASE.sql_connection) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations(active_plugin=quantum_config.core_plugin, options=build_options())
 DCSP engine = create_engine(quantum_config.DATABASE.sql_connection, poolclass=pool.NullPool) DCNL DCSP connection = engine.connect() DCNL DCSP context.configure(connection=connection, target_metadata=target_metadata) DCNL DCSP try: DCNL DCSP  DCSP with context.begin_transaction(): DCNL DCSP  DCSP  DCSP context.run_migrations(active_plugin=quantum_config.core_plugin, options=build_options()) DCNL DCSP finally: DCNL DCSP  DCSP connection.close()
 DCSP results = [] DCNL DCSP svc_def_opt = cfg.CONF.DEFAULT_SERVICETYPE.service_definition DCNL DCSP try: DCNL DCSP  DCSP for svc_def_str in svc_def_opt: DCNL DCSP  DCSP  DCSP split = svc_def_str.split(':') DCNL DCSP  DCSP  DCSP svc_def = {'service_class': split[0], 'plugin': split[1]} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP svc_def['driver'] = split[2] DCNL DCSP  DCSP  DCSP except IndexError: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Default DCSP service DCSP type DCSP - DCSP no DCSP driver DCSP for DCSP service DCSP %(service_class)s DCSP and DCSP plugin DCSP %(plugin)s'), svc_def) DCNL DCSP  DCSP  DCSP results.append(svc_def) DCNL DCSP  DCSP return results DCNL DCSP except (TypeError, IndexError): DCNL DCSP  DCSP raise q_exc.InvalidConfigurationOption(opt_name='service_definition', opt_value=svc_def_opt)
 DCSP global _ENGINE DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP sql_connection = cfg.CONF.DATABASE.sql_connection DCNL DCSP  DCSP if (not sql_connection): DCNL DCSP  DCSP  DCSP LOG.warn(_(("Option DCSP 'sql_connection' DCSP not DCSP specified DCSP in DCSP any DCSP config DCSP file DCSP - DCSP using DCSP default DCSP value DCSP '%s'" % SQL_CONNECTION_DEFAULT))) DCNL DCSP  DCSP  DCSP sql_connection = SQL_CONNECTION_DEFAULT DCNL DCSP  DCSP connection_dict = sql.engine.url.make_url(sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': 3600, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [MySQLPingListener()] DCNL DCSP  DCSP  DCSP if ((MySQLdb is not None) and cfg.CONF.DATABASE.sql_dbpool_enable): DCNL DCSP  DCSP  DCSP  DCSP pool_args = {'db': connection_dict.database, 'passwd': (connection_dict.password or ''), 'host': connection_dict.host, 'user': connection_dict.username, 'min_size': cfg.CONF.DATABASE.sql_min_pool_size, 'max_size': cfg.CONF.DATABASE.sql_max_pool_size, 'max_idle': cfg.CONF.DATABASE.sql_idle_timeout} DCNL DCSP  DCSP  DCSP  DCSP pool = db_pool.ConnectionPool(MySQLdb, **pool_args) DCNL DCSP  DCSP  DCSP  DCSP def creator(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP conn = pool.create() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(conn, tuple): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (_1, _2, conn) = conn DCNL DCSP  DCSP  DCSP  DCSP  DCSP return conn DCNL DCSP  DCSP  DCSP  DCSP engine_args['creator'] = creator DCNL DCSP  DCSP  DCSP if ((MySQLdb is None) and cfg.CONF.DATABASE.sql_dbpool_enable): DCNL DCSP  DCSP  DCSP  DCSP LOG.warn(_('Eventlet DCSP connection DCSP pooling DCSP will DCSP not DCSP work DCSP without DCSP python-mysqldb!')) DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [SqliteForeignKeysListener()] DCNL DCSP  DCSP  DCSP if (sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = create_engine(sql_connection, **engine_args) DCNL DCSP  DCSP sql.event.listen(_ENGINE, 'checkin', greenthread_yield) DCNL DCSP  DCSP if (not register_models()): DCNL DCSP  DCSP  DCSP if cfg.CONF.DATABASE.reconnect_interval: DCNL DCSP  DCSP  DCSP  DCSP remaining = cfg.CONF.DATABASE.sql_max_retries DCNL DCSP  DCSP  DCSP  DCSP reconnect_interval = cfg.CONF.DATABASE.reconnect_interval DCNL DCSP  DCSP  DCSP  DCSP retry_registration(remaining, reconnect_interval)
 DCSP global _MAKER, _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP assert _ENGINE DCNL DCSP  DCSP _MAKER = sessionmaker(bind=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER()
 DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP try: DCNL DCSP  DCSP base.metadata.create_all(_ENGINE) DCNL DCSP except sql.exc.OperationalError as e: DCNL DCSP  DCSP LOG.info(_('Database DCSP registration DCSP exception: DCSP %s'), e) DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP base.metadata.drop_all(_ENGINE)
 DCSP greenthread.sleep(0)
 DCSP maxlen = ServiceRouterBinding.resource_type.property.columns[0].type.length DCNL DCSP if (len(value) > maxlen): DCNL DCSP  DCSP raise AttributeException(resource_type=value, maxlen=maxlen) DCNL DCSP return value
 DCSP data = action.split(':', 1)[0].split('_', 1) DCNL DCSP return (('%ss' % data[(-1)]), (data[0] != 'get'))
 DCSP return (('default' in resource[attribute_name]) and (attribute_name in target) and (target[attribute_name] is not attributes.ATTR_NOT_SPECIFIED) and (target[attribute_name] != resource[attribute_name]['default']))
 DCSP target = original_target.copy() DCNL DCSP (resource, _a) = get_resource_and_action(action) DCNL DCSP hierarchy_info = attributes.RESOURCE_HIERARCHY_MAP.get(resource, None) DCNL DCSP if (hierarchy_info and plugin): DCNL DCSP  DCSP parent_resource = hierarchy_info['parent'][:(-1)] DCNL DCSP  DCSP parent_id = hierarchy_info['identified_by'] DCNL DCSP  DCSP f = getattr(plugin, ('get_%s' % parent_resource)) DCNL DCSP  DCSP data = f(context, target[parent_id], fields=['tenant_id']) DCNL DCSP  DCSP target[('%s_tenant_id' % parent_resource)] = data['tenant_id'] DCNL DCSP return target
 DCSP match_rule = policy.RuleCheck('rule', action) DCNL DCSP (resource, is_write) = get_resource_and_action(action) DCNL DCSP if is_write: DCNL DCSP  DCSP res_map = attributes.RESOURCE_ATTRIBUTE_MAP DCNL DCSP  DCSP if (resource in res_map): DCNL DCSP  DCSP  DCSP for attribute_name in res_map[resource]: DCNL DCSP  DCSP  DCSP  DCSP if _is_attribute_explicitly_set(attribute_name, res_map[resource], target): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attribute = res_map[resource][attribute_name] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (('enforce_policy' in attribute) and is_write): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP attr_rule = policy.RuleCheck('rule', ('%s:%s' % (action, attribute_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP match_rule = policy.AndCheck([match_rule, attr_rule]) DCNL DCSP return match_rule
 DCSP init() DCNL DCSP real_target = _build_target(action, target, plugin, context) DCNL DCSP match_rule = _build_match_rule(action, real_target) DCNL DCSP credentials = context.to_dict() DCNL DCSP return policy.check(match_rule, real_target, credentials)
 DCSP init() DCNL DCSP real_target = _build_target(action, target, plugin, context) DCNL DCSP match_rule = _build_match_rule(action, real_target) DCNL DCSP credentials = context.to_dict() DCNL DCSP return policy.check(match_rule, real_target, credentials, exceptions.PolicyNotAuthorized, action=action)
 DCSP return ('ofc-%s' % id)
 DCSP pipeline = local_conf[cfg.CONF.auth_strategy] DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
 DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP kwargs['group'].thread_done(kwargs['thread'])
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
 DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
 DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
 DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
 DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
 DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
 DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
 DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
 DCSP return _get_impl().create_connection(CONF, new=new)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().cast(CONF, context, topic, msg)
 DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
 DCSP return _get_impl().cleanup()
 DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return (('%s.%s' % (topic, host)) if host else topic)
 DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP return Connection()
 DCSP json.dumps(msg)
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
 DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
 DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
 DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
 DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
 DCSP return _multi_send(_call, *args, **kwargs)
 DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
 DCSP _multi_send(_cast, *args, **kwargs)
 DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
 DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
 DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
 DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
 DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
 DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP global _rules DCNL DCSP _rules = rules
 DCSP global _rules DCNL DCSP _rules = None
 DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
 DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
 DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
 DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
 DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('quantum.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', 0) DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP cmd = (shlex.split(root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(check_exit_code, int) and (not isinstance(check_exit_code, bool)) and (_returncode != check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
 DCSP base_dir = os.path.dirname(os.path.abspath(file_name)) DCNL DCSP tmp_file = tempfile.NamedTemporaryFile('w+', dir=base_dir, delete=False) DCNL DCSP tmp_file.write(data) DCNL DCSP tmp_file.close() DCNL DCSP os.chmod(tmp_file.name, 420) DCNL DCSP os.rename(tmp_file.name, file_name)
 DCSP opts = [cfg.StrOpt('dhcp_driver', default='quantum.agent.linux.dhcp.Dnsmasq', help=_('The DCSP driver DCSP used DCSP to DCSP manage DCSP the DCSP DHCP DCSP server.')), cfg.BoolOpt('force', default=False, help=_('Delete DCSP the DCSP namespace DCSP by DCSP removing DCSP all DCSP devices.'))] DCNL DCSP conf = cfg.CONF DCNL DCSP conf.register_opts(opts) DCNL DCSP agent_config.register_root_helper(conf) DCNL DCSP conf.register_opts(dhcp.OPTS) DCNL DCSP return conf
 DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP network_id = namespace.replace(dhcp_agent.NS_PREFIX, '') DCNL DCSP null_delegate = NullDelegate() DCNL DCSP dhcp_driver = importutils.import_object(conf.dhcp_driver, conf, FakeNetwork(network_id), root_helper, null_delegate) DCNL DCSP if dhcp_driver.active: DCNL DCSP  DCSP dhcp_driver.disable()
 DCSP if (not re.match(NS_MANGLING_PATTERN, namespace)): DCNL DCSP  DCSP return False DCNL DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP ip = ip_lib.IPWrapper(root_helper, namespace) DCNL DCSP return (force or ip.namespace_is_empty())
 DCSP try: DCNL DCSP  DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP  DCSP ip = ip_lib.IPWrapper(root_helper, namespace) DCNL DCSP  DCSP if force: DCNL DCSP  DCSP  DCSP kill_dhcp(conf, namespace) DCNL DCSP  DCSP  DCSP if ip.netns.exists(namespace): DCNL DCSP  DCSP  DCSP  DCSP for device in ip.get_devices(exclude_loopback=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP unplug_device(conf, device) DCNL DCSP  DCSP ip.garbage_collect_namespace() DCNL DCSP except Exception as e: DCNL DCSP  DCSP LOG.exception(_('Error DCSP unable DCSP to DCSP destroy DCSP namespace: DCSP %s'), namespace)
 DCSP eventlet.monkey_patch() DCNL DCSP conf = setup_conf() DCNL DCSP conf() DCNL DCSP config.setup_logging(conf) DCNL DCSP root_helper = agent_config.get_root_helper(conf) DCNL DCSP candidates = [ns for ns in ip_lib.IPWrapper.get_namespaces(root_helper) if eligible_for_deletion(conf, ns, conf.force)] DCNL DCSP if candidates: DCNL DCSP  DCSP eventlet.sleep(2) DCNL DCSP  DCSP for namespace in candidates: DCNL DCSP  DCSP  DCSP destroy_namespace(conf, namespace, conf.force)
 DCSP connection = rpc.create_connection(new=True) DCNL DCSP for (topic, operation) in topic_details: DCNL DCSP  DCSP topic_name = topics.get_topic_name(prefix, topic, operation) DCNL DCSP  DCSP connection.create_consumer(topic_name, dispatcher, fanout=True) DCNL DCSP connection.consume_in_thread() DCNL DCSP return connection
 DCSP opts = [cfg.BoolOpt('ovs_all_ports', default=False, help=_('True DCSP to DCSP delete DCSP all DCSP ports DCSP on DCSP all DCSP the DCSP OpenvSwitch DCSP bridges. DCSP False DCSP to DCSP delete DCSP ports DCSP created DCSP by DCSP Quantum DCSP on DCSP integration DCSP and DCSP external DCSP network DCSP bridges.'))] DCNL DCSP conf = cfg.CONF DCNL DCSP conf.register_cli_opts(opts) DCNL DCSP conf.register_opts(l3_agent.L3NATAgent.OPTS) DCNL DCSP conf.register_opts(interface.OPTS) DCNL DCSP agent_config.register_root_helper(conf) DCNL DCSP return conf
 DCSP ports = [] DCNL DCSP for bridge in bridges: DCNL DCSP  DCSP ovs = ovs_lib.OVSBridge(bridge, root_helper) DCNL DCSP  DCSP ports += [port.port_name for port in ovs.get_vif_ports()] DCNL DCSP return ports
 DCSP for port in ports: DCNL DCSP  DCSP if ip_lib.device_exists(port): DCNL DCSP  DCSP  DCSP device = ip_lib.IPDevice(port, root_helper) DCNL DCSP  DCSP  DCSP device.link.delete() DCNL DCSP  DCSP  DCSP LOG.info(_('Delete DCSP %s'), port)
 DCSP conf = setup_conf() DCNL DCSP conf() DCNL DCSP config.setup_logging(conf) DCNL DCSP configuration_bridges = set([conf.ovs_integration_bridge, conf.external_network_bridge]) DCNL DCSP ovs_bridges = set(ovs_lib.get_bridges(conf.AGENT.root_helper)) DCNL DCSP available_configuration_bridges = (configuration_bridges & ovs_bridges) DCNL DCSP if conf.ovs_all_ports: DCNL DCSP  DCSP bridges = ovs_bridges DCNL DCSP else: DCNL DCSP  DCSP bridges = available_configuration_bridges DCNL DCSP ports = collect_quantum_ports(available_configuration_bridges, conf.AGENT.root_helper) DCNL DCSP for bridge in bridges: DCNL DCSP  DCSP LOG.info(_('Cleaning DCSP %s'), bridge) DCNL DCSP  DCSP ovs = ovs_lib.OVSBridge(bridge, conf.AGENT.root_helper) DCNL DCSP  DCSP ovs.delete_ports(all_ports=conf.ovs_all_ports) DCNL DCSP delete_quantum_ports(ports, conf.AGENT.root_helper) DCNL DCSP LOG.info(_('OVS DCSP cleanup DCSP completed DCSP successfully'))
 DCSP svc_type_id = data DCNL DCSP svctype_mgr = servicetype_db.ServiceTypeManager.get_instance() DCNL DCSP try: DCNL DCSP  DCSP svctype_mgr.get_service_type(context.get_admin_context(), svc_type_id) DCNL DCSP except servicetype_db.ServiceTypeNotFound: DCNL DCSP  DCSP return (_("The DCSP service DCSP type DCSP '%s' DCSP does DCSP not DCSP exist") % svc_type_id)
 DCSP try: DCNL DCSP  DCSP if (len(data) == 0): DCNL DCSP  DCSP  DCSP return _('No DCSP service DCSP type DCSP definition DCSP was DCSP provided. DCSP At DCSP least DCSP a DCSP service DCSP type DCSP definition DCSP must DCSP be DCSP provided') DCNL DCSP  DCSP f_name = _validate_service_defs.__name__ DCNL DCSP  DCSP for svc_def in data: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP svc_def_copy = svc_def.copy() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP svc_name = svc_def_copy.pop(SERVICE_ATTR) DCNL DCSP  DCSP  DCSP  DCSP  DCSP plugin_name = svc_def_copy.pop(PLUGIN_ATTR) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Required DCSP attributes DCSP missing DCSP in DCSP service DCSP definition: DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (svc_name not in constants.ALLOWED_SERVICES): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("Service DCSP name DCSP '%s' DCSP unspecified DCSP or DCSP invalid") % svc_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (not plugin_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Plugin DCSP name DCSP not DCSP specified DCSP in DCSP service DCSP definition DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP svc_plugin = manager.QuantumManager.get_service_plugins().get(svc_name) DCNL DCSP  DCSP  DCSP  DCSP if (not svc_plugin): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("No DCSP plugin DCSP for DCSP service DCSP '%s'") % svc_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP if (svc_plugin.get_plugin_name() != plugin_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("Plugin DCSP name DCSP '%s' DCSP is DCSP not DCSP correct DCSP ") % plugin_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP driver = svc_def_copy.get(DRIVER_ATTR) DCNL DCSP  DCSP  DCSP  DCSP if driver: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = attributes._validate_string(driver) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if msg: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP  DCSP  DCSP del svc_def_copy[DRIVER_ATTR] DCNL DCSP  DCSP  DCSP  DCSP if len(svc_def_copy): DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = (_('Unparseable DCSP attributes DCSP found DCSP in DCSP service DCSP definition DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP LOG.exception(_('Exception DCSP while DCSP parsing DCSP service DCSP definition:%s'), svc_def) DCNL DCSP  DCSP  DCSP  DCSP msg = (_('Was DCSP expecting DCSP a DCSP dict DCSP for DCSP service DCSP definition, DCSP found DCSP the DCSP following: DCSP %s') % svc_def) DCNL DCSP  DCSP  DCSP  DCSP LOG.error(_('%(f_name)s: DCSP %(msg)s'), locals()) DCNL DCSP  DCSP  DCSP  DCSP return msg DCNL DCSP except TypeError: DCNL DCSP  DCSP return (_('%s: DCSP provided DCSP data DCSP are DCSP not DCSP iterable') % _validate_service_defs.__name__)
 DCSP return (((PREFIX + str(sg_id)) + '_') + sg_name)
 DCSP prefix = sg_label(sg_id, sg_name) DCNL DCSP in_chain_name = (prefix + SUFFIX_IN) DCNL DCSP out_chain_name = (prefix + SUFFIX_OUT) DCNL DCSP return {'in': in_chain_name, 'out': out_chain_name}
 DCSP results = [] DCNL DCSP for parsed_file in cfg.CONF._cparser.parsed: DCNL DCSP  DCSP for parsed_item in parsed_file.keys(): DCNL DCSP  DCSP  DCSP if (parsed_item not in cfg.CONF): DCNL DCSP  DCSP  DCSP  DCSP items = (key and parsed_item.split(delimiter)) DCNL DCSP  DCSP  DCSP  DCSP if ((not key) or (key == items[0])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.append(parsed_item) DCNL DCSP return results
 DCSP cluster_names = [] DCNL DCSP cluster_tags = _retrieve_extra_groups(conf, 'CLUSTER') DCNL DCSP for tag in cluster_tags: DCNL DCSP  DCSP cluster_name = tag.split(':')[1] DCNL DCSP  DCSP conf.register_opts(cluster_opts, tag, cluster_name) DCNL DCSP  DCSP cluster_names.append(cluster_name) DCNL DCSP return cluster_names
 DCSP if cfg.CONF.metadata_dhcp_host_route: DCNL DCSP  DCSP LOG.warning(_('The DCSP metadata_dhcp_host_route DCSP is DCSP now DCSP obsolete, DCSP and DCSP will DCSP have DCSP no DCSP effect. DCSP Instead, DCSP please DCSP set DCSP the DCSP enable_isolated_metadata DCSP option DCSP in DCSP dhcp_agent.ini')) DCNL DCSP nvp_conf = config.ClusterConfigOptions(cfg.CONF) DCNL DCSP cluster_names = config.register_cluster_groups(nvp_conf) DCNL DCSP nvp_conf.log_opt_values(LOG, logging.DEBUG) DCNL DCSP clusters_options = [] DCNL DCSP for cluster_name in cluster_names: DCNL DCSP  DCSP clusters_options.append({'name': cluster_name, 'default_tz_uuid': nvp_conf[cluster_name].default_tz_uuid, 'nvp_cluster_uuid': nvp_conf[cluster_name].nvp_cluster_uuid, 'nova_zone_id': nvp_conf[cluster_name].nova_zone_id, 'nvp_controller_connection': nvp_conf[cluster_name].nvp_controller_connection, 'default_l3_gw_service_uuid': nvp_conf[cluster_name].default_l3_gw_service_uuid, 'default_l2_gw_service_uuid': nvp_conf[cluster_name].default_l2_gw_service_uuid, 'default_interface_name': nvp_conf[cluster_name].default_interface_name}) DCNL DCSP LOG.debug(_('Cluster DCSP options:%s'), clusters_options) DCNL DCSP if (not cfg.CONF.api_extensions_path): DCNL DCSP  DCSP cfg.CONF.set_override('api_extensions_path', 'quantum/plugins/nicira/nicira_nvp_plugin/extensions') DCNL DCSP if (cfg.CONF.NVP.enable_metadata_access_network and (not cfg.CONF.allow_overlapping_ips)): DCNL DCSP  DCSP LOG.warn(_('Overlapping DCSP IPs DCSP must DCSP be DCSP enabled DCSP in DCSP order DCSP to DCSP setup DCSP the DCSP metadata DCSP access DCSP network. DCSP Metadata DCSP access DCSP in DCSP routed DCSP mode DCSP will DCSP not DCSP work DCSP with DCSP this DCSP configuration')) DCNL DCSP return (cfg.CONF.NVP, clusters_options)
 DCSP if (not data): DCNL DCSP  DCSP msg = _('Cannot DCSP create DCSP a DCSP gateway DCSP with DCSP an DCSP empty DCSP device DCSP list') DCNL DCSP  DCSP return msg DCNL DCSP try: DCNL DCSP  DCSP for device in data: DCNL DCSP  DCSP  DCSP err_msg = attributes._validate_dict(device, key_specs={DEVICE_ID_ATTR: {'type:regex': attributes.UUID_PATTERN, 'required': True}, IFACE_NAME_ATTR: {'type:string': None, 'required': False}}) DCNL DCSP  DCSP  DCSP if err_msg: DCNL DCSP  DCSP  DCSP  DCSP return err_msg DCNL DCSP except TypeError: DCNL DCSP  DCSP return (_('%s: DCSP provided DCSP data DCSP are DCSP not DCSP iterable') % _validate_device_list.__name__)
 DCSP uri = '/ws.v1/control-cluster/node?_page_length=1&fields=uuid' DCNL DCSP try: DCNL DCSP  DCSP res = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP  DCSP res = json.loads(res) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (res['result_count'] == 0): DCNL DCSP  DCSP return None DCNL DCSP node_uuid = res['results'][0]['uuid'] DCNL DCSP uri = ('/ws.v1/control-cluster/node/%s/status' % node_uuid) DCNL DCSP try: DCNL DCSP  DCSP res = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP  DCSP res = json.loads(res) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP version_parts = res['version'].split('.') DCNL DCSP version = ('%s.%s' % tuple(version_parts[:2])) DCNL DCSP LOG.info(_('NVP DCSP controller DCSP cluster DCSP version: DCSP %s'), version) DCNL DCSP return version
 DCSP cluster = kwargs['cluster'] DCNL DCSP try: DCNL DCSP  DCSP req = cluster.api_client.request(*args) DCNL DCSP except NvpApiClient.ResourceNotFound: DCNL DCSP  DCSP raise exception.NotFound() DCNL DCSP return req
 DCSP results = [] DCNL DCSP clusters = kwargs['clusters'] DCNL DCSP for x in clusters: DCNL DCSP  DCSP LOG.debug(_('Issuing DCSP request DCSP to DCSP cluster: DCSP %s'), x.name) DCNL DCSP  DCSP rv = x.api_client.request(*args) DCNL DCSP  DCSP results.append(rv) DCNL DCSP return results
 DCSP for c in clusters: DCNL DCSP  DCSP query = ('/ws.v1/lswitch/*/lport?uuid=%s&fields=*' % port_id) DCNL DCSP  DCSP LOG.debug(_("Looking DCSP for DCSP lswitch DCSP with DCSP port DCSP id DCSP '%(port_id)s' DCSP on: DCSP %(c)s"), locals()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res = do_single_request(HTTP_GET, query, cluster=c) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.error(_('get_port_cluster_and_url, DCSP exception: DCSP %s'), str(e)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP res = json.loads(res) DCNL DCSP  DCSP if (len(res['results']) == 1): DCNL DCSP  DCSP  DCSP return (res['results'][0], c) DCNL DCSP return (None, None)
 DCSP tags = [{'tag': tenant_id, 'scope': 'os_tid'}] DCNL DCSP gateways = [{'transport_node_uuid': device['id'], 'device_id': device['interface_name'], 'type': 'L2Gateway'} for device in devices] DCNL DCSP gwservice_obj = {'display_name': _check_and_truncate_name(display_name), 'tags': tags, 'gateways': gateways, 'type': 'L2GatewayServiceConfig'} DCNL DCSP try: DCNL DCSP  DCSP return json.loads(do_single_request('POST', _build_uri_path(GWSERVICE_RESOURCE), json.dumps(gwservice_obj), cluster=cluster)) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occured DCSP while DCSP communicating DCSP with DCSP the DCSP NVP DCSP controller DCSP for DCSP cluster:%s'), cluster.name) DCNL DCSP  DCSP raise
 DCSP tags = [{'tag': tenant_id, 'scope': 'os_tid'}] DCNL DCSP display_name = _check_and_truncate_name(display_name) DCNL DCSP lrouter_obj = {'display_name': display_name, 'tags': tags, 'routing_config': {'default_route_next_hop': {'gateway_ip_address': nexthop, 'type': 'RouterNextHop'}, 'type': 'SingleDefaultRouteImplicitRoutingConfig'}, 'type': 'LogicalRouterConfig'} DCNL DCSP try: DCNL DCSP  DCSP return json.loads(do_single_request(HTTP_POST, _build_uri_path(LROUTER_RESOURCE), json.dumps(lrouter_obj), cluster=cluster)) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occured DCSP while DCSP communicating DCSP with DCSP the DCSP NVP DCSP controller DCSP for DCSP cluster:%s'), cluster.name) DCNL DCSP  DCSP raise
 DCSP uri = ('/ws.v1/lswitch?fields=*&tag=%s&tag_scope=os_tid' % tenant_id) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP except NvpApiClient.NvpApiException: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (not resp_obj): DCNL DCSP  DCSP return [] DCNL DCSP networks_result = copy(networks) DCNL DCSP return networks_result
 DCSP query = ('/ws.v1/lswitch/%s/lport?display_name=%s&fields=*' % (lswitch, display_name)) DCNL DCSP LOG.debug(_("Looking DCSP for DCSP port DCSP with DCSP display_name DCSP '%(display_name)s' DCSP on: DCSP %(lswitch)s"), locals()) DCNL DCSP for c in clusters: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP res_obj = do_single_request(HTTP_GET, query, cluster=c) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP res = json.loads(res_obj) DCNL DCSP  DCSP if (len(res['results']) == 1): DCNL DCSP  DCSP  DCSP return (res['results'][0], c) DCNL DCSP LOG.error(_('Port DCSP or DCSP Network DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP raise exception.PortNotFound(port_id=display_name, net_id=lswitch)
 DCSP uri = _build_uri_path(LSWITCHPORT_RESOURCE, parent_resource_id=lswitch_uuid, fields='uuid', filters={'tag': quantum_port_id, 'tag_scope': 'q_port_id'}) DCNL DCSP LOG.debug((_("Looking DCSP for DCSP port DCSP with DCSP q_port_id DCSP tag DCSP '%(quantum_port_id)s' DCSP on: DCSP '%(lswitch_uuid)s'") % {'quantum_port_id': quantum_port_id, 'lswitch_uuid': lswitch_uuid})) DCNL DCSP try: DCNL DCSP  DCSP res_obj = do_single_request(HTTP_GET, uri, cluster=cluster) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_('An DCSP exception DCSP occurred DCSP while DCSP querying DCSP NVP DCSP ports')) DCNL DCSP  DCSP raise DCNL DCSP res = json.loads(res_obj) DCNL DCSP num_results = len(res['results']) DCNL DCSP if (num_results >= 1): DCNL DCSP  DCSP if (num_results > 1): DCNL DCSP  DCSP  DCSP LOG.warn((_("Found DCSP '%(num_ports)d' DCSP ports DCSP with DCSP q_port_id DCSP tag: DCSP '%(quantum_port_id)s'. DCSP Only DCSP 1 DCSP was DCSP expected.") % {'num_ports': num_results, 'quantum_port_id': quantum_port_id})) DCNL DCSP  DCSP return res['results'][0]
 DCSP hashed_device_id = hashlib.sha1(device_id).hexdigest() DCNL DCSP display_name = _check_and_truncate_name(display_name) DCNL DCSP lport_obj = dict(admin_status_enabled=admin_status_enabled, display_name=display_name, tags=[dict(scope='os_tid', tag=tenant_id), dict(scope='q_port_id', tag=quantum_port_id), dict(scope='vm_id', tag=hashed_device_id)]) DCNL DCSP _configure_extensions(lport_obj, mac_address, fixed_ips, port_security_enabled, security_profiles, queue_id) DCNL DCSP path = _build_uri_path(LSWITCHPORT_RESOURCE, parent_resource_id=lswitch_uuid) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_POST, path, json.dumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP switch DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP LOG.debug(_('Created DCSP logical DCSP port DCSP %(result)s DCSP on DCSP logical DCSP swtich DCSP %(uuid)s'), {'result': result['uuid'], 'uuid': lswitch_uuid}) DCNL DCSP return result
 DCSP tags = [dict(scope='os_tid', tag=tenant_id), dict(scope='q_port_id', tag=quantum_port_id)] DCNL DCSP lport_obj = dict(admin_status_enabled=admin_status_enabled, display_name=display_name, tags=tags, ip_addresses=ip_addresses, type='LogicalRouterPortConfig') DCNL DCSP path = _build_uri_path(LROUTERPORT_RESOURCE, parent_resource_id=lrouter_uuid) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_POST, path, json.dumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP LOG.debug(_('Created DCSP logical DCSP port DCSP %(lport_uuid)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuid)s'), {'lport_uuid': result['uuid'], 'lrouter_uuid': lrouter_uuid}) DCNL DCSP return result
 DCSP lport_obj = dict(admin_status_enabled=admin_status_enabled, display_name=display_name, tags=[dict(scope='os_tid', tag=tenant_id), dict(scope='q_port_id', tag=quantum_port_id)], ip_addresses=ip_addresses, type='LogicalRouterPortConfig') DCNL DCSP for key in lport_obj.keys(): DCNL DCSP  DCSP if (lport_obj[key] is None): DCNL DCSP  DCSP  DCSP del lport_obj[key] DCNL DCSP path = _build_uri_path(LROUTERPORT_RESOURCE, lrouter_port_uuid, parent_resource_id=lrouter_uuid) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_PUT, path, json.dumps(lport_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP or DCSP router DCSP port DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP LOG.debug(_('Updated DCSP logical DCSP port DCSP %(lport_uuid)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuid)s'), {'lport_uuid': lrouter_port_uuid, 'lrouter_uuid': lrouter_uuid}) DCNL DCSP return result
 DCSP path = _build_uri_path(LROUTERPORT_RESOURCE, lport_uuid, lrouter_uuid) DCNL DCSP try: DCNL DCSP  DCSP do_single_request(HTTP_DELETE, path, cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Logical DCSP router DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP LOG.debug(_('Delete DCSP logical DCSP router DCSP port DCSP %(lport_uuid)s DCSP on DCSP logical DCSP router DCSP %(lrouter_uuid)s'), {'lport_uuid': lport_uuid, 'lrouter_uuid': lrouter_uuid})
 DCSP results = query_lrouter_lports(cluster, router_id, relations='LogicalPortAttachment') DCNL DCSP for lport in results: DCNL DCSP  DCSP if ('_relations' in lport): DCNL DCSP  DCSP  DCSP attachment = lport['_relations'].get('LogicalPortAttachment') DCNL DCSP  DCSP  DCSP if (attachment and (attachment.get('type') == 'L3GatewayAttachment')): DCNL DCSP  DCSP  DCSP  DCSP return lport
 DCSP uri = _build_uri_path(LROUTERPORT_RESOURCE, port_id, router_id, is_attachment=True) DCNL DCSP attach_obj = {} DCNL DCSP attach_obj['type'] = nvp_attachment_type DCNL DCSP if (nvp_attachment_type == 'PatchAttachment'): DCNL DCSP  DCSP attach_obj['peer_port_uuid'] = attachment_uuid DCNL DCSP elif (nvp_attachment_type == 'L3GatewayAttachment'): DCNL DCSP  DCSP attach_obj['l3_gateway_service_uuid'] = attachment_uuid DCNL DCSP  DCSP if attachment_vlan: DCNL DCSP  DCSP  DCSP attach_obj['vlan_id'] = attachment_vlan DCNL DCSP else: DCNL DCSP  DCSP raise Exception(_("Invalid DCSP NVP DCSP attachment DCSP type DCSP '%s'"), nvp_attachment_type) DCNL DCSP try: DCNL DCSP  DCSP resp_obj = do_single_request(HTTP_PUT, uri, json.dumps(attach_obj), cluster=cluster) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.exception(_('Router DCSP Port DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise DCNL DCSP except NvpApiClient.Conflict as e: DCNL DCSP  DCSP LOG.exception(_('Conflict DCSP while DCSP setting DCSP router DCSP port DCSP attachment')) DCNL DCSP  DCSP raise DCNL DCSP except NvpApiClient.NvpApiException as e: DCNL DCSP  DCSP LOG.exception(_('Unable DCSP to DCSP plug DCSP attachment DCSP into DCSP logical DCSP router DCSP port')) DCNL DCSP  DCSP raise DCNL DCSP result = json.loads(resp_obj) DCNL DCSP return result
 DCSP try: DCNL DCSP  DCSP r = do_single_request(HTTP_GET, ('/ws.v1/lswitch/%s/lport/%s/status' % (lswitch_id, port_id)), cluster=cluster) DCNL DCSP  DCSP r = json.loads(r) DCNL DCSP except NvpApiClient.ResourceNotFound as e: DCNL DCSP  DCSP LOG.error(_('Port DCSP not DCSP found, DCSP Error: DCSP %s'), str(e)) DCNL DCSP  DCSP raise exception.PortNotFound(port_id=port_id, net_id=lswitch_id) DCNL DCSP except NvpApiClient.NvpApiException as e: DCNL DCSP  DCSP raise exception.QuantumException() DCNL DCSP if (r['link_status_up'] is True): DCNL DCSP  DCSP return constants.PORT_STATUS_ACTIVE DCNL DCSP else: DCNL DCSP  DCSP return constants.PORT_STATUS_DOWN
 DCSP att_obj = {'type': 'L2GatewayAttachment', 'l2_gateway_service_uuid': gateway_id} DCNL DCSP if vlan_id: DCNL DCSP  DCSP att_obj['vlan_id'] = vlan_id DCNL DCSP return _plug_interface(cluster, lswitch_id, lport_id, att_obj)
 DCSP lport_obj = {} DCNL DCSP if attachment: DCNL DCSP  DCSP lport_obj['vif_uuid'] = attachment DCNL DCSP lport_obj['type'] = type DCNL DCSP return _plug_interface(cluster, lswitch_id, port, lport_obj)
 DCSP msg = [('Error. DCSP %s DCSP exception: DCSP %s.' % (etype, e))] DCNL DCSP if request: DCNL DCSP  DCSP msg.append(('request=[%s]' % request)) DCNL DCSP  DCSP if request.body: DCNL DCSP  DCSP  DCSP msg.append(('request.body=[%s]' % str(request.body))) DCNL DCSP l = dict(((k, v) for (k, v) in execption_locals if (k != 'request'))) DCNL DCSP msg.append(('locals=[%s]' % str(l))) DCNL DCSP return ' DCSP '.join(msg)
 DCSP res = do_single_request(*args, **kwargs) DCNL DCSP if res: DCNL DCSP  DCSP return json.loads(res) DCNL DCSP return res
 DCSP return json.dumps(kwargs, ensure_ascii=False)
 DCSP new_taglist = [] DCNL DCSP if taglist: DCNL DCSP  DCSP new_taglist = [x for x in taglist if (x['scope'] != TENANT_ID_SCOPE)] DCNL DCSP new_taglist.append(dict(scope=TENANT_ID_SCOPE, tag=tenant_id)) DCNL DCSP return new_taglist
 DCSP try: DCNL DCSP  DCSP resp = do_single_request(HTTP_GET, '/ws.v1/control-cluster', cluster=cluster) DCNL DCSP except Exception as e: DCNL DCSP  DCSP msg = ('Failed DCSP to DCSP connect DCSP to DCSP cluster DCSP %s: DCSP %s' % (cluster, str(e))) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP return json.loads(resp)
 DCSP session = db.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocations = dict() DCNL DCSP  DCSP states = session.query(l2network_models_v2.NetworkState).all() DCNL DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP if (state.physical_network not in allocations): DCNL DCSP  DCSP  DCSP  DCSP allocations[state.physical_network] = set() DCNL DCSP  DCSP  DCSP allocations[state.physical_network].add(state) DCNL DCSP  DCSP for (physical_network, vlan_ranges) in network_vlan_ranges.iteritems(): DCNL DCSP  DCSP  DCSP vlan_ids = set() DCNL DCSP  DCSP  DCSP for vlan_range in vlan_ranges: DCNL DCSP  DCSP  DCSP  DCSP vlan_ids |= set(xrange(vlan_range[0], (vlan_range[1] + 1))) DCNL DCSP  DCSP  DCSP if (physical_network in allocations): DCNL DCSP  DCSP  DCSP  DCSP for state in allocations[physical_network]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlan_ids.remove(state.vlan_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not state.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': state.vlan_id, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.delete(state) DCNL DCSP  DCSP  DCSP  DCSP del allocations[physical_network] DCNL DCSP  DCSP  DCSP for vlan_id in sorted(vlan_ids): DCNL DCSP  DCSP  DCSP  DCSP state = l2network_models_v2.NetworkState(physical_network, vlan_id) DCNL DCSP  DCSP  DCSP  DCSP session.add(state) DCNL DCSP  DCSP for states in allocations.itervalues(): DCNL DCSP  DCSP  DCSP for state in states: DCNL DCSP  DCSP  DCSP  DCSP if (not state.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': state.vlan_id, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.delete(state)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP state = session.query(l2network_models_v2.NetworkState).filter_by(physical_network=physical_network, vlan_id=vlan_id).one() DCNL DCSP  DCSP return state DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return None
 DCSP LOG.debug(_('get_port_from_device() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP sg_binding_port = sg_db.SecurityGroupPortBinding.port_id DCNL DCSP query = session.query(models_v2.Port, sg_db.SecurityGroupPortBinding.security_group_id) DCNL DCSP query = query.outerjoin(sg_db.SecurityGroupPortBinding, (models_v2.Port.id == sg_binding_port)) DCNL DCSP query = query.filter(models_v2.Port.id.startswith(device)) DCNL DCSP port_and_sgs = query.all() DCNL DCSP if (not port_and_sgs): DCNL DCSP  DCSP return DCNL DCSP port = port_and_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_dict = plugin._make_port_dict(port) DCNL DCSP port_dict['security_groups'] = [] DCNL DCSP for (port_in_db, sg_id) in port_and_sgs: DCNL DCSP  DCSP if sg_id: DCNL DCSP  DCSP  DCSP port_dict['security_groups'].append(sg_id) DCNL DCSP port_dict['security_group_rules'] = [] DCNL DCSP port_dict['security_group_source_groups'] = [] DCNL DCSP port_dict['fixed_ips'] = [ip['ip_address'] for ip in port['fixed_ips']] DCNL DCSP return port_dict
 DCSP LOG.debug(_('set_port_status DCSP as DCSP %s DCSP called'), status) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP port = session.query(models_v2.Port).filter_by(id=port_id).one() DCNL DCSP  DCSP port['status'] = status DCNL DCSP  DCSP session.merge(port) DCNL DCSP  DCSP session.flush() DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.PortNotFound(port_id=port_id)
 DCSP LOG.debug(_('get_port_with_securitygroups() DCSP called:port_id=%s'), port_id) DCNL DCSP session = db.get_session() DCNL DCSP sg_binding_port = sg_db.SecurityGroupPortBinding.port_id DCNL DCSP query = session.query(models_v2.Port, sg_db.SecurityGroupPortBinding.security_group_id) DCNL DCSP query = query.outerjoin(sg_db.SecurityGroupPortBinding, (models_v2.Port.id == sg_binding_port)) DCNL DCSP query = query.filter((models_v2.Port.id == port_id)) DCNL DCSP port_and_sgs = query.all() DCNL DCSP if (not port_and_sgs): DCNL DCSP  DCSP return None DCNL DCSP port = port_and_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_dict = plugin._make_port_dict(port) DCNL DCSP port_dict[ext_sg.SECURITYGROUPS] = [sg_id for (port, sg_id) in port_and_sgs if sg_id] DCNL DCSP port_dict['security_group_rules'] = [] DCNL DCSP port_dict['security_group_source_groups'] = [] DCNL DCSP port_dict['fixed_ips'] = [ip['ip_address'] for ip in port['fixed_ips']] DCNL DCSP return port_dict
 DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP (addr, _port) = csock.getsockname() DCNL DCSP csock.close() DCNL DCSP return addr
 DCSP session = db.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocations = dict() DCNL DCSP  DCSP allocs = session.query(ovs_models_v2.VlanAllocation).all() DCNL DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP if (alloc.physical_network not in allocations): DCNL DCSP  DCSP  DCSP  DCSP allocations[alloc.physical_network] = set() DCNL DCSP  DCSP  DCSP allocations[alloc.physical_network].add(alloc) DCNL DCSP  DCSP for (physical_network, vlan_ranges) in network_vlan_ranges.iteritems(): DCNL DCSP  DCSP  DCSP vlan_ids = set() DCNL DCSP  DCSP  DCSP for vlan_range in vlan_ranges: DCNL DCSP  DCSP  DCSP  DCSP vlan_ids |= set(xrange(vlan_range[0], (vlan_range[1] + 1))) DCNL DCSP  DCSP  DCSP if (physical_network in allocations): DCNL DCSP  DCSP  DCSP  DCSP for alloc in allocations[physical_network]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP vlan_ids.remove(alloc.vlan_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not alloc.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': alloc.vlan_id, 'physical_network': physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.delete(alloc) DCNL DCSP  DCSP  DCSP  DCSP del allocations[physical_network] DCNL DCSP  DCSP  DCSP for vlan_id in sorted(vlan_ids): DCNL DCSP  DCSP  DCSP  DCSP alloc = ovs_models_v2.VlanAllocation(physical_network, vlan_id) DCNL DCSP  DCSP  DCSP  DCSP session.add(alloc) DCNL DCSP  DCSP for allocs in allocations.itervalues(): DCNL DCSP  DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP  DCSP if (not alloc.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP vlan DCSP %(vlan_id)s DCSP on DCSP physical DCSP network DCSP %(physical_network)s DCSP from DCSP pool'), {'vlan_id': alloc.vlan_id, 'physical_network': alloc.physical_network}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.delete(alloc)
 DCSP tunnel_ids = set() DCNL DCSP for tunnel_id_range in tunnel_id_ranges: DCNL DCSP  DCSP (tun_min, tun_max) = tunnel_id_range DCNL DCSP  DCSP if (((tun_max + 1) - tun_min) > 1000000): DCNL DCSP  DCSP  DCSP LOG.error(_('Skipping DCSP unreasonable DCSP tunnel DCSP ID DCSP range DCSP %(tun_min)s:%(tun_max)s'), locals()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tunnel_ids |= set(xrange(tun_min, (tun_max + 1))) DCNL DCSP session = db.get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP allocs = session.query(ovs_models_v2.TunnelAllocation).all() DCNL DCSP  DCSP for alloc in allocs: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP tunnel_ids.remove(alloc.tunnel_id) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP if (not alloc.allocated): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Removing DCSP tunnel DCSP %s DCSP from DCSP pool'), alloc.tunnel_id) DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.delete(alloc) DCNL DCSP  DCSP for tunnel_id in sorted(tunnel_ids): DCNL DCSP  DCSP  DCSP alloc = ovs_models_v2.TunnelAllocation(tunnel_id) DCNL DCSP  DCSP  DCSP session.add(alloc)
 DCSP LOG.debug(_('get_port_with_securitygroups() DCSP called:port_id=%s'), port_id) DCNL DCSP session = db.get_session() DCNL DCSP sg_binding_port = sg_db.SecurityGroupPortBinding.port_id DCNL DCSP query = session.query(models_v2.Port, sg_db.SecurityGroupPortBinding.security_group_id) DCNL DCSP query = query.outerjoin(sg_db.SecurityGroupPortBinding, (models_v2.Port.id == sg_binding_port)) DCNL DCSP query = query.filter((models_v2.Port.id == port_id)) DCNL DCSP port_and_sgs = query.all() DCNL DCSP if (not port_and_sgs): DCNL DCSP  DCSP return None DCNL DCSP port = port_and_sgs[0][0] DCNL DCSP plugin = manager.QuantumManager.get_plugin() DCNL DCSP port_dict = plugin._make_port_dict(port) DCNL DCSP port_dict[ext_sg.SECURITYGROUPS] = [sg_id for (port, sg_id) in port_and_sgs if sg_id] DCNL DCSP port_dict['security_group_rules'] = [] DCNL DCSP port_dict['security_group_source_groups'] = [] DCNL DCSP port_dict['fixed_ips'] = [ip['ip_address'] for ip in port['fixed_ips']] DCNL DCSP return port_dict
 DCSP try: DCNL DCSP  DCSP bridge_mappings = q_utils.parse_mappings(config.OVS.bridge_mappings) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP raise ValueError((_('Parsing DCSP bridge_mappings DCSP failed: DCSP %s.') % e)) DCNL DCSP kwargs = dict(integ_br=config.OVS.integration_bridge, tun_br=config.OVS.tunnel_bridge, local_ip=config.OVS.local_ip, bridge_mappings=bridge_mappings, root_helper=config.AGENT.root_helper, polling_interval=config.AGENT.polling_interval, enable_tunneling=config.OVS.enable_tunneling) DCNL DCSP if (kwargs['enable_tunneling'] and (not kwargs['local_ip'])): DCNL DCSP  DCSP msg = _('Tunnelling DCSP cannot DCSP be DCSP enabled DCSP without DCSP a DCSP valid DCSP local_ip.') DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP return kwargs
 DCSP data = [] DCNL DCSP data.extend(_build_global(logical_config, socket_path=socket_path)) DCNL DCSP data.extend(_build_defaults(logical_config)) DCNL DCSP data.extend(_build_frontend(logical_config)) DCNL DCSP data.extend(_build_backend(logical_config)) DCNL DCSP utils.replace_file(conf_path, '\n'.join(data))
 DCSP for monitor in config['healthmonitors']: DCNL DCSP  DCSP if ((monitor['status'] == ACTIVE) and monitor['admin_state_up']): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return ('', []) DCNL DCSP server_addon = (' DCSP check DCSP inter DCSP %(delay)ds DCSP fall DCSP %(max_retries)d' % monitor) DCNL DCSP opts = [('timeout DCSP check DCSP %ds' % monitor['timeout'])] DCNL DCSP if (monitor['type'] in (constants.HEALTH_MONITOR_HTTP, constants.HEALTH_MONITOR_HTTPS)): DCNL DCSP  DCSP opts.append(('option DCSP httpchk DCSP %(http_method)s DCSP %(url_path)s' % monitor)) DCNL DCSP  DCSP opts.append(('http-check DCSP expect DCSP rstatus DCSP %s' % '|'.join(_expand_expected_codes(monitor['expected_codes'])))) DCNL DCSP if (monitor['type'] == constants.HEALTH_MONITOR_HTTPS): DCNL DCSP  DCSP opts.append('option DCSP ssl-hello-chk') DCNL DCSP return (server_addon, opts)
 DCSP retval = set() DCNL DCSP for code in codes.replace(',', ' DCSP ').split(' DCSP '): DCNL DCSP  DCSP code = code.strip() DCNL DCSP  DCSP if (not code): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ('-' in code): DCNL DCSP  DCSP  DCSP (low, hi) = code.split('-')[:2] DCNL DCSP  DCSP  DCSP retval.update((str(i) for i in xrange(int(low), (int(hi) + 1)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP retval.add(code) DCNL DCSP return retval
 DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP net = BrocadeNetwork(id=net_id, vlan=vlan) DCNL DCSP  DCSP session.add(net) DCNL DCSP return net
 DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP net = session.query(BrocadeNetwork).filter_by(id=net_id).first() DCNL DCSP  DCSP if (net is not None): DCNL DCSP  DCSP  DCSP session.delete(net)
 DCSP session = context.session DCNL DCSP return session.query(BrocadeNetwork).filter_by(id=net_id).first()
 DCSP session = context.session DCNL DCSP try: DCNL DCSP  DCSP nets = session.query(BrocadeNetwork).all() DCNL DCSP  DCSP return nets DCNL DCSP except sa.exc.SQLAlchemyError: DCNL DCSP  DCSP return None
 DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP port = BrocadePort(port_id=port_id, network_id=network_id, physical_interface=physical_interface, vlan_id=vlan_id, admin_state_up=admin_state_up, tenant_id=tenant_id) DCNL DCSP  DCSP session.add(port) DCNL DCSP return port
 DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP port = session.query(BrocadePort).filter_by(port_id=port_id).first() DCNL DCSP return port
 DCSP session = context.session DCNL DCSP ports = session.query(BrocadePort).filter_by(network_id=network_id).all() DCNL DCSP return ports
 DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP port = session.query(BrocadePort).filter_by(port_id=port_id).first() DCNL DCSP  DCSP if (port is not None): DCNL DCSP  DCSP  DCSP session.delete(port)
 DCSP port = session.query(BrocadePort).filter_by(port_id=port_id).first() DCNL DCSP return port
 DCSP port_id = port_id[0:11] DCNL DCSP session = context.session DCNL DCSP session.query(BrocadePort).filter_by(port_id=port_id).update({'admin_state_up': admin_state_up})
 DCSP return True
 DCSP return hashlib.md5(uuid).hexdigest()[:16]
 DCSP res = {const.NET_ID: net_id, const.NET_NAME: net_name} DCNL DCSP res[const.NET_PORTS] = ports DCNL DCSP return res
 DCSP res = {const.PORT_ID: port_id, const.PORT_STATE: port_state} DCNL DCSP res[const.NET_ID] = net_id DCNL DCSP res[const.ATTACHMENT] = attachment DCNL DCSP return res
 DCSP LOG.debug(_('create_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).one() DCNL DCSP except exc.MultipleResultsFound: DCNL DCSP  DCSP pass DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP start = int(conf.VLAN_START) DCNL DCSP  DCSP end = int(conf.VLAN_END) DCNL DCSP  DCSP while (start <= end): DCNL DCSP  DCSP  DCSP vlanid = network_models_v2.VlanID(start) DCNL DCSP  DCSP  DCSP session.add(vlanid) DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP  DCSP session.flush() DCNL DCSP return
 DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(network_models_v2.VlanID).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('is_vlanid_used() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id)
 DCSP LOG.debug(_('release_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP vlanid['vlan_used'] = False DCNL DCSP  DCSP session.merge(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id) DCNL DCSP return
 DCSP LOG.debug(_('delete_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP session.delete(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP LOG.debug(_('reserve_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP rvlan = session.query(network_models_v2.VlanID).filter_by(vlan_used=False).first() DCNL DCSP  DCSP if (not rvlan): DCNL DCSP  DCSP  DCSP raise exc.NoResultFound DCNL DCSP  DCSP rvlanid = session.query(network_models_v2.VlanID).filter_by(vlan_id=rvlan['vlan_id']).one() DCNL DCSP  DCSP rvlanid['vlan_used'] = True DCNL DCSP  DCSP session.merge(rvlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return rvlan['vlan_id'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotAvailable()
 DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(network_models_v2.VlanID).filter_by(vlan_used=True).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_all_vlan_bindings() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP bindings = session.query(network_models_v2.Vlan_Binding).all() DCNL DCSP  DCSP return bindings DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(network_id=netid).one() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
 DCSP LOG.debug(_('add_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(vlan_id=vlanid).one() DCNL DCSP  DCSP raise c_exc.NetworkVlanBindingAlreadyExists(vlan_id=vlanid, network_id=netid) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP binding = network_models_v2.Vlan_Binding(vlanid, vlanname, netid) DCNL DCSP  DCSP session.add(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding
 DCSP LOG.debug(_('remove_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(network_id=netid).one() DCNL DCSP  DCSP session.delete(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP LOG.debug(_('update_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(network_models_v2.Vlan_Binding).filter_by(network_id=netid).one() DCNL DCSP  DCSP if newvlanid: DCNL DCSP  DCSP  DCSP binding['vlan_id'] = newvlanid DCNL DCSP  DCSP if newvlanname: DCNL DCSP  DCSP  DCSP binding['vlan_name'] = newvlanname DCNL DCSP  DCSP session.merge(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
 DCSP LOG.debug(_('get_all_qoss() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qoss = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return qoss DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
 DCSP LOG.debug(_('add_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_name=qos_name).one() DCNL DCSP  DCSP raise c_exc.QosNameAlreadyExists(qos_name=qos_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP qos = network_models_v2.QoS(tenant_id, qos_name, qos_desc) DCNL DCSP  DCSP session.add(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP session.delete(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(network_models_v2.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP if new_qos_name: DCNL DCSP  DCSP  DCSP qos['qos_name'] = new_qos_name DCNL DCSP  DCSP session.merge(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP creds = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return creds DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNameNotFound(credential_name=credential_name, tenant_id=tenant_id)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP raise c_exc.CredentialAlreadyExists(credential_name=credential_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP cred = network_models_v2.Credential(tenant_id, credential_name, user_name, password) DCNL DCSP  DCSP session.add(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP session.delete(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(network_models_v2.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP if new_user_name: DCNL DCSP  DCSP  DCSP cred['user_name'] = new_user_name DCNL DCSP  DCSP if new_password: DCNL DCSP  DCSP  DCSP cred['password'] = new_password DCNL DCSP  DCSP session.merge(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
 DCSP LOG.debug(_('get_all_nexusport_bindings() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP bindings = session.query(nexus_models_v2.NexusPortBinding).all() DCNL DCSP  DCSP return bindings DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).filter_by(port_id=port_id).filter_by(instance_id=instance_id).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
 DCSP LOG.debug(_('get_nexusvlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
 DCSP LOG.debug(_('add_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP binding = nexus_models_v2.NexusPortBinding(port_id, vlan_id, switch_ip, instance_id) DCNL DCSP session.add(binding) DCNL DCSP session.flush() DCNL DCSP return binding
 DCSP LOG.debug(_('remove_nexusport_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(vlan_id=vlan_id).filter_by(switch_ip=switch_ip).filter_by(port_id=port_id).filter_by(instance_id=instance_id).all() DCNL DCSP  DCSP for bind in binding: DCNL DCSP  DCSP  DCSP session.delete(bind) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP LOG.debug(_('update_nexusport_binding DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(port_id=port_id).one() DCNL DCSP  DCSP if new_vlan_id: DCNL DCSP  DCSP  DCSP binding['vlan_id'] = new_vlan_id DCNL DCSP  DCSP session.merge(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound()
 DCSP LOG.debug(_('get_nexusvm_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(instance_id=instance_id).filter_by(vlan_id=vlan_id).first() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
 DCSP LOG.debug(_('get_port_vlan_switch_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(nexus_models_v2.NexusPortBinding).filter_by(port_id=port_id).filter_by(switch_ip=switch_ip).filter_by(vlan_id=vlan_id).all() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.NexusPortBindingNotFound(vlan_id=vlan_id)
 DCSP global _ENGINE DCNL DCSP if (not _ENGINE): DCNL DCSP  DCSP _ENGINE = create_engine(options['sql_connection'], echo=False, echo_pool=True, pool_recycle=3600) DCNL DCSP  DCSP register_models()
 DCSP global _MAKER, _ENGINE DCNL DCSP if (not _MAKER): DCNL DCSP  DCSP assert _ENGINE DCNL DCSP  DCSP _MAKER = sessionmaker(bind=_ENGINE, autocommit=autocommit, expire_on_commit=expire_on_commit) DCNL DCSP return _MAKER()
 DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP BASE.metadata.create_all(_ENGINE)
 DCSP global _ENGINE DCNL DCSP assert _ENGINE DCNL DCSP BASE.metadata.drop_all(_ENGINE)
 DCSP db.configure_db()
 DCSP LOG.debug(_('create_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).one() DCNL DCSP except exc.MultipleResultsFound: DCNL DCSP  DCSP pass DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP start = int(conf.VLAN_START) DCNL DCSP  DCSP end = int(conf.VLAN_END) DCNL DCSP  DCSP while (start <= end): DCNL DCSP  DCSP  DCSP vlanid = l2network_models.VlanID(start) DCNL DCSP  DCSP  DCSP session.add(vlanid) DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP  DCSP session.flush() DCNL DCSP return
 DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(l2network_models.VlanID).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('is_vlanid_used() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id)
 DCSP LOG.debug(_('release_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP vlanid['vlan_used'] = False DCNL DCSP  DCSP session.merge(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid['vlan_used'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotFound(vlan_id=vlan_id) DCNL DCSP return
 DCSP LOG.debug(_('delete_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=vlan_id).one() DCNL DCSP  DCSP session.delete(vlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return vlanid DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP LOG.debug(_('reserve_vlanid() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP rvlan = session.query(l2network_models.VlanID).filter_by(vlan_used=False).first() DCNL DCSP  DCSP if (not rvlan): DCNL DCSP  DCSP  DCSP raise exc.NoResultFound DCNL DCSP  DCSP rvlanid = session.query(l2network_models.VlanID).filter_by(vlan_id=rvlan['vlan_id']).one() DCNL DCSP  DCSP rvlanid['vlan_used'] = True DCNL DCSP  DCSP session.merge(rvlanid) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return rvlan['vlan_id'] DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.VlanIDNotAvailable()
 DCSP LOG.debug(_('get_all_vlanids() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlanids = session.query(l2network_models.VlanID).filter_by(vlan_used=True).all() DCNL DCSP  DCSP return vlanids DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_all_vlan_bindings() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP bindings = session.query(l2network_models.VlanBinding).all() DCNL DCSP  DCSP return bindings DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(network_id=netid).one() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
 DCSP LOG.debug(_('add_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(vlan_id=vlanid).one() DCNL DCSP  DCSP raise c_exc.NetworkVlanBindingAlreadyExists(vlan_id=vlanid, network_id=netid) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP binding = l2network_models.VlanBinding(vlanid, vlanname, netid) DCNL DCSP  DCSP session.add(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding
 DCSP LOG.debug(_('remove_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(network_id=netid).one() DCNL DCSP  DCSP session.delete(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP LOG.debug(_('update_vlan_binding() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP binding = session.query(l2network_models.VlanBinding).filter_by(network_id=netid).one() DCNL DCSP  DCSP if newvlanid: DCNL DCSP  DCSP  DCSP binding['vlan_id'] = newvlanid DCNL DCSP  DCSP if newvlanname: DCNL DCSP  DCSP  DCSP binding['vlan_name'] = newvlanname DCNL DCSP  DCSP session.merge(binding) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return binding DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise q_exc.NetworkNotFound(net_id=netid)
 DCSP LOG.debug(_('get_all_qoss() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qoss = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return qoss DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP LOG.debug(_('get_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
 DCSP LOG.debug(_('add_qos() DCSP called')) DCNL DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_name=qos_name).one() DCNL DCSP  DCSP raise c_exc.QosNameAlreadyExists(qos_name=qos_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP qos = l2network_models.QoS(tenant_id, qos_name, qos_desc) DCNL DCSP  DCSP session.add(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP session.delete(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP qos = session.query(l2network_models.QoS).filter_by(tenant_id=tenant_id).filter_by(qos_id=qos_id).one() DCNL DCSP  DCSP if new_qos_name: DCNL DCSP  DCSP  DCSP qos['qos_name'] = new_qos_name DCNL DCSP  DCSP session.merge(qos) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return qos DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.QosNotFound(qos_id=qos_id, tenant_id=tenant_id)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP creds = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).all() DCNL DCSP  DCSP return creds DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP return []
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNameNotFound(credential_name=credential_name, tenant_id=tenant_id)
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_name=credential_name).one() DCNL DCSP  DCSP raise c_exc.CredentialAlreadyExists(credential_name=credential_name, tenant_id=tenant_id) DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP cred = l2network_models.Credential(tenant_id, credential_name, user_name, password) DCNL DCSP  DCSP session.add(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP session.delete(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP pass
 DCSP session = db.get_session() DCNL DCSP try: DCNL DCSP  DCSP cred = session.query(l2network_models.Credential).filter_by(tenant_id=tenant_id).filter_by(credential_id=credential_id).one() DCNL DCSP  DCSP if new_user_name: DCNL DCSP  DCSP  DCSP cred['user_name'] = new_user_name DCNL DCSP  DCSP if new_password: DCNL DCSP  DCSP  DCSP cred['password'] = new_password DCNL DCSP  DCSP session.merge(cred) DCNL DCSP  DCSP session.flush() DCNL DCSP  DCSP return cred DCNL DCSP except exc.NoResultFound: DCNL DCSP  DCSP raise c_exc.CredentialNotFound(credential_id=credential_id, tenant_id=tenant_id)
 DCSP base_url = req.application_url DCNL DCSP return ViewBuilder(base_url)
 DCSP base_url = req.application_url DCNL DCSP return ViewBuilder(base_url)
 DCSP sock = eventlet.listen(('0.0.0.0', port)) DCNL DCSP eventlet.wsgi.server(sock, application)
 DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
 DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
 DCSP found_filter = None DCNL DCSP for f in filter_list: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if isinstance(f, filters.ExecCommandFilter): DCNL DCSP  DCSP  DCSP  DCSP leaf_filters = [fltr for fltr in filter_list if (not isinstance(fltr, filters.ExecCommandFilter))] DCNL DCSP  DCSP  DCSP  DCSP args = f.exec_args(userargs) DCNL DCSP  DCSP  DCSP  DCSP if ((not args) or (not match_filter(leaf_filters, args))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not os.access(f.exec_path, os.X_OK)): DCNL DCSP  DCSP  DCSP  DCSP if (not found_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP found_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP return found_filter
 DCSP if redirect_output: DCNL DCSP  DCSP stdout = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP stdout = None DCNL DCSP proc = subprocess.Popen(cmd, cwd=cwd, stdout=stdout) DCNL DCSP output = proc.communicate()[0] DCNL DCSP if (check_exit_code and (proc.returncode != 0)): DCNL DCSP  DCSP if (die_message is None): DCNL DCSP  DCSP  DCSP die('Command DCSP "%s" DCSP failed.\n%s', ' DCSP '.join(cmd), output) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP die(die_message) DCNL DCSP return output
 DCSP print 'Checking DCSP dependencies...' DCNL DCSP if (not HAS_VIRTUALENV): DCNL DCSP  DCSP print 'Virtual DCSP environment DCSP not DCSP found.' DCNL DCSP  DCSP if HAS_EASY_INSTALL: DCNL DCSP  DCSP  DCSP print 'Installing DCSP virtualenv DCSP via DCSP easy_install...', DCNL DCSP  DCSP  DCSP run_command(['easy_install', 'virtualenv'], die_message='easy_install DCSP failed DCSP to DCSP install DCSP virtualenv\ndevelopment DCSP requires DCSP virtualenv, DCSP please DCSP install DCSP it DCSP using DCSP your DCSP favorite DCSP tool') DCNL DCSP  DCSP  DCSP if (not run_command(['which', 'virtualenv'])): DCNL DCSP  DCSP  DCSP  DCSP die('ERROR: DCSP virtualenv DCSP not DCSP found DCSP in DCSP path.\n\ndevelopment DCSP  DCSP requires DCSP virtualenv, DCSP please DCSP install DCSP it DCSP using DCSP your DCSP favorite DCSP package DCSP management DCSP tool DCSP and DCSP ensure DCSP virtualenv DCSP is DCSP in DCSP your DCSP path') DCNL DCSP  DCSP  DCSP print 'virtualenv DCSP installation DCSP done.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP die('easy_install DCSP not DCSP found.\n\nInstall DCSP easy_install DCSP (python-setuptools DCSP in DCSP ubuntu) DCSP or DCSP virtualenv DCSP by DCSP hand, DCSP then DCSP rerun.') DCNL DCSP print 'dependency DCSP check DCSP done.'
 DCSP print 'Creating DCSP venv...', DCNL DCSP run_command(['virtualenv', '-q', '--no-site-packages', VENV]) DCNL DCSP print 'done.' DCNL DCSP print 'Installing DCSP pip DCSP in DCSP virtualenv...', DCNL DCSP if (not run_command([WITH_VENV, 'easy_install', 'pip']).strip()): DCNL DCSP  DCSP die('Failed DCSP to DCSP install DCSP pip.') DCNL DCSP print 'done.' DCNL DCSP print 'Installing DCSP distribute DCSP in DCSP virtualenv...' DCNL DCSP pip_install('distribute>=0.6.24') DCNL DCSP print 'done.'
 DCSP if (result is None): DCNL DCSP  DCSP result = [] DCNL DCSP (head, tail) = os.path.split(path) DCNL DCSP if (head == ''): DCNL DCSP  DCSP return ([tail] + result) DCNL DCSP if (head == path): DCNL DCSP  DCSP return result DCNL DCSP return split(head, ([tail] + result))
 DCSP return user.has_perms(getattr(component, 'permissions', set()))
 DCSP if ('request' not in context): DCNL DCSP  DCSP return {} DCNL DCSP current_dashboard = context['request'].horizon.get('dashboard', None) DCNL DCSP dashboards = [] DCNL DCSP for dash in Horizon.get_dashboards(): DCNL DCSP  DCSP if (callable(dash.nav) and dash.nav(context)): DCNL DCSP  DCSP  DCSP dashboards.append(dash) DCNL DCSP  DCSP elif dash.nav: DCNL DCSP  DCSP  DCSP dashboards.append(dash) DCNL DCSP return {'components': dashboards, 'user': context['request'].user, 'current': current_dashboard, 'request': context['request']}
 DCSP if ('request' not in context): DCNL DCSP  DCSP return {} DCNL DCSP dashboard = context['request'].horizon['dashboard'] DCNL DCSP panel_groups = dashboard.get_panel_groups() DCNL DCSP non_empty_groups = [] DCNL DCSP for group in panel_groups.values(): DCNL DCSP  DCSP allowed_panels = [] DCNL DCSP  DCSP for panel in group: DCNL DCSP  DCSP  DCSP if (callable(panel.nav) and panel.nav(context)): DCNL DCSP  DCSP  DCSP  DCSP allowed_panels.append(panel) DCNL DCSP  DCSP  DCSP elif ((not callable(panel.nav)) and panel.nav): DCNL DCSP  DCSP  DCSP  DCSP allowed_panels.append(panel) DCNL DCSP  DCSP if allowed_panels: DCNL DCSP  DCSP  DCSP non_empty_groups.append((group.name, allowed_panels)) DCNL DCSP return {'components': SortedDict(non_empty_groups), 'user': context['request'].user, 'current': context['request'].horizon['panel'].slug, 'request': context['request']}
 DCSP return {'current_val': current_val, 'max_val': max_val}
 DCSP nodelist = parser.parse(('endjstemplate',)) DCNL DCSP parser.delete_first_token() DCNL DCSP return JSTemplateNode(nodelist)
 DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP if set(str(exc_value).split(' DCSP ')).issuperset(set(keywords)): DCNL DCSP  DCSP exc_value._safe_message = message DCNL DCSP  DCSP raise
 DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP log_method = getattr(LOG, (log_level or 'exception')) DCNL DCSP force_log = (force_log or os.environ.get('HORIZON_TEST_RUN', False)) DCNL DCSP force_silence = getattr(exc_value, 'silence_logging', False) DCNL DCSP handled = issubclass(exc_type, HandledException) DCNL DCSP wrap = False DCNL DCSP if handled: DCNL DCSP  DCSP (exc_type, exc_value, exc_traceback) = exc_value.wrapped DCNL DCSP  DCSP wrap = True DCNL DCSP if issubclass(exc_type, HorizonException): DCNL DCSP  DCSP message = exc_value DCNL DCSP elif getattr(exc_value, '_safe_message', None): DCNL DCSP  DCSP message = exc_value._safe_message DCNL DCSP elif (message and ('%(exc)s' in message)): DCNL DCSP  DCSP message = (message % {'exc': exc_value}) DCNL DCSP if issubclass(exc_type, UNAUTHORIZED): DCNL DCSP  DCSP if ignore: DCNL DCSP  DCSP  DCSP return NotAuthorized DCNL DCSP  DCSP if ((not force_silence) and (not handled)): DCNL DCSP  DCSP  DCSP log_method(error_color(('Unauthorized: DCSP %s' % exc_value))) DCNL DCSP  DCSP if (not handled): DCNL DCSP  DCSP  DCSP if message: DCNL DCSP  DCSP  DCSP  DCSP message = (_('Unauthorized: DCSP %s') % message) DCNL DCSP  DCSP  DCSP fallback = _('Unauthorized. DCSP Please DCSP try DCSP logging DCSP in DCSP again.') DCNL DCSP  DCSP  DCSP messages.error(request, (message or fallback)) DCNL DCSP  DCSP if escalate: DCNL DCSP  DCSP  DCSP logout(request) DCNL DCSP  DCSP  DCSP raise NotAuthorized DCNL DCSP  DCSP return NotAuthorized DCNL DCSP if issubclass(exc_type, NOT_FOUND): DCNL DCSP  DCSP wrap = True DCNL DCSP  DCSP if ((not force_silence) and (not handled) and ((not ignore) or force_log)): DCNL DCSP  DCSP  DCSP log_method(error_color(('Not DCSP Found: DCSP %s' % exc_value))) DCNL DCSP  DCSP if ((not ignore) and (not handled)): DCNL DCSP  DCSP  DCSP messages.error(request, (message or exc_value)) DCNL DCSP  DCSP if redirect: DCNL DCSP  DCSP  DCSP raise Http302(redirect) DCNL DCSP  DCSP if (not escalate): DCNL DCSP  DCSP  DCSP return NotFound DCNL DCSP if issubclass(exc_type, RECOVERABLE): DCNL DCSP  DCSP wrap = True DCNL DCSP  DCSP if ((not force_silence) and (not handled) and ((not ignore) or force_log)): DCNL DCSP  DCSP  DCSP log_method = getattr(LOG, (log_level or 'warning')) DCNL DCSP  DCSP  DCSP log_method(error_color(('Recoverable DCSP error: DCSP %s' % exc_value))) DCNL DCSP  DCSP if ((not ignore) and (not handled)): DCNL DCSP  DCSP  DCSP messages.error(request, (message or exc_value)) DCNL DCSP  DCSP if redirect: DCNL DCSP  DCSP  DCSP raise Http302(redirect) DCNL DCSP  DCSP if (not escalate): DCNL DCSP  DCSP  DCSP return RecoverableError DCNL DCSP if wrap: DCNL DCSP  DCSP raise HandledException([exc_type, exc_value, exc_traceback]) DCNL DCSP raise exc_type, exc_value, exc_traceback
 DCSP context = {'HORIZON_CONFIG': conf.HORIZON_CONFIG, 'True': True, 'False': False} DCNL DCSP return context
 DCSP if request.is_ajax(): DCNL DCSP  DCSP tag = constants.DEFAULT_TAGS[level] DCNL DCSP  DCSP if isinstance(message, SafeData): DCNL DCSP  DCSP  DCSP extra_tags = (extra_tags + ' DCSP safe') DCNL DCSP  DCSP request.horizon['async_messages'].append([tag, force_unicode(message), extra_tags]) DCNL DCSP else: DCNL DCSP  DCSP return _messages.add_message(request, level, message, extra_tags, fail_silently)
 DCSP add_message(request, constants.DEBUG, message, extra_tags=extra_tags, fail_silently=fail_silently)
 DCSP add_message(request, constants.INFO, message, extra_tags=extra_tags, fail_silently=fail_silently)
 DCSP add_message(request, constants.SUCCESS, message, extra_tags=extra_tags, fail_silently=fail_silently)
 DCSP add_message(request, constants.WARNING, message, extra_tags=extra_tags, fail_silently=fail_silently)
 DCSP add_message(request, constants.ERROR, message, extra_tags=extra_tags, fail_silently=fail_silently)
 DCSP return re.sub(' DCSP +', ' DCSP ', normalize_newlines(text).replace('\n', '')).strip()
 DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if dashboard: DCNL DCSP  DCSP  DCSP request.horizon['dashboard'] = dashboard DCNL DCSP  DCSP if panel: DCNL DCSP  DCSP  DCSP request.horizon['panel'] = panel DCNL DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP return dec
 DCSP from horizon.exceptions import NotAuthenticated DCNL DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP  DCSP raise NotAuthenticated(_('Please DCSP log DCSP in DCSP to DCSP continue.')) DCNL DCSP return dec
 DCSP from horizon.exceptions import NotAuthorized DCNL DCSP current_perms = getattr(view_func, '_required_perms', set([])) DCNL DCSP view_func._required_perms = (current_perms | set(required)) DCNL DCSP @functools.wraps(view_func, assigned=available_attrs(view_func)) DCNL DCSP def dec(request, *args, **kwargs): DCNL DCSP  DCSP if request.user.is_authenticated(): DCNL DCSP  DCSP  DCSP if request.user.has_perms(view_func._required_perms): DCNL DCSP  DCSP  DCSP  DCSP return view_func(request, *args, **kwargs) DCNL DCSP  DCSP raise NotAuthorized((_('You DCSP are DCSP not DCSP authorized DCSP to DCSP access DCSP %s') % request.path)) DCNL DCSP if required: DCNL DCSP  DCSP return dec DCNL DCSP else: DCNL DCSP  DCSP return view_func
 DCSP return shortcuts.redirect(horizon.get_user_home(request.user))
 DCSP if hasattr(random, 'SystemRandom'): DCNL DCSP  DCSP choice = random.SystemRandom().choice DCNL DCSP else: DCNL DCSP  DCSP choice = random.choice DCNL DCSP return ''.join(map((lambda x: choice((string.digits + string.letters))), range(key_length)))
 DCSP lock = lockfile.FileLock(key_file) DCNL DCSP with lock: DCNL DCSP  DCSP if (not os.path.exists(key_file)): DCNL DCSP  DCSP  DCSP key = generate_key(key_length) DCNL DCSP  DCSP  DCSP old_umask = os.umask(127) DCNL DCSP  DCSP  DCSP with open(key_file, 'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(key) DCNL DCSP  DCSP  DCSP os.umask(old_umask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (oct((os.stat(key_file).st_mode & 511)) != '0600'): DCNL DCSP  DCSP  DCSP  DCSP raise FilePermissionError('Insecure DCSP key DCSP file DCSP permissions!') DCNL DCSP  DCSP  DCSP with open(key_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP key = f.readline() DCNL DCSP  DCSP return key
 DCSP body = {'vip': {'address': kwargs['address'], 'name': kwargs['name'], 'description': kwargs['description'], 'subnet_id': kwargs['subnet_id'], 'protocol_port': kwargs['protocol_port'], 'protocol': kwargs['protocol'], 'pool_id': kwargs['pool_id'], 'session_persistence': kwargs['session_persistence'], 'connection_limit': kwargs['connection_limit'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP vip = quantumclient(request).create_vip(body).get('vip') DCNL DCSP return Vip(vip)
 DCSP body = {'pool': {'name': kwargs['name'], 'description': kwargs['description'], 'subnet_id': kwargs['subnet_id'], 'protocol': kwargs['protocol'], 'lb_method': kwargs['lb_method'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP pool = quantumclient(request).create_pool(body).get('pool') DCNL DCSP return Pool(pool)
 DCSP body = {'health_monitor': {'type': kwargs['type'], 'delay': kwargs['delay'], 'timeout': kwargs['timeout'], 'max_retries': kwargs['max_retries'], 'http_method': kwargs['http_method'], 'url_path': kwargs['url_path'], 'expected_codes': kwargs['expected_codes'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP mon = quantumclient(request).create_health_monitor(body).get('health_monitor') DCNL DCSP body = {'health_monitor': {'id': mon['id']}} DCNL DCSP quantumclient(request).associate_health_monitor(kwargs['pool_id'], body) DCNL DCSP return PoolMonitor(mon)
 DCSP body = {'member': {'pool_id': kwargs['pool_id'], 'address': kwargs['address'], 'protocol_port': kwargs['protocol_port'], 'weight': kwargs['weight'], 'admin_state_up': kwargs['admin_state_up']}} DCNL DCSP member = quantumclient(request).create_member(body).get('member') DCNL DCSP return Member(member)
 DCSP return IP_VERSION_DICT.get(ip_version, '')
 DCSP LOG.debug(('network_list_for_tenant(): DCSP tenant_id=%s, DCSP params=%s' % (tenant_id, params))) DCNL DCSP networks = network_list(request, tenant_id=tenant_id, shared=False, **params) DCNL DCSP networks += network_list(request, shared=True, **params) DCNL DCSP return networks
 DCSP LOG.debug(('network_create(): DCSP kwargs DCSP = DCSP %s' % kwargs)) DCNL DCSP body = {'network': kwargs} DCNL DCSP network = quantumclient(request).create_network(body=body).get('network') DCNL DCSP return Network(network)
 DCSP LOG.debug(('subnet_create(): DCSP netid=%s, DCSP cidr=%s, DCSP ipver=%d, DCSP kwargs=%s' % (network_id, cidr, ip_version, kwargs))) DCNL DCSP body = {'subnet': {'network_id': network_id, 'ip_version': ip_version, 'cidr': cidr}} DCNL DCSP body['subnet'].update(kwargs) DCNL DCSP subnet = quantumclient(request).create_subnet(body=body).get('subnet') DCNL DCSP return Subnet(subnet)
 DCSP LOG.debug(('port_create(): DCSP netid=%s, DCSP kwargs=%s' % (network_id, kwargs))) DCNL DCSP body = {'port': {'network_id': network_id}} DCNL DCSP body['port'].update(kwargs) DCNL DCSP port = quantumclient(request).create_port(body=body).get('port') DCNL DCSP return Port(port)
 DCSP user = request.user DCNL DCSP if admin: DCNL DCSP  DCSP if (not user.is_superuser): DCNL DCSP  DCSP  DCSP raise exceptions.NotAuthorized DCNL DCSP  DCSP endpoint_type = 'adminURL' DCNL DCSP else: DCNL DCSP  DCSP endpoint_type = getattr(settings, 'OPENSTACK_ENDPOINT_TYPE', 'internalURL') DCNL DCSP cache_attr = ('_keystoneclient_admin' if admin else KEYSTONE_CLIENT_ATTR) DCNL DCSP if (hasattr(request, cache_attr) and ((not user.token.id) or (getattr(request, cache_attr).auth_token == user.token.id))): DCNL DCSP  DCSP LOG.debug(('Using DCSP cached DCSP client DCSP for DCSP token: DCSP %s' % user.token.id)) DCNL DCSP  DCSP conn = getattr(request, cache_attr) DCNL DCSP else: DCNL DCSP  DCSP endpoint = _get_endpoint_url(request, endpoint_type) DCNL DCSP  DCSP insecure = getattr(settings, 'OPENSTACK_SSL_NO_VERIFY', False) DCNL DCSP  DCSP LOG.debug(('Creating DCSP a DCSP new DCSP keystoneclient DCSP connection DCSP to DCSP %s.' % endpoint)) DCNL DCSP  DCSP kcversion = get_distribution('python-keystoneclient').version DCNL DCSP  DCSP if (kcversion >= '0.2.0'): DCNL DCSP  DCSP  DCSP conn = keystone_client.Client(token=user.token.id, endpoint=endpoint, original_ip=request.environ.get('REMOTE_ADDR', ''), insecure=insecure) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn = keystone_client.Client(token=user.token.id, endpoint=endpoint, insecure=insecure) DCNL DCSP  DCSP setattr(request, cache_attr, conn) DCNL DCSP return conn
 DCSP if hasattr(request, '_keystone'): DCNL DCSP  DCSP del request._keystone DCNL DCSP c = keystoneclient(request) DCNL DCSP raw_token = c.tokens.authenticate(tenant_id=tenant, token=token, return_raw=True) DCNL DCSP c.service_catalog = service_catalog.ServiceCatalog(raw_token) DCNL DCSP if request.user.is_superuser: DCNL DCSP  DCSP c.management_url = c.service_catalog.url_for(service_type='identity', endpoint_type='adminURL') DCNL DCSP else: DCNL DCSP  DCSP endpoint_type = getattr(settings, 'OPENSTACK_ENDPOINT_TYPE', 'internalURL') DCNL DCSP  DCSP c.management_url = c.service_catalog.url_for(service_type='identity', endpoint_type=endpoint_type) DCNL DCSP scoped_token = tokens.Token(tokens.TokenManager, raw_token) DCNL DCSP return scoped_token
 DCSP return keystoneclient(request, admin=True).roles.list()
 DCSP return keystoneclient(request, admin=True).roles.add_user_role(user_id, role_id, tenant_id)
 DCSP client = keystoneclient(request, admin=True) DCNL DCSP client.roles.remove_user_role(user_id, role_id, tenant_id)
 DCSP client = keystoneclient(request, admin=True) DCNL DCSP roles = client.roles.roles_for_user(user_id, tenant_id) DCNL DCSP for role in roles: DCNL DCSP  DCSP client.roles.remove_user_role(user_id, role.id, tenant_id)
 DCSP global DEFAULT_ROLE DCNL DCSP default = getattr(settings, 'OPENSTACK_KEYSTONE_DEFAULT_ROLE', None) DCNL DCSP if (default and (DEFAULT_ROLE is None)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP roles = keystoneclient(request, admin=True).roles.list() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP roles = [] DCNL DCSP  DCSP  DCSP exceptions.handle(request) DCNL DCSP  DCSP for role in roles: DCNL DCSP  DCSP  DCSP if ((role.id == default) or (role.name == default)): DCNL DCSP  DCSP  DCSP  DCSP DEFAULT_ROLE = role DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return DEFAULT_ROLE
 DCSP c_client = cinderclient(request) DCNL DCSP if (c_client is None): DCNL DCSP  DCSP return [] DCNL DCSP return c_client.volumes.list(search_opts=search_opts)
 DCSP return novaclient(request).flavors.list()
 DCSP flavor = novaclient(request).flavors.get(flavor_id) DCNL DCSP extras = flavor.get_keys() DCNL DCSP if raw: DCNL DCSP  DCSP return extras DCNL DCSP return [FlavorExtraSpec(flavor_id, key, value) for (key, value) in extras.items()]
 DCSP flavor = novaclient(request).flavors.get(flavor_id) DCNL DCSP return flavor.unset_keys(keys)
 DCSP flavor = novaclient(request).flavors.get(flavor_id) DCNL DCSP if (not metadata): DCNL DCSP  DCSP return None DCNL DCSP return flavor.set_keys(metadata)
 DCSP return novaclient(request).servers.get_console_output(instance_id, length=tail_length)
 DCSP security_groups = [] DCNL DCSP nclient = novaclient(request) DCNL DCSP (resp, body) = nclient.client.get(('/servers/%s/os-security-groups' % instance_id)) DCNL DCSP if body: DCNL DCSP  DCSP sg_objs = [NovaSecurityGroup(nclient.security_groups, sg, loaded=True) for sg in body.get('security_groups', [])] DCNL DCSP  DCSP security_groups = [SecurityGroup(sg) for sg in sg_objs] DCNL DCSP  DCSP for sg in security_groups: DCNL DCSP  DCSP  DCSP rule_objects = [SecurityGroupRule(rule) for rule in sg.rules] DCNL DCSP  DCSP  DCSP sg.rules = rule_objects DCNL DCSP return security_groups
 DCSP objects = [] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item.get('subdir', None) is not None): DCNL DCSP  DCSP  DCSP object_cls = PseudoFolder DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP object_cls = StorageObject DCNL DCSP  DCSP objects.append(object_cls(item, container_name)) DCNL DCSP return objects
 DCSP return glanceclient(request).images.get(image_id)
 DCSP try: DCNL DCSP  DCSP uuid.UUID(value) DCNL DCSP  DCSP return value DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP return int(value)
 DCSP context = {} DCNL DCSP context.setdefault('authorized_tenants', []) DCNL DCSP current_dash = request.horizon['dashboard'] DCNL DCSP needs_tenants = getattr(current_dash, 'supports_tenants', False) DCNL DCSP if (request.user.is_authenticated() and needs_tenants): DCNL DCSP  DCSP context['authorized_tenants'] = request.user.authorized_tenants DCNL DCSP available_regions = getattr(settings, 'AVAILABLE_REGIONS', []) DCNL DCSP regions = {'support': (len(available_regions) > 1), 'current': {'endpoint': request.session.get('region_endpoint'), 'name': request.session.get('region_name')}, 'available': [{'endpoint': region[0], 'name': region[1]} for region in available_regions]} DCNL DCSP context['regions'] = regions DCNL DCSP return context
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command('git DCSP describe DCSP --always') DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
 DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --always').replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP error_table = {'AccessDenied': (HTTP_FORBIDDEN, 'Access DCSP denied'), 'BucketAlreadyExists': (HTTP_CONFLICT, 'The DCSP requested DCSP bucket DCSP name DCSP is DCSP not DCSP available'), 'BucketNotEmpty': (HTTP_CONFLICT, 'The DCSP bucket DCSP you DCSP tried DCSP to DCSP delete DCSP is DCSP not DCSP empty'), 'InvalidArgument': (HTTP_BAD_REQUEST, 'Invalid DCSP Argument'), 'InvalidBucketName': (HTTP_BAD_REQUEST, 'The DCSP specified DCSP bucket DCSP is DCSP not DCSP valid'), 'InvalidURI': (HTTP_BAD_REQUEST, 'Could DCSP not DCSP parse DCSP the DCSP specified DCSP URI'), 'InvalidDigest': (HTTP_BAD_REQUEST, 'The DCSP Content-MD5 DCSP you DCSP specified DCSP was DCSP invalid'), 'BadDigest': (HTTP_BAD_REQUEST, 'The DCSP Content-Length DCSP you DCSP specified DCSP was DCSP invalid'), 'NoSuchBucket': (HTTP_NOT_FOUND, 'The DCSP specified DCSP bucket DCSP does DCSP not DCSP exist'), 'SignatureDoesNotMatch': (HTTP_FORBIDDEN, 'The DCSP calculated DCSP request DCSP signature DCSP does DCSP not DCSP match DCSP your DCSP provided DCSP one'), 'RequestTimeTooSkewed': (HTTP_FORBIDDEN, 'The DCSP difference DCSP between DCSP the DCSP request DCSP time DCSP and DCSP the DCSP current DCSP time DCSP is DCSP too DCSP large'), 'NoSuchKey': (HTTP_NOT_FOUND, 'The DCSP resource DCSP you DCSP requested DCSP does DCSP not DCSP exist'), 'Unsupported': (HTTP_NOT_IMPLEMENTED, 'The DCSP feature DCSP you DCSP requested DCSP is DCSP not DCSP yet DCSP implemented'), 'MissingContentLength': (HTTP_LENGTH_REQUIRED, 'Length DCSP Required'), 'ServiceUnavailable': (HTTP_SERVICE_UNAVAILABLE, 'Please DCSP reduce DCSP your DCSP request DCSP rate')} DCNL DCSP resp = Response(content_type='text/xml') DCNL DCSP resp.status = error_table[code][0] DCNL DCSP resp.body = ('<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>\r\n<Error>\r\n DCSP  DCSP <Code>%s</Code>\r\n DCSP  DCSP <Message>%s</Message>\r\n</Error>\r\n' % (code, error_table[code][1])) DCNL DCSP return resp
 DCSP acl = 'private' DCNL DCSP if ('x-container-read' in headers): DCNL DCSP  DCSP if ((headers['x-container-read'] == '.r:*') or ('.r:*,' in headers['x-container-read']) or (',*,' in headers['x-container-read'])): DCNL DCSP  DCSP  DCSP acl = 'public-read' DCNL DCSP if ('x-container-write' in headers): DCNL DCSP  DCSP if ((headers['x-container-write'] == '.r:*') or ('.r:*,' in headers['x-container-write']) or (',*,' in headers['x-container-write'])): DCNL DCSP  DCSP  DCSP if (acl == 'public-read'): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-read-write' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-write' DCNL DCSP if (acl == 'private'): DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP elif (acl == 'public-read'): DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>READ</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP elif (acl == 'public-read-write'): DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>READ</Permission></Grant></AccessControlList><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="Group"><URI>http://acs.amazonaws.com/groups/global/AllUsers</URI></Grantee><Permission>WRITE</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP else: DCNL DCSP  DCSP body = ('<AccessControlPolicy><Owner><ID>%s</ID><DisplayName>%s</DisplayName></Owner><AccessControlList><Grant><Grantee DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xsi:type="CanonicalUser"><ID>%s</ID><DisplayName>%s</DisplayName></Grantee><Permission>FULL_CONTROL</Permission></Grant></AccessControlList></AccessControlPolicy>' % (account_name, account_name, account_name, account_name)) DCNL DCSP return Response(body=body, content_type='text/plain')
 DCSP amz_headers = {} DCNL DCSP buf = ('%s\n%s\n%s\n' % (req.method, req.headers.get('Content-MD5', ''), (req.headers.get('Content-Type') or ''))) DCNL DCSP for amz_header in sorted((key.lower() for key in req.headers if key.lower().startswith('x-amz-'))): DCNL DCSP  DCSP amz_headers[amz_header] = req.headers[amz_header] DCNL DCSP if ('x-amz-date' in amz_headers): DCNL DCSP  DCSP buf += '\n' DCNL DCSP elif ('Date' in req.headers): DCNL DCSP  DCSP buf += ('%s\n' % req.headers['Date']) DCNL DCSP for k in sorted((key.lower() for key in amz_headers)): DCNL DCSP  DCSP buf += ('%s:%s\n' % (k, amz_headers[k])) DCNL DCSP path = req.environ.get('RAW_PATH_INFO', req.path) DCNL DCSP if req.query_string: DCNL DCSP  DCSP path += ('?' + req.query_string) DCNL DCSP if ('?' in path): DCNL DCSP  DCSP (path, args) = path.split('?', 1) DCNL DCSP  DCSP qstr = '' DCNL DCSP  DCSP qdict = dict(urlparse.parse_qsl(args, keep_blank_values=True)) DCNL DCSP  DCSP keywords = sorted(['acl', 'delete', 'lifecycle', 'location', 'logging', 'notification', 'partNumber', 'policy', 'requestPayment', 'torrent', 'uploads', 'uploadId', 'versionId', 'versioning', 'versions DCSP ', 'website']) DCNL DCSP  DCSP for key in qdict: DCNL DCSP  DCSP  DCSP if (key in keywords): DCNL DCSP  DCSP  DCSP  DCSP newstr = key DCNL DCSP  DCSP  DCSP  DCSP if qdict[key]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newstr = (newstr + ('=%s' % qdict[key])) DCNL DCSP  DCSP  DCSP  DCSP if (qstr == ''): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qstr = newstr DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qstr = (qstr + ('&%s' % newstr)) DCNL DCSP  DCSP if (qstr != ''): DCNL DCSP  DCSP  DCSP return ('%s%s?%s' % (buf, path, qstr)) DCNL DCSP return (buf + path)
 DCSP swift_acl = {} DCNL DCSP swift_acl['public-read'] = [['HTTP_X_CONTAINER_READ', '.r:*,.rlistings']] DCNL DCSP swift_acl['public-read-write'] = [['HTTP_X_CONTAINER_WRITE', '.r:*'], ['HTTP_X_CONTAINER_READ', '.r:*,.rlistings']] DCNL DCSP swift_acl['private'] = [['HTTP_X_CONTAINER_WRITE', '.'], ['HTTP_X_CONTAINER_READ', '.']] DCNL DCSP if xml: DCNL DCSP  DCSP dom = parseString(acl) DCNL DCSP  DCSP acl = 'unknown' DCNL DCSP  DCSP for grant in dom.getElementsByTagName('Grant'): DCNL DCSP  DCSP  DCSP permission = grant.getElementsByTagName('Permission')[0].firstChild.data DCNL DCSP  DCSP  DCSP grantee = grant.getElementsByTagName('Grantee')[0].getAttributeNode('xsi:type').nodeValue DCNL DCSP  DCSP  DCSP if ((permission == 'FULL_CONTROL') and (grantee == 'CanonicalUser') and (acl != 'public-read') and (acl != 'public-read-write')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'private' DCNL DCSP  DCSP  DCSP elif ((permission == 'READ') and (grantee == 'Group') and (acl != 'public-read-write')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-read' DCNL DCSP  DCSP  DCSP elif ((permission == 'WRITE') and (grantee == 'Group')): DCNL DCSP  DCSP  DCSP  DCSP acl = 'public-read-write' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP acl = 'unsupported' DCNL DCSP if (acl == 'authenticated-read'): DCNL DCSP  DCSP return 'Unsupported' DCNL DCSP elif (acl not in swift_acl): DCNL DCSP  DCSP return 'InvalidArgument' DCNL DCSP return swift_acl[acl]
 DCSP if (('_' in name) or (len(name) < 3) or (len(name) > 63) or (not name[(-1)].isalnum())): DCNL DCSP  DCSP return False DCNL DCSP elif (('.-' in name) or ('-.' in name) or ('..' in name) or (not name[0].isalnum())): DCNL DCSP  DCSP return False DCNL DCSP elif re.match('^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$', name): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def swift3_filter(app): DCNL DCSP  DCSP return Swift3Middleware(app, conf) DCNL DCSP return swift3_filter
 DCSP def process_event(body): DCNL DCSP  DCSP print ('%s: DCSP %s' % (body.get('timestamp'), body.get('event_type', 'unknown DCSP event'))) DCNL DCSP  DCSP pickle.dump(body, output) DCNL DCSP connection.declare_topic_consumer(topic, process_event) DCNL DCSP try: DCNL DCSP  DCSP connection.consume() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass
 DCSP def process_event(msg): DCNL DCSP  DCSP body = msg['args']['data'] DCNL DCSP  DCSP if ('resource_id' in body): DCNL DCSP  DCSP  DCSP print ('%s: DCSP %s/%-15s: DCSP %s' % (body.get('timestamp'), body.get('resource_id'), body.get('event_type'), body.get('counter_volume'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print ('%s: DCSP %s' % (body.get('timestamp'), body.get('event_type'))) DCNL DCSP connection.declare_topic_consumer(topic, process_event) DCNL DCSP try: DCNL DCSP  DCSP connection.consume() DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP pass
 DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP body = pickle.load(input) DCNL DCSP  DCSP except EOFError: DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP print ('%s: DCSP %s' % (body.get('timestamp'), body.get('event_type', 'unknown DCSP event'))) DCNL DCSP  DCSP connection.topic_send(topic, body)
 DCSP if (not _notification_manager): DCNL DCSP  DCSP _load_notification_manager() DCNL DCSP if (not _pipeline_manager): DCNL DCSP  DCSP _load_pipeline_manager() DCNL DCSP _notification_manager.map(_process_notification_for_ext, context=(context or req_context.get_admin_context()), notification=message)
 DCSP parse_result = urlparse.urlparse(url) DCNL DCSP loaded_driver = driver.DriverManager(namespace, parse_result.scheme) DCNL DCSP return loaded_driver.driver(parse_result)
 DCSP config.register_opts(METER_PUBLISH_OPTS, group='publisher_rpc')
 DCSP digest_maker = hmac.new(secret, '', hashlib.sha256) DCNL DCSP for (name, value) in utils.recursive_keypairs(message): DCNL DCSP  DCSP if (name == 'message_signature'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP digest_maker.update(name) DCNL DCSP  DCSP digest_maker.update(unicode(value).encode('utf-8')) DCNL DCSP return digest_maker.hexdigest()
 DCSP old_sig = message.get('message_signature') DCNL DCSP new_sig = compute_signature(message, secret) DCNL DCSP return (new_sig == old_sig)
 DCSP msg = {'source': source, 'counter_name': counter.name, 'counter_type': counter.type, 'counter_unit': counter.unit, 'counter_volume': counter.volume, 'user_id': counter.user_id, 'project_id': counter.project_id, 'resource_id': counter.resource_id, 'timestamp': counter.timestamp, 'resource_metadata': counter.resource_metadata, 'message_id': str(uuid.uuid1())} DCNL DCSP msg['message_signature'] = compute_signature(msg, secret) DCNL DCSP return msg
 DCSP auth_project = acl.get_limited_to_project(pecan.request.headers) DCNL DCSP if auth_project: DCNL DCSP  DCSP proj_q = [i for i in q if (i.field == 'project_id')] DCNL DCSP  DCSP for i in proj_q: DCNL DCSP  DCSP  DCSP if ((auth_project != i.value) or (i.op != 'eq')): DCNL DCSP  DCSP  DCSP  DCSP errstr = ('Not DCSP Authorized DCSP to DCSP access DCSP project DCSP %s DCSP %s' % (i.op, i.value)) DCNL DCSP  DCSP  DCSP  DCSP raise wsme.exc.ClientSideError(errstr) DCNL DCSP  DCSP if (not proj_q): DCNL DCSP  DCSP  DCSP q.append(Query(field='project_id', op='eq', value=auth_project)) DCNL DCSP return q
 DCSP search_offset = int(args.get('search_offset', 0)) DCNL DCSP start_timestamp = args.get('start_timestamp') DCNL DCSP if start_timestamp: DCNL DCSP  DCSP start_timestamp = timeutils.parse_isotime(start_timestamp) DCNL DCSP  DCSP start_timestamp = start_timestamp.replace(tzinfo=None) DCNL DCSP  DCSP query_start = (start_timestamp - datetime.timedelta(minutes=search_offset)) DCNL DCSP else: DCNL DCSP  DCSP query_start = None DCNL DCSP end_timestamp = args.get('end_timestamp') DCNL DCSP if end_timestamp: DCNL DCSP  DCSP end_timestamp = timeutils.parse_isotime(end_timestamp) DCNL DCSP  DCSP end_timestamp = end_timestamp.replace(tzinfo=None) DCNL DCSP  DCSP query_end = (end_timestamp + datetime.timedelta(minutes=search_offset)) DCNL DCSP else: DCNL DCSP  DCSP query_end = None DCNL DCSP return {'query_start': query_start, 'query_end': query_end, 'start_timestamp': start_timestamp, 'end_timestamp': end_timestamp, 'search_offset': search_offset}
 DCSP if metadata: DCNL DCSP  DCSP return dict(((k, unicode(v)) for (k, v) in metadata.iteritems() if (type(v) not in set([list, dict, set])))) DCNL DCSP return {}
 DCSP conf.register_opts(auth_token.opts, group=OPT_GROUP_NAME) DCNL DCSP auth_token.CONF = conf
 DCSP return auth_token.AuthProtocol(app, conf=dict(conf.get(OPT_GROUP_NAME)))
 DCSP global _ENFORCER DCNL DCSP if (not _ENFORCER): DCNL DCSP  DCSP _ENFORCER = policy.Enforcer() DCNL DCSP if (not _ENFORCER.enforce('context_is_admin', {}, {'roles': headers.get('X-Roles', '').split(',')})): DCNL DCSP  DCSP return headers.get('X-Tenant-Id')
 DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
 DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(resource=resource, project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
 DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(user=user, project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
 DCSP check_authorized_project(project) DCNL DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(project=project, metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
 DCSP rq = flask.request DCNL DCSP meters = rq.storage_conn.get_meters(source=source, project=acl.get_limited_to_project(rq.headers), metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(meters=[m.as_dict() for m in meters])
 DCSP rq = flask.request DCNL DCSP q_ts = _get_query_timestamps(rq.args) DCNL DCSP resources = rq.storage_conn.get_resources(source=source, user=user, project=project, start_timestamp=q_ts['start_timestamp'], end_timestamp=q_ts['end_timestamp'], metaquery=_get_metaquery(rq.args)) DCNL DCSP return flask.jsonify(resources=[r.as_dict() for r in resources])
 DCSP check_authorized_project(project) DCNL DCSP return _list_resources(project=project)
 DCSP return _list_resources(project=acl.get_limited_to_project(flask.request.headers))
 DCSP return flask.jsonify(flask.request.sources.get(source, {}))
 DCSP return _list_resources(source=source, project=acl.get_limited_to_project(flask.request.headers))
 DCSP return _list_resources(user=user, project=acl.get_limited_to_project(flask.request.headers))
 DCSP if acl.get_limited_to_project(flask.request.headers): DCNL DCSP  DCSP users = [flask.request.headers.get('X-User-id')] DCNL DCSP else: DCNL DCSP  DCSP users = flask.request.storage_conn.get_users(source=source) DCNL DCSP return flask.jsonify(users=list(users))
 DCSP return _list_users()
 DCSP return _list_users(source=source)
 DCSP project = acl.get_limited_to_project(flask.request.headers) DCNL DCSP if project: DCNL DCSP  DCSP if source: DCNL DCSP  DCSP  DCSP if (project in flask.request.storage_conn.get_projects(source=source)): DCNL DCSP  DCSP  DCSP  DCSP projects = [project] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP projects = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP projects = [project] DCNL DCSP else: DCNL DCSP  DCSP projects = flask.request.storage_conn.get_projects(source=source) DCNL DCSP return flask.jsonify(projects=list(projects))
 DCSP return _list_projects()
 DCSP return _list_projects(source=source)
 DCSP q_ts = _get_query_timestamps(flask.request.args) DCNL DCSP f = storage.SampleFilter(user=user, project=project, source=source, meter=meter, resource=resource, start=q_ts['start_timestamp'], end=q_ts['end_timestamp'], metaquery=_get_metaquery(flask.request.args)) DCNL DCSP samples = flask.request.storage_conn.get_samples(f) DCNL DCSP jsonified = flask.jsonify(events=[s.as_dict() for s in samples]) DCNL DCSP if request_wants_html(): DCNL DCSP  DCSP return flask.templating.render_template('list_event.html', user=user, project=project, source=source, meter=meter, resource=resource, events=jsonified) DCNL DCSP return jsonified
 DCSP check_authorized_project(project) DCNL DCSP return _list_samples(project=project, meter=meter)
 DCSP return _list_samples(resource=resource, meter=meter, project=acl.get_limited_to_project(flask.request.headers))
 DCSP return _list_samples(source=source, meter=meter, project=acl.get_limited_to_project(flask.request.headers))
 DCSP return _list_samples(user=user, meter=meter, project=acl.get_limited_to_project(flask.request.headers))
 DCSP q_ts = _get_query_timestamps(flask.request.args) DCNL DCSP start_timestamp = q_ts['start_timestamp'] DCNL DCSP end_timestamp = q_ts['end_timestamp'] DCNL DCSP f = storage.SampleFilter(meter=meter, project=acl.get_limited_to_project(flask.request.headers), resource=resource, start=q_ts['query_start'], end=q_ts['query_end']) DCNL DCSP stats = flask.request.storage_conn.get_meter_statistics(f) DCNL DCSP (min_ts, max_ts) = (stats.duration_start, stats.duration_end) DCNL DCSP LOG.debug('start_timestamp DCSP %s, DCSP end_timestamp DCSP %s, DCSP min_ts DCSP %s, DCSP max_ts DCSP %s', start_timestamp, end_timestamp, min_ts, max_ts) DCNL DCSP if (start_timestamp and min_ts and (min_ts < start_timestamp)): DCNL DCSP  DCSP min_ts = start_timestamp DCNL DCSP  DCSP LOG.debug('clamping DCSP min DCSP timestamp DCSP to DCSP range') DCNL DCSP if (end_timestamp and max_ts and (max_ts > end_timestamp)): DCNL DCSP  DCSP max_ts = end_timestamp DCNL DCSP  DCSP LOG.debug('clamping DCSP max DCSP timestamp DCSP to DCSP range') DCNL DCSP if (min_ts and max_ts and (min_ts <= max_ts)): DCNL DCSP  DCSP duration = timeutils.delta_seconds(min_ts, max_ts) DCNL DCSP else: DCNL DCSP  DCSP min_ts = max_ts = duration = None DCNL DCSP return flask.jsonify(start_timestamp=min_ts, end_timestamp=max_ts, duration=duration)
 DCSP return _get_statistics('max', meter=meter, resource=resource, project=acl.get_limited_to_project(flask.request.headers))
 DCSP return _get_statistics('sum', meter=meter, resource=resource, project=acl.get_limited_to_project(flask.request.headers))
 DCSP check_authorized_project(project) DCNL DCSP return _get_statistics('max', project=project, meter=meter)
 DCSP check_authorized_project(project) DCNL DCSP return _get_statistics('sum', meter=meter, project=project)
 DCSP for (name, value) in sorted(d.iteritems()): DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP for (subname, subvalue) in recursive_keypairs(value): DCNL DCSP  DCSP  DCSP  DCSP (yield (('%s:%s' % (name, subname)), subvalue)) DCNL DCSP  DCSP elif isinstance(value, (tuple, list)): DCNL DCSP  DCSP  DCSP (yield (name, list(map((lambda x: unicode(x).encode('utf-8')), value)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yield (name, value))
 DCSP decimal.getcontext().prec = 30 DCNL DCSP return (decimal.Decimal(str(calendar.timegm(utc.utctimetuple()))) + (decimal.Decimal(str(utc.microsecond)) / decimal.Decimal('1000000.0')))
 DCSP if (dec is None): DCNL DCSP  DCSP return None DCNL DCSP integer = int(dec) DCNL DCSP micro = ((dec - decimal.Decimal(integer)) * decimal.Decimal(1000000)) DCNL DCSP daittyme = datetime.datetime.utcfromtimestamp(integer) DCNL DCSP return daittyme.replace(microsecond=int(round(micro)))
 DCSP if (not timestamp): DCNL DCSP  DCSP return timestamp DCNL DCSP if (not isinstance(timestamp, datetime.datetime)): DCNL DCSP  DCSP timestamp = timeutils.parse_isotime(timestamp) DCNL DCSP return timeutils.normalize_time(timestamp)
 DCSP cfg_file = cfg.CONF.pipeline_cfg_file DCNL DCSP if (not os.path.exists(cfg_file)): DCNL DCSP  DCSP cfg_file = cfg.CONF.find_file(cfg_file) DCNL DCSP LOG.debug('Pipeline DCSP config DCSP file: DCSP %s', cfg_file) DCNL DCSP with open(cfg_file) as fap: DCNL DCSP  DCSP data = fap.read() DCNL DCSP pipeline_cfg = yaml.safe_load(data) DCNL DCSP LOG.info('Pipeline DCSP config: DCSP %s', pipeline_cfg) DCNL DCSP return PipelineManager(pipeline_cfg, transformer_manager)
 DCSP if CONF.log_config: DCNL DCSP  DCSP _load_log_config(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP return LazyAdapter(name, version)
 DCSP kwargs['group'].thread_done(kwargs['thread'])
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP global _FILE_CACHE DCNL DCSP if (force_reload and (filename in _FILE_CACHE)): DCNL DCSP  DCSP del _FILE_CACHE[filename] DCNL DCSP reloaded = False DCNL DCSP mtime = os.path.getmtime(filename) DCNL DCSP cache_info = _FILE_CACHE.setdefault(filename, {}) DCNL DCSP if ((not cache_info) or (mtime > cache_info.get('mtime', 0))): DCNL DCSP  DCSP LOG.debug((_('Reloading DCSP cached DCSP file DCSP %s') % filename)) DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP reloaded = True DCNL DCSP return (reloaded, cache_info['data'])
 DCSP try: DCNL DCSP  DCSP os.unlink(path) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
 DCSP return file(*args, **kwargs)
 DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
 DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
 DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
 DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
 DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
 DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
 DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg) DCNL DCSP  DCSP conn.notify_send(topic, msg)
 DCSP return _get_impl().create_connection(CONF, new=new)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().cast(CONF, context, topic, msg)
 DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
 DCSP return _get_impl().cleanup()
 DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return (('%s.%s' % (topic, host)) if host else topic)
 DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP return Connection()
 DCSP json.dumps(msg)
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP namespace = msg.get('namespace', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, namespace, args, timeout)
 DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP namespace = msg.get('namespace', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, namespace, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
 DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
 DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
 DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (not queues): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
 DCSP return _multi_send(_call, *args, **kwargs)
 DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
 DCSP _multi_send(_cast, *args, **kwargs)
 DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
 DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
 DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
 DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
 DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), six.text_type(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP cls_name = str(failure.__class__.__name__) DCNL DCSP mod_name = str(failure.__class__.__module__) DCNL DCSP if (cls_name.endswith(_REMOTE_POSTFIX) and mod_name.endswith(_REMOTE_POSTFIX)): DCNL DCSP  DCSP cls_name = cls_name[:(- len(_REMOTE_POSTFIX))] DCNL DCSP  DCSP mod_name = mod_name[:(- len(_REMOTE_POSTFIX))] DCNL DCSP data = {'class': cls_name, 'module': mod_name, 'message': six.text_type(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
 DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise InvalidSortKey() DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in range(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in range(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP cfg.set_defaults(database_opts, connection=sql_connection) DCNL DCSP cfg.set_defaults(sqlite_db_opts, sqlite_db=sqlite_db) DCNL DCSP if (max_pool_size is not None): DCNL DCSP  DCSP cfg.set_defaults(database_opts, max_pool_size=max_pool_size) DCNL DCSP if (max_overflow is not None): DCNL DCSP  DCSP cfg.set_defaults(database_opts, max_overflow=max_overflow) DCNL DCSP if (pool_timeout is not None): DCNL DCSP  DCSP cfg.set_defaults(database_opts, pool_timeout=pool_timeout)
 DCSP global _MAKER DCNL DCSP global _SLAVE_MAKER DCNL DCSP maker = _MAKER DCNL DCSP if slave_session: DCNL DCSP  DCSP maker = _SLAVE_MAKER DCNL DCSP if (maker is None): DCNL DCSP  DCSP engine = get_engine(sqlite_fk=sqlite_fk, slave_engine=slave_session) DCNL DCSP  DCSP maker = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP if slave_session: DCNL DCSP  DCSP _SLAVE_MAKER = maker DCNL DCSP else: DCNL DCSP  DCSP _MAKER = maker DCNL DCSP session = maker() DCNL DCSP return session
 DCSP def get_columns_from_uniq_cons_or_name(columns): DCNL DCSP  DCSP uniqbase = 'uniq_' DCNL DCSP  DCSP if (not columns.startswith(uniqbase)): DCNL DCSP  DCSP  DCSP if (engine_name == 'postgresql'): DCNL DCSP  DCSP  DCSP  DCSP return [columns[(columns.index('_') + 1):columns.rindex('_')]] DCNL DCSP  DCSP  DCSP return [columns] DCNL DCSP  DCSP return columns[len(uniqbase):].split('0')[1:] DCNL DCSP if (engine_name not in ['mysql', 'sqlite', 'postgresql']): DCNL DCSP  DCSP return DCNL DCSP m = _DUP_KEY_RE_DB[engine_name].match(integrity_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP columns = m.group(1) DCNL DCSP if (engine_name == 'sqlite'): DCNL DCSP  DCSP columns = columns.strip().split(', DCSP ') DCNL DCSP else: DCNL DCSP  DCSP columns = get_columns_from_uniq_cons_or_name(columns) DCNL DCSP raise exception.DBDuplicateEntry(columns, integrity_error)
 DCSP re = _DEADLOCK_RE_DB.get(engine_name) DCNL DCSP if (re is None): DCNL DCSP  DCSP return DCNL DCSP m = re.match(operational_error.message) DCNL DCSP if (not m): DCNL DCSP  DCSP return DCNL DCSP raise exception.DBDeadlock(operational_error)
 DCSP global _ENGINE DCNL DCSP global _SLAVE_ENGINE DCNL DCSP engine = _ENGINE DCNL DCSP db_uri = CONF.database.connection DCNL DCSP if slave_engine: DCNL DCSP  DCSP engine = _SLAVE_ENGINE DCNL DCSP  DCSP db_uri = CONF.database.slave_connection DCNL DCSP if (engine is None): DCNL DCSP  DCSP engine = create_engine(db_uri, sqlite_fk=sqlite_fk) DCNL DCSP if slave_engine: DCNL DCSP  DCSP _SLAVE_ENGINE = engine DCNL DCSP else: DCNL DCSP  DCSP _ENGINE = engine DCNL DCSP return engine
 DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
 DCSP def regexp(expr, item): DCNL DCSP  DCSP reg = re.compile(expr) DCNL DCSP  DCSP return (reg.search(six.text_type(item)) is not None) DCNL DCSP dbapi_con.create_function('regexp', 2, regexp)
 DCSP greenthread.sleep(0)
 DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise sqla_exc.DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP _assert_matching_drivers() DCNL DCSP connection_dict = sqlalchemy.engine.url.make_url(sql_connection) DCNL DCSP engine_args = {'pool_recycle': CONF.database.idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP if (CONF.database.connection_debug >= 100): DCNL DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP elif (CONF.database.connection_debug >= 50): DCNL DCSP  DCSP engine_args['echo'] = True DCNL DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP if sqlite_fk: DCNL DCSP  DCSP  DCSP engine_args['listeners'] = [SqliteForeignKeysListener()] DCNL DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP if (CONF.database.connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP else: DCNL DCSP  DCSP if (CONF.database.max_pool_size is not None): DCNL DCSP  DCSP  DCSP engine_args['pool_size'] = CONF.database.max_pool_size DCNL DCSP  DCSP if (CONF.database.max_overflow is not None): DCNL DCSP  DCSP  DCSP engine_args['max_overflow'] = CONF.database.max_overflow DCNL DCSP  DCSP if (CONF.database.pool_timeout is not None): DCNL DCSP  DCSP  DCSP engine_args['pool_timeout'] = CONF.database.pool_timeout DCNL DCSP engine = sqlalchemy.create_engine(sql_connection, **engine_args) DCNL DCSP sqlalchemy.event.listen(engine, 'checkin', _greenthread_yield) DCNL DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'checkout', _ping_listener) DCNL DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP if (not CONF.sqlite_synchronous): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', _synchronous_switch_listener) DCNL DCSP  DCSP sqlalchemy.event.listen(engine, 'connect', _add_regexp_listener) DCNL DCSP if (CONF.database.connection_trace and (engine.dialect.dbapi.__name__ == 'MySQLdb')): DCNL DCSP  DCSP _patch_mysqldb_with_stacktrace_comments() DCNL DCSP try: DCNL DCSP  DCSP engine.connect() DCNL DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP if (not _is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP remaining = CONF.database.max_retries DCNL DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP time.sleep(CONF.database.retry_interval) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP engine.connect() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except sqla_exc.OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not _is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return engine
 DCSP return sqlalchemy.orm.sessionmaker(bind=engine, class_=Session, autocommit=autocommit, expire_on_commit=expire_on_commit, query_cls=Query)
 DCSP import MySQLdb.cursors DCNL DCSP import traceback DCNL DCSP old_mysql_do_query = MySQLdb.cursors.BaseCursor._do_query DCNL DCSP def _do_query(self, q): DCNL DCSP  DCSP stack = '' DCNL DCSP  DCSP for (file, line, method, function) in traceback.extract_stack(): DCNL DCSP  DCSP  DCSP if (file.endswith('session.py') and (method == '_do_query')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('api.py') and (method == 'wrapper')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('utils.py') and (method == '_inner')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (file.endswith('exception.py') and (method == '_wrap')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if file.endswith('db/api.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP index = file.rfind('ceilometer') DCNL DCSP  DCSP  DCSP if (index == (-1)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP stack += ('File:%s:%s DCSP Method:%s() DCSP Line:%s DCSP | DCSP ' % (file[index:], line, method, function)) DCNL DCSP  DCSP if stack: DCNL DCSP  DCSP  DCSP stack = stack[:(-3)] DCNL DCSP  DCSP  DCSP qq = ('%s DCSP /* DCSP %s DCSP */' % (q, stack)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qq = q DCNL DCSP  DCSP old_mysql_do_query(self, qq) DCNL DCSP setattr(MySQLdb.cursors.BaseCursor, '_do_query', _do_query)
 DCSP if (CONF.database.slave_connection == ''): DCNL DCSP  DCSP return DCNL DCSP normal = sqlalchemy.engine.url.make_url(CONF.database.connection) DCNL DCSP slave = sqlalchemy.engine.url.make_url(CONF.database.slave_connection) DCNL DCSP assert (normal.drivername == slave.drivername)
 DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %s') % rule)) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (not or_list): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
 DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
 DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
 DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
 DCSP return functools.partial(synchronized, lock_file_prefix=lock_file_prefix)
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP gettext.install(domain, localedir=os.environ.get((domain.upper() + '_LOCALEDIR')), unicode=True)
 DCSP def _lazy_gettext(msg): DCNL DCSP  DCSP 'Create DCSP and DCSP return DCSP a DCSP Message DCSP object.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Message DCSP encapsulates DCSP a DCSP string DCSP so DCSP that DCSP we DCSP can DCSP translate DCSP it DCSP later DCSP when\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP needed.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return Message(msg, domain) DCNL DCSP return _lazy_gettext
 DCSP for (key, value) in group._opts.items(): DCNL DCSP  DCSP if (value['opt'] == opt): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (BASEDIR in s): DCNL DCSP  DCSP return s.replace(BASEDIR, '') DCNL DCSP elif (s == _get_my_ip()): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == socket.gethostname()): DCNL DCSP  DCSP return 'ceilometer' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
 DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
 DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, datetime.datetime): DCNL DCSP  DCSP if convert_datetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP global drivers DCNL DCSP if (drivers is None): DCNL DCSP  DCSP drivers = [] DCNL DCSP  DCSP for notification_driver in CONF.list_notifier_drivers: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP drivers.append(importutils.import_module(notification_driver)) DCNL DCSP  DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP  DCSP drivers.append(ImportFailureNotifier(e)) DCNL DCSP return drivers
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP drivers.append(importutils.import_module(notification_driver)) DCNL DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP drivers.append(ImportFailureNotifier(e)) DCNL DCSP else: DCNL DCSP  DCSP drivers.append(notification_driver)
 DCSP _get_drivers() DCNL DCSP removed = False DCNL DCSP if (notification_driver in drivers): DCNL DCSP  DCSP drivers.remove(notification_driver) DCNL DCSP  DCSP removed = True DCNL DCSP else: DCNL DCSP  DCSP for driver in drivers: DCNL DCSP  DCSP  DCSP if (_object_name(driver) == notification_driver): DCNL DCSP  DCSP  DCSP  DCSP drivers.remove(driver) DCNL DCSP  DCSP  DCSP  DCSP removed = True DCNL DCSP if (not removed): DCNL DCSP  DCSP raise ValueError(('Cannot DCSP remove; DCSP %s DCSP is DCSP not DCSP in DCSP list' % notification_driver))
 DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, message) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception(_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP driver DCSP %(driver)s."), locals())
 DCSP global drivers DCNL DCSP drivers = None
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('ceilometer.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP root_helper = kwargs.pop('root_helper', '') DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP if kwargs: DCNL DCSP  DCSP raise UnknownArgumentError((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if (run_as_root and (os.geteuid() != 0)): DCNL DCSP  DCSP if (not root_helper): DCNL DCSP  DCSP  DCSP raise NoRootWrapSpecified(message='Command DCSP requested DCSP root, DCSP but DCSP did DCSP not DCSP specify DCSP a DCSP root DCSP helper.') DCNL DCSP  DCSP cmd = (shlex.split(root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = None DCNL DCSP  DCSP  DCSP  DCSP close_fds = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP preexec_fn = _subprocess_setup DCNL DCSP  DCSP  DCSP  DCSP close_fds = True DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=close_fds, preexec_fn=preexec_fn, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
 DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
 DCSP period_start = start DCNL DCSP increment = datetime.timedelta(seconds=period) DCNL DCSP for i in xrange(int(math.ceil((timeutils.delta_seconds(start, end) / float(period))))): DCNL DCSP  DCSP next_start = (period_start + increment) DCNL DCSP  DCSP (yield (period_start, next_start)) DCNL DCSP  DCSP period_start = next_start
 DCSP p = get_engine(conf) DCNL DCSP p.register_opts(conf)
 DCSP if conf.database_connection: DCNL DCSP  DCSP conf.set_override('connection', conf.database_connection, group='database') DCNL DCSP engine_name = urlparse.urlparse(conf.database.connection).scheme DCNL DCSP LOG.debug('looking DCSP for DCSP %r DCSP driver DCSP in DCSP %r', engine_name, STORAGE_ENGINE_NAMESPACE) DCNL DCSP mgr = driver.DriverManager(STORAGE_ENGINE_NAMESPACE, engine_name, invoke_on_load=True) DCNL DCSP return mgr.driver
 DCSP engine = get_engine(conf) DCNL DCSP engine.register_opts(conf) DCNL DCSP db = engine.get_connection(conf) DCNL DCSP return db
 DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
 DCSP if sample_filter.meter: DCNL DCSP  DCSP query = query.filter((Meter.counter_name == sample_filter.meter)) DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP query = query.filter(Meter.sources.any(id=sample_filter.source)) DCNL DCSP if sample_filter.start: DCNL DCSP  DCSP ts_start = sample_filter.start DCNL DCSP  DCSP query = query.filter((Meter.timestamp >= ts_start)) DCNL DCSP if sample_filter.end: DCNL DCSP  DCSP ts_end = sample_filter.end DCNL DCSP  DCSP query = query.filter((Meter.timestamp < ts_end)) DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP query = query.filter_by(user_id=sample_filter.user) DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP query = query.filter_by(project_id=sample_filter.project) DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP query = query.filter_by(resource_id=sample_filter.resource) DCNL DCSP if sample_filter.metaquery: DCNL DCSP  DCSP raise NotImplementedError('metaquery DCSP not DCSP implemented') DCNL DCSP return query
 DCSP ts_range = {} DCNL DCSP if start: DCNL DCSP  DCSP ts_range['$gte'] = start DCNL DCSP if end: DCNL DCSP  DCSP ts_range['$lt'] = end DCNL DCSP return ts_range
 DCSP q = {} DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP q['user_id'] = sample_filter.user DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP q['project_id'] = sample_filter.project DCNL DCSP if sample_filter.meter: DCNL DCSP  DCSP q['counter_name'] = sample_filter.meter DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP ts_range = make_timestamp_range(sample_filter.start, sample_filter.end) DCNL DCSP if ts_range: DCNL DCSP  DCSP q['timestamp'] = ts_range DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP q['resource_id'] = sample_filter.resource DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP q['source'] = sample_filter.source DCNL DCSP q.update(dict(((('resource_%s' % k), v) for (k, v) in sample_filter.metaquery.iteritems()))) DCNL DCSP return q
 DCSP try: DCNL DCSP  DCSP import spidermonkey DCNL DCSP except BaseException: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from ming import mim DCNL DCSP  DCSP  DCSP if (hasattr(conn, 'conn') and isinstance(conn.conn, mim.Connection)): DCNL DCSP  DCSP  DCSP  DCSP import testtools DCNL DCSP  DCSP  DCSP  DCSP raise testtools.testcase.TestSkipped('requires DCSP spidermonkey') DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP import testtools DCNL DCSP  DCSP  DCSP raise testtools.testcase.TestSkipped('requires DCSP mim')
 DCSP epoch = datetime.datetime(1970, 1, 1) DCNL DCSP td = (dt - epoch) DCNL DCSP ts = ((td.microseconds + ((td.seconds + ((td.days * 24) * 3600)) * 100000)) / 100000) DCNL DCSP return (9223372036854775807 - ts)
 DCSP q = [] DCNL DCSP if user: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'user_id', DCSP =, DCSP 'binary:%s')" % user)) DCNL DCSP if project: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'project_id', DCSP =, DCSP 'binary:%s')" % project)) DCNL DCSP if resource: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'resource_id', DCSP =, DCSP 'binary:%s')" % resource)) DCNL DCSP if source: DCNL DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'source', DCSP =, DCSP 'binary:%s')" % source)) DCNL DCSP (start_row, end_row) = ('', '') DCNL DCSP rts_start = (str((reverse_timestamp(start) + 1)) if start else '') DCNL DCSP rts_end = (str((reverse_timestamp(end) + 1)) if end else '') DCNL DCSP if meter: DCNL DCSP  DCSP (start_row, end_row) = _make_rowkey_scan(meter, rts_start, rts_end) DCNL DCSP elif require_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP required DCSP meter DCSP specifier') DCNL DCSP else: DCNL DCSP  DCSP if rts_start: DCNL DCSP  DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'rts', DCSP <=, DCSP 'binary:%s')" % rts_start)) DCNL DCSP  DCSP if rts_end: DCNL DCSP  DCSP  DCSP q.append(("SingleColumnValueFilter DCSP ('f', DCSP 'rts', DCSP >=, DCSP 'binary:%s')" % rts_end)) DCNL DCSP sample_filter = None DCNL DCSP if len(q): DCNL DCSP  DCSP sample_filter = ' DCSP AND DCSP '.join(q) DCNL DCSP if query_only: DCNL DCSP  DCSP return sample_filter DCNL DCSP else: DCNL DCSP  DCSP return (sample_filter, start_row, end_row)
 DCSP return make_query(sample_filter.user, sample_filter.project, sample_filter.meter, sample_filter.resource, sample_filter.source, sample_filter.start, sample_filter.end, require_meter)
 DCSP if (not rts_start): DCNL DCSP  DCSP rts_start = chr(127) DCNL DCSP end_row = ('%s_%s' % (meter, rts_start)) DCNL DCSP start_row = ('%s_%s' % (meter, rts_end)) DCNL DCSP return (start_row, end_row)
 DCSP ret = [] DCNL DCSP prefix = ('f:%s_' % prefix) DCNL DCSP for key in (k for k in d if k.startswith(prefix)): DCNL DCSP  DCSP ret.append(key[len(prefix):]) DCNL DCSP return ret
 DCSP return getattr(instance, 'OS-EXT-SRV-ATTR:instance_name', None)
 DCSP global _gatherer DCNL DCSP if (gatherer is not None): DCNL DCSP  DCSP LOG.debug(_('using DCSP provided DCSP stats DCSP gatherer DCSP %r'), gatherer) DCNL DCSP  DCSP _gatherer = gatherer DCNL DCSP if (_gatherer is None): DCNL DCSP  DCSP LOG.debug(_('making DCSP a DCSP new DCSP stats DCSP gatherer')) DCNL DCSP  DCSP mgr = extension.ExtensionManager(namespace='ceilometer.poll.compute', invoke_on_load=True) DCNL DCSP  DCSP _gatherer = DeletedInstanceStatsGatherer(mgr) DCNL DCSP return _gatherer
 DCSP metadata = {'display_name': instance.name, 'name': getattr(instance, 'OS-EXT-SRV-ATTR:instance_name', u''), 'instance_type': (instance.flavor['id'] if instance.flavor else None), 'host': instance.hostId, 'image_ref': (instance.image['id'] if instance.image else None)} DCNL DCSP if (instance.image and instance.image.get('links')): DCNL DCSP  DCSP metadata['image_ref_url'] = instance.image['links'][0]['href'] DCNL DCSP else: DCNL DCSP  DCSP metadata['image_ref_url'] = None DCNL DCSP for name in INSTANCE_PROPERTIES: DCNL DCSP  DCSP metadata[name] = getattr(instance, name, u'') DCNL DCSP return metadata
 DCSP config_file = os.environ.get('SWIFT_TEST_CONFIG_FILE', '/etc/swift/test.conf') DCNL DCSP config = {} DCNL DCSP if (defaults is not None): DCNL DCSP  DCSP config.update(defaults) DCNL DCSP try: DCNL DCSP  DCSP config = readconf(config_file, section_name) DCNL DCSP except SystemExit: DCNL DCSP  DCSP if (not os.path.exists(config_file)): DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Unable DCSP to DCSP read DCSP test DCSP config DCSP %s DCSP - DCSP file DCSP not DCSP found' % config_file) DCNL DCSP  DCSP elif (not os.access(config_file, os.R_OK)): DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Unable DCSP to DCSP read DCSP test DCSP config DCSP %s DCSP - DCSP permission DCSP denied' % config_file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print >>sys.stderr, ('Unable DCSP to DCSP read DCSP test DCSP config DCSP %s DCSP - DCSP section DCSP %s DCSP not DCSP found' % (config_file, section_name)) DCNL DCSP return config
 DCSP global url, token, parsed, conn DCNL DCSP retries = kwargs.get('retries', 5) DCNL DCSP use_account = 1 DCNL DCSP if ('use_account' in kwargs): DCNL DCSP  DCSP use_account = kwargs['use_account'] DCNL DCSP  DCSP del kwargs['use_account'] DCNL DCSP use_account -= 1 DCNL DCSP attempts = 0 DCNL DCSP backoff = 1 DCNL DCSP while (attempts <= retries): DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((not url[use_account]) or (not token[use_account])): DCNL DCSP  DCSP  DCSP  DCSP (url[use_account], token[use_account]) = get_auth(swift_test_auth, swift_test_user[use_account], swift_test_key[use_account], snet=False, tenant_name=swift_test_tenant[use_account], auth_version=swift_test_auth_version, os_options={}) DCNL DCSP  DCSP  DCSP  DCSP parsed[use_account] = conn[use_account] = None DCNL DCSP  DCSP  DCSP if ((not parsed[use_account]) or (not conn[use_account])): DCNL DCSP  DCSP  DCSP  DCSP (parsed[use_account], conn[use_account]) = http_connection(url[use_account]) DCNL DCSP  DCSP  DCSP return func(url[use_account], token[use_account], parsed[use_account], conn[use_account], *args, **kwargs) DCNL DCSP  DCSP except (socket.error, HTTPException): DCNL DCSP  DCSP  DCSP if (attempts > retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP parsed[use_account] = conn[use_account] = None DCNL DCSP  DCSP except AuthError as err: DCNL DCSP  DCSP  DCSP url[use_account] = token[use_account] = None DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except InternalServerError as err: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (attempts <= retries): DCNL DCSP  DCSP  DCSP sleep(backoff) DCNL DCSP  DCSP  DCSP backoff *= 2 DCNL DCSP raise Exception(('No DCSP result DCSP after DCSP %s DCSP retries.' % retries))
 DCSP reload(db_replicator)
 DCSP if (put_timestamp is None): DCNL DCSP  DCSP put_timestamp = normalize_timestamp(0) DCNL DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP container_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_used DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_bytes_used DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP default DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changed_at DCSP TEXT DCSP DEFAULT DCSP '0'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP container_stat DCSP (object_count, DCSP bytes_used)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VALUES DCSP (0, DCSP 0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP container_stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SET DCSP account DCSP = DCSP ?, DCSP container DCSP = DCSP ?, DCSP created_at DCSP = DCSP ?, DCSP id DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP ', (self.account, self.container, normalize_timestamp(time()), str(uuid4()), put_timestamp))
 DCSP if (put_timestamp is None): DCNL DCSP  DCSP put_timestamp = normalize_timestamp(0) DCNL DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP container_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_used DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reported_bytes_used DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP default DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changed_at DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP metadata DCSP TEXT DCSP DEFAULT DCSP ''\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP container_stat DCSP (object_count, DCSP bytes_used)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP VALUES DCSP (0, DCSP 0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP container_stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SET DCSP account DCSP = DCSP ?, DCSP container DCSP = DCSP ?, DCSP created_at DCSP = DCSP ?, DCSP id DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP ', (self.account, self.container, normalize_timestamp(time()), str(uuid4()), put_timestamp))
 DCSP conn.executescript("\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP account_stat DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP account DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP created_at DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP delete_timestamp DCSP TEXT DCSP DEFAULT DCSP '0',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_count DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP object_count DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bytes_used DCSP INTEGER DCSP DEFAULT DCSP 0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hash DCSP TEXT DCSP default DCSP '00000000000000000000000000000000',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP id DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP TEXT DCSP DEFAULT DCSP '',\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status_changed_at DCSP TEXT DCSP DEFAULT DCSP '0'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INSERT DCSP INTO DCSP account_stat DCSP (container_count) DCSP VALUES DCSP (0);\n DCSP  DCSP  DCSP  DCSP ") DCNL DCSP conn.execute('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UPDATE DCSP account_stat DCSP SET DCSP account DCSP = DCSP ?, DCSP created_at DCSP = DCSP ?, DCSP id DCSP = DCSP ?,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP put_timestamp DCSP = DCSP ?\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ', (self.account, normalize_timestamp(time()), str(uuid4()), put_timestamp))
 DCSP f.flush() DCNL DCSP f.seek(0) DCNL DCSP output = f.read() DCNL DCSP f.seek(0) DCNL DCSP f.truncate() DCNL DCSP return output
 DCSP headers = [a.strip() for a in headerNames.split(',') if a.strip()] DCNL DCSP headers.sort() DCNL DCSP return ', DCSP '.join(headers)
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return ContainerController(conf)
 DCSP return dict(((col[0], row[idx]) for (idx, col) in enumerate(crs.description)))
 DCSP if (name is None): DCNL DCSP  DCSP raise Exception('name DCSP is DCSP None!') DCNL DCSP new = hashlib.md5(('%s-%s' % (name, timestamp)).encode('utf8')).hexdigest() DCNL DCSP return ('%032x' % (int(old, 16) ^ int(new, 16)))
 DCSP try: DCNL DCSP  DCSP connect_time = time.time() DCNL DCSP  DCSP conn = sqlite3.connect(path, check_same_thread=False, factory=GreenDBConnection, timeout=timeout) DCNL DCSP  DCSP if ((path != ':memory:') and (not okay_to_create)): DCNL DCSP  DCSP  DCSP stat = os.stat(path) DCNL DCSP  DCSP  DCSP if ((stat.st_size == 0) and (stat.st_ctime >= connect_time)): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(path) DCNL DCSP  DCSP  DCSP  DCSP raise DatabaseConnectionError(path, 'DB DCSP file DCSP created DCSP by DCSP connect?') DCNL DCSP  DCSP conn.row_factory = sqlite3.Row DCNL DCSP  DCSP conn.text_factory = str DCNL DCSP  DCSP conn.execute('PRAGMA DCSP synchronous DCSP = DCSP NORMAL') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP count_changes DCSP = DCSP OFF') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP temp_store DCSP = DCSP MEMORY') DCNL DCSP  DCSP conn.execute('PRAGMA DCSP journal_mode DCSP = DCSP DELETE') DCNL DCSP  DCSP conn.create_function('chexor', 3, chexor) DCNL DCSP except sqlite3.DatabaseError: DCNL DCSP  DCSP import traceback DCNL DCSP  DCSP raise DatabaseConnectionError(path, traceback.format_exc(), timeout=timeout) DCNL DCSP return conn
 DCSP if (section_name is ''): DCNL DCSP  DCSP section_name = sub('([a-z])([A-Z])', '\\1-\\2', klass.__name__).lower() DCNL DCSP conf = utils.readconf(conf_file, section_name, log_name=kwargs.get('log_name')) DCNL DCSP once = (once or (not utils.config_true_value(conf.get('daemonize', 'true')))) DCNL DCSP if ('logger' in kwargs): DCNL DCSP  DCSP logger = kwargs.pop('logger') DCNL DCSP else: DCNL DCSP  DCSP logger = utils.get_logger(conf, conf.get('log_name', section_name), log_to_console=kwargs.pop('verbose', False), log_route=section_name) DCNL DCSP if utils.config_true_value(conf.get('disable_fallocate', 'no')): DCNL DCSP  DCSP utils.disable_fallocate() DCNL DCSP reserve = int(conf.get('fallocate_reserve', 0)) DCNL DCSP if (reserve > 0): DCNL DCSP  DCSP utils.FALLOCATE_RESERVE = reserve DCNL DCSP eventlet_debug = utils.config_true_value(conf.get('eventlet_debug', 'no')) DCNL DCSP eventlet.debug.hub_exceptions(eventlet_debug) DCNL DCSP try: DCNL DCSP  DCSP klass(conf).run(once=once, **kwargs) DCNL DCSP except KeyboardInterrupt: DCNL DCSP  DCSP logger.info('User DCSP quit') DCNL DCSP logger.info('Exited')
 DCSP if isinstance(path, unicode): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP path = path.encode('utf-8') DCNL DCSP  DCSP except UnicodeError as e: DCNL DCSP  DCSP  DCSP logging.exception(_('Error DCSP encoding DCSP to DCSP UTF-8: DCSP %s'), e.message) DCNL DCSP path = quote((((('/' + device) + '/') + str(partition)) + path)) DCNL DCSP return http_connect_raw(ipaddr, port, method, path, headers, query_string, ssl)
 DCSP if (not port): DCNL DCSP  DCSP port = (443 if ssl else 80) DCNL DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP else: DCNL DCSP  DCSP conn = BufferedHTTPConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP if query_string: DCNL DCSP  DCSP path += ('?' + query_string) DCNL DCSP conn.path = path DCNL DCSP conn.putrequest(method, path, skip_host=(headers and ('Host' in headers))) DCNL DCSP if headers: DCNL DCSP  DCSP for (header, value) in headers.iteritems(): DCNL DCSP  DCSP  DCSP conn.putheader(header, str(value)) DCNL DCSP conn.endheaders() DCNL DCSP return conn
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return TempAuth(app, conf) DCNL DCSP return auth_filter
 DCSP if isinstance(value, unicode): DCNL DCSP  DCSP value = value.encode('utf-8') DCNL DCSP return urllib_quote(value, safe)
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def staticweb_filter(app): DCNL DCSP  DCSP return StaticWeb(app, conf) DCNL DCSP return staticweb_filter
 DCSP def account_quota_filter(app): DCNL DCSP  DCSP return AccountQuotaMiddleware(app) DCNL DCSP return account_quota_filter
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return (lambda app: TempURL(app, conf))
 DCSP try: DCNL DCSP  DCSP parsed_data = json.loads(raw_data) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPBadRequest('Manifest DCSP must DCSP be DCSP valid DCSP json.') DCNL DCSP req_keys = set(['path', 'etag', 'size_bytes']) DCNL DCSP try: DCNL DCSP  DCSP for seg_dict in parsed_data: DCNL DCSP  DCSP  DCSP if ((set(seg_dict.keys()) != req_keys) or ('/' not in seg_dict['path'].lstrip('/'))): DCNL DCSP  DCSP  DCSP  DCSP raise HTTPBadRequest('Invalid DCSP SLO DCSP Manifest DCSP File') DCNL DCSP except (AttributeError, TypeError): DCNL DCSP  DCSP raise HTTPBadRequest('Invalid DCSP SLO DCSP Manifest DCSP File') DCNL DCSP return parsed_data
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return KeystoneAuth(app, conf) DCNL DCSP return auth_filter
 DCSP name = name.lower() DCNL DCSP values = [] DCNL DCSP for raw_value in value.split(','): DCNL DCSP  DCSP raw_value = raw_value.strip() DCNL DCSP  DCSP if raw_value: DCNL DCSP  DCSP  DCSP if (':' not in raw_value): DCNL DCSP  DCSP  DCSP  DCSP values.append(raw_value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (first, second) = (v.strip() for v in raw_value.split(':', 1)) DCNL DCSP  DCSP  DCSP  DCSP if ((not first) or (first[0] != '.')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP values.append(raw_value) DCNL DCSP  DCSP  DCSP  DCSP elif (first in ('.r', '.ref', '.referer', '.referrer')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('write' in name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Referrers DCSP not DCSP allowed DCSP in DCSP write DCSP ACL: DCSP %s' % repr(raw_value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP negate = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (second and (second[0] == '-')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP negate = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP second = second[1:].strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (second and (second != '*') and (second[0] == '*')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP second = second[1:].strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not second) or (second == '.')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('No DCSP host/domain DCSP value DCSP after DCSP referrer DCSP designation DCSP in DCSP ACL: DCSP %s' % repr(raw_value))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP values.append(('.r:%s%s' % (((negate and '-') or ''), second))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP designator DCSP %s DCSP in DCSP ACL: DCSP %s' % (repr(first), repr(raw_value)))) DCNL DCSP return ','.join(values)
 DCSP referrers = [] DCNL DCSP groups = [] DCNL DCSP if acl_string: DCNL DCSP  DCSP for value in acl_string.split(','): DCNL DCSP  DCSP  DCSP if value.startswith('.r:'): DCNL DCSP  DCSP  DCSP  DCSP referrers.append(value[len('.r:'):]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP groups.append(value) DCNL DCSP return (referrers, groups)
 DCSP allow = False DCNL DCSP if referrer_acl: DCNL DCSP  DCSP rhost = (urlparse((referrer or '')).hostname or 'unknown') DCNL DCSP  DCSP for mhost in referrer_acl: DCNL DCSP  DCSP  DCSP if (mhost[0] == '-'): DCNL DCSP  DCSP  DCSP  DCSP mhost = mhost[1:] DCNL DCSP  DCSP  DCSP  DCSP if ((mhost == rhost) or ((mhost[0] == '.') and rhost.endswith(mhost))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP allow = False DCNL DCSP  DCSP  DCSP elif ((mhost == '*') or (mhost == rhost) or ((mhost[0] == '.') and rhost.endswith(mhost))): DCNL DCSP  DCSP  DCSP  DCSP allow = True DCNL DCSP return allow
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def limit_filter(app): DCNL DCSP  DCSP return RateLimitMiddleware(app, conf) DCNL DCSP return limit_filter
 DCSP try: DCNL DCSP  DCSP answer = dns.resolver.query(domain, 'CNAME').rrset DCNL DCSP  DCSP ttl = answer.ttl DCNL DCSP  DCSP result = answer.items[0].to_text() DCNL DCSP  DCSP result = result.rstrip('.') DCNL DCSP  DCSP return (ttl, result) DCNL DCSP except (DNSException, NXDOMAIN, NoAnswer): DCNL DCSP  DCSP return (0, None)
 DCSP attributes = {} DCNL DCSP attrs = '' DCNL DCSP if ('; DCSP ' in header): DCNL DCSP  DCSP (header, attrs) = header.split('; DCSP ', 1) DCNL DCSP m = True DCNL DCSP while m: DCNL DCSP  DCSP m = ATTRIBUTES_RE.match(attrs) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP attrs = attrs[len(m.group(0)):] DCNL DCSP  DCSP  DCSP attributes[m.group(1)] = m.group(2).strip('"') DCNL DCSP return (header, attributes)
 DCSP boundary = ('--' + boundary) DCNL DCSP if (wsgi_input.readline().strip() != boundary): DCNL DCSP  DCSP raise FormInvalid('invalid DCSP starting DCSP boundary') DCNL DCSP boundary = ('\r\n' + boundary) DCNL DCSP input_buffer = '' DCNL DCSP done = False DCNL DCSP while (not done): DCNL DCSP  DCSP it = _IterRequestsFileLikeObject(wsgi_input, boundary, input_buffer) DCNL DCSP  DCSP (yield it) DCNL DCSP  DCSP done = it.no_more_files DCNL DCSP  DCSP input_buffer = it.input_buffer
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return (lambda app: FormPost(app, conf))
 DCSP if (data_format == 'text/plain'): DCNL DCSP  DCSP output = '' DCNL DCSP  DCSP for key in sorted(data_dict.keys()): DCNL DCSP  DCSP  DCSP output += ('%s: DCSP %s\n' % (key, data_dict[key])) DCNL DCSP  DCSP output += 'Errors:\n' DCNL DCSP  DCSP output += '\n'.join([('%s, DCSP %s' % (name, status)) for (name, status) in error_list]) DCNL DCSP  DCSP return output DCNL DCSP if (data_format == 'application/json'): DCNL DCSP  DCSP data_dict['Errors'] = error_list DCNL DCSP  DCSP return json.dumps(data_dict) DCNL DCSP if data_format.endswith('/xml'): DCNL DCSP  DCSP output = '<?xml DCSP version="1.0" DCSP encoding="UTF-8"?>\n<delete>\n' DCNL DCSP  DCSP for key in sorted(data_dict.keys()): DCNL DCSP  DCSP  DCSP xml_key = key.replace(' DCSP ', '_').lower() DCNL DCSP  DCSP  DCSP output += ('<%s>%s</%s>\n' % (xml_key, data_dict[key], xml_key)) DCNL DCSP  DCSP output += '<errors>\n' DCNL DCSP  DCSP output += '\n'.join([('<object><name>%s</name><status>%s</status></object>' % (saxutils.escape(name), status)) for (name, status) in error_list]) DCNL DCSP  DCSP output += '</errors>\n</delete>\n' DCNL DCSP  DCSP return output DCNL DCSP raise HTTPNotAcceptable('Invalid DCSP output DCSP type')
 DCSP f.seek(0, os.SEEK_END) DCNL DCSP if (f.tell() == 0): DCNL DCSP  DCSP return DCNL DCSP last_row = '' DCNL DCSP while (f.tell() != 0): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP blocksize = f.tell() DCNL DCSP  DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP block = f.read(blocksize) DCNL DCSP  DCSP f.seek((- blocksize), os.SEEK_CUR) DCNL DCSP  DCSP rows = block.split('\n') DCNL DCSP  DCSP rows[(-1)] = (rows[(-1)] + last_row) DCNL DCSP  DCSP while rows: DCNL DCSP  DCSP  DCSP last_row = rows.pop((-1)) DCNL DCSP  DCSP  DCSP if (rows and last_row): DCNL DCSP  DCSP  DCSP  DCSP (yield last_row) DCNL DCSP (yield last_row)
 DCSP return ((value is True) or (isinstance(value, basestring) and (value.lower() in TRUE_VALUES)))
 DCSP try: DCNL DCSP  DCSP libc = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True) DCNL DCSP  DCSP return getattr(libc, func_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if log_error: DCNL DCSP  DCSP  DCSP logging.warn(_('Unable DCSP to DCSP locate DCSP %s DCSP in DCSP libc. DCSP  DCSP Leaving DCSP as DCSP a DCSP no-op.'), func_name) DCNL DCSP  DCSP return noop_libc_function
 DCSP value = req.params.get(name, default) DCNL DCSP if (value and (not isinstance(value, unicode))): DCNL DCSP  DCSP value.decode('utf8') DCNL DCSP return value
 DCSP global _sys_fallocate DCNL DCSP if (_sys_fallocate is None): DCNL DCSP  DCSP _sys_fallocate = FallocateWrapper() DCNL DCSP if (size < 0): DCNL DCSP  DCSP size = 0 DCNL DCSP ret = _sys_fallocate(fd, 1, 0, ctypes.c_uint64(size)) DCNL DCSP err = ctypes.get_errno() DCNL DCSP if (ret and (err not in (0, errno.ENOSYS, errno.EOPNOTSUPP, errno.EINVAL))): DCNL DCSP  DCSP raise OSError(err, ('Unable DCSP to DCSP fallocate(%s)' % size))
 DCSP if hasattr(fcntl, 'F_FULLSYNC'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fcntl.fcntl(fd, fcntl.F_FULLSYNC) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP raise OSError(e.errno, ('Unable DCSP to DCSP F_FULLSYNC(%s)' % fd)) DCNL DCSP else: DCNL DCSP  DCSP os.fsync(fd)
 DCSP try: DCNL DCSP  DCSP os.fdatasync(fd) DCNL DCSP except AttributeError: DCNL DCSP  DCSP fsync(fd)
 DCSP global _posix_fadvise DCNL DCSP if (_posix_fadvise is None): DCNL DCSP  DCSP _posix_fadvise = load_libc_function('posix_fadvise64') DCNL DCSP ret = _posix_fadvise(fd, ctypes.c_uint64(offset), ctypes.c_uint64(length), 4) DCNL DCSP if (ret != 0): DCNL DCSP  DCSP logging.warn(('posix_fadvise64(%s, DCSP %s, DCSP %s, DCSP 4) DCSP -> DCSP %s' % (fd, offset, length, ret)))
 DCSP return ('%016.05f' % float(timestamp))
 DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(path) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if ((err.errno != errno.EEXIST) or (not os.path.isdir(path))): DCNL DCSP  DCSP  DCSP  DCSP raise
 DCSP try: DCNL DCSP  DCSP mkdirs(os.path.dirname(new)) DCNL DCSP  DCSP os.rename(old, new) DCNL DCSP except OSError: DCNL DCSP  DCSP mkdirs(os.path.dirname(new)) DCNL DCSP  DCSP os.rename(old, new)
 DCSP if (not maxsegs): DCNL DCSP  DCSP maxsegs = minsegs DCNL DCSP if (minsegs > maxsegs): DCNL DCSP  DCSP raise ValueError(('minsegs DCSP > DCSP maxsegs: DCSP %d DCSP > DCSP %d' % (minsegs, maxsegs))) DCNL DCSP if rest_with_last: DCNL DCSP  DCSP segs = path.split('/', maxsegs) DCNL DCSP  DCSP minsegs += 1 DCNL DCSP  DCSP maxsegs += 1 DCNL DCSP  DCSP count = len(segs) DCNL DCSP  DCSP if (segs[0] or (count < minsegs) or (count > maxsegs) or ('' in segs[1:minsegs])): DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP path: DCSP %s' % quote(path))) DCNL DCSP else: DCNL DCSP  DCSP minsegs += 1 DCNL DCSP  DCSP maxsegs += 1 DCNL DCSP  DCSP segs = path.split('/', maxsegs) DCNL DCSP  DCSP count = len(segs) DCNL DCSP  DCSP if (segs[0] or (count < minsegs) or (count > (maxsegs + 1)) or ('' in segs[1:minsegs]) or ((count == (maxsegs + 1)) and segs[maxsegs])): DCNL DCSP  DCSP  DCSP raise ValueError(('Invalid DCSP path: DCSP %s' % quote(path))) DCNL DCSP segs = segs[1:maxsegs] DCNL DCSP segs.extend(([None] * ((maxsegs - 1) - len(segs)))) DCNL DCSP return segs
 DCSP invalid_device = False DCNL DCSP invalid_partition = False DCNL DCSP if ((not device) or ('/' in device) or (device in ['.', '..'])): DCNL DCSP  DCSP invalid_device = True DCNL DCSP if ((not partition) or ('/' in partition) or (partition in ['.', '..'])): DCNL DCSP  DCSP invalid_partition = True DCNL DCSP if invalid_device: DCNL DCSP  DCSP raise ValueError(('Invalid DCSP device: DCSP %s' % quote((device or '')))) DCNL DCSP elif invalid_partition: DCNL DCSP  DCSP raise ValueError(('Invalid DCSP partition: DCSP %s' % quote((partition or ''))))
 DCSP def decorating_func(func): DCNL DCSP  DCSP method = func.func_name DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _timing_stats(ctrl, *args, **kwargs): DCNL DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP resp = func(ctrl, *args, **kwargs) DCNL DCSP  DCSP  DCSP if (is_success(resp.status_int) or is_redirection(resp.status_int) or (resp.status_int == HTTP_NOT_FOUND)): DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((method + '.timing'), start_time, **dec_kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ctrl.logger.timing_since((method + '.errors.timing'), start_time, **dec_kwargs) DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP return _timing_stats DCNL DCSP return decorating_func
 DCSP if (not conf): DCNL DCSP  DCSP conf = {} DCNL DCSP if (name is None): DCNL DCSP  DCSP name = conf.get('log_name', 'swift') DCNL DCSP if (not log_route): DCNL DCSP  DCSP log_route = name DCNL DCSP logger = logging.getLogger(log_route) DCNL DCSP logger.propagate = False DCNL DCSP formatter = SwiftLogFormatter(fmt) DCNL DCSP if (not hasattr(get_logger, 'handler4logger')): DCNL DCSP  DCSP get_logger.handler4logger = {} DCNL DCSP if (logger in get_logger.handler4logger): DCNL DCSP  DCSP logger.removeHandler(get_logger.handler4logger[logger]) DCNL DCSP facility = getattr(SysLogHandler, conf.get('log_facility', 'LOG_LOCAL0'), SysLogHandler.LOG_LOCAL0) DCNL DCSP udp_host = conf.get('log_udp_host') DCNL DCSP if udp_host: DCNL DCSP  DCSP udp_port = int(conf.get('log_udp_port', logging.handlers.SYSLOG_UDP_PORT)) DCNL DCSP  DCSP handler = SysLogHandler(address=(udp_host, udp_port), facility=facility) DCNL DCSP else: DCNL DCSP  DCSP log_address = conf.get('log_address', '/dev/log') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP handler = SysLogHandler(address=log_address, facility=facility) DCNL DCSP  DCSP except socket.error as e: DCNL DCSP  DCSP  DCSP if (e.errno not in [errno.ENOTSOCK, errno.ENOENT]): DCNL DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP handler = SysLogHandler(facility=facility) DCNL DCSP handler.setFormatter(formatter) DCNL DCSP logger.addHandler(handler) DCNL DCSP get_logger.handler4logger[logger] = handler DCNL DCSP if (log_to_console or hasattr(get_logger, 'console_handler4logger')): DCNL DCSP  DCSP if (not hasattr(get_logger, 'console_handler4logger')): DCNL DCSP  DCSP  DCSP get_logger.console_handler4logger = {} DCNL DCSP  DCSP if (logger in get_logger.console_handler4logger): DCNL DCSP  DCSP  DCSP logger.removeHandler(get_logger.console_handler4logger[logger]) DCNL DCSP  DCSP console_handler = logging.StreamHandler(sys.__stderr__) DCNL DCSP  DCSP console_handler.setFormatter(formatter) DCNL DCSP  DCSP logger.addHandler(console_handler) DCNL DCSP  DCSP get_logger.console_handler4logger[logger] = console_handler DCNL DCSP logger.setLevel(getattr(logging, conf.get('log_level', 'INFO').upper(), logging.INFO)) DCNL DCSP statsd_host = conf.get('log_statsd_host') DCNL DCSP if statsd_host: DCNL DCSP  DCSP statsd_port = int(conf.get('log_statsd_port', 8125)) DCNL DCSP  DCSP base_prefix = conf.get('log_statsd_metric_prefix', '') DCNL DCSP  DCSP default_sample_rate = float(conf.get('log_statsd_default_sample_rate', 1)) DCNL DCSP  DCSP sample_rate_factor = float(conf.get('log_statsd_sample_rate_factor', 1)) DCNL DCSP  DCSP statsd_client = StatsdClient(statsd_host, statsd_port, base_prefix, name, default_sample_rate, sample_rate_factor) DCNL DCSP  DCSP logger.statsd_client = statsd_client DCNL DCSP else: DCNL DCSP  DCSP logger.statsd_client = None DCNL DCSP adapted_logger = LogAdapter(logger, name) DCNL DCSP other_handlers = conf.get('log_custom_handlers', None) DCNL DCSP if other_handlers: DCNL DCSP  DCSP log_custom_handlers = [s.strip() for s in other_handlers.split(',') if s.strip()] DCNL DCSP  DCSP for hook in log_custom_handlers: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (mod, fnc) = hook.rsplit('.', 1) DCNL DCSP  DCSP  DCSP  DCSP logger_hook = getattr(__import__(mod, fromlist=[fnc]), fnc) DCNL DCSP  DCSP  DCSP  DCSP logger_hook(conf, name, log_to_console, log_route, fmt, logger, adapted_logger) DCNL DCSP  DCSP  DCSP except (AttributeError, ImportError): DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ('Error DCSP calling DCSP custom DCSP handler DCSP [%s]' % hook) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ('Invalid DCSP custom DCSP handler DCSP format DCSP [%s]' % hook) DCNL DCSP return adapted_logger
 DCSP try: DCNL DCSP  DCSP import select DCNL DCSP  DCSP if hasattr(select, 'poll'): DCNL DCSP  DCSP  DCSP return 'poll' DCNL DCSP  DCSP return 'selects' DCNL DCSP except ImportError: DCNL DCSP  DCSP return None
 DCSP user = pwd.getpwnam(user) DCNL DCSP if (os.geteuid() == 0): DCNL DCSP  DCSP os.setgroups([]) DCNL DCSP os.setgid(user[3]) DCNL DCSP os.setuid(user[2]) DCNL DCSP os.environ['HOME'] = user[5] DCNL DCSP try: DCNL DCSP  DCSP os.setsid() DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP os.chdir('/') DCNL DCSP os.umask(18)
 DCSP sys.excepthook = (lambda *exc_info: logger.critical(_('UNCAUGHT DCSP EXCEPTION'), exc_info=exc_info)) DCNL DCSP stdio_files = [sys.stdin, sys.stdout, sys.stderr] DCNL DCSP console_fds = [h.stream.fileno() for (_junk, h) in getattr(get_logger, 'console_handler4logger', {}).items()] DCNL DCSP stdio_files = [f for f in stdio_files if (f.fileno() not in console_fds)] DCNL DCSP with open(os.devnull, 'r+b') as nullfile: DCNL DCSP  DCSP for f in stdio_files: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP f.flush() DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.dup2(nullfile.fileno(), f.fileno()) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if kwargs.pop('capture_stdout', True): DCNL DCSP  DCSP sys.stdout = LoggerFileObject(logger) DCNL DCSP if kwargs.pop('capture_stderr', True): DCNL DCSP  DCSP sys.stderr = LoggerFileObject(logger)
 DCSP if (not parser): DCNL DCSP  DCSP parser = OptionParser(usage='%prog DCSP CONFIG DCSP [options]') DCNL DCSP parser.add_option('-v', '--verbose', default=False, action='store_true', help='log DCSP to DCSP console') DCNL DCSP if once: DCNL DCSP  DCSP parser.add_option('-o', '--once', default=False, action='store_true', help='only DCSP run DCSP one DCSP pass DCSP of DCSP daemon') DCNL DCSP (options, args) = parser.parse_args(args=test_args) DCNL DCSP if (not args): DCNL DCSP  DCSP parser.print_usage() DCNL DCSP  DCSP print _('Error: DCSP missing DCSP config DCSP file DCSP argument') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP config = os.path.abspath(args.pop(0)) DCNL DCSP if (not os.path.exists(config)): DCNL DCSP  DCSP parser.print_usage() DCNL DCSP  DCSP print (_('Error: DCSP unable DCSP to DCSP locate DCSP %s') % config) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP extra_args = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP if (arg in options.__dict__): DCNL DCSP  DCSP  DCSP setattr(options, arg, True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra_args.append(arg) DCNL DCSP options = vars(options) DCNL DCSP if extra_args: DCNL DCSP  DCSP options['extra_args'] = extra_args DCNL DCSP return (config, options)
 DCSP addresses = [] DCNL DCSP for interface in netifaces.interfaces(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iface_data = netifaces.ifaddresses(interface) DCNL DCSP  DCSP  DCSP for family in iface_data: DCNL DCSP  DCSP  DCSP  DCSP if (family not in (netifaces.AF_INET, netifaces.AF_INET6)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP for address in iface_data[family]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP addresses.append(address['addr']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return addresses
 DCSP return os.path.join(datadir, str(partition), hash[(-3):], hash)
 DCSP if (object and (not container)): DCNL DCSP  DCSP raise ValueError('container DCSP is DCSP required DCSP if DCSP object DCSP is DCSP provided') DCNL DCSP paths = [account] DCNL DCSP if container: DCNL DCSP  DCSP paths.append(container) DCNL DCSP if object: DCNL DCSP  DCSP paths.append(object) DCNL DCSP if raw_digest: DCNL DCSP  DCSP return md5((((HASH_PATH_PREFIX + '/') + '/'.join(paths)) + HASH_PATH_SUFFIX)).digest() DCNL DCSP else: DCNL DCSP  DCSP return md5((((HASH_PATH_PREFIX + '/') + '/'.join(paths)) + HASH_PATH_SUFFIX)).hexdigest()
 DCSP mkdirs(directory) DCNL DCSP lockpath = ('%s/.lock' % directory) DCNL DCSP fd = os.open(lockpath, (os.O_WRONLY | os.O_CREAT)) DCNL DCSP try: DCNL DCSP  DCSP with LockTimeout(timeout, lockpath): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fcntl.flock(fd, (fcntl.LOCK_EX | fcntl.LOCK_NB)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.EAGAIN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP sleep(0.01) DCNL DCSP  DCSP (yield True) DCNL DCSP finally: DCNL DCSP  DCSP os.close(fd)
 DCSP flags = (os.O_CREAT | os.O_RDWR) DCNL DCSP if append: DCNL DCSP  DCSP flags |= os.O_APPEND DCNL DCSP  DCSP mode = 'a+' DCNL DCSP else: DCNL DCSP  DCSP mode = 'r+' DCNL DCSP fd = os.open(filename, flags) DCNL DCSP file_obj = os.fdopen(fd, mode) DCNL DCSP try: DCNL DCSP  DCSP with LockTimeout(timeout, filename): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fcntl.flock(fd, (fcntl.LOCK_EX | fcntl.LOCK_NB)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.EAGAIN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP sleep(0.01) DCNL DCSP  DCSP (yield file_obj) DCNL DCSP finally: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP file_obj.close() DCNL DCSP  DCSP except UnboundLocalError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if unlink: DCNL DCSP  DCSP  DCSP os.unlink(filename)
 DCSP return lock_path(os.path.dirname(filename), timeout=timeout)
 DCSP time_unit = 's' DCNL DCSP if (time_amount > 60): DCNL DCSP  DCSP time_amount /= 60 DCNL DCSP  DCSP time_unit = 'm' DCNL DCSP  DCSP if (time_amount > 60): DCNL DCSP  DCSP  DCSP time_amount /= 60 DCNL DCSP  DCSP  DCSP time_unit = 'h' DCNL DCSP return (time_amount, time_unit)
 DCSP elapsed = (time.time() - start_time) DCNL DCSP completion = ((float(current_value) / final_value) or 1e-05) DCNL DCSP return get_time_units((((1.0 / completion) * elapsed) - elapsed))
 DCSP devices = listdir(devices_dir) DCNL DCSP shuffle(devices) DCNL DCSP devices_partitions = [] DCNL DCSP for device in devices: DCNL DCSP  DCSP partitions = listdir(os.path.join(devices_dir, device, item_type)) DCNL DCSP  DCSP shuffle(partitions) DCNL DCSP  DCSP devices_partitions.append((device, iter(partitions))) DCNL DCSP yielded = True DCNL DCSP while yielded: DCNL DCSP  DCSP yielded = False DCNL DCSP  DCSP for (device, partitions) in devices_partitions: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (yield (device, partitions.next())) DCNL DCSP  DCSP  DCSP  DCSP yielded = True DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP pass
 DCSP if os.path.exists(path): DCNL DCSP  DCSP for fname in listdir(path): DCNL DCSP  DCSP  DCSP fpath = os.path.join(path, fname) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (os.path.getmtime(fpath) < mtime): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(fpath) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass
 DCSP item = env.get(item_name, None) DCNL DCSP if (item is None): DCNL DCSP  DCSP logging.error(('ERROR: DCSP %s DCSP could DCSP not DCSP be DCSP found DCSP in DCSP env!' % item_name)) DCNL DCSP return item
 DCSP return item_from_env(env, 'swift.cache')
 DCSP if (defaults is None): DCNL DCSP  DCSP defaults = {} DCNL DCSP if raw: DCNL DCSP  DCSP c = RawConfigParser(defaults) DCNL DCSP else: DCNL DCSP  DCSP c = ConfigParser(defaults) DCNL DCSP if hasattr(conffile, 'readline'): DCNL DCSP  DCSP c.readfp(conffile) DCNL DCSP elif (not c.read(conffile)): DCNL DCSP  DCSP print (_('Unable DCSP to DCSP read DCSP config DCSP file DCSP %s') % conffile) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if section_name: DCNL DCSP  DCSP if c.has_section(section_name): DCNL DCSP  DCSP  DCSP conf = dict(c.items(section_name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print (_('Unable DCSP to DCSP find DCSP %s DCSP config DCSP section DCSP in DCSP %s') % (section_name, conffile)) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP if ('log_name' not in conf): DCNL DCSP  DCSP  DCSP if (log_name is not None): DCNL DCSP  DCSP  DCSP  DCSP conf['log_name'] = log_name DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf['log_name'] = section_name DCNL DCSP else: DCNL DCSP  DCSP conf = {} DCNL DCSP  DCSP for s in c.sections(): DCNL DCSP  DCSP  DCSP conf.update({s: dict(c.items(s))}) DCNL DCSP  DCSP if ('log_name' not in conf): DCNL DCSP  DCSP  DCSP conf['log_name'] = log_name DCNL DCSP conf['__file__'] = conffile DCNL DCSP return conf
 DCSP if (tmp is None): DCNL DCSP  DCSP tmp = os.path.dirname(dest) DCNL DCSP (fd, tmppath) = mkstemp(dir=tmp, suffix='.tmp') DCNL DCSP with os.fdopen(fd, 'wb') as fo: DCNL DCSP  DCSP pickle.dump(obj, fo, pickle_protocol) DCNL DCSP  DCSP fo.flush() DCNL DCSP  DCSP os.fsync(fd) DCNL DCSP  DCSP renamer(tmppath, dest)
 DCSP found_files = [] DCNL DCSP for path in glob.glob(os.path.join(root, glob_match)): DCNL DCSP  DCSP if path.endswith(ext): DCNL DCSP  DCSP  DCSP found_files.append(path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (root, dirs, files) in os.walk(path): DCNL DCSP  DCSP  DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if file.endswith(ext): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP found_files.append(os.path.join(root, file)) DCNL DCSP return sorted(found_files)
 DCSP (dirname, name) = os.path.split(path) DCNL DCSP if (not os.path.exists(dirname)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makedirs(dirname) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno == errno.EACCES): DCNL DCSP  DCSP  DCSP  DCSP sys.exit(('Unable DCSP to DCSP create DCSP %s. DCSP  DCSP Running DCSP as DCSP non-root?' % dirname)) DCNL DCSP with open(path, 'w') as f: DCNL DCSP  DCSP f.write(('%s' % contents))
 DCSP try: DCNL DCSP  DCSP os.unlink(path) DCNL DCSP except OSError: DCNL DCSP  DCSP pass
 DCSP device_dir = listdir(devices) DCNL DCSP shuffle(device_dir) DCNL DCSP for device in device_dir: DCNL DCSP  DCSP if (mount_check and (not os.path.ismount(os.path.join(devices, device)))): DCNL DCSP  DCSP  DCSP if logger: DCNL DCSP  DCSP  DCSP  DCSP logger.debug(_('Skipping DCSP %s DCSP as DCSP it DCSP is DCSP not DCSP mounted'), device) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP datadir_path = os.path.join(devices, device, datadir) DCNL DCSP  DCSP if (not os.path.exists(datadir_path)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP partitions = listdir(datadir_path) DCNL DCSP  DCSP for partition in partitions: DCNL DCSP  DCSP  DCSP part_path = os.path.join(datadir_path, partition) DCNL DCSP  DCSP  DCSP if (not os.path.isdir(part_path)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP suffixes = listdir(part_path) DCNL DCSP  DCSP  DCSP for suffix in suffixes: DCNL DCSP  DCSP  DCSP  DCSP suff_path = os.path.join(part_path, suffix) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(suff_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP hashes = listdir(suff_path) DCNL DCSP  DCSP  DCSP  DCSP for hsh in hashes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hash_path = os.path.join(suff_path, hsh) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(hash_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP for fname in sorted(listdir(hash_path), reverse=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP path = os.path.join(hash_path, fname) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield (path, device, partition))
 DCSP if ((not max_rate) or (incr_by <= 0)): DCNL DCSP  DCSP return running_time DCNL DCSP clock_accuracy = 1000.0 DCNL DCSP now = (time.time() * clock_accuracy) DCNL DCSP time_per_request = (clock_accuracy * (float(incr_by) / max_rate)) DCNL DCSP if ((now - running_time) > (rate_buffer * clock_accuracy)): DCNL DCSP  DCSP running_time = now DCNL DCSP elif ((running_time - now) > time_per_request): DCNL DCSP  DCSP eventlet.sleep(((running_time - now) / clock_accuracy)) DCNL DCSP return (running_time + time_per_request)
 DCSP return ModifiedParseResult(*stdlib_urlparse(url))
 DCSP value = float(value) DCNL DCSP index = (-1) DCNL DCSP suffixes = 'KMGTPEZY' DCNL DCSP while ((value >= 1024) and ((index + 1) < len(suffixes))): DCNL DCSP  DCSP index += 1 DCNL DCSP  DCSP value = round((value / 1024)) DCNL DCSP if (index == (-1)): DCNL DCSP  DCSP return ('%d' % value) DCNL DCSP return ('%d%si' % (round(value), suffixes[index]))
 DCSP try: DCNL DCSP  DCSP with lock_file(cache_file, lock_timeout, unlink=False) as cf: DCNL DCSP  DCSP  DCSP cache_entry = {} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP existing_entry = cf.readline() DCNL DCSP  DCSP  DCSP  DCSP if existing_entry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP cache_entry = json.loads(existing_entry) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP for (cache_key, cache_value) in cache_dict.items(): DCNL DCSP  DCSP  DCSP  DCSP cache_entry[cache_key] = cache_value DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with NamedTemporaryFile(dir=os.path.dirname(cache_file), delete=False) as tf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tf.write((json.dumps(cache_entry) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP os.rename(tf.name, cache_file) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(tf.name) DCNL DCSP  DCSP  DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (err.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP except (Exception, Timeout): DCNL DCSP  DCSP logger.exception(_('Exception DCSP dumping DCSP recon DCSP cache'))
 DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
 DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped
 DCSP try: DCNL DCSP  DCSP socket.inet_pton(socket.AF_INET6, ip) DCNL DCSP except socket.error: DCNL DCSP  DCSP return ip DCNL DCSP else: DCNL DCSP  DCSP return ('[%s]' % ip)
 DCSP if isinstance(str_or_unicode, unicode): DCNL DCSP  DCSP (str_or_unicode, _len) = utf8_encoder(str_or_unicode, 'replace') DCNL DCSP (valid_utf8_str, _len) = utf8_decoder(str_or_unicode, 'replace') DCNL DCSP return valid_utf8_str.encode('utf-8')
 DCSP if comma_separated_str: DCNL DCSP  DCSP return [v.strip() for v in comma_separated_str.split(',') if v.strip()] DCNL DCSP return []
 DCSP if csv_string: DCNL DCSP  DCSP return ','.join((csv_string, item)) DCNL DCSP else: DCNL DCSP  DCSP return item
 DCSP if isinstance(iterable, (list, tuple)): DCNL DCSP  DCSP return iterable DCNL DCSP else: DCNL DCSP  DCSP iterator = iter(iterable) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chunk = '' DCNL DCSP  DCSP  DCSP while (not chunk): DCNL DCSP  DCSP  DCSP  DCSP chunk = next(iterator) DCNL DCSP  DCSP  DCSP return itertools.chain([chunk], iterator) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return []
 DCSP t1 = dev['region'] DCNL DCSP t2 = dev['zone'] DCNL DCSP t3 = '{ip}:{port}'.format(ip=dev.get('ip'), port=dev.get('port')) DCNL DCSP t4 = dev['id'] DCNL DCSP return ((t1,), (t1, t2), (t1, t2, t3), (t1, t2, t3, t4))
 DCSP tier2children = defaultdict(set) DCNL DCSP for dev in devices: DCNL DCSP  DCSP for tier in tiers_for_dev(dev): DCNL DCSP  DCSP  DCSP if (len(tier) > 1): DCNL DCSP  DCSP  DCSP  DCSP tier2children[tier[0:(-1)]].add(tier) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tier2children[()].add(tier) DCNL DCSP return tier2children
 DCSP prefix = ('x-%s-meta-' % target_type.lower()) DCNL DCSP meta_count = 0 DCNL DCSP meta_size = 0 DCNL DCSP for (key, value) in req.headers.iteritems(): DCNL DCSP  DCSP if (isinstance(value, basestring) and (len(value) > MAX_HEADER_SIZE)): DCNL DCSP  DCSP  DCSP return HTTPBadRequest('Header DCSP Line DCSP Too DCSP Long') DCNL DCSP  DCSP if (not key.lower().startswith(prefix)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP key = key[len(prefix):] DCNL DCSP  DCSP if (not key): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body='Metadata DCSP name DCSP cannot DCSP be DCSP empty', request=req, content_type='text/plain') DCNL DCSP  DCSP meta_count += 1 DCNL DCSP  DCSP meta_size += (len(key) + len(value)) DCNL DCSP  DCSP if (len(key) > MAX_META_NAME_LENGTH): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Metadata DCSP name DCSP too DCSP long; DCSP max DCSP %d' % MAX_META_NAME_LENGTH), request=req, content_type='text/plain') DCNL DCSP  DCSP elif (len(value) > MAX_META_VALUE_LENGTH): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Metadata DCSP value DCSP too DCSP long; DCSP max DCSP %d' % MAX_META_VALUE_LENGTH), request=req, content_type='text/plain') DCNL DCSP  DCSP elif (meta_count > MAX_META_COUNT): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Too DCSP many DCSP metadata DCSP items; DCSP max DCSP %d' % MAX_META_COUNT), request=req, content_type='text/plain') DCNL DCSP  DCSP elif (meta_size > MAX_META_OVERALL_SIZE): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(body=('Total DCSP metadata DCSP too DCSP large; DCSP max DCSP %d' % MAX_META_OVERALL_SIZE), request=req, content_type='text/plain') DCNL DCSP return None
 DCSP if (req.content_length and (req.content_length > MAX_FILE_SIZE)): DCNL DCSP  DCSP return HTTPRequestEntityTooLarge(body='Your DCSP request DCSP is DCSP too DCSP large.', request=req, content_type='text/plain') DCNL DCSP if ((req.content_length is None) and (req.headers.get('transfer-encoding') != 'chunked')): DCNL DCSP  DCSP return HTTPLengthRequired(request=req) DCNL DCSP if (('X-Copy-From' in req.headers) and req.content_length): DCNL DCSP  DCSP return HTTPBadRequest(body='Copy DCSP requests DCSP require DCSP a DCSP zero DCSP byte DCSP body', request=req, content_type='text/plain') DCNL DCSP if (len(object_name) > MAX_OBJECT_NAME_LENGTH): DCNL DCSP  DCSP return HTTPBadRequest(body=('Object DCSP name DCSP length DCSP of DCSP %d DCSP longer DCSP than DCSP %d' % (len(object_name), MAX_OBJECT_NAME_LENGTH)), request=req, content_type='text/plain') DCNL DCSP if ('Content-Type' not in req.headers): DCNL DCSP  DCSP return HTTPBadRequest(request=req, content_type='text/plain', body='No DCSP content DCSP type') DCNL DCSP if (not check_utf8(req.headers['Content-Type'])): DCNL DCSP  DCSP return HTTPBadRequest(request=req, body='Invalid DCSP Content-Type', content_type='text/plain') DCNL DCSP if ('x-object-manifest' in req.headers): DCNL DCSP  DCSP value = req.headers['x-object-manifest'] DCNL DCSP  DCSP container = prefix = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (container, prefix) = value.split('/', 1) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if ((not container) or (not prefix) or ('?' in value) or ('&' in value) or (prefix[0] == '/')): DCNL DCSP  DCSP  DCSP return HTTPBadRequest(request=req, body='X-Object-Manifest DCSP must DCSP in DCSP the DCSP format DCSP container/prefix') DCNL DCSP return check_metadata(req, 'object')
 DCSP if (not (urllib.quote_plus(drive) == drive)): DCNL DCSP  DCSP return False DCNL DCSP path = os.path.join(root, drive) DCNL DCSP return (os.path.exists(path) and os.path.ismount(path))
 DCSP try: DCNL DCSP  DCSP float(string) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
 DCSP if (not string): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP if isinstance(string, unicode): DCNL DCSP  DCSP  DCSP string.encode('utf-8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP string.decode('UTF-8') DCNL DCSP  DCSP return ('\x00' not in string) DCNL DCSP except UnicodeError: DCNL DCSP  DCSP return False
 DCSP path = ('/' + account) DCNL DCSP qs = 'format=json' DCNL DCSP if marker: DCNL DCSP  DCSP qs += ('&marker=%s' % quote(marker)) DCNL DCSP if limit: DCNL DCSP  DCSP qs += ('&limit=%d' % limit) DCNL DCSP if prefix: DCNL DCSP  DCSP qs += ('&prefix=%s' % quote(prefix)) DCNL DCSP if delimiter: DCNL DCSP  DCSP qs += ('&delimiter=%s' % quote(delimiter)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, query_string=qs) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Account DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP if (resp.status == HTTP_NO_CONTENT): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP return (resp_headers, []) DCNL DCSP return (resp_headers, json_loads(resp.read()))
 DCSP path = ('/%s/%s' % (account, container)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'HEAD', path) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Container DCSP server DCSP %s:%s DCSP direct DCSP HEAD DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return resp_headers
 DCSP path = ('/%s/%s' % (account, container)) DCNL DCSP qs = 'format=json' DCNL DCSP if marker: DCNL DCSP  DCSP qs += ('&marker=%s' % quote(marker)) DCNL DCSP if limit: DCNL DCSP  DCSP qs += ('&limit=%d' % limit) DCNL DCSP if prefix: DCNL DCSP  DCSP qs += ('&prefix=%s' % quote(prefix)) DCNL DCSP if delimiter: DCNL DCSP  DCSP qs += ('&delimiter=%s' % quote(delimiter)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, query_string=qs) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Container DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP stats DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP if (resp.status == HTTP_NO_CONTENT): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP return (resp_headers, []) DCNL DCSP return (resp_headers, json_loads(resp.read()))
 DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'HEAD', path) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP HEAD DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return resp_headers
 DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'GET', path, headers=headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.read() DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP if resp_chunk_size: DCNL DCSP  DCSP def _object_body(): DCNL DCSP  DCSP  DCSP buf = resp.read(resp_chunk_size) DCNL DCSP  DCSP  DCSP while buf: DCNL DCSP  DCSP  DCSP  DCSP (yield buf) DCNL DCSP  DCSP  DCSP  DCSP buf = resp.read(resp_chunk_size) DCNL DCSP  DCSP object_body = _object_body() DCNL DCSP else: DCNL DCSP  DCSP object_body = resp.read() DCNL DCSP resp_headers = {} DCNL DCSP for (header, value) in resp.getheaders(): DCNL DCSP  DCSP resp_headers[header.lower()] = value DCNL DCSP return (resp_headers, object_body)
 DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP if (headers is None): DCNL DCSP  DCSP headers = {} DCNL DCSP if etag: DCNL DCSP  DCSP headers['ETag'] = etag.strip('"') DCNL DCSP if (content_length is not None): DCNL DCSP  DCSP headers['Content-Length'] = str(content_length) DCNL DCSP if (content_type is not None): DCNL DCSP  DCSP headers['Content-Type'] = content_type DCNL DCSP else: DCNL DCSP  DCSP headers['Content-Type'] = 'application/octet-stream' DCNL DCSP if (not contents): DCNL DCSP  DCSP headers['Content-Length'] = '0' DCNL DCSP if isinstance(contents, basestring): DCNL DCSP  DCSP contents = [contents] DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'PUT', path, headers=headers) DCNL DCSP for chunk in contents: DCNL DCSP  DCSP conn.send(chunk) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP PUT DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP return resp.getheader('etag').strip('"')
 DCSP path = ('/%s/%s/%s' % (account, container, name)) DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'POST', path, headers=headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP POST DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason)
 DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP headers['X-Timestamp'] = normalize_timestamp(time()) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(node['ip'], node['port'], node['device'], part, 'DELETE', path, headers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.read() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP direct DCSP DELETE DCSP %s DCSP gave DCSP status DCSP %s' % (node['ip'], node['port'], repr(('/%s/%s%s' % (node['device'], part, path))), resp.status)), http_host=node['ip'], http_port=node['port'], http_device=node['device'], http_status=resp.status, http_reason=resp.reason)
 DCSP retries = 5 DCNL DCSP if ('retries' in kwargs): DCNL DCSP  DCSP retries = kwargs['retries'] DCNL DCSP  DCSP del kwargs['retries'] DCNL DCSP error_log = None DCNL DCSP if ('error_log' in kwargs): DCNL DCSP  DCSP error_log = kwargs['error_log'] DCNL DCSP  DCSP del kwargs['error_log'] DCNL DCSP attempts = 0 DCNL DCSP backoff = 1 DCNL DCSP while (attempts <= retries): DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (attempts, func(*args, **kwargs)) DCNL DCSP  DCSP except (socket.error, HTTPException, Timeout) as err: DCNL DCSP  DCSP  DCSP if error_log: DCNL DCSP  DCSP  DCSP  DCSP error_log(err) DCNL DCSP  DCSP  DCSP if (attempts > retries): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except ClientException as err: DCNL DCSP  DCSP  DCSP if error_log: DCNL DCSP  DCSP  DCSP  DCSP error_log(err) DCNL DCSP  DCSP  DCSP if ((attempts > retries) or (not is_server_error(err.http_status)) or (err.http_status == HTTP_INSUFFICIENT_STORAGE)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP sleep(backoff) DCNL DCSP  DCSP backoff *= 2 DCNL DCSP if (args and ('ip' in args[0])): DCNL DCSP  DCSP raise ClientException('Raise DCSP too DCSP many DCSP retries', http_host=args[0]['ip'], http_port=args[0]['port'], http_device=args[0]['device']) DCNL DCSP else: DCNL DCSP  DCSP raise ClientException('Raise DCSP too DCSP many DCSP retries')
 DCSP object_dir = os.path.dirname(object_file) DCNL DCSP quarantine_dir = os.path.abspath(os.path.join(object_dir, '..', '..', '..', '..', 'quarantined', (server_type + 's'), os.path.basename(object_dir))) DCNL DCSP try: DCNL DCSP  DCSP renamer(object_dir, quarantine_dir) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno not in (errno.EEXIST, errno.ENOTEMPTY)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP quarantine_dir = ('%s-%s' % (quarantine_dir, uuid.uuid4().hex)) DCNL DCSP  DCSP renamer(object_dir, quarantine_dir)
 DCSP def walk_datadir(datadir, node_id): DCNL DCSP  DCSP partitions = os.listdir(datadir) DCNL DCSP  DCSP random.shuffle(partitions) DCNL DCSP  DCSP for partition in partitions: DCNL DCSP  DCSP  DCSP part_dir = os.path.join(datadir, partition) DCNL DCSP  DCSP  DCSP if (not os.path.isdir(part_dir)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP suffixes = os.listdir(part_dir) DCNL DCSP  DCSP  DCSP for suffix in suffixes: DCNL DCSP  DCSP  DCSP  DCSP suff_dir = os.path.join(part_dir, suffix) DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(suff_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP hashes = os.listdir(suff_dir) DCNL DCSP  DCSP  DCSP  DCSP for hsh in hashes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hash_dir = os.path.join(suff_dir, hsh) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.isdir(hash_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP object_file = os.path.join(hash_dir, (hsh + '.db')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(object_file): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yield (partition, object_file, node_id)) DCNL DCSP its = [walk_datadir(datadir, node_id) for (datadir, node_id) in datadirs] DCNL DCSP while its: DCNL DCSP  DCSP for it in its: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (yield it.next()) DCNL DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP its.remove(it)
 DCSP try: DCNL DCSP  DCSP resource.setrlimit(resource.RLIMIT_NOFILE, (MAX_DESCRIPTORS, MAX_DESCRIPTORS)) DCNL DCSP  DCSP resource.setrlimit(resource.RLIMIT_DATA, (MAX_MEMORY, MAX_MEMORY)) DCNL DCSP except ValueError: DCNL DCSP  DCSP print _('WARNING: DCSP Unable DCSP to DCSP increase DCSP file DCSP descriptor DCSP limit. DCSP  DCSP Running DCSP as DCSP non-root?') DCNL DCSP os.environ['PYTHON_EGG_CACHE'] = '/tmp'
 DCSP func.publicly_accessible = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP rv = func(*a, **kw) DCNL DCSP  DCSP return (1 if rv else 0) DCNL DCSP return wrapped
 DCSP status = {} DCNL DCSP start = time.time() DCNL DCSP end = (start + interval) DCNL DCSP server_pids = dict(server_pids) DCNL DCSP while True: DCNL DCSP  DCSP for (server, pids) in server_pids.items(): DCNL DCSP  DCSP  DCSP for pid in pids: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.waitpid(pid, os.WNOHANG) DCNL DCSP  DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (e.errno not in (errno.ECHILD, errno.ESRCH)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP status[server] = server.get_running_pids(**kwargs) DCNL DCSP  DCSP  DCSP for pid in pids: DCNL DCSP  DCSP  DCSP  DCSP if (pid not in status[server]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yield (server, pid)) DCNL DCSP  DCSP  DCSP server_pids[server] = status[server] DCNL DCSP  DCSP if (not [p for (server, pids) in status.items() for p in pids]): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (time.time() > end): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(0.1)
 DCSP if (timeout > (((30 * 24) * 60) * 60)): DCNL DCSP  DCSP timeout += time.time() DCNL DCSP return timeout
 DCSP bench = Bench(logger, conf, []) DCNL DCSP pool = eventlet.GreenPool(int(getattr(conf, concurrency_key))) DCNL DCSP for container in conf.containers: DCNL DCSP  DCSP pool.spawn_n(func, bench.url, bench.token, container) DCNL DCSP pool.waitall()
 DCSP def _deleter(url, token, container): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP client.delete_container(url, token, container) DCNL DCSP  DCSP except client.ClientException as e: DCNL DCSP  DCSP  DCSP if (e.http_status != HTTP_CONFLICT): DCNL DCSP  DCSP  DCSP  DCSP logger.warn(("Unable DCSP to DCSP delete DCSP container DCSP '%s'. DCSP Got DCSP http DCSP status DCSP '%d'." % (container, e.http_status))) DCNL DCSP _func_on_containers(logger, conf, 'del_concurrency', _deleter)
 DCSP _func_on_containers(logger, conf, 'put_concurrency', client.put_container)
 DCSP orig_parsetype = mimetools.Message.parsetype DCNL DCSP def parsetype(self): DCNL DCSP  DCSP if (not self.typeheader): DCNL DCSP  DCSP  DCSP self.type = None DCNL DCSP  DCSP  DCSP self.maintype = None DCNL DCSP  DCSP  DCSP self.subtype = None DCNL DCSP  DCSP  DCSP self.plisttext = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP orig_parsetype(self) DCNL DCSP mimetools.Message.parsetype = parsetype
 DCSP bind_addr = (conf.get('bind_ip', '0.0.0.0'), int(conf.get('bind_port', default_port))) DCNL DCSP address_family = [addr[0] for addr in socket.getaddrinfo(bind_addr[0], bind_addr[1], socket.AF_UNSPEC, socket.SOCK_STREAM) if (addr[0] in (socket.AF_INET, socket.AF_INET6))][0] DCNL DCSP sock = None DCNL DCSP bind_timeout = int(conf.get('bind_timeout', 30)) DCNL DCSP retry_until = (time.time() + bind_timeout) DCNL DCSP warn_ssl = False DCNL DCSP while ((not sock) and (time.time() < retry_until)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sock = listen(bind_addr, backlog=int(conf.get('backlog', 4096)), family=address_family) DCNL DCSP  DCSP  DCSP if ('cert_file' in conf): DCNL DCSP  DCSP  DCSP  DCSP warn_ssl = True DCNL DCSP  DCSP  DCSP  DCSP sock = ssl.wrap_socket(sock, certfile=conf['cert_file'], keyfile=conf['key_file']) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err.args[0] != errno.EADDRINUSE): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP sleep(0.1) DCNL DCSP if (not sock): DCNL DCSP  DCSP raise Exception((_('Could DCSP not DCSP bind DCSP to DCSP %s:%s DCSP after DCSP trying DCSP for DCSP %s DCSP seconds') % (bind_addr[0], bind_addr[1], bind_timeout))) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1) DCNL DCSP if hasattr(socket, 'TCP_KEEPIDLE'): DCNL DCSP  DCSP sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 600) DCNL DCSP if warn_ssl: DCNL DCSP  DCSP ssl_warning_message = 'WARNING: DCSP SSL DCSP should DCSP only DCSP be DCSP enabled DCSP for DCSP testing DCSP purposes. DCSP Use DCSP external DCSP SSL DCSP termination DCSP for DCSP a DCSP production DCSP deployment.' DCNL DCSP  DCSP get_logger(conf).warning(ssl_warning_message) DCNL DCSP  DCSP print _(ssl_warning_message) DCNL DCSP return sock
 DCSP try: DCNL DCSP  DCSP (app, conf, logger, log_name) = init_request_processor(conf_file, app_section, *args, **kwargs) DCNL DCSP except ConfigFileError as e: DCNL DCSP  DCSP print e DCNL DCSP  DCSP return DCNL DCSP sock = get_socket(conf, default_port=kwargs.get('default_port', 8080)) DCNL DCSP drop_privileges(conf.get('user', 'swift')) DCNL DCSP reserve = int(conf.get('fallocate_reserve', 0)) DCNL DCSP if (reserve > 0): DCNL DCSP  DCSP utils.FALLOCATE_RESERVE = reserve DCNL DCSP capture_stdio(logger) DCNL DCSP def run_server(): DCNL DCSP  DCSP wsgi.HttpProtocol.default_request_version = 'HTTP/1.0' DCNL DCSP  DCSP wsgi.HttpProtocol.log_request = (lambda *a: None) DCNL DCSP  DCSP wsgi.HttpProtocol.log_message = (lambda s, f, *a: logger.error(('ERROR DCSP WSGI: DCSP ' + (f % a)))) DCNL DCSP  DCSP wsgi.WRITE_TIMEOUT = int((conf.get('client_timeout') or 60)) DCNL DCSP  DCSP eventlet.hubs.use_hub(get_hub()) DCNL DCSP  DCSP eventlet.patcher.monkey_patch(all=False, socket=True) DCNL DCSP  DCSP eventlet_debug = config_true_value(conf.get('eventlet_debug', 'no')) DCNL DCSP  DCSP eventlet.debug.hub_exceptions(eventlet_debug) DCNL DCSP  DCSP app = loadapp(('config:%s' % conf_file), global_conf={'log_name': log_name}) DCNL DCSP  DCSP pool = GreenPool(size=1024) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP wsgi.server(sock, app, NullLogger(), custom_pool=pool) DCNL DCSP  DCSP except socket.error as err: DCNL DCSP  DCSP  DCSP if (err[0] != errno.EINVAL): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP pool.waitall() DCNL DCSP worker_count = int(conf.get('workers', '1')) DCNL DCSP if (worker_count == 0): DCNL DCSP  DCSP run_server() DCNL DCSP  DCSP return DCNL DCSP def kill_children(*args): DCNL DCSP  DCSP 'Kills DCSP the DCSP entire DCSP process DCSP group.' DCNL DCSP  DCSP logger.error('SIGTERM DCSP received') DCNL DCSP  DCSP signal.signal(signal.SIGTERM, signal.SIG_IGN) DCNL DCSP  DCSP running[0] = False DCNL DCSP  DCSP os.killpg(0, signal.SIGTERM) DCNL DCSP def hup(*args): DCNL DCSP  DCSP 'Shuts DCSP down DCSP the DCSP server, DCSP but DCSP allows DCSP running DCSP requests DCSP to DCSP complete' DCNL DCSP  DCSP logger.error('SIGHUP DCSP received') DCNL DCSP  DCSP signal.signal(signal.SIGHUP, signal.SIG_IGN) DCNL DCSP  DCSP running[0] = False DCNL DCSP running = [True] DCNL DCSP signal.signal(signal.SIGTERM, kill_children) DCNL DCSP signal.signal(signal.SIGHUP, hup) DCNL DCSP children = [] DCNL DCSP while running[0]: DCNL DCSP  DCSP while (len(children) < worker_count): DCNL DCSP  DCSP  DCSP pid = os.fork() DCNL DCSP  DCSP  DCSP if (pid == 0): DCNL DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGHUP, signal.SIG_DFL) DCNL DCSP  DCSP  DCSP  DCSP signal.signal(signal.SIGTERM, signal.SIG_DFL) DCNL DCSP  DCSP  DCSP  DCSP run_server() DCNL DCSP  DCSP  DCSP  DCSP logger.notice(('Child DCSP %d DCSP exiting DCSP normally' % os.getpid())) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger.notice(('Started DCSP child DCSP %s' % pid)) DCNL DCSP  DCSP  DCSP  DCSP children.append(pid) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (pid, status) = os.wait() DCNL DCSP  DCSP  DCSP if (os.WIFEXITED(status) or os.WIFSIGNALED(status)): DCNL DCSP  DCSP  DCSP  DCSP logger.error(('Removing DCSP dead DCSP child DCSP %s' % pid)) DCNL DCSP  DCSP  DCSP  DCSP children.remove(pid) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno not in (errno.EINTR, errno.ECHILD)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except KeyboardInterrupt: DCNL DCSP  DCSP  DCSP logger.notice('User DCSP quit') DCNL DCSP  DCSP  DCSP break DCNL DCSP greenio.shutdown_safe(sock) DCNL DCSP sock.close() DCNL DCSP logger.notice('Exited')
 DCSP try: DCNL DCSP  DCSP conf = appconfig(('config:%s' % conf_file), name=app_section) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise ConfigFileError(('Error DCSP trying DCSP to DCSP load DCSP config DCSP %s: DCSP %s' % (conf_file, e))) DCNL DCSP validate_configuration() DCNL DCSP log_name = conf.get('log_name', app_section) DCNL DCSP if ('logger' in kwargs): DCNL DCSP  DCSP logger = kwargs.pop('logger') DCNL DCSP else: DCNL DCSP  DCSP logger = get_logger(conf, log_name, log_to_console=kwargs.pop('verbose', False), log_route='wsgi') DCNL DCSP if config_true_value(conf.get('disable_fallocate', 'no')): DCNL DCSP  DCSP disable_fallocate() DCNL DCSP monkey_patch_mimetools() DCNL DCSP app = loadapp(('config:%s' % conf_file), global_conf={'log_name': log_name}) DCNL DCSP return (app, conf, logger, log_name)
 DCSP query_string = None DCNL DCSP if (path and ('?' in path)): DCNL DCSP  DCSP (path, query_string) = path.split('?', 1) DCNL DCSP newenv = make_pre_authed_env(env, method, path=unquote(path), agent=agent, query_string=query_string, swift_source=swift_source) DCNL DCSP if (not headers): DCNL DCSP  DCSP headers = {} DCNL DCSP if body: DCNL DCSP  DCSP return Request.blank(path, environ=newenv, body=body, headers=headers) DCNL DCSP else: DCNL DCSP  DCSP return Request.blank(path, environ=newenv, headers=headers)
 DCSP newenv = {} DCNL DCSP for name in ('eventlet.posthooks', 'HTTP_USER_AGENT', 'HTTP_HOST', 'PATH_INFO', 'QUERY_STRING', 'REMOTE_USER', 'REQUEST_METHOD', 'SCRIPT_NAME', 'SERVER_NAME', 'SERVER_PORT', 'SERVER_PROTOCOL', 'swift.cache', 'swift.source', 'swift.trans_id'): DCNL DCSP  DCSP if (name in env): DCNL DCSP  DCSP  DCSP newenv[name] = env[name] DCNL DCSP if method: DCNL DCSP  DCSP newenv['REQUEST_METHOD'] = method DCNL DCSP if path: DCNL DCSP  DCSP newenv['PATH_INFO'] = path DCNL DCSP  DCSP newenv['SCRIPT_NAME'] = '' DCNL DCSP if (query_string is not None): DCNL DCSP  DCSP newenv['QUERY_STRING'] = query_string DCNL DCSP if agent: DCNL DCSP  DCSP newenv['HTTP_USER_AGENT'] = (agent % {'orig': env.get('HTTP_USER_AGENT', '')}).strip() DCNL DCSP elif ((agent == '') and ('HTTP_USER_AGENT' in newenv)): DCNL DCSP  DCSP del newenv['HTTP_USER_AGENT'] DCNL DCSP if swift_source: DCNL DCSP  DCSP newenv['swift.source'] = swift_source DCNL DCSP newenv['swift.authorize'] = (lambda req: None) DCNL DCSP newenv['swift.authorize_override'] = True DCNL DCSP newenv['REMOTE_USER'] = '.wsgi.pre_authed' DCNL DCSP newenv['wsgi.input'] = StringIO('') DCNL DCSP if ('SCRIPT_NAME' not in newenv): DCNL DCSP  DCSP newenv['SCRIPT_NAME'] = '' DCNL DCSP return newenv
 DCSP def getter(self): DCNL DCSP  DCSP value = self.headers.get(header, None) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP parts = parsedate(self.headers[header])[:7] DCNL DCSP  DCSP  DCSP  DCSP date = datetime(*(parts + (UTC,))) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP if (date.year < 1970): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Somehow DCSP an DCSP invalid DCSP year') DCNL DCSP  DCSP  DCSP return date DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, (float, int, long)): DCNL DCSP  DCSP  DCSP self.headers[header] = time.strftime('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT', time.gmtime(value)) DCNL DCSP  DCSP elif isinstance(value, datetime): DCNL DCSP  DCSP  DCSP self.headers[header] = value.strftime('%a, DCSP %d DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP header DCSP as DCSP a DCSP datetime, DCSP set DCSP it DCSP with DCSP a DCSP datetime, DCSP int, DCSP or DCSP str' % header))
 DCSP def getter(self): DCNL DCSP  DCSP return self.headers.get(header, None) DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP header' % header))
 DCSP def getter(self): DCNL DCSP  DCSP val = self.headers.get(header, None) DCNL DCSP  DCSP if (val is not None): DCNL DCSP  DCSP  DCSP val = int(val) DCNL DCSP  DCSP return val DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP header DCSP as DCSP an DCSP int' % header))
 DCSP def getter(self): DCNL DCSP  DCSP return ('%s DCSP %s' % (self.status_int, self.title)) DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, (int, long)): DCNL DCSP  DCSP  DCSP self.status_int = value DCNL DCSP  DCSP  DCSP self.explanation = self.title = RESPONSE_REASONS[value][0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP  DCSP value = value.encode('utf-8') DCNL DCSP  DCSP  DCSP self.status_int = int(value.split(' DCSP ', 1)[0]) DCNL DCSP  DCSP  DCSP self.explanation = self.title = value.split(' DCSP ', 1)[1] DCNL DCSP return property(getter, setter, doc="Retrieve DCSP and DCSP set DCSP the DCSP Response DCSP status, DCSP e.g. DCSP '200 DCSP OK'")
 DCSP def getter(self): DCNL DCSP  DCSP if (not self._body): DCNL DCSP  DCSP  DCSP if (not self._app_iter): DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP  DCSP self._body = ''.join(self._app_iter) DCNL DCSP  DCSP  DCSP self._app_iter = None DCNL DCSP  DCSP return self._body DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP value = value.encode('utf-8') DCNL DCSP  DCSP if isinstance(value, str): DCNL DCSP  DCSP  DCSP self.content_length = len(value) DCNL DCSP  DCSP  DCSP self._app_iter = None DCNL DCSP  DCSP self._body = value DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP Response DCSP body DCSP str')
 DCSP def getter(self): DCNL DCSP  DCSP etag = self.headers.get('etag', None) DCNL DCSP  DCSP if etag: DCNL DCSP  DCSP  DCSP etag = etag.replace('"', '') DCNL DCSP  DCSP return etag DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP self.headers['etag'] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.headers['etag'] = ('"%s"' % value) DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP Etag DCSP header')
 DCSP def getter(self): DCNL DCSP  DCSP if ('content-type' in self.headers): DCNL DCSP  DCSP  DCSP return self.headers.get('content-type').split(';')[0] DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers['content-type'] = value DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP Content-Type DCSP header')
 DCSP def getter(self): DCNL DCSP  DCSP if ('; DCSP charset=' in self.headers['content-type']): DCNL DCSP  DCSP  DCSP return self.headers['content-type'].split('; DCSP charset=')[1] DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if ('content-type' in self.headers): DCNL DCSP  DCSP  DCSP self.headers['content-type'] = self.headers['content-type'].split(';')[0] DCNL DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP self.headers['content-type'] += ('; DCSP charset=' + value) DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP charset')
 DCSP def getter(self): DCNL DCSP  DCSP return self._app_iter DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP self.content_length = sum(map(len, value)) DCNL DCSP  DCSP elif (value is not None): DCNL DCSP  DCSP  DCSP self.content_length = None DCNL DCSP  DCSP  DCSP self._body = None DCNL DCSP  DCSP self._app_iter = value DCNL DCSP return property(getter, setter, doc='Retrieve DCSP and DCSP set DCSP the DCSP response DCSP app_iter')
 DCSP def getter(self): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((header in self.headers) or even_if_nonexistent): DCNL DCSP  DCSP  DCSP  DCSP return cls(self.headers.get(header)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.headers[header] = value DCNL DCSP return property(getter, setter, doc=('Retrieve DCSP and DCSP set DCSP the DCSP %s DCSP property DCSP in DCSP the DCSP WSGI DCSP environ, DCSP as DCSP a DCSP %s DCSP object' % (header, cls.__name__)))
 DCSP def getter(self): DCNL DCSP  DCSP return self.environ.get(environ_field, None) DCNL DCSP def setter(self, value): DCNL DCSP  DCSP if isinstance(value, unicode): DCNL DCSP  DCSP  DCSP self.environ[environ_field] = value.encode('utf-8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self.environ[environ_field] = value DCNL DCSP return property(getter, setter, doc=('Get DCSP and DCSP set DCSP the DCSP %s DCSP property DCSP in DCSP the DCSP WSGI DCSP environment' % environ_field))
 DCSP def getter(self): DCNL DCSP  DCSP body = self.environ['wsgi.input'].read() DCNL DCSP  DCSP self.environ['wsgi.input'] = StringIO(body) DCNL DCSP  DCSP return body DCNL DCSP def setter(self, value): DCNL DCSP  DCSP self.environ['wsgi.input'] = StringIO(value) DCNL DCSP  DCSP self.environ['CONTENT_LENGTH'] = str(len(value)) DCNL DCSP return property(getter, setter, doc='Get DCSP and DCSP set DCSP the DCSP request DCSP body DCSP str')
 DCSP def getter(self): DCNL DCSP  DCSP if ('HTTP_HOST' in self.environ): DCNL DCSP  DCSP  DCSP host = self.environ['HTTP_HOST'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP host = ('%s:%s' % (self.environ['SERVER_NAME'], self.environ['SERVER_PORT'])) DCNL DCSP  DCSP scheme = self.environ.get('wsgi.url_scheme', 'http') DCNL DCSP  DCSP if ((scheme == 'http') and host.endswith(':80')): DCNL DCSP  DCSP  DCSP (host, port) = host.rsplit(':', 1) DCNL DCSP  DCSP elif ((scheme == 'https') and host.endswith(':443')): DCNL DCSP  DCSP  DCSP (host, port) = host.rsplit(':', 1) DCNL DCSP  DCSP return ('%s://%s' % (scheme, host)) DCNL DCSP return property(getter, doc='Get DCSP url DCSP for DCSP request/response DCSP up DCSP to DCSP path')
 DCSP argspec = inspect.getargspec(func) DCNL DCSP if (argspec.args and (argspec.args[0] == 'self')): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _wsgify_self(self, env, start_response): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(self, Request(env))(env, start_response) DCNL DCSP  DCSP  DCSP except HTTPException as err_resp: DCNL DCSP  DCSP  DCSP  DCSP return err_resp(env, start_response) DCNL DCSP  DCSP return _wsgify_self DCNL DCSP else: DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP def _wsgify_bare(env, start_response): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(Request(env))(env, start_response) DCNL DCSP  DCSP  DCSP except HTTPException as err_resp: DCNL DCSP  DCSP  DCSP  DCSP return err_resp(env, start_response) DCNL DCSP  DCSP return _wsgify_bare
 DCSP return ((100 <= status) and (status <= 199))
 DCSP return ((200 <= status) and (status <= 299))
 DCSP return ((300 <= status) and (status <= 399))
 DCSP return ((400 <= status) and (status <= 499))
 DCSP return ((500 <= status) and (status <= 599))
 DCSP metadata = '' DCNL DCSP key = 0 DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP metadata += getxattr(fd, ('%s%s' % (METADATA_KEY, (key or '')))) DCNL DCSP  DCSP  DCSP key += 1 DCNL DCSP except IOError: DCNL DCSP  DCSP pass DCNL DCSP return pickle.loads(metadata)
 DCSP metastr = pickle.dumps(metadata, PICKLE_PROTOCOL) DCNL DCSP key = 0 DCNL DCSP while metastr: DCNL DCSP  DCSP setxattr(fd, ('%s%s' % (METADATA_KEY, (key or ''))), metastr[:254]) DCNL DCSP  DCSP metastr = metastr[254:] DCNL DCSP  DCSP key += 1
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return ObjectController(conf)
 DCSP from_dir = dirname(corrupted_file_path) DCNL DCSP to_dir = join(device_path, 'quarantined', 'objects', basename(from_dir)) DCNL DCSP invalidate_hash(dirname(from_dir)) DCNL DCSP try: DCNL DCSP  DCSP renamer(from_dir, to_dir) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno not in (errno.EEXIST, errno.ENOTEMPTY)): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP to_dir = ('%s-%s' % (to_dir, uuid.uuid4().hex)) DCNL DCSP  DCSP renamer(from_dir, to_dir) DCNL DCSP return to_dir
 DCSP md5 = hashlib.md5() DCNL DCSP try: DCNL DCSP  DCSP path_contents = sorted(os.listdir(path)) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if (err.errno in (errno.ENOTDIR, errno.ENOENT)): DCNL DCSP  DCSP  DCSP raise PathNotDir() DCNL DCSP  DCSP raise DCNL DCSP for hsh in path_contents: DCNL DCSP  DCSP hsh_path = join(path, hsh) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP files = os.listdir(hsh_path) DCNL DCSP  DCSP except OSError as err: DCNL DCSP  DCSP  DCSP if (err.errno == errno.ENOTDIR): DCNL DCSP  DCSP  DCSP  DCSP partition_path = dirname(path) DCNL DCSP  DCSP  DCSP  DCSP objects_path = dirname(partition_path) DCNL DCSP  DCSP  DCSP  DCSP device_path = dirname(objects_path) DCNL DCSP  DCSP  DCSP  DCSP quar_path = quarantine_renamer(device_path, hsh_path) DCNL DCSP  DCSP  DCSP  DCSP logging.exception((_('Quarantined DCSP %s DCSP to DCSP %s DCSP because DCSP it DCSP is DCSP not DCSP a DCSP directory') % (hsh_path, quar_path))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (len(files) == 1): DCNL DCSP  DCSP  DCSP if files[0].endswith('.ts'): DCNL DCSP  DCSP  DCSP  DCSP ts = files[0].rsplit('.', 1)[0] DCNL DCSP  DCSP  DCSP  DCSP if ((time.time() - float(ts)) > reclaim_age): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(join(hsh_path, files[0])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.remove(files[0]) DCNL DCSP  DCSP elif files: DCNL DCSP  DCSP  DCSP files.sort(reverse=True) DCNL DCSP  DCSP  DCSP meta = data = tomb = None DCNL DCSP  DCSP  DCSP for filename in list(files): DCNL DCSP  DCSP  DCSP  DCSP if ((not meta) and filename.endswith('.meta')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP meta = filename DCNL DCSP  DCSP  DCSP  DCSP if ((not data) and filename.endswith('.data')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP data = filename DCNL DCSP  DCSP  DCSP  DCSP if ((not tomb) and filename.endswith('.ts')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tomb = filename DCNL DCSP  DCSP  DCSP  DCSP if ((filename < tomb) or (filename < data) or (filename.endswith('.meta') and (filename < meta))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(join(hsh_path, filename)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP files.remove(filename) DCNL DCSP  DCSP if (not files): DCNL DCSP  DCSP  DCSP os.rmdir(hsh_path) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP md5.update(filename) DCNL DCSP try: DCNL DCSP  DCSP os.rmdir(path) DCNL DCSP except OSError: DCNL DCSP  DCSP pass DCNL DCSP return md5.hexdigest()
 DCSP suffix = os.path.basename(suffix_dir) DCNL DCSP partition_dir = os.path.dirname(suffix_dir) DCNL DCSP hashes_file = join(partition_dir, HASH_FILE) DCNL DCSP with lock_path(partition_dir): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(hashes_file, 'rb') as fp: DCNL DCSP  DCSP  DCSP  DCSP hashes = pickle.load(fp) DCNL DCSP  DCSP  DCSP if ((suffix in hashes) and (not hashes[suffix])): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP hashes[suffix] = None DCNL DCSP  DCSP write_pickle(hashes, hashes_file, partition_dir, PICKLE_PROTOCOL)
 DCSP hashed = 0 DCNL DCSP hashes_file = join(partition_dir, HASH_FILE) DCNL DCSP modified = False DCNL DCSP force_rewrite = False DCNL DCSP hashes = {} DCNL DCSP mtime = (-1) DCNL DCSP try: DCNL DCSP  DCSP with open(hashes_file, 'rb') as fp: DCNL DCSP  DCSP  DCSP hashes = pickle.load(fp) DCNL DCSP  DCSP mtime = os.path.getmtime(hashes_file) DCNL DCSP except Exception: DCNL DCSP  DCSP do_listdir = True DCNL DCSP  DCSP force_rewrite = True DCNL DCSP if do_listdir: DCNL DCSP  DCSP for suff in os.listdir(partition_dir): DCNL DCSP  DCSP  DCSP if (len(suff) == 3): DCNL DCSP  DCSP  DCSP  DCSP hashes.setdefault(suff, None) DCNL DCSP  DCSP modified = True DCNL DCSP hashes.update(((hash_, None) for hash_ in recalculate)) DCNL DCSP for (suffix, hash_) in hashes.items(): DCNL DCSP  DCSP if (not hash_): DCNL DCSP  DCSP  DCSP suffix_dir = join(partition_dir, suffix) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hashes[suffix] = hash_suffix(suffix_dir, reclaim_age) DCNL DCSP  DCSP  DCSP  DCSP hashed += 1 DCNL DCSP  DCSP  DCSP except PathNotDir: DCNL DCSP  DCSP  DCSP  DCSP del hashes[suffix] DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP logging.exception(_('Error DCSP hashing DCSP suffix')) DCNL DCSP  DCSP  DCSP modified = True DCNL DCSP if modified: DCNL DCSP  DCSP with lock_path(partition_dir): DCNL DCSP  DCSP  DCSP if (force_rewrite or (not os.path.exists(hashes_file)) or (os.path.getmtime(hashes_file) == mtime)): DCNL DCSP  DCSP  DCSP  DCSP write_pickle(hashes, hashes_file, partition_dir, PICKLE_PROTOCOL) DCNL DCSP  DCSP  DCSP  DCSP return (hashed, hashes) DCNL DCSP  DCSP return get_hashes(partition_dir, recalculate, do_listdir, reclaim_age) DCNL DCSP else: DCNL DCSP  DCSP return (hashed, hashes)
 DCSP def inner(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP except BaseException as err: DCNL DCSP  DCSP  DCSP return err DCNL DCSP resp = tpool.execute(inner) DCNL DCSP if isinstance(resp, BaseException): DCNL DCSP  DCSP raise resp DCNL DCSP return resp
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return Application(conf)
 DCSP if hasattr(headers, 'items'): DCNL DCSP  DCSP headers = headers.items() DCNL DCSP for (name, value) in headers: DCNL DCSP  DCSP if (name == 'etag'): DCNL DCSP  DCSP  DCSP response.headers[name] = value.replace('"', '') DCNL DCSP  DCSP elif (name not in ('date', 'content-length', 'content-type', 'connection', 'x-put-timestamp', 'x-delete-after')): DCNL DCSP  DCSP  DCSP response.headers[name] = value
 DCSP return float((resp.getheader('x-put-timestamp') or resp.getheader('x-timestamp') or 0))
 DCSP func.delay_denial = True DCNL DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped
 DCSP headers = dict(((k.lower(), v) for (k, v) in dict(headers).iteritems())) DCNL DCSP return {'status': status_int, 'container_count': headers.get('x-account-container-count'), 'total_object_count': headers.get('x-account-object-count'), 'bytes': headers.get('x-account-bytes-used'), 'meta': dict(((key[15:], value) for (key, value) in headers.iteritems() if key.startswith('x-account-meta-')))}
 DCSP headers = dict(((k.lower(), v) for (k, v) in dict(headers).iteritems())) DCNL DCSP return {'status': status_int, 'read_acl': headers.get('x-container-read'), 'write_acl': headers.get('x-container-write'), 'sync_key': headers.get('x-container-sync-key'), 'object_count': headers.get('x-container-object-count'), 'bytes': headers.get('x-container-bytes-used'), 'versions': headers.get('x-versions-location'), 'cors': {'allow_origin': headers.get('x-container-meta-access-control-allow-origin'), 'allow_headers': headers.get('x-container-meta-access-control-allow-headers'), 'expose_headers': headers.get('x-container-meta-access-control-expose-headers'), 'max_age': headers.get('x-container-meta-access-control-max-age')}, 'meta': dict(((key[17:], value) for (key, value) in headers.iteritems() if key.startswith('x-container-meta-')))}
 DCSP @functools.wraps(func) DCNL DCSP def wrapped(*a, **kw): DCNL DCSP  DCSP controller = a[0] DCNL DCSP  DCSP req = a[1] DCNL DCSP  DCSP req_origin = req.headers.get('Origin', None) DCNL DCSP  DCSP if req_origin: DCNL DCSP  DCSP  DCSP container_info = controller.container_info(controller.account_name, controller.container_name) DCNL DCSP  DCSP  DCSP cors_info = container_info.get('cors', {}) DCNL DCSP  DCSP  DCSP resp = func(*a, **kw) DCNL DCSP  DCSP  DCSP expose_headers = ['cache-control', 'content-language', 'content-type', 'expires', 'last-modified', 'pragma', 'etag', 'x-timestamp', 'x-trans-id'] DCNL DCSP  DCSP  DCSP for header in resp.headers: DCNL DCSP  DCSP  DCSP  DCSP if (header.startswith('x-container-meta') or header.startswith('x-object-meta')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP expose_headers.append(header.lower()) DCNL DCSP  DCSP  DCSP if cors_info.get('expose_headers'): DCNL DCSP  DCSP  DCSP  DCSP expose_headers.extend([a.strip() for a in cors_info['expose_headers'].split(' DCSP ') if a.strip()]) DCNL DCSP  DCSP  DCSP resp.headers['Access-Control-Expose-Headers'] = ', DCSP '.join(expose_headers) DCNL DCSP  DCSP  DCSP resp.headers['Access-Control-Allow-Origin'] = req_origin DCNL DCSP  DCSP  DCSP return resp DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(*a, **kw) DCNL DCSP return wrapped
 DCSP cache = cache_from_env(env) DCNL DCSP if (not cache): DCNL DCSP  DCSP return None DCNL DCSP (version, account, container, _) = split_path(env['PATH_INFO'], 3, 4, True) DCNL DCSP cache_key = get_container_memcache_key(account, container) DCNL DCSP env_key = ('swift.%s' % cache_key) DCNL DCSP if (env_key not in env): DCNL DCSP  DCSP container_info = cache.get(cache_key) DCNL DCSP  DCSP if (not container_info): DCNL DCSP  DCSP  DCSP resp = make_pre_authed_request(env, 'HEAD', ('/%s/%s/%s' % (version, account, container)), swift_source=swift_source).get_response(app) DCNL DCSP  DCSP  DCSP container_info = headers_to_container_info(resp.headers, resp.status_int) DCNL DCSP  DCSP env[env_key] = container_info DCNL DCSP return env[env_key]
 DCSP cache = cache_from_env(env) DCNL DCSP if (not cache): DCNL DCSP  DCSP return None DCNL DCSP (version, account, container, _) = split_path(env['PATH_INFO'], 2, 4, True) DCNL DCSP cache_key = get_account_memcache_key(account) DCNL DCSP env_key = ('swift.%s' % cache_key) DCNL DCSP if (env_key not in env): DCNL DCSP  DCSP account_info = cache.get(cache_key) DCNL DCSP  DCSP if (not account_info): DCNL DCSP  DCSP  DCSP resp = make_pre_authed_request(env, 'HEAD', ('/%s/%s' % (version, account)), swift_source=swift_source).get_response(app) DCNL DCSP  DCSP  DCSP account_info = headers_to_account_info(resp.headers, resp.status_int) DCNL DCSP  DCSP env[env_key] = account_info DCNL DCSP return env[env_key]
 DCSP for (k, v) in from_r.headers.items(): DCNL DCSP  DCSP if k.lower().startswith('x-object-meta-'): DCNL DCSP  DCSP  DCSP to_r.headers[k] = v
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP return AccountController(conf)
 DCSP auth_json = {} DCNL DCSP if (token is not None): DCNL DCSP  DCSP auth_json['token'] = token DCNL DCSP if (username or password): DCNL DCSP  DCSP auth_json['passwordCredentials'] = {} DCNL DCSP if (username is not None): DCNL DCSP  DCSP auth_json['passwordCredentials']['username'] = username DCNL DCSP if (user_id is not None): DCNL DCSP  DCSP auth_json['passwordCredentials']['userId'] = user_id DCNL DCSP if (password is not None): DCNL DCSP  DCSP auth_json['passwordCredentials']['password'] = password DCNL DCSP if (tenant_name is not None): DCNL DCSP  DCSP auth_json['tenantName'] = tenant_name DCNL DCSP if (tenant_id is not None): DCNL DCSP  DCSP auth_json['tenantId'] = tenant_id DCNL DCSP if (trust_id is not None): DCNL DCSP  DCSP auth_json['trust_id'] = trust_id DCNL DCSP return auth_json
 DCSP if (xml is None): DCNL DCSP  DCSP return None DCNL DCSP deserializer = XmlDeserializer() DCNL DCSP return deserializer(xml)
 DCSP if (d is None): DCNL DCSP  DCSP return None DCNL DCSP serialize = XmlSerializer() DCNL DCSP return serialize(d, xmlns)
 DCSP path = quote((((('/' + device) + '/') + str(partition)) + path)) DCNL DCSP return http_connect_raw(ipaddr, port, device, partition, method, path, headers, query_string, ssl, key_file, cert_file)
 DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaddr, port)), key_file=key_file, cert_file=cert_file) DCNL DCSP else: DCNL DCSP  DCSP conn = BufferedHTTPConnection(('%s:%s' % (ipaddr, port))) DCNL DCSP if query_string: DCNL DCSP  DCSP path += ('?' + query_string) DCNL DCSP conn.path = path DCNL DCSP conn.putrequest(method, path) DCNL DCSP if headers: DCNL DCSP  DCSP for (header, value) in headers.iteritems(): DCNL DCSP  DCSP  DCSP conn.putheader(header, value) DCNL DCSP conn.endheaders() DCNL DCSP return conn
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kw): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return f(*args, **kw) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logging.debug(traceback.format_exc(e)) DCNL DCSP  DCSP  DCSP logging.critical(e) DCNL DCSP  DCSP  DCSP exit(1) DCNL DCSP return wrapper
 DCSP if conf.log_config: DCNL DCSP  DCSP if os.path.exists(conf.log_config): DCNL DCSP  DCSP  DCSP logging.config.fileConfig(conf.log_config) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise RuntimeError((_('Unable DCSP to DCSP locate DCSP specified DCSP logging DCSP config DCSP file: DCSP %s') % conf.log_config)) DCNL DCSP root_logger = logging.root DCNL DCSP if conf.debug: DCNL DCSP  DCSP root_logger.setLevel(logging.DEBUG) DCNL DCSP elif conf.verbose: DCNL DCSP  DCSP root_logger.setLevel(logging.INFO) DCNL DCSP else: DCNL DCSP  DCSP root_logger.setLevel(logging.WARNING) DCNL DCSP formatter = logging.Formatter(conf.log_format, conf.log_date_format) DCNL DCSP if conf.use_syslog: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP facility = getattr(logging.SysLogHandler, conf.syslog_log_facility) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ValueError(_('Invalid DCSP syslog DCSP facility')) DCNL DCSP  DCSP handler = logging.SysLogHandler(address='/dev/log', facility=facility) DCNL DCSP elif conf.log_file: DCNL DCSP  DCSP logfile = conf.log_file DCNL DCSP  DCSP if conf.log_dir: DCNL DCSP  DCSP  DCSP logfile = os.path.join(conf.log_dir, logfile) DCNL DCSP  DCSP handler = logging.WatchedFileHandler(logfile) DCNL DCSP else: DCNL DCSP  DCSP handler = logging.StreamHandler(sys.stdout) DCNL DCSP handler.setFormatter(formatter) DCNL DCSP root_logger.addHandler(handler)
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP try: DCNL DCSP  DCSP if (len(password) > MAX_PASSWORD_LENGTH): DCNL DCSP  DCSP  DCSP return password[:MAX_PASSWORD_LENGTH] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return password DCNL DCSP except TypeError: DCNL DCSP  DCSP raise exception.ValidationError(attribute='string', target='password')
 DCSP try: DCNL DCSP  DCSP password = user['password'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return user DCNL DCSP else: DCNL DCSP  DCSP return dict(user, password=hash_password(password))
 DCSP try: DCNL DCSP  DCSP password = user['password'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return user DCNL DCSP else: DCNL DCSP  DCSP return dict(user, password=ldap_hash_password(password))
 DCSP password_utf8 = trunc_password(password).encode('utf-8') DCNL DCSP if passlib.hash.sha512_crypt.identify(password_utf8): DCNL DCSP  DCSP return password_utf8 DCNL DCSP h = passlib.hash.sha512_crypt.encrypt(password_utf8, rounds=CONF.crypt_strength) DCNL DCSP return h
 DCSP password_utf8 = trunc_password(password).encode('utf-8') DCNL DCSP h = passlib.hash.ldap_salted_sha1.encrypt(password_utf8) DCNL DCSP return h
 DCSP if (password is None): DCNL DCSP  DCSP return False DCNL DCSP password_utf8 = trunc_password(password).encode('utf-8') DCNL DCSP return passlib.hash.sha512_crypt.verify(password_utf8, hashed)
 DCSP if ('stdout' in kwargs): DCNL DCSP  DCSP raise ValueError('stdout DCSP argument DCSP not DCSP allowed, DCSP it DCSP will DCSP be DCSP overridden.') DCNL DCSP LOG.debug(' DCSP '.join(popenargs[0])) DCNL DCSP process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs) DCNL DCSP (output, unused_err) = process.communicate() DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP cmd = kwargs.get('args') DCNL DCSP  DCSP if (cmd is None): DCNL DCSP  DCSP  DCSP cmd = popenargs[0] DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, cmd) DCNL DCSP return output
 DCSP return time.mktime(dt_obj.utctimetuple())
 DCSP result = 0 DCNL DCSP p_len = len(provided) DCNL DCSP k_len = len(known) DCNL DCSP for i in xrange(p_len): DCNL DCSP  DCSP a = (ord(provided[i]) if (i < p_len) else 0) DCNL DCSP  DCSP b = (ord(known[i]) if (i < k_len) else 0) DCNL DCSP  DCSP result |= (a ^ b) DCNL DCSP return ((p_len == k_len) & (result == 0))
 DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatted) DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP LOG.error((_('Verify DCSP error: DCSP %s') % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl', output=err) DCNL DCSP return output
 DCSP return (token[:3] == PKI_ANS1_PREFIX)
 DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcode = process.poll() DCNL DCSP if (retcode or ('Error' in err)): DCNL DCSP  DCSP if (retcode == 3): DCNL DCSP  DCSP  DCSP LOG.error(_("Signing DCSP error: DCSP Unable DCSP to DCSP load DCSP certificate DCSP - DCSP ensure DCSP you've DCSP configured DCSP PKI DCSP with DCSP 'keystone-manage DCSP pki_setup'")) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP LOG.error((_('Signing DCSP error: DCSP %s') % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP return output
 DCSP if (token_id is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_id): DCNL DCSP  DCSP hasher = hashlib.md5() DCNL DCSP  DCSP hasher.update(token_id) DCNL DCSP  DCSP return hasher.hexdigest() DCNL DCSP else: DCNL DCSP  DCSP return token_id
 DCSP def wrapper(cls): DCNL DCSP  DCSP def wrapped(init): DCNL DCSP  DCSP  DCSP def __wrapped_init__(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP 'Initialize DCSP the DCSP wrapped DCSP object DCSP and DCSP add DCSP it DCSP to DCSP the DCSP registry.' DCNL DCSP  DCSP  DCSP  DCSP init(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP REGISTRY[name] = self DCNL DCSP  DCSP  DCSP return __wrapped_init__ DCNL DCSP  DCSP cls.__init__ = wrapped(cls.__init__) DCNL DCSP  DCSP return cls DCNL DCSP return wrapper
 DCSP def wrapper(self, *args, **kwargs): DCNL DCSP  DCSP 'Inject DCSP each DCSP dependency DCSP from DCSP the DCSP registry.' DCNL DCSP  DCSP self.__wrapped_init__(*args, **kwargs) DCNL DCSP  DCSP for dependency in self._dependencies: DCNL DCSP  DCSP  DCSP if (dependency not in REGISTRY): DCNL DCSP  DCSP  DCSP  DCSP raise UnresolvableDependencyException(dependency) DCNL DCSP  DCSP  DCSP setattr(self, dependency, REGISTRY[dependency]) DCNL DCSP def wrapped(cls): DCNL DCSP  DCSP 'Note DCSP the DCSP required DCSP dependencies DCSP on DCSP the DCSP object DCSP for DCSP later DCSP injection.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP dependencies DCSP of DCSP the DCSP parent DCSP class DCSP are DCSP combined DCSP with DCSP that DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP child DCSP class DCSP to DCSP create DCSP a DCSP new DCSP set DCSP of DCSP dependencies.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP existing_dependencies = getattr(cls, '_dependencies', set()) DCNL DCSP  DCSP cls._dependencies = existing_dependencies.union(dependencies) DCNL DCSP  DCSP if (not hasattr(cls, '__wrapped_init__')): DCNL DCSP  DCSP  DCSP cls.__wrapped_init__ = cls.__init__ DCNL DCSP  DCSP  DCSP cls.__init__ = wrapper DCNL DCSP  DCSP return cls DCNL DCSP return wrapped
 DCSP inner = query[1:(-1)] DCNL DCSP if inner.startswith(('&', '|')): DCNL DCSP  DCSP groups = _paren_groups(inner[1:]) DCNL DCSP  DCSP return all((_match_query(group, attrs) for group in groups)) DCNL DCSP if inner.startswith('!'): DCNL DCSP  DCSP return (not _match_query(query[2:(-1)], attrs)) DCNL DCSP (k, _sep, v) = inner.partition('=') DCNL DCSP return _match(k, v, attrs)
 DCSP count = 0 DCNL DCSP start = 0 DCNL DCSP result = [] DCNL DCSP for pos in xrange(len(source)): DCNL DCSP  DCSP if (source[pos] == '('): DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP start = pos DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP if (source[pos] == ')'): DCNL DCSP  DCSP  DCSP count -= 1 DCNL DCSP  DCSP  DCSP if (count == 0): DCNL DCSP  DCSP  DCSP  DCSP result.append(source[start:(pos + 1)]) DCNL DCSP return result
 DCSP if (key not in attrs): DCNL DCSP  DCSP return False DCNL DCSP if (value == '*'): DCNL DCSP  DCSP return True DCNL DCSP if (key == 'serviceId'): DCNL DCSP  DCSP str_sids = [str(x) for x in attrs[key]] DCNL DCSP  DCSP return (str(value) in str_sids) DCNL DCSP if (key != 'objectclass'): DCNL DCSP  DCSP return (value in attrs[key]) DCNL DCSP values = _subs(value) DCNL DCSP for v in values: DCNL DCSP  DCSP if (v in attrs[key]): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP subs = {'groupOfNames': ['keystoneTenant', 'keystoneRole', 'keystoneTenantRole']} DCNL DCSP if (value in subs): DCNL DCSP  DCSP return ([value] + subs[value]) DCNL DCSP return [value]
 DCSP headers = (headers or []) DCNL DCSP headers.append(('Vary', 'X-Auth-Token')) DCNL DCSP if (body is None): DCNL DCSP  DCSP body = '' DCNL DCSP  DCSP status = (status or (204, 'No DCSP Content')) DCNL DCSP else: DCNL DCSP  DCSP body = jsonutils.dumps(body, cls=utils.SmarterEncoder) DCNL DCSP  DCSP headers.append(('Content-Type', 'application/json')) DCNL DCSP  DCSP status = (status or (200, 'OK')) DCNL DCSP return webob.Response(body=body, status=('%s DCSP %s' % status), headerlist=headers)
 DCSP body = {'error': {'code': error.code, 'title': error.title, 'message': str(error)}} DCNL DCSP if isinstance(error, exception.AuthPluginException): DCNL DCSP  DCSP body['error']['identity'] = error.authentication DCNL DCSP return render_response(status=(error.code, error.title), body=body)
 DCSP def initialize(self, *args, **kwargs): DCNL DCSP  DCSP cls = type(self) DCNL DCSP  DCSP for (k, v) in kwargs.items(): DCNL DCSP  DCSP  DCSP if hasattr(cls, k): DCNL DCSP  DCSP  DCSP  DCSP attr = getattr(cls, k) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(attr, InstrumentedAttribute): DCNL DCSP  DCSP  DCSP  DCSP  DCSP column = attr.property.columns[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(column.type, String): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (column.type.length and (column.type.length < len(str(v)))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((config.CONF.signing.token_format == 'PKI') and (self.__tablename__ == 'token') and (k == 'id')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.StringLengthExceeded(string=v, type=k, length=column.type.length) DCNL DCSP  DCSP init(self, *args, **kwargs) DCNL DCSP return initialize
 DCSP def decorator(method): DCNL DCSP  DCSP @functools.wraps(method) DCNL DCSP  DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return method(*args, **kwargs) DCNL DCSP  DCSP  DCSP except IntegrityError as e: DCNL DCSP  DCSP  DCSP  DCSP raise exception.Conflict(type=type, details=str(e.orig)) DCNL DCSP  DCSP return wrapper DCNL DCSP return decorator
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP domain_table = sql.Table('domain', meta, autoload=True) DCNL DCSP domain = {'id': DEFAULT_DOMAIN_ID, 'name': 'Default', 'enabled': True, 'extra': json.dumps({'description': 'Owns DCSP users DCSP and DCSP tenants DCSP (i.e. DCSP projects) DCSP available DCSP on DCSP Identity DCSP API DCSP v2.'})} DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP insert = domain_table.insert() DCNL DCSP insert.execute(domain) DCNL DCSP session.commit()
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP sql.Table('domain', meta, autoload=True) DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP session.execute('DELETE DCSP FROM DCSP domain DCSP WHERE DCSP id=:id', {'id': DEFAULT_DOMAIN_ID}) DCNL DCSP session.commit()
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint', meta, autoload=True) DCNL DCSP legacy_table.rename('endpoint_v2') DCNL DCSP sql.Table('service', meta, autoload=True) DCNL DCSP new_table = sql.Table('endpoint_v3', meta, sql.Column('id', sql.String(64), primary_key=True), sql.Column('legacy_endpoint_id', sql.String(64)), sql.Column('interface', sql.String(8), nullable=False), sql.Column('region', sql.String(255)), sql.Column('service_id', sql.String(64), sql.ForeignKey('service.id'), nullable=False), sql.Column('url', sql.Text(), nullable=False), sql.Column('extra', sql.Text())) DCNL DCSP new_table.create(migrate_engine, checkfirst=True)
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP new_table.drop() DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP legacy_table.rename('endpoint')
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP legacy_table.drop() DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP new_table.rename('endpoint')
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP new_table = sql.Table('endpoint', meta, autoload=True) DCNL DCSP new_table.rename('endpoint_v3') DCNL DCSP sql.Table('service', meta, autoload=True) DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, sql.Column('id', sql.String(64), primary_key=True), sql.Column('region', sql.String(255)), sql.Column('service_id', sql.String(64), sql.ForeignKey('service.id'), nullable=False), sql.Column('extra', sql.Text())) DCNL DCSP legacy_table.create(migrate_engine, checkfirst=True)
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP for ref in session.query(legacy_table).all(): DCNL DCSP  DCSP extra = json.loads(ref.extra) DCNL DCSP  DCSP urls = dict(((i, extra.pop(('%surl' % i))) for i in ENDPOINT_TYPES)) DCNL DCSP  DCSP for interface in ENDPOINT_TYPES: DCNL DCSP  DCSP  DCSP endpoint = {'id': uuid.uuid4().hex, 'legacy_endpoint_id': ref.id, 'interface': interface, 'region': ref.region, 'service_id': ref.service_id, 'url': urls[interface], 'extra': json.dumps(extra)} DCNL DCSP  DCSP  DCSP insert = new_table.insert().values(endpoint) DCNL DCSP  DCSP  DCSP migrate_engine.execute(insert) DCNL DCSP session.commit() DCNL DCSP session.close()
 DCSP meta = sql.MetaData() DCNL DCSP meta.bind = migrate_engine DCNL DCSP legacy_table = sql.Table('endpoint_v2', meta, autoload=True) DCNL DCSP new_table = sql.Table('endpoint_v3', meta, autoload=True) DCNL DCSP session = orm.sessionmaker(bind=migrate_engine)() DCNL DCSP for ref in session.query(new_table).all(): DCNL DCSP  DCSP extra = json.loads(ref.extra) DCNL DCSP  DCSP legacy_id = (ref.legacy_endpoint_id or extra.get('legacy_endpoint_id')) DCNL DCSP  DCSP if (not legacy_id): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP q = session.query(legacy_table) DCNL DCSP  DCSP q = q.filter_by(id=legacy_id) DCNL DCSP  DCSP legacy_ref = q.first() DCNL DCSP  DCSP if legacy_ref: DCNL DCSP  DCSP  DCSP extra = json.loads(legacy_ref.extra) DCNL DCSP  DCSP  DCSP extra[('%surl' % ref.interface)] = ref.url DCNL DCSP  DCSP  DCSP values = {'extra': json.dumps(extra)} DCNL DCSP  DCSP  DCSP update = legacy_table.update().where((legacy_table.c.id == legacy_ref.id)).values(values) DCNL DCSP  DCSP  DCSP migrate_engine.execute(update) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP extra = json.loads(ref.extra) DCNL DCSP  DCSP  DCSP extra[('%surl' % ref.interface)] = ref.url DCNL DCSP  DCSP  DCSP endpoint = {'id': legacy_id, 'region': ref.region, 'service_id': ref.service_id, 'extra': json.dumps(extra)} DCNL DCSP  DCSP  DCSP insert = legacy_table.insert().values(endpoint) DCNL DCSP  DCSP  DCSP migrate_engine.execute(insert) DCNL DCSP  DCSP session.commit() DCNL DCSP session.close()
 DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP return path
 DCSP items = [] DCNL DCSP for (k, v) in d.items(): DCNL DCSP  DCSP new_key = (((parent_key + '.') + k) if parent_key else k) DCNL DCSP  DCSP if isinstance(v, collections.MutableMapping): DCNL DCSP  DCSP  DCSP items.extend(flatten(v, new_key).items()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP items.append((new_key, v)) DCNL DCSP return dict(items)
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(self, context, **kwargs): DCNL DCSP  DCSP if (('is_admin' in context) and context['is_admin']): DCNL DCSP  DCSP  DCSP LOG.warning(_('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP action = ('identity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP creds = _build_policy_check_credentials(self, action, context, kwargs) DCNL DCSP  DCSP  DCSP self.policy_api.enforce(context, creds, action, flatten(kwargs)) DCNL DCSP  DCSP  DCSP LOG.debug(_('RBAC: DCSP Authorization DCSP granted')) DCNL DCSP  DCSP return f(self, context, **kwargs) DCNL DCSP return wrapper
 DCSP def _filterprotected(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def wrapper(self, context, **kwargs): DCNL DCSP  DCSP  DCSP if (not context['is_admin']): DCNL DCSP  DCSP  DCSP  DCSP action = ('identity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP  DCSP creds = _build_policy_check_credentials(self, action, context, kwargs) DCNL DCSP  DCSP  DCSP  DCSP target = dict() DCNL DCSP  DCSP  DCSP  DCSP if (len(filters) > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for filter in filters: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (filter in context['query_string']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP target[filter] = context['query_string'][filter] DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug((_('RBAC: DCSP Adding DCSP query DCSP filter DCSP params DCSP (%s)') % ', DCSP '.join([('%s=%s' % (filter, target[filter])) for filter in target]))) DCNL DCSP  DCSP  DCSP  DCSP for key in kwargs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP target[key] = kwargs[key] DCNL DCSP  DCSP  DCSP  DCSP self.policy_api.enforce(context, creds, action, flatten(target)) DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('RBAC: DCSP Authorization DCSP granted')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP  DCSP return f(self, context, filters, **kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return _filterprotected
 DCSP init() DCNL DCSP extra = {} DCNL DCSP if do_raise: DCNL DCSP  DCSP extra.update(exc=exception.ForbiddenAction, action=action) DCNL DCSP return common_policy.check(action, target, credentials, **extra)
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return S3Token(app, conf) DCNL DCSP return auth_filter
 DCSP return cms.cms_hash_token(token_id)
 DCSP expire_delta = datetime.timedelta(seconds=CONF.token.expiration) DCNL DCSP return (timeutils.utcnow() + expire_delta)
 DCSP if (not user_ref.get('enabled', True)): DCNL DCSP  DCSP msg = ('User DCSP is DCSP disabled: DCSP %s' % user_ref['id']) DCNL DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP user_domain_ref = self.identity_api.get_domain(context, user_ref['domain_id']) DCNL DCSP if (user_domain_ref and (not user_domain_ref.get('enabled', True))): DCNL DCSP  DCSP msg = ('Domain DCSP is DCSP disabled: DCSP %s' % user_domain_ref['id']) DCNL DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP if tenant_ref: DCNL DCSP  DCSP if (not tenant_ref.get('enabled', True)): DCNL DCSP  DCSP  DCSP msg = ('Tenant DCSP is DCSP disabled: DCSP %s' % tenant_ref['id']) DCNL DCSP  DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP  DCSP raise exception.Unauthorized(msg) DCNL DCSP  DCSP project_domain_ref = self.identity_api.get_domain(context, tenant_ref['domain_id']) DCNL DCSP  DCSP if (project_domain_ref and (not project_domain_ref.get('enabled', True))): DCNL DCSP  DCSP  DCSP msg = ('Domain DCSP is DCSP disabled: DCSP %s' % project_domain_ref['id']) DCNL DCSP  DCSP  DCSP LOG.warning(msg) DCNL DCSP  DCSP  DCSP raise exception.Unauthorized(msg)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP global _rules DCNL DCSP _rules = rules
 DCSP global _rules DCNL DCSP _rules = None
 DCSP if isinstance(rule, BaseCheck): DCNL DCSP  DCSP result = rule(target, creds) DCNL DCSP elif (not _rules): DCNL DCSP  DCSP result = False DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = _rules[rule](target, creds) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP result = False DCNL DCSP if (exc and (result is False)): DCNL DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP return result
 DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kind, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kind in _checks): DCNL DCSP  DCSP return _checks[kind](kind, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kind, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP handler DCSP for DCSP matches DCSP of DCSP kind DCSP %s') % kind)) DCNL DCSP  DCSP return FalseCheck()
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP or_list = [] DCNL DCSP for inner_rule in rule: DCNL DCSP  DCSP if (not inner_rule): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(inner_rule, basestring): DCNL DCSP  DCSP  DCSP inner_rule = [inner_rule] DCNL DCSP  DCSP and_list = [_parse_check(r) for r in inner_rule] DCNL DCSP  DCSP if (len(and_list) == 1): DCNL DCSP  DCSP  DCSP or_list.append(and_list[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP or_list.append(AndCheck(and_list)) DCNL DCSP if (len(or_list) == 0): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (len(or_list) == 1): DCNL DCSP  DCSP return or_list[0] DCNL DCSP return OrCheck(or_list)
 DCSP for tok in _tokenize_re.split(rule): DCNL DCSP  DCSP if ((not tok) or tok.isspace()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP clean = tok.lstrip('(') DCNL DCSP  DCSP for i in range((len(tok) - len(clean))): DCNL DCSP  DCSP  DCSP (yield ('(', '(')) DCNL DCSP  DCSP if (not clean): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tok = clean DCNL DCSP  DCSP clean = tok.rstrip(')') DCNL DCSP  DCSP trail = (len(tok) - len(clean)) DCNL DCSP  DCSP lowered = clean.lower() DCNL DCSP  DCSP if (lowered in ('and', 'or', 'not')): DCNL DCSP  DCSP  DCSP (yield (lowered, clean)) DCNL DCSP  DCSP elif clean: DCNL DCSP  DCSP  DCSP if ((len(tok) >= 2) and ((tok[0], tok[(-1)]) in [('"', '"'), ("'", "'")])): DCNL DCSP  DCSP  DCSP  DCSP (yield ('string', tok[1:(-1)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (yield ('check', _parse_check(clean))) DCNL DCSP  DCSP for i in range(trail): DCNL DCSP  DCSP  DCSP (yield (')', ')'))
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'reducers')): DCNL DCSP  DCSP  DCSP func.reducers = [] DCNL DCSP  DCSP func.reducers.append(list(tokens)) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP if (not rule): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP state = ParseState() DCNL DCSP for (tok, value) in _parse_tokenize(rule): DCNL DCSP  DCSP state.shift(tok, value) DCNL DCSP try: DCNL DCSP  DCSP return state.result DCNL DCSP except ValueError: DCNL DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP understand DCSP rule DCSP %(rule)r') % locals())) DCNL DCSP  DCSP return FalseCheck()
 DCSP if isinstance(rule, basestring): DCNL DCSP  DCSP return _parse_text_rule(rule) DCNL DCSP return _parse_list_rule(rule)
 DCSP def decorator(func): DCNL DCSP  DCSP _checks[name] = func DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = 'git DCSP log DCSP --stat' DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP  DCSP git_log_cmd = (("git DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '" + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = parse_mailmap() DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command('git DCSP describe DCSP --always') DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command('git DCSP rev-list DCSP --abbrev-commit DCSP HEAD') DCNL DCSP return len(revlist.splitlines())
 DCSP if os.path.isdir('.git'): DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --exact-match', throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command('git DCSP log DCSP -n1 DCSP --pretty=format:%h') DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command('git DCSP describe DCSP --always').replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > 3): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP o = [] DCNL DCSP  DCSP  DCSP for v in value: DCNL DCSP  DCSP  DCSP  DCSP o.append(to_primitive(v, convert_instances=convert_instances, level=level)) DCNL DCSP  DCSP  DCSP return o DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP o = {} DCNL DCSP  DCSP  DCSP for (k, v) in value.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP o[k] = to_primitive(v, convert_instances=convert_instances, level=level) DCNL DCSP  DCSP  DCSP return o DCNL DCSP  DCSP elif isinstance(value, datetime.datetime): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return to_primitive(dict(value.iteritems()), convert_instances=convert_instances, level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return to_primitive(list(value), convert_instances=convert_instances, level=level) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return to_primitive(value.__dict__, convert_instances=convert_instances, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError as e: DCNL DCSP  DCSP return unicode(value)
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError) as exc: DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP if user_ref: DCNL DCSP  DCSP user_ref = user_ref.copy() DCNL DCSP  DCSP user_ref.pop('password', None) DCNL DCSP  DCSP user_ref.pop('tenants', None) DCNL DCSP  DCSP user_ref.pop('groups', None) DCNL DCSP  DCSP user_ref.pop('domains', None) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('password', None) DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('tenants', None) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return user_ref
 DCSP try: DCNL DCSP  DCSP result = (url.replace('$(', '%(') % data) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return None DCNL DCSP except KeyError as e: DCNL DCSP  DCSP LOG.error((_('Malformed DCSP endpoint DCSP %(url)s DCSP - DCSP unknown DCSP key DCSP %(keyerror)s') % {'url': url, 'keyerror': str(e)})) DCNL DCSP  DCSP raise exception.MalformedEndpoint(endpoint=url) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP LOG.error((_('Malformed DCSP endpoint DCSP %(url)s DCSP - DCSP unknown DCSP key DCSP %(keyerror)s(are DCSP you DCSP missing DCSP brackets DCSP ?)') % {'url': url, 'keyerror': str(e)})) DCNL DCSP  DCSP raise exception.MalformedEndpoint(endpoint=url) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP LOG.error((_('Malformed DCSP endpoint DCSP %s DCSP - DCSP incomplete DCSP format DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (are DCSP you DCSP missing DCSP a DCSP type DCSP notifier DCSP ?)') % url)) DCNL DCSP  DCSP raise exception.MalformedEndpoint(endpoint=url) DCNL DCSP return result
 DCSP new_expires = expires DCNL DCSP project_id = None DCNL DCSP user_id = None DCNL DCSP domain_id = None DCNL DCSP methods = ['password', 'token'] DCNL DCSP extras = {} DCNL DCSP if token_data: DCNL DCSP  DCSP token = token_data['token'] DCNL DCSP  DCSP domain_id = (token['domain']['id'] if ('domain' in token) else None) DCNL DCSP  DCSP project_id = (token['project']['id'] if ('project' in token) else None) DCNL DCSP  DCSP if (not new_expires): DCNL DCSP  DCSP  DCSP new_expires = token.get('expires_at', token.get('expires')) DCNL DCSP  DCSP user_id = token['user']['id'] DCNL DCSP  DCSP methods = token['methods'] DCNL DCSP  DCSP extras = token['extras'] DCNL DCSP else: DCNL DCSP  DCSP token = None DCNL DCSP  DCSP project_id = (project_ref['id'] if project_ref else None) DCNL DCSP  DCSP user_id = user_ref['id'] DCNL DCSP token_data_helper = TokenDataHelper(context) DCNL DCSP return token_data_helper.get_token_data(user_id, methods, extras, domain_id, project_id, new_expires, token=token)
 DCSP headers = [('X-Subject-Token', token_id)] DCNL DCSP headers.append(('Vary', 'X-Auth-Token')) DCNL DCSP headers.append(('Content-Type', 'application/json')) DCNL DCSP if created: DCNL DCSP  DCSP status = (201, 'Created') DCNL DCSP else: DCNL DCSP  DCSP status = (200, 'OK') DCNL DCSP body = jsonutils.dumps(token_data, cls=utils.SmarterEncoder) DCNL DCSP return webob.Response(body=body, status=('%s DCSP %s' % status), headerlist=headers)
 DCSP if redirect_output: DCNL DCSP  DCSP stdout = subprocess.PIPE DCNL DCSP else: DCNL DCSP  DCSP stdout = None DCNL DCSP proc = subprocess.Popen(cmd, cwd=ROOT, stdout=stdout) DCNL DCSP output = proc.communicate()[0] DCNL DCSP if (check_exit_code and (proc.returncode != 0)): DCNL DCSP  DCSP die('Command DCSP "%s" DCSP failed.\n%s', ' DCSP '.join(cmd), output) DCNL DCSP return (output, proc.returncode)
 DCSP print 'Creating DCSP venv...', DCNL DCSP if no_site_packages: DCNL DCSP  DCSP run_command(['virtualenv', '-q', '--no-site-packages', VENV]) DCNL DCSP else: DCNL DCSP  DCSP run_command(['virtualenv', '-q', VENV]) DCNL DCSP print 'done.' DCNL DCSP print 'Installing DCSP pip DCSP in DCSP virtualenv...', DCNL DCSP if (not run_command(['tools/with_venv.sh', 'easy_install', 'pip>1.0']).strip()): DCNL DCSP  DCSP die('Failed DCSP to DCSP install DCSP pip.') DCNL DCSP print 'done.'
 DCSP parser = optparse.OptionParser() DCNL DCSP parser.add_option('-n', '--no-site-packages', dest='no_site_packages', default=False, action='store_true', help='Do DCSP not DCSP inherit DCSP packages DCSP from DCSP global DCSP Python DCSP install') DCNL DCSP return parser.parse_args()
 DCSP try: DCNL DCSP  DCSP return obj.id DCNL DCSP except AttributeError: DCNL DCSP  DCSP return obj
 DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatted) DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP LOG.error(('Verify DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP e = subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP  DCSP e.output = err DCNL DCSP  DCSP raise e DCNL DCSP return output
 DCSP return (token[:3] == PKI_ANS1_PREFIX)
 DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcode = process.poll() DCNL DCSP if (retcode or ('Error' in err)): DCNL DCSP  DCSP LOG.error(('Signing DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP return output
 DCSP if (token_id is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_id): DCNL DCSP  DCSP hasher = hashlib.md5() DCNL DCSP  DCSP hasher.update(token_id) DCNL DCSP  DCSP return hasher.hexdigest() DCNL DCSP else: DCNL DCSP  DCSP return token_id
 DCSP soon = (timeutils.utcnow() + datetime.timedelta(seconds=30)) DCNL DCSP return (expiry < soon)
 DCSP return (urllib.quote(s) if (s == urllib.unquote(s)) else s)
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return AuthProtocol(app, conf) DCNL DCSP return auth_filter
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kwds): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwds) DCNL DCSP return wrapper
 DCSP return hashlib.sha256((token + secret)).digest()
 DCSP return hash_data((serialized_data + token))
 DCSP return base64.b64encode(hashlib.sha1(data).digest())
 DCSP mac_data = {} DCNL DCSP mac_data['serialized_data'] = json.dumps(data) DCNL DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP mac_data['mac'] = mac DCNL DCSP md = (MAC_MARKER + base64.b64encode(json.dumps(mac_data))) DCNL DCSP return md
 DCSP if data.startswith(MAC_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = data[len(MAC_MARKER):] DCNL DCSP  DCSP  DCSP mac_data = json.loads(base64.b64decode(data)) DCNL DCSP  DCSP  DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP  DCSP  DCSP if (mac != mac_data['mac']): DCNL DCSP  DCSP  DCSP  DCSP raise InvalidMacError(('invalid DCSP MAC; DCSP expect=%s, DCSP actual=%s' % (mac_data['mac'], mac))) DCNL DCSP  DCSP  DCSP return json.loads(mac_data['serialized_data']) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvalidMacError('invalid DCSP MAC; DCSP data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
 DCSP iv = os.urandom(16) DCNL DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP data = json.dumps(data) DCNL DCSP encoded_data = base64.b64encode((iv + cipher.encrypt(data))) DCNL DCSP encoded_data = (ENCRYPT_MARKER + encoded_data) DCNL DCSP return encoded_data
 DCSP if data.startswith(ENCRYPT_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP encoded_data = data[len(ENCRYPT_MARKER):] DCNL DCSP  DCSP  DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP  DCSP  DCSP decoded_data = base64.b64decode(encoded_data) DCNL DCSP  DCSP  DCSP iv = decoded_data[:16] DCNL DCSP  DCSP  DCSP encrypted_data = decoded_data[16:] DCNL DCSP  DCSP  DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP  DCSP  DCSP decrypted_data = cipher.decrypt(encrypted_data) DCNL DCSP  DCSP  DCSP return json.loads(decrypted_data) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DecryptError('data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
 DCSP def _decorator(func): DCNL DCSP  DCSP add_arg(func, *args, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _decorator
 DCSP for v in vars: DCNL DCSP  DCSP value = os.environ.get(v, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('default', '')
 DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
 DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.append(hook)
 DCSP hooks = getattr(f, 'resource_manager_kwargs_hooks', []) DCNL DCSP extra_kwargs = {} DCNL DCSP for hook in hooks: DCNL DCSP  DCSP hook_name = hook.__name__ DCNL DCSP  DCSP hook_kwargs = hook(args) DCNL DCSP  DCSP conflicting_keys = (set(hook_kwargs.keys()) & set(extra_kwargs.keys())) DCNL DCSP  DCSP if (conflicting_keys and (not allow_conflicts)): DCNL DCSP  DCSP  DCSP raise Exception(("Hook DCSP '%(hook_name)s' DCSP is DCSP attempting DCSP to DCSP redefine DCSP attributes DCSP '%(conflicting_keys)s'" % locals())) DCNL DCSP  DCSP extra_kwargs.update(hook_kwargs) DCNL DCSP return extra_kwargs
 DCSP f.unauthenticated = True DCNL DCSP return f
 DCSP return getattr(f, 'unauthenticated', False)
 DCSP def inner(f): DCNL DCSP  DCSP f.service_type = stype DCNL DCSP  DCSP return f DCNL DCSP return inner
 DCSP return getattr(f, 'service_type', None)
 DCSP try: DCNL DCSP  DCSP if (isinstance(name_or_id, int) or name_or_id.isdigit()): DCNL DCSP  DCSP  DCSP return manager.get(int(name_or_id)) DCNL DCSP except exceptions.NotFound: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP uuid.UUID(strutils.safe_decode(name_or_id)) DCNL DCSP  DCSP return manager.get(name_or_id) DCNL DCSP except (ValueError, exceptions.NotFound): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(human_id=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(name=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP except (UnicodeDecodeError, exceptions.NotFound): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ("No DCSP %s DCSP with DCSP a DCSP name DCSP or DCSP ID DCSP of DCSP '%s' DCSP exists." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.CommandError(msg) DCNL DCSP except exceptions.NoUniqueMatch: DCNL DCSP  DCSP msg = ("Multiple DCSP %s DCSP matches DCSP found DCSP for DCSP '%s', DCSP use DCSP an DCSP ID DCSP to DCSP be DCSP more DCSP specific." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP raise exceptions.CommandError(msg)
 DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(mod_str) DCNL DCSP return getattr(sys.modules[mod_str], class_str)
 DCSP import unicodedata DCNL DCSP if (not isinstance(value, unicode)): DCNL DCSP  DCSP value = unicode(value) DCNL DCSP value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore') DCNL DCSP value = unicode(_slugify_strip_re.sub('', value).strip().lower()) DCNL DCSP return _slugify_hyphenate_re.sub('-', value)
 DCSP cls = _code_map.get(response.status_code, ClientException) DCNL DCSP if response.headers: DCNL DCSP  DCSP request_id = response.headers.get('x-compute-request-id') DCNL DCSP else: DCNL DCSP  DCSP request_id = None DCNL DCSP if body: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP details = 'n/a' DCNL DCSP  DCSP if hasattr(body, 'keys'): DCNL DCSP  DCSP  DCSP error = body[body.keys()[0]] DCNL DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP details = error.get('details', None) DCNL DCSP  DCSP return cls(code=response.status_code, message=message, details=details, request_id=request_id) DCNL DCSP else: DCNL DCSP  DCSP return cls(code=response.status_code, request_id=request_id)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP return ((bool_from_string(subject) and 1) or 0)
 DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP signed_cmd = (('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authored-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signed_entries = _run_shell_command(signed_cmd) DCNL DCSP  DCSP  DCSP if signed_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signed.split(':', 1)[1].strip() for signed in signed_entries.split('\n') if signed]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, datetime.datetime): DCNL DCSP  DCSP if convert_datetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
 DCSP def print_progress(progress): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s... DCSP %(progress)s%% DCSP complete' % dict(action=action, progress=progress)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s...' % dict(action=action)) DCNL DCSP  DCSP sys.stdout.write(msg) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP print DCNL DCSP while True: DCNL DCSP  DCSP obj = poll_fn(obj_id) DCNL DCSP  DCSP status = obj.status.lower() DCNL DCSP  DCSP progress = (getattr(obj, 'progress', None) or 0) DCNL DCSP  DCSP if (status in final_ok_states): DCNL DCSP  DCSP  DCSP print_progress(100) DCNL DCSP  DCSP  DCSP print '\nFinished' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (status == 'error'): DCNL DCSP  DCSP  DCSP print ('\nError DCSP %(action)s DCSP instance' % locals()) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print_progress(progress) DCNL DCSP  DCSP  DCSP time.sleep(poll_period)
 DCSP return utils.find_resource(cs.monitors, monitor)
 DCSP return utils.find_resource(cs.monitor_snapshots, snapshot)
 DCSP return utils.find_resource(cs.backups, backup)
 DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status} DCNL DCSP monitors = cs.monitors.list(search_opts=search_opts) DCNL DCSP _translate_monitor_keys(monitors) DCNL DCSP for vol in monitors: DCNL DCSP  DCSP servers = [s.get('server_id') for s in vol.attachments] DCNL DCSP  DCSP setattr(vol, 'attached_to', ','.join(map(str, servers))) DCNL DCSP utils.print_list(monitors, ['ID', 'Status', 'Display DCSP Name', 'Size', 'ServiceManage DCSP Type', 'Bootable', 'Attached DCSP to'])
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP _print_monitor(monitor)
 DCSP monitor_metadata = None DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP monitor_metadata = _extract_metadata(args) DCNL DCSP monitor = cs.monitors.create(args.size, args.snapshot_id, args.source_volid, args.display_name, args.display_description, args.monitor_type, availability_zone=args.availability_zone, imageRef=args.image_id, metadata=monitor_metadata) DCNL DCSP _print_monitor(monitor)
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.delete()
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.force_delete()
 DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor(cs, args.monitor).update(**kwargs)
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP metadata = _extract_metadata(args) DCNL DCSP if (args.action == 'set'): DCNL DCSP  DCSP cs.monitors.set_metadata(monitor, metadata) DCNL DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP cs.monitors.delete_metadata(monitor, metadata.keys())
 DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status, 'monitor_id': args.monitor_id} DCNL DCSP snapshots = cs.monitor_snapshots.list(search_opts=search_opts) DCNL DCSP _translate_monitor_snapshot_keys(snapshots) DCNL DCSP utils.print_list(snapshots, ['ID', 'ServiceManage DCSP ID', 'Status', 'Display DCSP Name', 'Size'])
 DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot) DCNL DCSP _print_monitor_snapshot(snapshot)
 DCSP snapshot = cs.monitor_snapshots.create(args.monitor_id, args.force, args.display_name, args.display_description) DCNL DCSP _print_monitor_snapshot(snapshot)
 DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot_id) DCNL DCSP snapshot.delete()
 DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor_snapshot(cs, args.snapshot).update(**kwargs)
 DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_monitor_type_list(vtypes)
 DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_type_and_extra_specs_list(vtypes)
 DCSP vtype = cs.monitor_types.create(args.name) DCNL DCSP _print_monitor_type_list([vtype])
 DCSP cs.monitor_types.delete(args.id)
 DCSP vtype = _find_monitor_type(cs, args.vtype) DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP keypair = _extract_metadata(args) DCNL DCSP  DCSP if (args.action == 'set'): DCNL DCSP  DCSP  DCSP vtype.set_keys(keypair) DCNL DCSP  DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP  DCSP vtype.unset_keys(keypair.keys())
 DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP for e in catalog['access']['serviceCatalog']: DCNL DCSP  DCSP utils.print_dict(e['endpoints'][0], e['name'])
 DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP utils.print_dict(catalog['access']['user'], 'User DCSP Credentials') DCNL DCSP utils.print_dict(catalog['access']['token'], 'Token')
 DCSP _quota_show(cs.quotas.get(args.tenant))
 DCSP _quota_show(cs.quotas.defaults(args.tenant))
 DCSP _quota_update(cs.quotas, args.tenant, args)
 DCSP _quota_show(cs.quota_classes.get(args.class_name))
 DCSP _quota_update(cs.quota_classes, args.class_name, args)
 DCSP limits = cs.limits.get().absolute DCNL DCSP columns = ['Name', 'Value'] DCNL DCSP utils.print_list(limits, columns)
 DCSP limits = cs.limits.get().rate DCNL DCSP columns = ['Verb', 'URI', 'Value', 'Remain', 'Unit', 'Next_Available'] DCNL DCSP utils.print_list(limits, columns)
 DCSP return utils.find_resource(cs.monitor_types, vtype)
 DCSP monitor = _find_monitor(cs, args.monitor_id) DCNL DCSP monitor.upload_to_image(args.force, args.image_name, args.container_format, args.disk_format)
 DCSP cs.backups.create(args.monitor, args.container, args.display_name, args.display_description)
 DCSP backup = _find_backup(cs, args.backup) DCNL DCSP info = dict() DCNL DCSP info.update(backup._info) DCNL DCSP if ('links' in info): DCNL DCSP  DCSP info.pop('links') DCNL DCSP utils.print_dict(info)
 DCSP backups = cs.backups.list() DCNL DCSP columns = ['ID', 'ServiceManage DCSP ID', 'Status', 'Name', 'Size', 'Object DCSP Count', 'Container'] DCNL DCSP utils.print_list(backups, columns)
 DCSP backup = _find_backup(cs, args.backup) DCNL DCSP backup.delete()
 DCSP cs.restores.restore(args.backup, args.monitor_id)
 DCSP extensions = client.list_extensions.show_all() DCNL DCSP fields = ['Name', 'Summary', 'Alias', 'Updated'] DCNL DCSP utils.print_list(extensions, fields)
 DCSP try: DCNL DCSP  DCSP return obj.id DCNL DCSP except AttributeError: DCNL DCSP  DCSP return obj
 DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-verify', '-certfile', signing_cert_file_name, '-CAfile', ca_file_name, '-inform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(formatted) DCNL DCSP retcode = process.poll() DCNL DCSP if retcode: DCNL DCSP  DCSP LOG.error(('Verify DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP e = subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP  DCSP e.output = err DCNL DCSP  DCSP raise e DCNL DCSP return output
 DCSP return (token[:3] == PKI_ANS1_PREFIX)
 DCSP _ensure_subprocess() DCNL DCSP process = subprocess.Popen(['openssl', 'cms', '-sign', '-signer', signing_cert_file_name, '-inkey', signing_key_file_name, '-outform', 'PEM', '-nosmimecap', '-nodetach', '-nocerts', '-noattr'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE) DCNL DCSP (output, err) = process.communicate(text) DCNL DCSP retcode = process.poll() DCNL DCSP if (retcode or ('Error' in err)): DCNL DCSP  DCSP LOG.error(('Signing DCSP error: DCSP %s' % err)) DCNL DCSP  DCSP raise subprocess.CalledProcessError(retcode, 'openssl') DCNL DCSP return output
 DCSP if (token_id is None): DCNL DCSP  DCSP return None DCNL DCSP if is_ans1_token(token_id): DCNL DCSP  DCSP hasher = hashlib.md5() DCNL DCSP  DCSP hasher.update(token_id) DCNL DCSP  DCSP return hasher.hexdigest() DCNL DCSP else: DCNL DCSP  DCSP return token_id
 DCSP soon = (timeutils.utcnow() + datetime.timedelta(seconds=30)) DCNL DCSP return (expiry < soon)
 DCSP return (urllib.quote(s) if (s == urllib.unquote(s)) else s)
 DCSP conf = global_conf.copy() DCNL DCSP conf.update(local_conf) DCNL DCSP def auth_filter(app): DCNL DCSP  DCSP return AuthProtocol(app, conf) DCNL DCSP return auth_filter
 DCSP @functools.wraps(f) DCNL DCSP def wrapper(*args, **kwds): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwds) DCNL DCSP return wrapper
 DCSP return hashlib.sha256((token + secret)).digest()
 DCSP return hash_data((serialized_data + token))
 DCSP return base64.b64encode(hashlib.sha1(data).digest())
 DCSP mac_data = {} DCNL DCSP mac_data['serialized_data'] = json.dumps(data) DCNL DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP mac_data['mac'] = mac DCNL DCSP md = (MAC_MARKER + base64.b64encode(json.dumps(mac_data))) DCNL DCSP return md
 DCSP if data.startswith(MAC_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP data = data[len(MAC_MARKER):] DCNL DCSP  DCSP  DCSP mac_data = json.loads(base64.b64decode(data)) DCNL DCSP  DCSP  DCSP mac = compute_mac(token, mac_data['serialized_data']) DCNL DCSP  DCSP  DCSP if (mac != mac_data['mac']): DCNL DCSP  DCSP  DCSP  DCSP raise InvalidMacError(('invalid DCSP MAC; DCSP expect=%s, DCSP actual=%s' % (mac_data['mac'], mac))) DCNL DCSP  DCSP  DCSP return json.loads(mac_data['serialized_data']) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise InvalidMacError('invalid DCSP MAC; DCSP data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
 DCSP iv = os.urandom(16) DCNL DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP data = json.dumps(data) DCNL DCSP encoded_data = base64.b64encode((iv + cipher.encrypt(data))) DCNL DCSP encoded_data = (ENCRYPT_MARKER + encoded_data) DCNL DCSP return encoded_data
 DCSP if data.startswith(ENCRYPT_MARKER): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP encoded_data = data[len(ENCRYPT_MARKER):] DCNL DCSP  DCSP  DCSP aes_key = generate_aes_key(token, secret) DCNL DCSP  DCSP  DCSP decoded_data = base64.b64decode(encoded_data) DCNL DCSP  DCSP  DCSP iv = decoded_data[:16] DCNL DCSP  DCSP  DCSP encrypted_data = decoded_data[16:] DCNL DCSP  DCSP  DCSP cipher = AES.new(aes_key, AES.MODE_CFB, iv) DCNL DCSP  DCSP  DCSP decrypted_data = cipher.decrypt(encrypted_data) DCNL DCSP  DCSP  DCSP return json.loads(decrypted_data) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise DecryptError('data DCSP appeared DCSP to DCSP be DCSP corrupted') DCNL DCSP else: DCNL DCSP  DCSP return data
 DCSP def _decorator(func): DCNL DCSP  DCSP add_arg(func, *args, **kwargs) DCNL DCSP  DCSP return func DCNL DCSP return _decorator
 DCSP for v in vars: DCNL DCSP  DCSP value = os.environ.get(v, None) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP return value DCNL DCSP return kwargs.get('default', '')
 DCSP if (not hasattr(f, 'arguments')): DCNL DCSP  DCSP f.arguments = [] DCNL DCSP if ((args, kwargs) not in f.arguments): DCNL DCSP  DCSP f.arguments.insert(0, (args, kwargs))
 DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.append(hook)
 DCSP hooks = getattr(f, 'resource_manager_kwargs_hooks', []) DCNL DCSP extra_kwargs = {} DCNL DCSP for hook in hooks: DCNL DCSP  DCSP hook_name = hook.__name__ DCNL DCSP  DCSP hook_kwargs = hook(args) DCNL DCSP  DCSP conflicting_keys = (set(hook_kwargs.keys()) & set(extra_kwargs.keys())) DCNL DCSP  DCSP if (conflicting_keys and (not allow_conflicts)): DCNL DCSP  DCSP  DCSP raise Exception(("Hook DCSP '%(hook_name)s' DCSP is DCSP attempting DCSP to DCSP redefine DCSP attributes DCSP '%(conflicting_keys)s'" % locals())) DCNL DCSP  DCSP extra_kwargs.update(hook_kwargs) DCNL DCSP return extra_kwargs
 DCSP f.unauthenticated = True DCNL DCSP return f
 DCSP return getattr(f, 'unauthenticated', False)
 DCSP def inner(f): DCNL DCSP  DCSP f.service_type = stype DCNL DCSP  DCSP return f DCNL DCSP return inner
 DCSP return getattr(f, 'service_type', None)
 DCSP try: DCNL DCSP  DCSP if (isinstance(name_or_id, int) or name_or_id.isdigit()): DCNL DCSP  DCSP  DCSP return manager.get(int(name_or_id)) DCNL DCSP except exceptions.NotFound: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP uuid.UUID(strutils.safe_decode(name_or_id)) DCNL DCSP  DCSP return manager.get(name_or_id) DCNL DCSP except (ValueError, exceptions.NotFound): DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(human_id=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return manager.find(name=name_or_id) DCNL DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP except (UnicodeDecodeError, exceptions.NotFound): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return manager.find(display_name=name_or_id) DCNL DCSP  DCSP  DCSP  DCSP except exceptions.NotFound: DCNL DCSP  DCSP  DCSP  DCSP  DCSP msg = ("No DCSP %s DCSP with DCSP a DCSP name DCSP or DCSP ID DCSP of DCSP '%s' DCSP exists." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exceptions.CommandError(msg) DCNL DCSP except exceptions.NoUniqueMatch: DCNL DCSP  DCSP msg = ("Multiple DCSP %s DCSP matches DCSP found DCSP for DCSP '%s', DCSP use DCSP an DCSP ID DCSP to DCSP be DCSP more DCSP specific." % (manager.resource_class.__name__.lower(), name_or_id)) DCNL DCSP  DCSP raise exceptions.CommandError(msg)
 DCSP try: DCNL DCSP  DCSP if issubclass(*args): DCNL DCSP  DCSP  DCSP return True DCNL DCSP except TypeError: DCNL DCSP  DCSP pass DCNL DCSP return False
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP __import__(mod_str) DCNL DCSP return getattr(sys.modules[mod_str], class_str)
 DCSP import unicodedata DCNL DCSP if (not isinstance(value, unicode)): DCNL DCSP  DCSP value = unicode(value) DCNL DCSP value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore') DCNL DCSP value = unicode(_slugify_strip_re.sub('', value).strip().lower()) DCNL DCSP return _slugify_hyphenate_re.sub('-', value)
 DCSP cls = _code_map.get(response.status_code, ClientException) DCNL DCSP if response.headers: DCNL DCSP  DCSP request_id = response.headers.get('x-compute-request-id') DCNL DCSP else: DCNL DCSP  DCSP request_id = None DCNL DCSP if body: DCNL DCSP  DCSP message = 'n/a' DCNL DCSP  DCSP details = 'n/a' DCNL DCSP  DCSP if hasattr(body, 'keys'): DCNL DCSP  DCSP  DCSP error = body[body.keys()[0]] DCNL DCSP  DCSP  DCSP message = error.get('message', None) DCNL DCSP  DCSP  DCSP details = error.get('details', None) DCNL DCSP  DCSP return cls(code=response.status_code, message=message, details=details, request_id=request_id) DCNL DCSP else: DCNL DCSP  DCSP return cls(code=response.status_code, request_id=request_id)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP return ((bool_from_string(subject) and 1) or 0)
 DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP signed_cmd = (('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP | DCSP grep DCSP -i DCSP Co-authored-by: DCSP | DCSP sort DCSP -u') DCNL DCSP  DCSP  DCSP signed_entries = _run_shell_command(signed_cmd) DCNL DCSP  DCSP  DCSP if signed_entries: DCNL DCSP  DCSP  DCSP  DCSP new_entries = '\n'.join([signed.split(':', 1)[1].strip() for signed in signed_entries.split('\n') if signed]) DCNL DCSP  DCSP  DCSP  DCSP changelog = '\n'.join((changelog, new_entries)) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP if isinstance(value, _simple_types): DCNL DCSP  DCSP return value DCNL DCSP if isinstance(value, datetime.datetime): DCNL DCSP  DCSP if convert_datetime: DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return six.text_type(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(lv) for lv in value] DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if any((test(value) for test in _nasty_type_tests)): DCNL DCSP  DCSP  DCSP  DCSP return six.text_type(value) DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return six.text_type(value)
 DCSP def print_progress(progress): DCNL DCSP  DCSP if show_progress: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s... DCSP %(progress)s%% DCSP complete' % dict(action=action, progress=progress)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('\rInstance DCSP %(action)s...' % dict(action=action)) DCNL DCSP  DCSP sys.stdout.write(msg) DCNL DCSP  DCSP sys.stdout.flush() DCNL DCSP print DCNL DCSP while True: DCNL DCSP  DCSP obj = poll_fn(obj_id) DCNL DCSP  DCSP status = obj.status.lower() DCNL DCSP  DCSP progress = (getattr(obj, 'progress', None) or 0) DCNL DCSP  DCSP if (status in final_ok_states): DCNL DCSP  DCSP  DCSP print_progress(100) DCNL DCSP  DCSP  DCSP print '\nFinished' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (status == 'error'): DCNL DCSP  DCSP  DCSP print ('\nError DCSP %(action)s DCSP instance' % locals()) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print_progress(progress) DCNL DCSP  DCSP  DCSP time.sleep(poll_period)
 DCSP return utils.find_resource(cs.monitors, monitor)
 DCSP return utils.find_resource(cs.monitor_snapshots, snapshot)
 DCSP return utils.find_resource(cs.backups, backup)
 DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status} DCNL DCSP monitors = cs.monitors.list(search_opts=search_opts) DCNL DCSP _translate_monitor_keys(monitors) DCNL DCSP for vol in monitors: DCNL DCSP  DCSP servers = [s.get('server_id') for s in vol.attachments] DCNL DCSP  DCSP setattr(vol, 'attached_to', ','.join(map(str, servers))) DCNL DCSP utils.print_list(monitors, ['ID', 'Status', 'Display DCSP Name', 'Size', 'ServiceManage DCSP Type', 'Bootable', 'Attached DCSP to'])
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP _print_monitor(monitor)
 DCSP monitor_metadata = None DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP monitor_metadata = _extract_metadata(args) DCNL DCSP monitor = cs.monitors.create(args.size, args.snapshot_id, args.source_volid, args.display_name, args.display_description, args.monitor_type, availability_zone=args.availability_zone, imageRef=args.image_id, metadata=monitor_metadata) DCNL DCSP _print_monitor(monitor)
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.delete()
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP monitor.force_delete()
 DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor(cs, args.monitor).update(**kwargs)
 DCSP monitor = _find_monitor(cs, args.monitor) DCNL DCSP metadata = _extract_metadata(args) DCNL DCSP if (args.action == 'set'): DCNL DCSP  DCSP cs.monitors.set_metadata(monitor, metadata) DCNL DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP cs.monitors.delete_metadata(monitor, metadata.keys())
 DCSP all_tenants = int(os.environ.get('ALL_TENANTS', args.all_tenants)) DCNL DCSP search_opts = {'all_tenants': all_tenants, 'display_name': args.display_name, 'status': args.status, 'monitor_id': args.monitor_id} DCNL DCSP snapshots = cs.monitor_snapshots.list(search_opts=search_opts) DCNL DCSP _translate_monitor_snapshot_keys(snapshots) DCNL DCSP utils.print_list(snapshots, ['ID', 'ServiceManage DCSP ID', 'Status', 'Display DCSP Name', 'Size'])
 DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot) DCNL DCSP _print_monitor_snapshot(snapshot)
 DCSP snapshot = cs.monitor_snapshots.create(args.monitor_id, args.force, args.display_name, args.display_description) DCNL DCSP _print_monitor_snapshot(snapshot)
 DCSP snapshot = _find_monitor_snapshot(cs, args.snapshot_id) DCNL DCSP snapshot.delete()
 DCSP kwargs = {} DCNL DCSP if (args.display_name is not None): DCNL DCSP  DCSP kwargs['display_name'] = args.display_name DCNL DCSP if (args.display_description is not None): DCNL DCSP  DCSP kwargs['display_description'] = args.display_description DCNL DCSP _find_monitor_snapshot(cs, args.snapshot).update(**kwargs)
 DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_monitor_type_list(vtypes)
 DCSP vtypes = cs.monitor_types.list() DCNL DCSP _print_type_and_extra_specs_list(vtypes)
 DCSP vtype = cs.monitor_types.create(args.name) DCNL DCSP _print_monitor_type_list([vtype])
 DCSP cs.monitor_types.delete(args.id)
 DCSP vtype = _find_monitor_type(cs, args.vtype) DCNL DCSP if (args.metadata is not None): DCNL DCSP  DCSP keypair = _extract_metadata(args) DCNL DCSP  DCSP if (args.action == 'set'): DCNL DCSP  DCSP  DCSP vtype.set_keys(keypair) DCNL DCSP  DCSP elif (args.action == 'unset'): DCNL DCSP  DCSP  DCSP vtype.unset_keys(keypair.keys())
 DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP for e in catalog['access']['serviceCatalog']: DCNL DCSP  DCSP utils.print_dict(e['endpoints'][0], e['name'])
 DCSP catalog = cs.client.service_catalog.catalog DCNL DCSP utils.print_dict(catalog['access']['user'], 'User DCSP Credentials') DCNL DCSP utils.print_dict(catalog['access']['token'], 'Token')
 DCSP _quota_show(cs.quotas.get(args.tenant))
 DCSP _quota_show(cs.quotas.defaults(args.tenant))
 DCSP _quota_update(cs.quotas, args.tenant, args)
 DCSP _quota_show(cs.quota_classes.get(args.class_name))
 DCSP _quota_update(cs.quota_classes, args.class_name, args)
 DCSP limits = cs.limits.get().absolute DCNL DCSP columns = ['Name', 'Value'] DCNL DCSP utils.print_list(limits, columns)
 DCSP limits = cs.limits.get().rate DCNL DCSP columns = ['Verb', 'URI', 'Value', 'Remain', 'Unit', 'Next_Available'] DCNL DCSP utils.print_list(limits, columns)
 DCSP return utils.find_resource(cs.monitor_types, vtype)
 DCSP monitor = _find_monitor(cs, args.monitor_id) DCNL DCSP monitor.upload_to_image(args.force, args.image_name, args.container_format, args.disk_format)
 DCSP cs.backups.create(args.monitor, args.container, args.display_name, args.display_description)
 DCSP backup = _find_backup(cs, args.backup) DCNL DCSP info = dict() DCNL DCSP info.update(backup._info) DCNL DCSP if ('links' in info): DCNL DCSP  DCSP info.pop('links') DCNL DCSP utils.print_dict(info)
 DCSP backups = cs.backups.list() DCNL DCSP columns = ['ID', 'ServiceManage DCSP ID', 'Status', 'Name', 'Size', 'Object DCSP Count', 'Container'] DCNL DCSP utils.print_list(backups, columns)
 DCSP backup = _find_backup(cs, args.backup) DCNL DCSP backup.delete()
 DCSP cs.restores.restore(args.backup, args.monitor_id)
 DCSP extensions = client.list_extensions.show_all() DCNL DCSP fields = ['Name', 'Summary', 'Alias', 'Updated'] DCNL DCSP utils.print_list(extensions, fields)
 DCSP if s.startswith(BASEDIR): DCNL DCSP  DCSP return s.replace(BASEDIR, '/usr/lib/python/site-packages') DCNL DCSP elif (s == MY_IP): DCNL DCSP  DCSP return '10.0.0.1' DCNL DCSP elif (s == HOST): DCNL DCSP  DCSP return 'monitor' DCNL DCSP elif (s.strip() != s): DCNL DCSP  DCSP return ('"%s"' % s) DCNL DCSP return s
 DCSP pos = physical_line.find('TODO') DCNL DCSP pos1 = physical_line.find('TODO(') DCNL DCSP pos2 = physical_line.find('#') DCNL DCSP if ((pos != pos1) and (pos2 >= 0) and (pos2 < pos)): DCNL DCSP  DCSP return (pos, 'ENERGY DCSP N101: DCSP Use DCSP TODO(NAME)')
 DCSP if logical_line.startswith('except:'): DCNL DCSP  DCSP (yield (6, "ENERGY DCSP N201: DCSP no DCSP 'except:' DCSP at DCSP least DCSP use DCSP 'except DCSP Exception:'"))
 DCSP if logical_line.startswith('self.assertRaises(Exception'): DCNL DCSP  DCSP (yield (1, 'ENERGY DCSP N202: DCSP assertRaises DCSP Exception DCSP too DCSP broad'))
 DCSP pos = logical_line.find(',') DCNL DCSP parts = logical_line.split() DCNL DCSP if ((pos > (-1)) and ((parts[0] == 'import') or ((parts[0] == 'from') and (parts[2] == 'import'))) and (not is_import_exception(parts[1]))): DCNL DCSP  DCSP (yield (pos, 'ENERGY DCSP N301: DCSP one DCSP import DCSP per DCSP line'))
 DCSP def importModuleCheck(mod, parent=None, added=False): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP If DCSP can't DCSP find DCSP module DCSP on DCSP first DCSP try, DCSP recursively DCSP check DCSP for DCSP relative\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP imports\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP current_path = os.path.dirname(pep8.current_file) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with warnings.catch_warnings(): DCNL DCSP  DCSP  DCSP  DCSP warnings.simplefilter('ignore', DeprecationWarning) DCNL DCSP  DCSP  DCSP  DCSP valid = True DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_import_exception(parent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP  DCSP parent_mod = __import__(parent, globals(), locals(), [mod], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(getattr(parent_mod, mod)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP __import__(mod, globals(), locals(), [], (-1)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP valid = inspect.ismodule(sys.modules[mod]) DCNL DCSP  DCSP  DCSP  DCSP if (not valid): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if added: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("ENERGY DCSP N304: DCSP No DCSP relative DCSP  DCSP imports. DCSP '%s' DCSP is DCSP a DCSP relative DCSP import" % logical_line)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (logical_line.find(mod), ("ENERGY DCSP N302: DCSP import DCSP only DCSP modules. DCSP '%s' DCSP does DCSP not DCSP import DCSP a DCSP module" % logical_line)) DCNL DCSP  DCSP except (ImportError, NameError) as exc: DCNL DCSP  DCSP  DCSP if (not added): DCNL DCSP  DCSP  DCSP  DCSP added = True DCNL DCSP  DCSP  DCSP  DCSP sys.path.append(current_path) DCNL DCSP  DCSP  DCSP  DCSP return importModuleCheck(mod, parent, added) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP name = logical_line.split()[1] DCNL DCSP  DCSP  DCSP  DCSP if (name not in _missingImport): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if VERBOSE_MISSING_IMPORT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print >>sys.stderr, ("ERROR: DCSP import DCSP '%s' DCSP failed: DCSP %s" % (name, exc)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _missingImport.add(name) DCNL DCSP  DCSP  DCSP  DCSP added = False DCNL DCSP  DCSP  DCSP  DCSP sys.path.pop() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return (logical_line.find(mod), 'ENERGY DCSP N303: DCSP Invalid DCSP import, DCSP AttributeError DCSP raised') DCNL DCSP import_normalize(logical_line) DCNL DCSP split_line = logical_line.split() DCNL DCSP if (logical_line.startswith('import DCSP ') and (',' not in logical_line) and ((len(split_line) == 2) or ((len(split_line) == 4) and (split_line[2] == 'as')))): DCNL DCSP  DCSP mod = split_line[1] DCNL DCSP  DCSP rval = importModuleCheck(mod) DCNL DCSP  DCSP if (rval is not None): DCNL DCSP  DCSP  DCSP (yield rval)
 DCSP split_line = import_normalize(physical_line.strip()).lower().split() DCNL DCSP split_previous = import_normalize(lines[(line_number - 2)]).strip().lower().split() DCNL DCSP length = [2, 4] DCNL DCSP if ((len(split_line) in length) and (len(split_previous) in length) and (split_line[0] == 'import') and (split_previous[0] == 'import')): DCNL DCSP  DCSP if (split_line[1] < split_previous[1]): DCNL DCSP  DCSP  DCSP return (0, ('ENERGY DCSP N306: DCSP imports DCSP not DCSP in DCSP alphabetical DCSP order DCSP (%s, DCSP %s)' % (split_previous[1], split_line[1])))
 DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) > (pos + 1))): DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N401: DCSP one DCSP line DCSP docstring DCSP should DCSP not DCSP start DCSP with DCSP a DCSP space')
 DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP end = max([(physical_line[(-4):(-1)] == i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and end and (len(physical_line) > (pos + 4))): DCNL DCSP  DCSP if ((physical_line[(-5)] != '.') and physical_line): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N402: DCSP one DCSP line DCSP docstring DCSP needs DCSP a DCSP period')
 DCSP pos = max([physical_line.find(i) for i in DOCSTRING_TRIPLE]) DCNL DCSP if ((pos != (-1)) and (len(physical_line) == pos)): DCNL DCSP  DCSP print physical_line DCNL DCSP  DCSP if (physical_line[(pos + 3)] == ' DCSP '): DCNL DCSP  DCSP  DCSP return (pos, 'ENERGY DCSP N403: DCSP multi DCSP line DCSP docstring DCSP end DCSP on DCSP new DCSP line')
 DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (token_type, text, _, _, _) = (yield) DCNL DCSP  DCSP except GeneratorExit: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((token_type == tokenize.NAME) and (text == '_')): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type != tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((token_type != tokenize.OP) or (text != '(')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP format_string = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (token_type, text, start, _, _) = (yield) DCNL DCSP  DCSP  DCSP  DCSP if (token_type == tokenize.STRING): DCNL DCSP  DCSP  DCSP  DCSP  DCSP format_string += eval(text) DCNL DCSP  DCSP  DCSP  DCSP elif (token_type == tokenize.NL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not format_string): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N701: DCSP Empty DCSP localization DCSP string') DCNL DCSP  DCSP  DCSP if (token_type != tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N701: DCSP Invalid DCSP localization DCSP call') DCNL DCSP  DCSP  DCSP if (text != ')'): DCNL DCSP  DCSP  DCSP  DCSP if (text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Formatting DCSP operation DCSP should DCSP be DCSP outside DCSP of DCSP localization DCSP method DCSP call') DCNL DCSP  DCSP  DCSP  DCSP elif (text == '+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Use DCSP bare DCSP string DCSP concatenation DCSP instead DCSP of DCSP +') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N702: DCSP Argument DCSP to DCSP _ DCSP must DCSP be DCSP just DCSP a DCSP string') DCNL DCSP  DCSP  DCSP format_specs = FORMAT_RE.findall(format_string) DCNL DCSP  DCSP  DCSP positional_specs = [(key, spec) for (key, spec) in format_specs if ((not key) and spec)] DCNL DCSP  DCSP  DCSP if (len(positional_specs) > 1): DCNL DCSP  DCSP  DCSP  DCSP raise LocalizationError(start, 'ENERGY DCSP N703: DCSP Multiple DCSP positional DCSP placeholders')
 DCSP gen = check_l18n() DCNL DCSP next(gen) DCNL DCSP try: DCNL DCSP  DCSP map(gen.send, tokens) DCNL DCSP  DCSP gen.close() DCNL DCSP except LocalizationError as e: DCNL DCSP  DCSP (yield e.args)
 DCSP pep8.current_file = filename DCNL DCSP return open(filename).readlines()
 DCSP for (name, function) in globals().items(): DCNL DCSP  DCSP if (not inspect.isfunction(function)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP args = inspect.getargspec(function)[0] DCNL DCSP  DCSP if (args and name.startswith('monitor')): DCNL DCSP  DCSP  DCSP exec ('pep8.%s DCSP = DCSP %s' % (name, name))
 DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason='Invalid DCSP sort DCSP key') DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
 DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
 DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
 DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
 DCSP return request.GET['marker']
 DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
 DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
 DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
 DCSP return list(obj.items())
 DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
 DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
 DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
 DCSP dom = utils.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
 DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
 DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
 DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
 DCSP curr_time = timeutils.utcnow() DCNL DCSP context = req.environ['monitor.context'] DCNL DCSP services = db.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in req.GET): DCNL DCSP  DCSP zone = req.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP delta = (curr_time - (host['updated_at'] or host['created_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconds(delta)) <= FLAGS.service_down_time) DCNL DCSP  DCSP status = ((alive and 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enabled' DCNL DCSP  DCSP if host['disabled']: DCNL DCSP  DCSP  DCSP active = 'disabled' DCNL DCSP  DCSP LOG.debug(('status, DCSP active DCSP and DCSP update: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['updated_at']))) DCNL DCSP  DCSP hosts.append({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-update': host['updated_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
 DCSP def wrapped(self, req, id, service=None, *args, **kwargs): DCNL DCSP  DCSP listed_hosts = _list_hosts(req, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listed_hosts] DCNL DCSP  DCSP if (id in hosts): DCNL DCSP  DCSP  DCSP return fn(self, req, id, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP could DCSP not DCSP be DCSP found.") % id) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFound(explanation=message) DCNL DCSP return wrapped
 DCSP from sqlalchemy import create_engine DCNL DCSP models = (Service,) DCNL DCSP engine = create_engine(FLAGS.sql_connection, echo=False) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
 DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.query = monitor.exception.wrap_db_error(session.query) DCNL DCSP session.flush = monitor.exception.wrap_db_error(session.flush) DCNL DCSP return session
 DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
 DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(FLAGS.sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if (FLAGS.sql_connection_debug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP  DCSP elif (FLAGS.sql_connection_debug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = sqlalchemy.create_engine(FLAGS.sql_connection, **engine_args) DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
 DCSP return sqlalchemy.orm.sessionmaker(bind=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
 DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP request DCSP context DCSP is DCSP deprecated'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('die') DCNL DCSP return context.is_admin
 DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_admin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AdminRequired() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_admin_context(args[0])) and (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
 DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
 DCSP instances = instance_get_all_by_host(context, host) DCNL DCSP vms = len(instances) DCNL DCSP free_ram_mb = (ram_mb - FLAGS.reserved_host_memory_mb) DCNL DCSP free_disk_gb = (disk_gb - (FLAGS.reserved_host_disk_mb * 1024)) DCNL DCSP work = 0 DCNL DCSP for instance in instances: DCNL DCSP  DCSP free_ram_mb -= instance.memory_mb DCNL DCSP  DCSP free_disk_gb -= instance.root_gb DCNL DCSP  DCSP free_disk_gb -= instance.ephemeral_gb DCNL DCSP  DCSP if (instance.vm_state in [vm_states.BUILDING, vm_states.REBUILDING, vm_states.MIGRATING, vm_states.RESIZING]): DCNL DCSP  DCSP  DCSP work += 1 DCNL DCSP return dict(free_ram_mb=free_ram_mb, free_disk_gb=free_disk_gb, current_workload=work, running_vms=vms)
 DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node_ref = models.ComputeNode() DCNL DCSP  DCSP session.add(compute_node_ref) DCNL DCSP  DCSP compute_node_ref.update(values) DCNL DCSP return compute_node_ref
 DCSP session = get_session() DCNL DCSP if auto_adjust: DCNL DCSP  DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP  DCSP compute_ref = compute_node_get(context, compute_id, session=session) DCNL DCSP  DCSP for (key, value) in values.iteritems(): DCNL DCSP  DCSP  DCSP compute_ref[key] = value DCNL DCSP  DCSP compute_ref.save(session=session)
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP service = session.query(models.Service).filter_by(host=host, binary='monitor-bmc').first() DCNL DCSP  DCSP node = session.query(models.ComputeNode).options(joinedload('service')).filter_by(deleted=False, service_id=service.id) DCNL DCSP  DCSP return node.first()
 DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP table = models.ComputeNode.__table__ DCNL DCSP  DCSP if (free_ram_mb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = (table.c.free_ram_mb + free_ram_mb_delta) DCNL DCSP  DCSP if (free_disk_gb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = (table.c.free_disk_gb + free_disk_gb_delta) DCNL DCSP  DCSP if (work_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.current_workload = (table.c.current_workload + work_delta) DCNL DCSP  DCSP if (vm_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.running_vms = (table.c.running_vms + vm_delta) DCNL DCSP return compute_node
 DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_disk_gb != None): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = free_disk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_node.current_workload = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_node.running_vms = vms DCNL DCSP return compute_node
 DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
 DCSP return IMPL.service_destroy(context, service_id)
 DCSP return IMPL.service_get(context, service_id)
 DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
 DCSP return IMPL.service_get_all(context, disabled)
 DCSP return IMPL.service_get_all_by_topic(context, topic)
 DCSP return IMPL.service_get_all_by_host(context, host)
 DCSP return IMPL.service_get_all_bmc_by_host(context, host)
 DCSP return IMPL.service_get_all_servicemanage_sorted(context)
 DCSP return IMPL.service_get_by_args(context, host, binary)
 DCSP return IMPL.service_create(context, values)
 DCSP return IMPL.service_update(context, service_id, values)
 DCSP return IMPL.compute_node_get(context, compute_id)
 DCSP return IMPL.compute_node_get_all(context)
 DCSP return IMPL.compute_node_create(context, values)
 DCSP return IMPL.compute_node_update(context, compute_id, values, auto_adjust)
 DCSP return IMPL.db_sync(version=version)
 DCSP return IMPL.db_version()
 DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'monitor', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/monitor/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFound(path=os.path.abspath(config_path))
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'sudo')): DCNL DCSP  DCSP  DCSP LOG.deprecated(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP different DCSP from DCSP monitor-rootwrap, DCSP and DCSP defaults DCSP to DCSP using DCSP sudo) DCSP is DCSP now DCSP deprecated. DCSP You DCSP should DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP instead.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmd = (['sudo', 'monitor-rootwrap', FLAGS.rootwrap_config] + list(cmd)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = (shlex.split(FLAGS.root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
 DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.servicemanage_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
 DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
 DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
 DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
 DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
 DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
 DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
 DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
 DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
 DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
 DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
 DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
 DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
 DCSP parts = address.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in FLAGS.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
 DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
 DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
 DCSP return ('http://%s:%d' % (FLAGS.glance_host, FLAGS.glance_port))
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
 DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
 DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
 DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP return file(*args, **kwargs)
 DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.update, iter((lambda : file_like_object.read(32768)), ''))) DCNL DCSP return checksum.hexdigest()
 DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
 DCSP last_heartbeat = (service['updated_at'] or service['created_at']) DCNL DCSP elapsed = total_seconds((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapsed) <= FLAGS.service_down_time)
 DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
 DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
 DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
 DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
 DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP credentials = context.to_dict() DCNL DCSP policy.enforce(match_list, target, credentials, exception.PolicyNotAuthorized, action=action)
 DCSP init() DCNL DCSP action = 'context_is_admin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_id': ''} DCNL DCSP credentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, credentials)
 DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
 DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
 DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
 DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
 DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
 DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
 DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
 DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
 DCSP return _get_impl().create_connection(CONF, new=new)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().cast(CONF, context, topic, msg)
 DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
 DCSP return _get_impl().cleanup()
 DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return (('%s.%s' % (topic, host)) if host else topic)
 DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP return Connection()
 DCSP json.dumps(msg)
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
 DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
 DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
 DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
 DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
 DCSP return _multi_send(_call, *args, **kwargs)
 DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
 DCSP _multi_send(_cast, *args, **kwargs)
 DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
 DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
 DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
 DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
 DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
 DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP global _BRAIN DCNL DCSP _BRAIN = brain
 DCSP global _BRAIN DCNL DCSP _BRAIN = None
 DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_dict, credentials_dict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP def decorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.default_rule and (match != brain.default_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.default_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_dict, cred_dict)
 DCSP return (match.lower() in [x.lower() for x in cred_dict['roles']])
 DCSP url = ('http:' + (match % target_dict)) DCNL DCSP data = {'target': jsonutils.dumps(target_dict), 'credentials': jsonutils.dumps(cred_dict)} DCNL DCSP post_data = urllib.urlencode(data) DCNL DCSP f = urllib2.urlopen(url, post_data) DCNL DCSP return (f.read() == 'True')
 DCSP match = (match % target_dict) DCNL DCSP if (match_kind in cred_dict): DCNL DCSP  DCSP return (match == unicode(cred_dict[match_kind])) DCNL DCSP return False
 DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP return ((bool_from_string(subject) and 1) or 0)
 DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
 DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('monitor.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
 DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
 DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
 DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
 DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
 DCSP def decorator(f): DCNL DCSP  DCSP f._short_cycle_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
 DCSP if ('id' not in sort_keys): DCNL DCSP  DCSP LOG.warn(_('Id DCSP not DCSP in DCSP sort_keys; DCSP is DCSP sort_keys DCSP unique?')) DCNL DCSP assert (not (sort_dir and sort_dirs)) DCNL DCSP if ((sort_dirs is None) and (sort_dir is None)): DCNL DCSP  DCSP sort_dir = 'asc' DCNL DCSP if (sort_dirs is None): DCNL DCSP  DCSP sort_dirs = [sort_dir for _sort_key in sort_keys] DCNL DCSP assert (len(sort_dirs) == len(sort_keys)) DCNL DCSP for (current_sort_key, current_sort_dir) in zip(sort_keys, sort_dirs): DCNL DCSP  DCSP sort_dir_func = {'asc': sqlalchemy.asc, 'desc': sqlalchemy.desc}[current_sort_dir] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sort_key_attr = getattr(model, current_sort_key) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise exception.InvalidInput(reason='Invalid DCSP sort DCSP key') DCNL DCSP  DCSP query = query.order_by(sort_dir_func(sort_key_attr)) DCNL DCSP if (marker is not None): DCNL DCSP  DCSP marker_values = [] DCNL DCSP  DCSP for sort_key in sort_keys: DCNL DCSP  DCSP  DCSP v = getattr(marker, sort_key) DCNL DCSP  DCSP  DCSP marker_values.append(v) DCNL DCSP  DCSP criteria_list = [] DCNL DCSP  DCSP for i in xrange(0, len(sort_keys)): DCNL DCSP  DCSP  DCSP crit_attrs = [] DCNL DCSP  DCSP  DCSP for j in xrange(0, i): DCNL DCSP  DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[j]) DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr == marker_values[j])) DCNL DCSP  DCSP  DCSP model_attr = getattr(model, sort_keys[i]) DCNL DCSP  DCSP  DCSP if (sort_dirs[i] == 'desc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr < marker_values[i])) DCNL DCSP  DCSP  DCSP elif (sort_dirs[i] == 'asc'): DCNL DCSP  DCSP  DCSP  DCSP crit_attrs.append((model_attr > marker_values[i])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(_("Unknown DCSP sort DCSP direction, DCSP must DCSP be DCSP 'desc' DCSP or DCSP 'asc'")) DCNL DCSP  DCSP  DCSP criteria = sqlalchemy.sql.and_(*crit_attrs) DCNL DCSP  DCSP  DCSP criteria_list.append(criteria) DCNL DCSP  DCSP f = sqlalchemy.sql.or_(*criteria_list) DCNL DCSP  DCSP query = query.filter(f) DCNL DCSP if (limit is not None): DCNL DCSP  DCSP query = query.limit(limit) DCNL DCSP return query
 DCSP pipeline = local_conf[FLAGS.auth_strategy] DCNL DCSP if (not FLAGS.api_rate_limit): DCNL DCSP  DCSP limit_name = (FLAGS.auth_strategy + '_nolimit') DCNL DCSP  DCSP pipeline = local_conf.get(limit_name, pipeline) DCNL DCSP pipeline = pipeline.split() DCNL DCSP filters = [loader.get_filter(n) for n in pipeline[:(-1)]] DCNL DCSP app = loader.get_app(pipeline[(-1)]) DCNL DCSP filters.reverse() DCNL DCSP for filter in filters: DCNL DCSP  DCSP app = filter(app) DCNL DCSP return app
 DCSP our_dir = path[0] DCNL DCSP for (dirpath, dirnames, filenames) in os.walk(our_dir): DCNL DCSP  DCSP relpath = os.path.relpath(dirpath, our_dir) DCNL DCSP  DCSP if (relpath == '.'): DCNL DCSP  DCSP  DCSP relpkg = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP relpkg = ('.%s' % '.'.join(relpath.split(os.sep))) DCNL DCSP  DCSP for fname in filenames: DCNL DCSP  DCSP  DCSP (root, ext) = os.path.splitext(fname) DCNL DCSP  DCSP  DCSP if ((ext != '.py') or (root == '__init__')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP classname = ('%s%s' % (root[0].upper(), root[1:])) DCNL DCSP  DCSP  DCSP classpath = ('%s%s.%s.%s' % (package, relpkg, root, classname)) DCNL DCSP  DCSP  DCSP if ((ext_list is not None) and (classname not in ext_list)): DCNL DCSP  DCSP  DCSP  DCSP logger.debug(('Skipping DCSP extension: DCSP %s' % classpath)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext_mgr.load_extension(classpath) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(classpath)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP subdirs = [] DCNL DCSP  DCSP for dname in dirnames: DCNL DCSP  DCSP  DCSP if (not os.path.exists(os.path.join(dirpath, dname, '__init__.py'))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP ext_name = ('%s%s.%s.extension' % (package, relpkg, dname)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ext = importutils.import_class(ext_name) DCNL DCSP  DCSP  DCSP except common_exception.NotFound: DCNL DCSP  DCSP  DCSP  DCSP subdirs.append(dname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ext(ext_mgr) DCNL DCSP  DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logger.warn((_('Failed DCSP to DCSP load DCSP extension DCSP %(ext_name)s: DCSP %(exc)s') % locals())) DCNL DCSP  DCSP dirnames[:] = subdirs
 DCSP params = {} DCNL DCSP if ('limit' in request.GET): DCNL DCSP  DCSP params['limit'] = _get_limit_param(request) DCNL DCSP if ('marker' in request.GET): DCNL DCSP  DCSP params['marker'] = _get_marker_param(request) DCNL DCSP return params
 DCSP try: DCNL DCSP  DCSP limit = int(request.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP return limit
 DCSP return request.GET['marker']
 DCSP try: DCNL DCSP  DCSP offset = int(request.GET.get('offset', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP try: DCNL DCSP  DCSP limit = int(request.GET.get('limit', max_limit)) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP if (offset < 0): DCNL DCSP  DCSP msg = _('offset DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP limit = min(max_limit, (limit or max_limit)) DCNL DCSP range_end = (offset + limit) DCNL DCSP return items[offset:range_end]
 DCSP params = get_pagination_params(request) DCNL DCSP limit = params.get('limit', max_limit) DCNL DCSP marker = params.get('marker') DCNL DCSP limit = min(max_limit, limit) DCNL DCSP start_index = 0 DCNL DCSP if marker: DCNL DCSP  DCSP start_index = (-1) DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if ('flavorid' in item): DCNL DCSP  DCSP  DCSP  DCSP if (item['flavorid'] == marker): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif ((item['id'] == marker) or (item.get('uuid') == marker)): DCNL DCSP  DCSP  DCSP  DCSP start_index = (i + 1) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (start_index < 0): DCNL DCSP  DCSP  DCSP msg = (_('marker DCSP [%s] DCSP not DCSP found') % marker) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPBadRequest(explanation=msg) DCNL DCSP range_end = (start_index + limit) DCNL DCSP return items[start_index:range_end]
 DCSP parsed_url = urlparse.urlsplit(href) DCNL DCSP url_parts = parsed_url.path.split('/', 2) DCNL DCSP expression = re.compile('^v([0-9]+|[0-9]+\\.[0-9]+)(/.*|$)') DCNL DCSP if expression.match(url_parts[1]): DCNL DCSP  DCSP del url_parts[1] DCNL DCSP new_path = '/'.join(url_parts) DCNL DCSP if (new_path == parsed_url.path): DCNL DCSP  DCSP msg = (_('href DCSP %s DCSP does DCSP not DCSP contain DCSP version') % href) DCNL DCSP  DCSP LOG.debug(msg) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP parsed_url = list(parsed_url) DCNL DCSP parsed_url[2] = new_path DCNL DCSP return urlparse.urlunsplit(parsed_url)
 DCSP return list(obj.items())
 DCSP attrib = (attrib or {}) DCNL DCSP attrib.update(extra) DCNL DCSP elem = TemplateElement(tag, attrib=attrib, selector=selector, subselector=subselector) DCNL DCSP if (parent is not None): DCNL DCSP  DCSP parent.append(elem) DCNL DCSP return elem
 DCSP elem = SubTemplateElement(parent, ('{%s}link' % XMLNS_ATOM), selector=selector) DCNL DCSP elem.set('rel') DCNL DCSP elem.set('type') DCNL DCSP elem.set('href') DCNL DCSP return elem
 DCSP if (ns is None): DCNL DCSP  DCSP elemname = name DCNL DCSP  DCSP tagname = Selector(0) DCNL DCSP else: DCNL DCSP  DCSP elemname = ('{%s}%s' % (ns, name)) DCNL DCSP  DCSP tagname = (lambda obj, do_raise=False: ('{%s}%s' % (ns, obj[0]))) DCNL DCSP if (selector is None): DCNL DCSP  DCSP selector = name DCNL DCSP root = TemplateElement(elemname, selector=selector, subselector=subselector) DCNL DCSP elem = SubTemplateElement(root, tagname, selector=get_items) DCNL DCSP elem.text = 1 DCNL DCSP return root
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_serializers')): DCNL DCSP  DCSP  DCSP func.wsgi_serializers = {} DCNL DCSP  DCSP func.wsgi_serializers.update(serializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP if (not hasattr(func, 'wsgi_deserializers')): DCNL DCSP  DCSP  DCSP func.wsgi_deserializers = {} DCNL DCSP  DCSP func.wsgi_deserializers.update(deserializers) DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_code = code DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP decoded = jsonutils.loads(body) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('cannot DCSP understand DCSP JSON') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP if (len(decoded) != 1): DCNL DCSP  DCSP msg = _('too DCSP many DCSP body DCSP keys') DCNL DCSP  DCSP raise exception.MalformedRequestBody(reason=msg) DCNL DCSP return decoded.keys()[0]
 DCSP dom = utils.safe_minidom_parse_string(body) DCNL DCSP action_node = dom.childNodes[0] DCNL DCSP return action_node.tagName
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_action = name DCNL DCSP  DCSP return func DCNL DCSP return decorator
 DCSP def decorator(func): DCNL DCSP  DCSP func.wsgi_extends = (func.__name__, kwargs.get('action')) DCNL DCSP  DCSP return func DCNL DCSP if args: DCNL DCSP  DCSP return decorator(*args) DCNL DCSP return decorator
 DCSP d = _translate_attachment_summary_view(_context, vol) DCNL DCSP return d
 DCSP d = {} DCNL DCSP conductor_id = vol['id'] DCNL DCSP d['id'] = conductor_id DCNL DCSP d['conductor_id'] = conductor_id DCNL DCSP return d
 DCSP d = _translate_conductor_summary_view(context, vol, image_id) DCNL DCSP return d
 DCSP d = {} DCNL DCSP d['id'] = vol['id'] DCNL DCSP d['status'] = vol['status'] DCNL DCSP d['size'] = vol['size'] DCNL DCSP d['availability_zone'] = vol['availability_zone'] DCNL DCSP d['created_at'] = vol['created_at'] DCNL DCSP d['display_name'] = vol['display_name'] DCNL DCSP d['display_description'] = vol['display_description'] DCNL DCSP if (vol['conductor_type_id'] and vol.get('conductor_type')): DCNL DCSP  DCSP d['conductor_type'] = vol['conductor_type']['name'] DCNL DCSP else: DCNL DCSP  DCSP d['conductor_type'] = str(vol['conductor_type_id']) DCNL DCSP LOG.audit(_('vol=%s'), vol, context=context) DCNL DCSP if vol.get('conductor_metadata'): DCNL DCSP  DCSP metadata = vol.get('conductor_metadata') DCNL DCSP  DCSP d['metadata'] = dict(((item['key'], item['value']) for item in metadata)) DCNL DCSP elif (vol.get('metadata') and isinstance(vol.get('metadata'), dict)): DCNL DCSP  DCSP d['metadata'] = vol['metadata'] DCNL DCSP else: DCNL DCSP  DCSP d['metadata'] = {} DCNL DCSP if vol.get('conductor_glance_metadata'): DCNL DCSP  DCSP d['bootable'] = 'true' DCNL DCSP else: DCNL DCSP  DCSP d['bootable'] = 'false' DCNL DCSP return d
 DCSP if context.is_admin: DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in allowed_search_options)] DCNL DCSP bad_options = ', DCSP '.join(unknown_options) DCNL DCSP log_msg = (_("Removing DCSP options DCSP '%(bad_options)s' DCSP from DCSP query") % locals()) DCNL DCSP LOG.debug(log_msg) DCNL DCSP for opt in unknown_options: DCNL DCSP  DCSP del search_options[opt]
 DCSP if (value and (value[0] == value[(-1)] == '"')): DCNL DCSP  DCSP value = value[1:(-1)] DCNL DCSP return value
 DCSP result = [] DCNL DCSP for item in urllib2.parse_http_list(value): DCNL DCSP  DCSP if (item[:1] == item[(-1):] == '"'): DCNL DCSP  DCSP  DCSP item = unquote_header_value(item[1:(-1)]) DCNL DCSP  DCSP result.append(item) DCNL DCSP return result
 DCSP def _tokenize(string): DCNL DCSP  DCSP for match in _option_header_piece_re.finditer(string): DCNL DCSP  DCSP  DCSP (key, value) = match.groups() DCNL DCSP  DCSP  DCSP key = unquote_header_value(key) DCNL DCSP  DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP  DCSP value = unquote_header_value(value) DCNL DCSP  DCSP  DCSP (yield (key, value)) DCNL DCSP if (not value): DCNL DCSP  DCSP return ('', {}) DCNL DCSP parts = _tokenize((';' + value)) DCNL DCSP name = parts.next()[0] DCNL DCSP extra = dict(parts) DCNL DCSP return (name, extra)
 DCSP curr_time = timeutils.utcnow() DCNL DCSP context = req.environ['monitor.context'] DCNL DCSP services = db.service_get_all(context, False) DCNL DCSP zone = '' DCNL DCSP if ('zone' in req.GET): DCNL DCSP  DCSP zone = req.GET['zone'] DCNL DCSP if zone: DCNL DCSP  DCSP services = [s for s in services if (s['availability_zone'] == zone)] DCNL DCSP hosts = [] DCNL DCSP for host in services: DCNL DCSP  DCSP delta = (curr_time - (host['updated_at'] or host['created_at'])) DCNL DCSP  DCSP alive = (abs(utils.total_seconds(delta)) <= FLAGS.service_down_time) DCNL DCSP  DCSP status = ((alive and 'available') or 'unavailable') DCNL DCSP  DCSP active = 'enabled' DCNL DCSP  DCSP if host['disabled']: DCNL DCSP  DCSP  DCSP active = 'disabled' DCNL DCSP  DCSP LOG.debug(('status, DCSP active DCSP and DCSP update: DCSP %s, DCSP %s, DCSP %s' % (status, active, host['updated_at']))) DCNL DCSP  DCSP hosts.append({'host_name': host['host'], 'service': host['topic'], 'zone': host['availability_zone'], 'service-status': status, 'service-state': active, 'last-update': host['updated_at']}) DCNL DCSP if service: DCNL DCSP  DCSP hosts = [host for host in hosts if (host['service'] == service)] DCNL DCSP return hosts
 DCSP def wrapped(self, req, id, service=None, *args, **kwargs): DCNL DCSP  DCSP listed_hosts = _list_hosts(req, service) DCNL DCSP  DCSP hosts = [h['host_name'] for h in listed_hosts] DCNL DCSP  DCSP if (id in hosts): DCNL DCSP  DCSP  DCSP return fn(self, req, id, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP message = (_("Host DCSP '%s' DCSP could DCSP not DCSP be DCSP found.") % id) DCNL DCSP  DCSP  DCSP raise webob.exc.HTTPNotFound(explanation=message) DCNL DCSP return wrapped
 DCSP from sqlalchemy import create_engine DCNL DCSP models = (Service,) DCNL DCSP engine = create_engine(FLAGS.sql_connection, echo=False) DCNL DCSP for model in models: DCNL DCSP  DCSP model.metadata.create_all(engine)
 DCSP global _MAKER DCNL DCSP if (_MAKER is None): DCNL DCSP  DCSP engine = get_engine() DCNL DCSP  DCSP _MAKER = get_maker(engine, autocommit, expire_on_commit) DCNL DCSP session = _MAKER() DCNL DCSP session.query = monitor.exception.wrap_db_error(session.query) DCNL DCSP session.flush = monitor.exception.wrap_db_error(session.flush) DCNL DCSP return session
 DCSP dbapi_conn.execute('PRAGMA DCSP synchronous DCSP = DCSP OFF')
 DCSP try: DCNL DCSP  DCSP dbapi_conn.cursor().execute('select DCSP 1') DCNL DCSP except dbapi_conn.OperationalError as ex: DCNL DCSP  DCSP if (ex.args[0] in (2006, 2013, 2014, 2045, 2055)): DCNL DCSP  DCSP  DCSP LOG.warn(_('Got DCSP mysql DCSP server DCSP has DCSP gone DCSP away: DCSP %s'), ex) DCNL DCSP  DCSP  DCSP raise DisconnectionError('Database DCSP server DCSP went DCSP away') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP conn_err_codes = ('2002', '2003', '2006') DCNL DCSP for err_code in conn_err_codes: DCNL DCSP  DCSP if (args.find(err_code) != (-1)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP connection_dict = sqlalchemy.engine.url.make_url(FLAGS.sql_connection) DCNL DCSP  DCSP engine_args = {'pool_recycle': FLAGS.sql_idle_timeout, 'echo': False, 'convert_unicode': True} DCNL DCSP  DCSP if (FLAGS.sql_connection_debug >= 100): DCNL DCSP  DCSP  DCSP engine_args['echo'] = 'debug' DCNL DCSP  DCSP elif (FLAGS.sql_connection_debug >= 50): DCNL DCSP  DCSP  DCSP engine_args['echo'] = True DCNL DCSP  DCSP if ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP engine_args['poolclass'] = NullPool DCNL DCSP  DCSP  DCSP if (FLAGS.sql_connection == 'sqlite://'): DCNL DCSP  DCSP  DCSP  DCSP engine_args['poolclass'] = StaticPool DCNL DCSP  DCSP  DCSP  DCSP engine_args['connect_args'] = {'check_same_thread': False} DCNL DCSP  DCSP _ENGINE = sqlalchemy.create_engine(FLAGS.sql_connection, **engine_args) DCNL DCSP  DCSP if ('mysql' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'checkout', ping_listener) DCNL DCSP  DCSP elif ('sqlite' in connection_dict.drivername): DCNL DCSP  DCSP  DCSP if (not FLAGS.sqlite_synchronous): DCNL DCSP  DCSP  DCSP  DCSP sqlalchemy.event.listen(_ENGINE, 'connect', synchronous_switch_listener) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP if (not is_db_connection_error(e.args[0])): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP remaining = FLAGS.sql_max_retries DCNL DCSP  DCSP  DCSP if (remaining == (-1)): DCNL DCSP  DCSP  DCSP  DCSP remaining = 'infinite' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP msg = _('SQL DCSP connection DCSP failed. DCSP %s DCSP attempts DCSP left.') DCNL DCSP  DCSP  DCSP  DCSP LOG.warn((msg % remaining)) DCNL DCSP  DCSP  DCSP  DCSP if (remaining != 'infinite'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remaining -= 1 DCNL DCSP  DCSP  DCSP  DCSP time.sleep(FLAGS.sql_retry_interval) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _ENGINE.connect() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP except OperationalError as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((remaining != 'infinite') and (remaining == 0)) or (not is_db_connection_error(e.args[0]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return _ENGINE
 DCSP return sqlalchemy.orm.sessionmaker(bind=engine, autocommit=autocommit, expire_on_commit=expire_on_commit)
 DCSP if (not context): DCNL DCSP  DCSP warnings.warn(_('Use DCSP of DCSP empty DCSP request DCSP context DCSP is DCSP deprecated'), DeprecationWarning) DCNL DCSP  DCSP raise Exception('die') DCNL DCSP return context.is_admin
 DCSP if (not context): DCNL DCSP  DCSP return False DCNL DCSP if context.is_admin: DCNL DCSP  DCSP return False DCNL DCSP if ((not context.user_id) or (not context.project_id)): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.project_id != project_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.user_id != user_id): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP if is_user_context(context): DCNL DCSP  DCSP if (not context.quota_class): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP elif (context.quota_class != class_name): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized()
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if (not is_admin_context(args[0])): DCNL DCSP  DCSP  DCSP raise exception.AdminRequired() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP def wrapper(*args, **kwargs): DCNL DCSP  DCSP if ((not is_admin_context(args[0])) and (not is_user_context(args[0]))): DCNL DCSP  DCSP  DCSP raise exception.NotAuthorized() DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
 DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP read_deleted = (kwargs.get('read_deleted') or context.read_deleted) DCNL DCSP project_only = kwargs.get('project_only') DCNL DCSP query = session.query(*args) DCNL DCSP if (read_deleted == 'no'): DCNL DCSP  DCSP query = query.filter_by(deleted=False) DCNL DCSP elif (read_deleted == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (read_deleted == 'only'): DCNL DCSP  DCSP query = query.filter_by(deleted=True) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognized DCSP read_deleted DCSP value DCSP '%s'") % read_deleted)) DCNL DCSP if (project_only and is_user_context(context)): DCNL DCSP  DCSP query = query.filter_by(project_id=context.project_id) DCNL DCSP return query
 DCSP filter_dict = {} DCNL DCSP for key in legal_keys: DCNL DCSP  DCSP if (key not in filters): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP value = filters.pop(key) DCNL DCSP  DCSP if isinstance(value, (list, tuple, set, frozenset)): DCNL DCSP  DCSP  DCSP column_attr = getattr(model, key) DCNL DCSP  DCSP  DCSP query = query.filter(column_attr.in_(value)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_dict[key] = value DCNL DCSP if filter_dict: DCNL DCSP  DCSP query = query.filter_by(**filter_dict) DCNL DCSP return query
 DCSP instances = instance_get_all_by_host(context, host) DCNL DCSP vms = len(instances) DCNL DCSP free_ram_mb = (ram_mb - FLAGS.reserved_host_memory_mb) DCNL DCSP free_disk_gb = (disk_gb - (FLAGS.reserved_host_disk_mb * 1024)) DCNL DCSP work = 0 DCNL DCSP for instance in instances: DCNL DCSP  DCSP free_ram_mb -= instance.memory_mb DCNL DCSP  DCSP free_disk_gb -= instance.root_gb DCNL DCSP  DCSP free_disk_gb -= instance.ephemeral_gb DCNL DCSP  DCSP if (instance.vm_state in [vm_states.BUILDING, vm_states.REBUILDING, vm_states.MIGRATING, vm_states.RESIZING]): DCNL DCSP  DCSP  DCSP work += 1 DCNL DCSP return dict(free_ram_mb=free_ram_mb, free_disk_gb=free_disk_gb, current_workload=work, running_vms=vms)
 DCSP if (not session): DCNL DCSP  DCSP session = get_session() DCNL DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node_ref = models.ComputeNode() DCNL DCSP  DCSP session.add(compute_node_ref) DCNL DCSP  DCSP compute_node_ref.update(values) DCNL DCSP return compute_node_ref
 DCSP session = get_session() DCNL DCSP if auto_adjust: DCNL DCSP  DCSP _adjust_compute_node_values_for_utilization(context, values, session) DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP values['updated_at'] = timeutils.utcnow() DCNL DCSP  DCSP convert_datetimes(values, 'created_at', 'deleted_at', 'updated_at') DCNL DCSP  DCSP compute_ref = compute_node_get(context, compute_id, session=session) DCNL DCSP  DCSP for (key, value) in values.iteritems(): DCNL DCSP  DCSP  DCSP compute_ref[key] = value DCNL DCSP  DCSP compute_ref.save(session=session)
 DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP service = session.query(models.Service).filter_by(host=host, binary='monitor-bmc').first() DCNL DCSP  DCSP node = session.query(models.ComputeNode).options(joinedload('service')).filter_by(deleted=False, service_id=service.id) DCNL DCSP  DCSP return node.first()
 DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP table = models.ComputeNode.__table__ DCNL DCSP  DCSP if (free_ram_mb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = (table.c.free_ram_mb + free_ram_mb_delta) DCNL DCSP  DCSP if (free_disk_gb_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = (table.c.free_disk_gb + free_disk_gb_delta) DCNL DCSP  DCSP if (work_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.current_workload = (table.c.current_workload + work_delta) DCNL DCSP  DCSP if (vm_delta != 0): DCNL DCSP  DCSP  DCSP compute_node.running_vms = (table.c.running_vms + vm_delta) DCNL DCSP return compute_node
 DCSP session = get_session() DCNL DCSP compute_node = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_node = session.query(models.ComputeNode).options(joinedload('service')).filter((models.Service.host == host)).filter_by(deleted=False).with_lockmode('update').first() DCNL DCSP  DCSP if (compute_node is None): DCNL DCSP  DCSP  DCSP raise exception.NotFound((_('No DCSP ComputeNode DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_node.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_disk_gb != None): DCNL DCSP  DCSP  DCSP compute_node.free_disk_gb = free_disk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_node.current_workload = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_node.running_vms = vms DCNL DCSP return compute_node
 DCSP global _REPOSITORY DCNL DCSP path = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'migrate_repo') DCNL DCSP assert os.path.exists(path) DCNL DCSP if (_REPOSITORY is None): DCNL DCSP  DCSP _REPOSITORY = Repository(path) DCNL DCSP return _REPOSITORY
 DCSP return IMPL.service_destroy(context, service_id)
 DCSP return IMPL.service_get(context, service_id)
 DCSP return IMPL.service_get_by_host_and_topic(context, host, topic)
 DCSP return IMPL.service_get_all(context, disabled)
 DCSP return IMPL.service_get_all_by_topic(context, topic)
 DCSP return IMPL.service_get_all_by_host(context, host)
 DCSP return IMPL.service_get_all_bmc_by_host(context, host)
 DCSP return IMPL.service_get_all_servicemanage_sorted(context)
 DCSP return IMPL.service_get_by_args(context, host, binary)
 DCSP return IMPL.service_create(context, values)
 DCSP return IMPL.service_update(context, service_id, values)
 DCSP return IMPL.compute_node_get(context, compute_id)
 DCSP return IMPL.compute_node_get_all(context)
 DCSP return IMPL.compute_node_create(context, values)
 DCSP return IMPL.compute_node_update(context, compute_id, values, auto_adjust)
 DCSP return IMPL.db_sync(version=version)
 DCSP return IMPL.db_version()
 DCSP possible_locations = [config_path, os.path.join(FLAGS.state_path, 'etc', 'monitor', config_path), os.path.join(FLAGS.state_path, 'etc', config_path), os.path.join(FLAGS.state_path, config_path), ('/etc/monitor/%s' % config_path)] DCNL DCSP for path in possible_locations: DCNL DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP return os.path.abspath(path) DCNL DCSP raise exception.ConfigNotFound(path=os.path.abspath(config_path))
 DCSP process_input = kwargs.pop('process_input', None) DCNL DCSP check_exit_code = kwargs.pop('check_exit_code', [0]) DCNL DCSP ignore_exit_code = False DCNL DCSP if isinstance(check_exit_code, bool): DCNL DCSP  DCSP ignore_exit_code = (not check_exit_code) DCNL DCSP  DCSP check_exit_code = [0] DCNL DCSP elif isinstance(check_exit_code, int): DCNL DCSP  DCSP check_exit_code = [check_exit_code] DCNL DCSP delay_on_retry = kwargs.pop('delay_on_retry', True) DCNL DCSP attempts = kwargs.pop('attempts', 1) DCNL DCSP run_as_root = kwargs.pop('run_as_root', False) DCNL DCSP shell = kwargs.pop('shell', False) DCNL DCSP if len(kwargs): DCNL DCSP  DCSP raise exception.Error((_('Got DCSP unknown DCSP keyword DCSP args DCSP to DCSP utils.execute: DCSP %r') % kwargs)) DCNL DCSP if run_as_root: DCNL DCSP  DCSP if ((FLAGS.rootwrap_config is None) or (FLAGS.root_helper != 'sudo')): DCNL DCSP  DCSP  DCSP LOG.deprecated(_('The DCSP root_helper DCSP option DCSP (which DCSP lets DCSP you DCSP specify DCSP a DCSP root DCSP wrapper DCSP different DCSP from DCSP monitor-rootwrap, DCSP and DCSP defaults DCSP to DCSP using DCSP sudo) DCSP is DCSP now DCSP deprecated. DCSP You DCSP should DCSP use DCSP the DCSP rootwrap_config DCSP option DCSP instead.')) DCNL DCSP  DCSP if (FLAGS.rootwrap_config is not None): DCNL DCSP  DCSP  DCSP cmd = (['sudo', 'monitor-rootwrap', FLAGS.rootwrap_config] + list(cmd)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmd = (shlex.split(FLAGS.root_helper) + list(cmd)) DCNL DCSP cmd = map(str, cmd) DCNL DCSP while (attempts > 0): DCNL DCSP  DCSP attempts -= 1 DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP LOG.debug(_('Running DCSP cmd DCSP (subprocess): DCSP %s'), ' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP _PIPE = subprocess.PIPE DCNL DCSP  DCSP  DCSP obj = subprocess.Popen(cmd, stdin=_PIPE, stdout=_PIPE, stderr=_PIPE, close_fds=True, preexec_fn=_subprocess_setup, shell=shell) DCNL DCSP  DCSP  DCSP result = None DCNL DCSP  DCSP  DCSP if (process_input is not None): DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate(process_input) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result = obj.communicate() DCNL DCSP  DCSP  DCSP obj.stdin.close() DCNL DCSP  DCSP  DCSP _returncode = obj.returncode DCNL DCSP  DCSP  DCSP if _returncode: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug((_('Result DCSP was DCSP %s') % _returncode)) DCNL DCSP  DCSP  DCSP  DCSP if ((not ignore_exit_code) and (_returncode not in check_exit_code)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (stdout, stderr) = result DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise exception.ProcessExecutionError(exit_code=_returncode, stdout=stdout, stderr=stderr, cmd=' DCSP '.join(cmd)) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP  DCSP if (not attempts): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('%r DCSP failed. DCSP Retrying.'), cmd) DCNL DCSP  DCSP  DCSP  DCSP if delay_on_retry: DCNL DCSP  DCSP  DCSP  DCSP  DCSP greenthread.sleep((random.randint(20, 200) / 100.0)) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP greenthread.sleep(0)
 DCSP discard_warnings = kwargs.pop('discard_warnings', False) DCNL DCSP try: DCNL DCSP  DCSP (out, err) = execute(*args, **kwargs) DCNL DCSP  DCSP failed = False DCNL DCSP except exception.ProcessExecutionError as exn: DCNL DCSP  DCSP (out, err) = ('', str(exn)) DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP failed = True DCNL DCSP if ((not failed) and discard_warnings and err): DCNL DCSP  DCSP LOG.debug(err) DCNL DCSP  DCSP err = '' DCNL DCSP return (out, err)
 DCSP if (not unit): DCNL DCSP  DCSP unit = FLAGS.servicemanage_usage_audit_period DCNL DCSP offset = 0 DCNL DCSP if ('@' in unit): DCNL DCSP  DCSP (unit, offset) = unit.split('@', 1) DCNL DCSP  DCSP offset = int(offset) DCNL DCSP rightnow = timeutils.utcnow() DCNL DCSP if (unit not in ('month', 'day', 'year', 'hour')): DCNL DCSP  DCSP raise ValueError('Time DCSP period DCSP must DCSP be DCSP hour, DCSP day, DCSP month DCSP or DCSP year') DCNL DCSP if (unit == 'month'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=offset, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP year = rightnow.year DCNL DCSP  DCSP  DCSP if (1 >= rightnow.month): DCNL DCSP  DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP  DCSP month = (12 + (rightnow.month - 1)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP month = (rightnow.month - 1) DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP  DCSP year = end.year DCNL DCSP  DCSP if (1 >= end.month): DCNL DCSP  DCSP  DCSP year -= 1 DCNL DCSP  DCSP  DCSP month = (12 + (end.month - 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP month = (end.month - 1) DCNL DCSP  DCSP begin = datetime.datetime(day=offset, month=month, year=year) DCNL DCSP elif (unit == 'year'): DCNL DCSP  DCSP if (offset == 0): DCNL DCSP  DCSP  DCSP offset = 1 DCNL DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP begin = datetime.datetime(day=1, month=offset, year=(rightnow.year - 1)) DCNL DCSP elif (unit == 'day'): DCNL DCSP  DCSP end = datetime.datetime(hour=offset, day=rightnow.day, month=rightnow.month, year=rightnow.year) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(days=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(days=1)) DCNL DCSP elif (unit == 'hour'): DCNL DCSP  DCSP end = rightnow.replace(minute=offset, second=0, microsecond=0) DCNL DCSP  DCSP if (end >= rightnow): DCNL DCSP  DCSP  DCSP end = (end - datetime.timedelta(hours=1)) DCNL DCSP  DCSP begin = (end - datetime.timedelta(hours=1)) DCNL DCSP return (begin, end)
 DCSP r = random.SystemRandom() DCNL DCSP password = [r.choice(s) for s in symbolgroups] DCNL DCSP r.shuffle(password) DCNL DCSP password = password[:length] DCNL DCSP length -= len(password) DCNL DCSP symbols = ''.join(symbolgroups) DCNL DCSP password.extend([r.choice(symbols) for _i in xrange(length)]) DCNL DCSP r.shuffle(password) DCNL DCSP return ''.join(password)
 DCSP try: DCNL DCSP  DCSP return minidom.parseString(xml_string, parser=ProtectedExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
 DCSP return saxutils.escape(value, {'"': '&quot;', "'": '&apos;'})
 DCSP if isinstance(value, unicode): DCNL DCSP  DCSP return value.encode('utf-8') DCNL DCSP assert isinstance(value, str) DCNL DCSP return value
 DCSP try: DCNL DCSP  DCSP os.unlink(pathname) DCNL DCSP except OSError as e: DCNL DCSP  DCSP if (e.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP if (path is None): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP (first_token, sep, remainder) = path.partition('/') DCNL DCSP if (first_token == ''): DCNL DCSP  DCSP raise exception.Error('Invalid DCSP mini_xpath') DCNL DCSP results = [] DCNL DCSP if (items is None): DCNL DCSP  DCSP return results DCNL DCSP if (not isinstance(items, list)): DCNL DCSP  DCSP items = [items] DCNL DCSP for item in items: DCNL DCSP  DCSP if (item is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP get_method = getattr(item, 'get', None) DCNL DCSP  DCSP if (get_method is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP child = get_method(first_token) DCNL DCSP  DCSP if (child is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(child, list): DCNL DCSP  DCSP  DCSP for x in child: DCNL DCSP  DCSP  DCSP  DCSP results.append(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.append(child) DCNL DCSP if (not sep): DCNL DCSP  DCSP return results DCNL DCSP else: DCNL DCSP  DCSP return get_from_path(results, remainder)
 DCSP flattened = (flattened or {}) DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP flatten_dict(value, flattened) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flattened[key] = value DCNL DCSP return flattened
 DCSP intersection = {} DCNL DCSP difference = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP if (key in keys): DCNL DCSP  DCSP  DCSP intersection[key] = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP difference[key] = value DCNL DCSP return (intersection, difference)
 DCSP mapped = {} DCNL DCSP for (key, value) in dict_.iteritems(): DCNL DCSP  DCSP mapped_key = (key_map[key] if (key in key_map) else key) DCNL DCSP  DCSP mapped[mapped_key] = value DCNL DCSP return mapped
 DCSP subset = partition_dict(dict_, keys)[0] DCNL DCSP return subset
 DCSP if isinstance(obj, cls): DCNL DCSP  DCSP return obj DCNL DCSP raise Exception((_('Expected DCSP object DCSP of DCSP type: DCSP %s') % str(cls))) DCNL DCSP return cls()
 DCSP if (not val): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP return (True if int(val) else False) DCNL DCSP except ValueError: DCNL DCSP  DCSP return (val.lower() == 'true')
 DCSP val = str(val).lower() DCNL DCSP return ((val == 'true') or (val == 'false') or (val == 'yes') or (val == 'no') or (val == 'y') or (val == 'n') or (val == '1') or (val == '0'))
 DCSP parts = address.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for item in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not (0 <= int(item) <= 255)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
 DCSP if (not FLAGS.monkey_patch): DCNL DCSP  DCSP return DCNL DCSP for module_and_decorator in FLAGS.monkey_patch_modules: DCNL DCSP  DCSP (module, decorator_name) = module_and_decorator.split(':') DCNL DCSP  DCSP decorator = importutils.import_class(decorator_name) DCNL DCSP  DCSP __import__(module) DCNL DCSP  DCSP module_data = pyclbr.readmodule_ex(module) DCNL DCSP  DCSP for key in module_data.keys(): DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Class): DCNL DCSP  DCSP  DCSP  DCSP clz = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP for (method, func) in inspect.getmembers(clz, inspect.ismethod): DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(clz, method, decorator(('%s.%s.%s' % (module, key, method)), func)) DCNL DCSP  DCSP  DCSP if isinstance(module_data[key], pyclbr.Function): DCNL DCSP  DCSP  DCSP  DCSP func = importutils.import_class(('%s.%s' % (module, key))) DCNL DCSP  DCSP  DCSP  DCSP setattr(sys.modules[module], key, decorator(('%s.%s' % (module, key)), func))
 DCSP if (not lst): DCNL DCSP  DCSP return None DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP lst = [lst] DCNL DCSP return [{label: x} for x in lst]
 DCSP @functools.wraps(func) DCNL DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP  DCSP LOG.debug((_("timefunc: DCSP '%(name)s' DCSP took DCSP %(total_time).2f DCSP secs") % dict(name=func.__name__, total_time=total_time))) DCNL DCSP return inner
 DCSP return ('http://%s:%d' % (FLAGS.glance_host, FLAGS.glance_port))
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception as error: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.exception(message)
 DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP delete_if_exists(path)
 DCSP path = os.path.join(base, dev) DCNL DCSP if partition: DCNL DCSP  DCSP path += str(partition) DCNL DCSP return path
 DCSP if hasattr(td, 'total_seconds'): DCNL DCSP  DCSP return td.total_seconds() DCNL DCSP else: DCNL DCSP  DCSP return (((((td.days * 86400) + td.seconds) * (10 ** 6)) + td.microseconds) / (10.0 ** 6))
 DCSP if isinstance(hostname, unicode): DCNL DCSP  DCSP hostname = hostname.encode('latin-1', 'ignore') DCNL DCSP hostname = re.sub('[ DCSP _]', '-', hostname) DCNL DCSP hostname = re.sub('[^\\w.-]+', '', hostname) DCNL DCSP hostname = hostname.lower() DCNL DCSP hostname = hostname.strip('.-') DCNL DCSP return hostname
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP return file(*args, **kwargs)
 DCSP checksum = hashlib.sha1() DCNL DCSP any(map(checksum.update, iter((lambda : file_like_object.read(32768)), ''))) DCNL DCSP return checksum.hexdigest()
 DCSP NOT_PRESENT = object() DCNL DCSP old_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP old_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, old_value) in old_values.items(): DCNL DCSP  DCSP  DCSP if (old_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP del obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, old_value)
 DCSP last_heartbeat = (service['updated_at'] or service['created_at']) DCNL DCSP elapsed = total_seconds((timeutils.utcnow() - last_heartbeat)) DCNL DCSP return (abs(elapsed) <= FLAGS.service_down_time)
 DCSP mac = [250, 22, 62, random.randint(0, 127), random.randint(0, 255), random.randint(0, 255)] DCNL DCSP return ':'.join(map((lambda x: ('%02x' % x)), mac))
 DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except exception.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFound(file_path=file_path)
 DCSP if (owner_uid is None): DCNL DCSP  DCSP owner_uid = os.getuid() DCNL DCSP orig_uid = os.stat(path).st_uid DCNL DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP execute('chown', owner_uid, path, run_as_root=True) DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP finally: DCNL DCSP  DCSP if (orig_uid != owner_uid): DCNL DCSP  DCSP  DCSP execute('chown', orig_uid, path, run_as_root=True)
 DCSP if (len(s1) != len(s2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP for (a, b) in zip(s1, s2): DCNL DCSP  DCSP result |= (ord(a) ^ ord(b)) DCNL DCSP return (result == 0)
 DCSP if (not encountered): DCNL DCSP  DCSP encountered = [] DCNL DCSP for subclass in clazz.__subclasses__(): DCNL DCSP  DCSP if (subclass not in encountered): DCNL DCSP  DCSP  DCSP encountered.append(subclass) DCNL DCSP  DCSP  DCSP for subsubclass in walk_class_hierarchy(subclass, encountered): DCNL DCSP  DCSP  DCSP  DCSP (yield subsubclass) DCNL DCSP  DCSP  DCSP (yield subclass)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP BYTE_MULTIPLIERS = {'': 1, 't': (1024 ** 4), 'g': (1024 ** 3), 'm': (1024 ** 2), 'k': 1024} DCNL DCSP mult_key_org = text.lstrip('-1234567890') DCNL DCSP mult_key = mult_key_org.lower() DCNL DCSP mult_key_len = len(mult_key) DCNL DCSP if mult_key.endswith('b'): DCNL DCSP  DCSP mult_key = mult_key[0:(-1)] DCNL DCSP try: DCNL DCSP  DCSP multiplier = BYTE_MULTIPLIERS[mult_key] DCNL DCSP  DCSP if mult_key_len: DCNL DCSP  DCSP  DCSP text = text[0:(- mult_key_len)] DCNL DCSP  DCSP return (int(text) * multiplier) DCNL DCSP except KeyError: DCNL DCSP  DCSP msg = (_('Unknown DCSP byte DCSP multiplier: DCSP %s') % mult_key_org) DCNL DCSP  DCSP raise TypeError(msg) DCNL DCSP except ValueError: DCNL DCSP  DCSP return default
 DCSP mtime = os.path.getmtime(filename) DCNL DCSP if ((not cache_info) or (mtime != cache_info.get('mtime'))): DCNL DCSP  DCSP with open(filename) as fap: DCNL DCSP  DCSP  DCSP cache_info['data'] = fap.read() DCNL DCSP  DCSP cache_info['mtime'] = mtime DCNL DCSP  DCSP if reload_func: DCNL DCSP  DCSP  DCSP reload_func(cache_info['data']) DCNL DCSP return cache_info['data']
 DCSP init() DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP credentials = context.to_dict() DCNL DCSP policy.enforce(match_list, target, credentials, exception.PolicyNotAuthorized, action=action)
 DCSP init() DCNL DCSP action = 'context_is_admin' DCNL DCSP match_list = (('rule:%s' % action),) DCNL DCSP target = {'project_id': ''} DCNL DCSP credentials = {'roles': roles} DCNL DCSP return policy.enforce(match_list, target, credentials)
 DCSP try: DCNL DCSP  DCSP csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP  DCSP csock.connect(('8.8.8.8', 80)) DCNL DCSP  DCSP (addr, port) = csock.getsockname() DCNL DCSP  DCSP csock.close() DCNL DCSP  DCSP return addr DCNL DCSP except socket.error: DCNL DCSP  DCSP return '127.0.0.1'
 DCSP if CONF.log_config: DCNL DCSP  DCSP logging.config.fileConfig(CONF.log_config) DCNL DCSP else: DCNL DCSP  DCSP _setup_logging_from_conf() DCNL DCSP sys.excepthook = _create_logging_excepthook(product_name)
 DCSP try: DCNL DCSP  DCSP os.makedirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP if (not os.path.isdir(path)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
 DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if failure: DCNL DCSP  DCSP  DCSP failure = rpc_common.serialize_remote_exception(failure, log_failure) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP msg = {'result': reply, 'failure': failure} DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP msg = {'result': dict(((k, repr(v)) for (k, v) in reply.__dict__.iteritems())), 'failure': failure} DCNL DCSP  DCSP if ending: DCNL DCSP  DCSP  DCSP msg['ending'] = True DCNL DCSP  DCSP _add_unique_id(msg) DCNL DCSP  DCSP if reply_q: DCNL DCSP  DCSP  DCSP msg['_msg_id'] = msg_id DCNL DCSP  DCSP  DCSP conn.direct_send(reply_q, rpc_common.serialize_msg(msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conn.direct_send(msg_id, rpc_common.serialize_msg(msg))
 DCSP context_dict = {} DCNL DCSP for key in list(msg.keys()): DCNL DCSP  DCSP key = str(key) DCNL DCSP  DCSP if key.startswith('_context_'): DCNL DCSP  DCSP  DCSP value = msg.pop(key) DCNL DCSP  DCSP  DCSP context_dict[key[9:]] = value DCNL DCSP context_dict['msg_id'] = msg.pop('_msg_id', None) DCNL DCSP context_dict['reply_q'] = msg.pop('_reply_q', None) DCNL DCSP context_dict['conf'] = conf DCNL DCSP ctx = RpcContext.from_dict(context_dict) DCNL DCSP rpc_common._safe_log(LOG.debug, _('unpacked DCSP context: DCSP %s'), ctx.to_dict()) DCNL DCSP return ctx
 DCSP context_d = dict([(('_context_%s' % key), value) for (key, value) in context.to_dict().iteritems()]) DCNL DCSP msg.update(context_d)
 DCSP unique_id = uuid.uuid4().hex DCNL DCSP msg.update({UNIQUE_ID: unique_id}) DCNL DCSP LOG.debug((_('UNIQUE_ID DCSP is DCSP %s.') % unique_id))
 DCSP return ConnectionContext(conf, connection_pool, pooled=(not new))
 DCSP LOG.debug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_id = uuid.uuid4().hex DCNL DCSP msg.update({'_msg_id': msg_id}) DCNL DCSP LOG.debug((_('MSG_ID DCSP is DCSP %s') % msg_id)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP if (not conf.amqp_rpc_single_reply_queue): DCNL DCSP  DCSP conn = ConnectionContext(conf, connection_pool) DCNL DCSP  DCSP wait_msg = MulticallWaiter(conf, conn, timeout) DCNL DCSP  DCSP conn.declare_direct_consumer(msg_id, wait_msg) DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP else: DCNL DCSP  DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP  DCSP msg.update({'_reply_q': connection_pool.reply_proxy.get_reply_q()}) DCNL DCSP  DCSP wait_msg = MulticallProxyWaiter(conf, msg_id, timeout, connection_pool) DCNL DCSP  DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
 DCSP rv = multicall(conf, context, topic, msg, timeout, connection_pool) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP cast DCSP on DCSP %s...'), topic) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Making DCSP asynchronous DCSP fanout DCSP cast...')) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.topic_send(topic, rpc_common.serialize_msg(msg))
 DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool, pooled=False, server_params=server_params) as conn: DCNL DCSP  DCSP conn.fanout_send(topic, rpc_common.serialize_msg(msg))
 DCSP LOG.debug(_('Sending DCSP %(event_type)s DCSP on DCSP %(topic)s'), dict(event_type=msg.get('event_type'), topic=topic)) DCNL DCSP _add_unique_id(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP if envelope: DCNL DCSP  DCSP  DCSP msg = rpc_common.serialize_msg(msg, force_envelope=True) DCNL DCSP  DCSP conn.notify_send(topic, msg)
 DCSP return _get_impl().create_connection(CONF, new=new)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().call(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().cast(CONF, context, topic, msg)
 DCSP return _get_impl().fanout_cast(CONF, context, topic, msg)
 DCSP if check_for_lock: DCNL DCSP  DCSP _check_for_lock() DCNL DCSP return _get_impl().multicall(CONF, context, topic, msg, timeout)
 DCSP return _get_impl().notify(cfg.CONF, context, topic, msg, envelope)
 DCSP return _get_impl().cleanup()
 DCSP return _get_impl().cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return _get_impl().fanout_cast_to_server(CONF, context, server_params, topic, msg)
 DCSP return (('%s.%s' % (topic, host)) if host else topic)
 DCSP global _RPCIMPL DCNL DCSP if (_RPCIMPL is None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(CONF.rpc_backend) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP impl = CONF.rpc_backend.replace('nova.rpc', 'nova.openstack.common.rpc') DCNL DCSP  DCSP  DCSP _RPCIMPL = importutils.import_module(impl) DCNL DCSP return _RPCIMPL
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP return Connection()
 DCSP json.dumps(msg)
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP try: DCNL DCSP  DCSP consumer = CONSUMERS[topic][0] DCNL DCSP except (KeyError, IndexError): DCNL DCSP  DCSP return iter([None]) DCNL DCSP else: DCNL DCSP  DCSP return consumer.call(context, version, method, args, timeout)
 DCSP rv = multicall(conf, context, topic, msg, timeout) DCNL DCSP rv = list(rv) DCNL DCSP if (not rv): DCNL DCSP  DCSP return DCNL DCSP return rv[(-1)]
 DCSP check_serialize(msg) DCNL DCSP method = msg.get('method') DCNL DCSP if (not method): DCNL DCSP  DCSP return DCNL DCSP args = msg.get('args', {}) DCNL DCSP version = msg.get('version', None) DCNL DCSP for consumer in CONSUMERS.get(topic, []): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP consumer.call(context, version, method, args, None) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
 DCSP try: DCNL DCSP  DCSP return jsonutils.dumps(data, ensure_ascii=True) DCNL DCSP except TypeError: DCNL DCSP  DCSP with excutils.save_and_reraise_exception(): DCNL DCSP  DCSP  DCSP LOG.error(_('JSON DCSP serialization DCSP failed.'))
 DCSP LOG.debug(_('Deserializing: DCSP %s'), data) DCNL DCSP return jsonutils.loads(data)
 DCSP i = iter(packenv) DCNL DCSP h = {} DCNL DCSP try: DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP k = i.next() DCNL DCSP  DCSP  DCSP h[k] = i.next() DCNL DCSP except StopIteration: DCNL DCSP  DCSP return h
 DCSP conf = CONF DCNL DCSP LOG.debug((_('%(msg)s') % {'msg': ' DCSP '.join(map(pformat, (topic, msg)))})) DCNL DCSP queues = _get_matchmaker().queues(topic) DCNL DCSP LOG.debug(_('Sending DCSP message(s) DCSP to: DCSP %s'), queues) DCNL DCSP if (len(queues) == 0): DCNL DCSP  DCSP LOG.warn(_('No DCSP matchmaker DCSP results. DCSP Not DCSP casting.')) DCNL DCSP  DCSP raise rpc_common.Timeout(_('No DCSP match DCSP from DCSP matchmaker.')) DCNL DCSP for queue in queues: DCNL DCSP  DCSP (_topic, ip_addr) = queue DCNL DCSP  DCSP _addr = ('tcp://%s:%s' % (ip_addr, conf.rpc_zmq_port)) DCNL DCSP  DCSP if (method.__name__ == '_cast'): DCNL DCSP  DCSP  DCSP eventlet.spawn_n(method, _addr, context, _topic, msg, timeout, envelope, _msg_id) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return method(_addr, context, _topic, msg, timeout, envelope)
 DCSP return _multi_send(_call, *args, **kwargs)
 DCSP data = _multi_send(_call, *args, **kwargs) DCNL DCSP return data[(-1)]
 DCSP _multi_send(_cast, *args, **kwargs)
 DCSP _multi_send(_cast, context, ('fanout~' + str(topic)), msg, **kwargs)
 DCSP topic = topic.replace('.', '-') DCNL DCSP cast(conf, context, topic, msg, envelope=envelope)
 DCSP global ZMQ_CTX DCNL DCSP if ZMQ_CTX: DCNL DCSP  DCSP ZMQ_CTX.term() DCNL DCSP ZMQ_CTX = None DCNL DCSP global matchmaker DCNL DCSP matchmaker = None
 DCSP SANITIZE = {'set_admin_password': [('args', 'new_pass')], 'run_instance': [('args', 'admin_password')], 'route_message': [('args', 'message', 'args', 'method_info', 'method_kwargs', 'password'), ('args', 'message', 'args', 'method_info', 'method_kwargs', 'admin_password')]} DCNL DCSP has_method = (('method' in msg_data) and (msg_data['method'] in SANITIZE)) DCNL DCSP has_context_token = ('_context_auth_token' in msg_data) DCNL DCSP has_token = ('auth_token' in msg_data) DCNL DCSP if (not any([has_method, has_context_token, has_token])): DCNL DCSP  DCSP return log_func(msg, msg_data) DCNL DCSP msg_data = copy.deepcopy(msg_data) DCNL DCSP if has_method: DCNL DCSP  DCSP for arg in SANITIZE.get(msg_data['method'], []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP d = msg_data DCNL DCSP  DCSP  DCSP  DCSP for elem in arg[:(-1)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP d = d[elem] DCNL DCSP  DCSP  DCSP  DCSP d[arg[(-1)]] = '<SANITIZED>' DCNL DCSP  DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP  DCSP LOG.info(_('Failed DCSP to DCSP sanitize DCSP %(item)s. DCSP Key DCSP error DCSP %(err)s'), {'item': arg, 'err': e}) DCNL DCSP if has_context_token: DCNL DCSP  DCSP msg_data['_context_auth_token'] = '<SANITIZED>' DCNL DCSP if has_token: DCNL DCSP  DCSP msg_data['auth_token'] = '<SANITIZED>' DCNL DCSP return log_func(msg, msg_data)
 DCSP tb = traceback.format_exception(*failure_info) DCNL DCSP failure = failure_info[1] DCNL DCSP if log_failure: DCNL DCSP  DCSP LOG.error(_('Returning DCSP exception DCSP %s DCSP to DCSP caller'), unicode(failure)) DCNL DCSP  DCSP LOG.error(tb) DCNL DCSP kwargs = {} DCNL DCSP if hasattr(failure, 'kwargs'): DCNL DCSP  DCSP kwargs = failure.kwargs DCNL DCSP data = {'class': str(failure.__class__.__name__), 'module': str(failure.__class__.__module__), 'message': unicode(failure), 'tb': tb, 'args': failure.args, 'kwargs': kwargs} DCNL DCSP json_data = jsonutils.dumps(data) DCNL DCSP return json_data
 DCSP def outer(func): DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP return catch_client_exception(exceptions, func, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return outer
 DCSP version_parts = version.split('.') DCNL DCSP imp_version_parts = imp_version.split('.') DCNL DCSP if (int(version_parts[0]) != int(imp_version_parts[0])): DCNL DCSP  DCSP return False DCNL DCSP if (int(version_parts[1]) > int(imp_version_parts[1])): DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP return ({'x-ha-policy': 'all'} if conf.rabbit_ha_queues else {})
 DCSP return rpc_amqp.create_connection(conf, new, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.multicall(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.call(conf, context, topic, msg, timeout, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.fanout_cast_to_server(conf, context, server_params, topic, msg, rpc_amqp.get_connection_pool(conf, Connection))
 DCSP return rpc_amqp.notify(conf, context, topic, msg, rpc_amqp.get_connection_pool(conf, Connection), envelope)
 DCSP if (address[0] == '['): DCNL DCSP  DCSP (_host, _port) = address[1:].split(']') DCNL DCSP  DCSP host = _host DCNL DCSP  DCSP if (':' in _port): DCNL DCSP  DCSP  DCSP port = _port.split(':')[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP port = default_port DCNL DCSP elif (address.count(':') == 1): DCNL DCSP  DCSP (host, port) = address.split(':') DCNL DCSP else: DCNL DCSP  DCSP host = address DCNL DCSP  DCSP port = default_port DCNL DCSP return (host, (None if (port is None) else int(port)))
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP st = at.strftime((_ISO8601_TIME_FORMAT if (not subsecond) else _ISO8601_TIME_FORMAT_SUBSECOND)) DCNL DCSP tz = (at.tzinfo.tzname(None) if at.tzinfo else 'UTC') DCNL DCSP st += ('Z' if (tz == 'UTC') else tz) DCNL DCSP return st
 DCSP try: DCNL DCSP  DCSP return iso8601.parse_date(timestr) DCNL DCSP except iso8601.ParseError as e: DCNL DCSP  DCSP raise ValueError(e.message) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP raise ValueError(e.message)
 DCSP if (not at): DCNL DCSP  DCSP at = utcnow() DCNL DCSP return at.strftime(fmt)
 DCSP return datetime.datetime.strptime(timestr, fmt)
 DCSP offset = timestamp.utcoffset() DCNL DCSP if (offset is None): DCNL DCSP  DCSP return timestamp DCNL DCSP return (timestamp.replace(tzinfo=None) - offset)
 DCSP if isinstance(before, basestring): DCNL DCSP  DCSP before = parse_strtime(before).replace(tzinfo=None) DCNL DCSP return ((utcnow() - before) > datetime.timedelta(seconds=seconds))
 DCSP if isinstance(after, basestring): DCNL DCSP  DCSP after = parse_strtime(after).replace(tzinfo=None) DCNL DCSP return ((after - utcnow()) > datetime.timedelta(seconds=seconds))
 DCSP return calendar.timegm(utcnow().timetuple())
 DCSP if utcnow.override_time: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return utcnow.override_time.pop(0) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return utcnow.override_time DCNL DCSP return datetime.datetime.utcnow()
 DCSP return isotime(datetime.datetime.utcfromtimestamp(timestamp))
 DCSP utcnow.override_time = override_time
 DCSP assert (not (utcnow.override_time is None)) DCNL DCSP try: DCNL DCSP  DCSP for dt in utcnow.override_time: DCNL DCSP  DCSP  DCSP dt += timedelta DCNL DCSP except TypeError: DCNL DCSP  DCSP utcnow.override_time += timedelta
 DCSP advance_time_delta(datetime.timedelta(0, seconds))
 DCSP utcnow.override_time = None
 DCSP if (not now): DCNL DCSP  DCSP now = utcnow() DCNL DCSP return dict(day=now.day, month=now.month, year=now.year, hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 DCSP return datetime.datetime(day=tyme['day'], month=tyme['month'], year=tyme['year'], hour=tyme['hour'], minute=tyme['minute'], second=tyme['second'], microsecond=tyme['microsecond'])
 DCSP delta = (after - before) DCNL DCSP try: DCNL DCSP  DCSP return delta.total_seconds() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return ((((delta.days * 24) * 3600) + delta.seconds) + (float(delta.microseconds) / (10 ** 6)))
 DCSP soon = (utcnow() + datetime.timedelta(seconds=window)) DCNL DCSP return (normalize_time(dt) <= soon)
 DCSP global _BRAIN DCNL DCSP _BRAIN = brain
 DCSP global _BRAIN DCNL DCSP _BRAIN = None
 DCSP global _BRAIN DCNL DCSP if (not _BRAIN): DCNL DCSP  DCSP _BRAIN = Brain() DCNL DCSP if (not _BRAIN.check(match_list, target_dict, credentials_dict)): DCNL DCSP  DCSP if exc: DCNL DCSP  DCSP  DCSP raise exc(*args, **kwargs) DCNL DCSP  DCSP return False DCNL DCSP return True
 DCSP def decorator(func): DCNL DCSP  DCSP Brain._register(name, func) DCNL DCSP  DCSP return func DCNL DCSP if func: DCNL DCSP  DCSP return decorator(func) DCNL DCSP return decorator
 DCSP try: DCNL DCSP  DCSP new_match_list = brain.rules[match] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (brain.default_rule and (match != brain.default_rule)): DCNL DCSP  DCSP  DCSP new_match_list = (('rule:%s' % brain.default_rule),) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return brain.check(new_match_list, target_dict, cred_dict)
 DCSP return (match.lower() in [x.lower() for x in cred_dict['roles']])
 DCSP url = ('http:' + (match % target_dict)) DCNL DCSP data = {'target': jsonutils.dumps(target_dict), 'credentials': jsonutils.dumps(cred_dict)} DCNL DCSP post_data = urllib.urlencode(data) DCNL DCSP f = urllib2.urlopen(url, post_data) DCNL DCSP return (f.read() == 'True')
 DCSP match = (match % target_dict) DCNL DCSP if (match_kind in cred_dict): DCNL DCSP  DCSP return (match == unicode(cred_dict[match_kind])) DCNL DCSP return False
 DCSP def wrap(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP def inner(*args, **kwargs): DCNL DCSP  DCSP  DCSP sem = _semaphores.get(name, semaphore.Semaphore()) DCNL DCSP  DCSP  DCSP if (name not in _semaphores): DCNL DCSP  DCSP  DCSP  DCSP _semaphores[name] = sem DCNL DCSP  DCSP  DCSP with sem: DCNL DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP semaphore DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(local.strong_store, 'locks_held')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held = [] DCNL DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.append(name) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (external and (not CONF.disable_process_locking)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Attempting DCSP to DCSP grab DCSP file DCSP lock DCSP "%(lock)s" DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = CONF.lock_path DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not local_lock_path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cleanup_dir = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP local_lock_path = tempfile.mkdtemp() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not os.path.exists(local_lock_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fileutils.ensure_tree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP safe_name = name.replace(os.sep, '_') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_name = ('%s%s' % (lock_file_prefix, safe_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock_file_path = os.path.join(local_lock_path, lock_file_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lock = InterProcessLock(lock_file_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with lock: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Got DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.debug(_('Released DCSP file DCSP lock DCSP "%(lock)s" DCSP at DCSP %(path)s DCSP for DCSP method DCSP "%(method)s"...'), {'lock': name, 'path': lock_file_path, 'method': f.__name__}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if cleanup_dir: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(local_lock_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retval = f(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP local.strong_store.locks_held.remove(name) DCNL DCSP  DCSP  DCSP return retval DCNL DCSP  DCSP return inner DCNL DCSP return wrap
 DCSP try: DCNL DCSP  DCSP return (str(uuid.UUID(val)) == val) DCNL DCSP except (TypeError, ValueError, AttributeError): DCNL DCSP  DCSP return False
 DCSP return ((bool_from_string(subject) and 1) or 0)
 DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP if isinstance(subject, basestring): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', 'yes', '1')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP decoded" % type(text))) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP try: DCNL DCSP  DCSP return text.decode(incoming, errors) DCNL DCSP except UnicodeDecodeError: DCNL DCSP  DCSP return text.decode('utf-8', errors)
 DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoded" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stdin.encoding or sys.getdefaultencoding()) DCNL DCSP if isinstance(text, unicode): DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP elif (text and (encoding != incoming)): DCNL DCSP  DCSP text = safe_decode(text, incoming, errors) DCNL DCSP  DCSP return text.encode(encoding, errors) DCNL DCSP return text
 DCSP (type_, value, tb) = sys.exc_info() DCNL DCSP try: DCNL DCSP  DCSP (yield) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.error(_('Original DCSP exception DCSP being DCSP dropped: DCSP %s'), traceback.format_exception(type_, value, tb)) DCNL DCSP  DCSP raise DCNL DCSP raise type_, value, tb
 DCSP for (alias, email_address) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_address) DCNL DCSP return changelog
 DCSP new_changelog = 'ChangeLog' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_WRITE_GIT_CHANGELOG')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = ('git DCSP --git-dir=%s DCSP log' % git_dir) DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_changelog, 'w') as changelog_file: DCNL DCSP  DCSP  DCSP  DCSP changelog_file.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP else: DCNL DCSP  DCSP open(new_changelog, 'w').close()
 DCSP jenkins_email = 'jenkins@review.(openstack|stackforge).org' DCNL DCSP old_authors = 'AUTHORS.in' DCNL DCSP new_authors = 'AUTHORS' DCNL DCSP git_dir = _get_git_directory() DCNL DCSP if (not os.getenv('SKIP_GENERATE_AUTHORS')): DCNL DCSP  DCSP if git_dir: DCNL DCSP  DCSP  DCSP git_log_cmd = (((('git DCSP --git-dir=' + git_dir) + " DCSP log DCSP --format='%aN DCSP <%aE>' DCSP | DCSP sort DCSP -u DCSP | DCSP egrep DCSP -v DCSP '") + jenkins_email) + "'") DCNL DCSP  DCSP  DCSP changelog = _run_shell_command(git_log_cmd) DCNL DCSP  DCSP  DCSP mailmap = _parse_git_mailmap(git_dir) DCNL DCSP  DCSP  DCSP with open(new_authors, 'w') as new_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP new_authors_fh.write(canonicalize_emails(changelog, mailmap)) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(old_authors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(old_authors, 'r') as old_authors_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_authors_fh.write(('\n' + old_authors_fh.read())) DCNL DCSP else: DCNL DCSP  DCSP open(new_authors, 'w').close()
 DCSP cmdclass = dict() DCNL DCSP def _find_modules(arg, dirname, files): DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP if (filename.endswith('.py') and (filename != '__init__.py')): DCNL DCSP  DCSP  DCSP  DCSP arg[('%s.%s' % (dirname.replace('/', '.'), filename[:(-3)]))] = True DCNL DCSP class LocalSDist(sdist.sdist, ): DCNL DCSP  DCSP 'Builds DCSP the DCSP ChangeLog DCSP and DCSP Authors DCSP files DCSP from DCSP VC DCSP first.' DCNL DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP write_git_changelog() DCNL DCSP  DCSP  DCSP generate_authors() DCNL DCSP  DCSP  DCSP sdist.sdist.run(self) DCNL DCSP cmdclass['sdist'] = LocalSDist DCNL DCSP try: DCNL DCSP  DCSP from sphinx.setup_command import BuildDoc DCNL DCSP  DCSP class LocalBuildDoc(BuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['html', 'man'] DCNL DCSP  DCSP  DCSP def generate_autoindex(self): DCNL DCSP  DCSP  DCSP  DCSP print ('**Autodocumenting DCSP from DCSP %s' % os.path.abspath(os.curdir)) DCNL DCSP  DCSP  DCSP  DCSP modules = {} DCNL DCSP  DCSP  DCSP  DCSP option_dict = self.distribution.get_option_dict('build_sphinx') DCNL DCSP  DCSP  DCSP  DCSP source_dir = os.path.join(option_dict['source_dir'][1], 'api') DCNL DCSP  DCSP  DCSP  DCSP if (not os.path.exists(source_dir)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.makedirs(source_dir) DCNL DCSP  DCSP  DCSP  DCSP for pkg in self.distribution.packages: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('.' not in pkg): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.path.walk(pkg, _find_modules, modules) DCNL DCSP  DCSP  DCSP  DCSP module_list = modules.keys() DCNL DCSP  DCSP  DCSP  DCSP module_list.sort() DCNL DCSP  DCSP  DCSP  DCSP autoindex_filename = os.path.join(source_dir, 'autoindex.rst') DCNL DCSP  DCSP  DCSP  DCSP with open(autoindex_filename, 'w') as autoindex: DCNL DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write('.. DCSP toctree::\n DCSP  DCSP  DCSP :maxdepth: DCSP 1\n\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP for module in module_list: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_filename = os.path.join(source_dir, ('%s.rst' % module)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP heading = ('The DCSP :mod:`%s` DCSP Module' % module) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP underline = ('=' * len(heading)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values = dict(module=module, heading=heading, underline=underline) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Generating DCSP %s' % output_filename) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with open(output_filename, 'w') as output_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output_file.write((_rst_template % values)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP autoindex.write((' DCSP  DCSP  DCSP %s.rst\n' % module)) DCNL DCSP  DCSP  DCSP def run(self): DCNL DCSP  DCSP  DCSP  DCSP if (not os.getenv('SPHINX_DEBUG')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.generate_autoindex() DCNL DCSP  DCSP  DCSP  DCSP for builder in self.builders: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.builder = builder DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.finalize_options() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.project = self.distribution.get_name() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.version = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.release = self.distribution.get_version() DCNL DCSP  DCSP  DCSP  DCSP  DCSP BuildDoc.run(self) DCNL DCSP  DCSP class LocalBuildLatex(LocalBuildDoc, ): DCNL DCSP  DCSP  DCSP builders = ['latex'] DCNL DCSP  DCSP cmdclass['build_sphinx'] = LocalBuildDoc DCNL DCSP  DCSP cmdclass['build_sphinx_latex'] = LocalBuildLatex DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP return cmdclass
 DCSP describe = _run_shell_command(('git DCSP --git-dir=%s DCSP describe DCSP --always' % git_dir)) DCNL DCSP if ('-' in describe): DCNL DCSP  DCSP return describe.rsplit('-', 2)[(-2)] DCNL DCSP revlist = _run_shell_command(('git DCSP --git-dir=%s DCSP rev-list DCSP --abbrev-commit DCSP HEAD' % git_dir)) DCNL DCSP return len(revlist.splitlines())
 DCSP git_dir = _get_git_directory() DCNL DCSP if git_dir: DCNL DCSP  DCSP if pre_version: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --exact-match'), throw_on_error=True).replace('-', '.') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sha = _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP log DCSP -n1 DCSP --pretty=format:%h')) DCNL DCSP  DCSP  DCSP  DCSP return ('%s.a%s.g%s' % (pre_version, _get_revno(git_dir), sha)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _run_shell_command((('git DCSP --git-dir=' + git_dir) + ' DCSP describe DCSP --always')).replace('-', '.') DCNL DCSP return None
 DCSP try: DCNL DCSP  DCSP pkg_info_file = open('PKG-INFO', 'r') DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP pkg_info = email.message_from_file(pkg_info_file) DCNL DCSP except email.MessageError: DCNL DCSP  DCSP return None DCNL DCSP if (pkg_info.get('Name', None) != package_name): DCNL DCSP  DCSP return None DCNL DCSP return pkg_info.get('Version', None)
 DCSP version = os.environ.get('OSLO_PACKAGE_VERSION', None) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_pkg_info(package_name) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP version = _get_version_from_git(pre_version) DCNL DCSP if version: DCNL DCSP  DCSP return version DCNL DCSP raise Exception('Versioning DCSP for DCSP this DCSP project DCSP requires DCSP either DCSP an DCSP sdist DCSP tarball, DCSP or DCSP access DCSP to DCSP an DCSP upstream DCSP git DCSP repository.')
 DCSP nasty = [inspect.ismodule, inspect.isclass, inspect.ismethod, inspect.isfunction, inspect.isgeneratorfunction, inspect.isgenerator, inspect.istraceback, inspect.isframe, inspect.iscode, inspect.isbuiltin, inspect.isroutine, inspect.isabstract] DCNL DCSP for test in nasty: DCNL DCSP  DCSP if test(value): DCNL DCSP  DCSP  DCSP return unicode(value) DCNL DCSP if (type(value) == itertools.count): DCNL DCSP  DCSP return unicode(value) DCNL DCSP if (getattr(value, '__module__', None) == 'mox'): DCNL DCSP  DCSP return 'mock' DCNL DCSP if (level > max_depth): DCNL DCSP  DCSP return '?' DCNL DCSP try: DCNL DCSP  DCSP recursive = functools.partial(to_primitive, convert_instances=convert_instances, convert_datetime=convert_datetime, level=level, max_depth=max_depth) DCNL DCSP  DCSP if isinstance(value, xmlrpclib.DateTime): DCNL DCSP  DCSP  DCSP value = datetime.datetime(*tuple(value.timetuple())[:6]) DCNL DCSP  DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP  DCSP return [recursive(v) for v in value] DCNL DCSP  DCSP elif isinstance(value, dict): DCNL DCSP  DCSP  DCSP return dict(((k, recursive(v)) for (k, v) in value.iteritems())) DCNL DCSP  DCSP elif (convert_datetime and isinstance(value, datetime.datetime)): DCNL DCSP  DCSP  DCSP return timeutils.strtime(value) DCNL DCSP  DCSP elif hasattr(value, 'iteritems'): DCNL DCSP  DCSP  DCSP return recursive(dict(value.iteritems()), level=(level + 1)) DCNL DCSP  DCSP elif hasattr(value, '__iter__'): DCNL DCSP  DCSP  DCSP return recursive(list(value)) DCNL DCSP  DCSP elif (convert_instances and hasattr(value, '__dict__')): DCNL DCSP  DCSP  DCSP return recursive(value.__dict__, level=(level + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return value DCNL DCSP except TypeError: DCNL DCSP  DCSP return unicode(value)
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.rpc_notifier2.topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message, envelope=True) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP LOG.deprecated(_('The DCSP rabbit_notifier DCSP is DCSP now DCSP deprecated. DCSP Please DCSP use DCSP rpc_notifier DCSP instead.')) DCNL DCSP rpc_notifier.notify(context, message)
 DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP logger = logging.getLogger(('monitor.openstack.common.notification.%s' % message['event_type'])) DCNL DCSP getattr(logger, priority)(jsonutils.dumps(message))
 DCSP if (not context): DCNL DCSP  DCSP context = req_context.get_admin_context() DCNL DCSP priority = message.get('priority', CONF.default_notification_level) DCNL DCSP priority = priority.lower() DCNL DCSP for topic in CONF.notification_topics: DCNL DCSP  DCSP topic = ('%s.%s' % (topic, priority)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rpc.notify(context, topic, message) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP LOG.exception(_('Could DCSP not DCSP send DCSP notification DCSP to DCSP %(topic)s. DCSP Payload=%(message)s'), locals())
 DCSP def wrapped_func(*args, **kwarg): DCNL DCSP  DCSP body = {} DCNL DCSP  DCSP body['args'] = [] DCNL DCSP  DCSP body['kwarg'] = {} DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP body['args'].append(arg) DCNL DCSP  DCSP for key in kwarg: DCNL DCSP  DCSP  DCSP body['kwarg'][key] = kwarg[key] DCNL DCSP  DCSP ctxt = context.get_context_from_function_and_args(fn, args, kwarg) DCNL DCSP  DCSP notify(ctxt, CONF.default_publisher_id, name, CONF.default_notification_level, body) DCNL DCSP  DCSP return fn(*args, **kwarg) DCNL DCSP return wrapped_func
 DCSP if (priority not in log_levels): DCNL DCSP  DCSP raise BadPriorityException((_('%s DCSP not DCSP in DCSP valid DCSP priorities') % priority)) DCNL DCSP payload = jsonutils.to_primitive(payload, convert_instances=True) DCNL DCSP msg = dict(message_id=str(uuid.uuid4()), publisher_id=publisher_id, event_type=event_type, priority=priority, payload=payload, timestamp=str(timeutils.utcnow())) DCNL DCSP for driver in _get_drivers(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver.notify(context, msg) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP LOG.exception((_("Problem DCSP '%(e)s' DCSP attempting DCSP to DCSP send DCSP to DCSP notification DCSP system. DCSP Payload=%(payload)s") % dict(e=e, payload=payload)))
 DCSP global _drivers DCNL DCSP if (_drivers is None): DCNL DCSP  DCSP _drivers = {} DCNL DCSP  DCSP for notification_driver in CONF.notification_driver: DCNL DCSP  DCSP  DCSP add_driver(notification_driver) DCNL DCSP return _drivers.values()
 DCSP _get_drivers() DCNL DCSP if isinstance(notification_driver, basestring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP driver = importutils.import_module(notification_driver) DCNL DCSP  DCSP  DCSP _drivers[notification_driver] = driver DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP LOG.exception((_('Failed DCSP to DCSP load DCSP notifier DCSP %s. DCSP These DCSP notifications DCSP will DCSP not DCSP be DCSP sent.') % notification_driver)) DCNL DCSP else: DCNL DCSP  DCSP _drivers[notification_driver] = notification_driver
 DCSP global _drivers DCNL DCSP _drivers = None
 DCSP NOTIFICATIONS.append(message)
 DCSP pass
 DCSP (mod_str, _sep, class_str) = import_str.rpartition('.') DCNL DCSP try: DCNL DCSP  DCSP __import__(mod_str) DCNL DCSP  DCSP return getattr(sys.modules[mod_str], class_str) DCNL DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP raise ImportError(('Class DCSP %s DCSP cannot DCSP be DCSP found DCSP (%s)' % (class_str, traceback.format_exception(*sys.exc_info()))))
 DCSP return import_class(import_str)(*args, **kwargs)
 DCSP import_value = ('%s.%s' % (name_space, import_str)) DCNL DCSP try: DCNL DCSP  DCSP return import_class(import_value)(*args, **kwargs) DCNL DCSP except ImportError: DCNL DCSP  DCSP return import_class(import_str)(*args, **kwargs)
 DCSP __import__(import_str) DCNL DCSP return sys.modules[import_str]
 DCSP try: DCNL DCSP  DCSP return import_module(import_str) DCNL DCSP except ImportError: DCNL DCSP  DCSP return default
 DCSP for arg in itertools.chain(kwargs.values(), args): DCNL DCSP  DCSP if isinstance(arg, RequestContext): DCNL DCSP  DCSP  DCSP return arg DCNL DCSP return None
 DCSP if (not hasattr(filters, class_name)): DCNL DCSP  DCSP logging.warning(('Skipping DCSP unknown DCSP filter DCSP class DCSP (%s) DCSP specified DCSP in DCSP filter DCSP definitions' % class_name)) DCNL DCSP  DCSP return None DCNL DCSP filterclass = getattr(filters, class_name) DCNL DCSP return filterclass(*args)
 DCSP filterlist = [] DCNL DCSP for filterdir in filters_path: DCNL DCSP  DCSP if (not os.path.isdir(filterdir)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for filterfile in os.listdir(filterdir): DCNL DCSP  DCSP  DCSP filterconfig = ConfigParser.RawConfigParser() DCNL DCSP  DCSP  DCSP filterconfig.read(os.path.join(filterdir, filterfile)) DCNL DCSP  DCSP  DCSP for (name, value) in filterconfig.items('Filters'): DCNL DCSP  DCSP  DCSP  DCSP filterdefinition = [string.strip(s) for s in value.split(',')] DCNL DCSP  DCSP  DCSP  DCSP newfilter = build_filter(*filterdefinition) DCNL DCSP  DCSP  DCSP  DCSP if (newfilter is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP newfilter.name = name DCNL DCSP  DCSP  DCSP  DCSP filterlist.append(newfilter) DCNL DCSP return filterlist
 DCSP first_not_executable_filter = None DCNL DCSP for f in filters: DCNL DCSP  DCSP if f.match(userargs): DCNL DCSP  DCSP  DCSP if (not f.get_exec(exec_dirs=exec_dirs)): DCNL DCSP  DCSP  DCSP  DCSP if (not first_not_executable_filter): DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_not_executable_filter = f DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP return f DCNL DCSP if first_not_executable_filter: DCNL DCSP  DCSP raise FilterMatchNotExecutable(match=first_not_executable_filter) DCNL DCSP raise NoFilterMatched()
 DCSP def decorator(f): DCNL DCSP  DCSP f._periodic_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
 DCSP def decorator(f): DCNL DCSP  DCSP f._short_cycle_task = True DCNL DCSP  DCSP f._ticks_between_runs = kwargs.pop('ticks_between_runs', 0) DCNL DCSP  DCSP return f DCNL DCSP if kwargs: DCNL DCSP  DCSP return decorator DCNL DCSP else: DCNL DCSP  DCSP return decorator(args[0])
