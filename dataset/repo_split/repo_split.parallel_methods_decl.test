def test_default_param(self):
def test_print_args(self):
@property DCNL def __name__(self):
def fit(self, X, y=None):
def transform(self, X, y=None):
def __init__(self, estimator):
def fit(self, X, y=None, **fit_params):
def transform(self, X):
def __init__(self, generations=100, population_size=100, offspring_size=None, mutation_rate=0.9, crossover_rate=0.1, scoring=None, cv=5, subsample=1.0, n_jobs=1, max_time_mins=None, max_eval_time_mins=5, random_state=None, config_dict=None, warm_start=False, verbosity=0, disable_update_check=False):
def fit(self, features, target, sample_weight=None, groups=None):
def _update_top_pipeline(self):
def predict(self, features):
def fit_predict(self, features, target):
def score(self, testing_features, testing_target):
def predict_proba(self, features):
def set_params(self, **params):
def export(self, output_file_name):
def _impute_values(self, features):
def _check_dataset(self, features, target):
def _compile_to_sklearn(self, expr):
def _set_param_recursive(self, pipeline_steps, parameter, value):
def _evaluate_individuals(self, individuals, features, target, sample_weight=None, groups=None):
@_pre_test DCNL def _random_mutation_operator(self, individual):
def _gen_grow_safe(self, pset, min_, max_, type_=None):
@_pre_test DCNL def _generate(self, pset, min_, max_, condition, type_=None):
def add_rule(self, rule):
def to_xml(self):
def add_transition(self, days=None, date=None, storage_class=None):
def to_xml(self):
def add_rule(self, id=None, prefix='', status='Enabled', expiration=None, transition=None):
def connect(self, **kw_params):
def set_key_class(self, key_class):
def lookup(self, key_name, headers=None):
def get_key(self, key_name, headers=None, version_id=None, response_headers=None, validate=True):
def list(self, prefix='', delimiter='', marker='', headers=None, encoding_type=None):
def list_versions(self, prefix='', delimiter='', key_marker='', version_id_marker='', headers=None, encoding_type=None):
def list_multipart_uploads(self, key_marker='', upload_id_marker='', headers=None, encoding_type=None):
def validate_kwarg_names(self, kwargs, names):
def get_all_keys(self, headers=None, **params):
def get_all_versions(self, headers=None, **params):
def validate_get_all_versions_params(self, params):
def get_all_multipart_uploads(self, headers=None, **params):
def new_key(self, key_name=None):
def delete_keys(self, keys, quiet=False, mfa_token=None, headers=None):
def delete_key(self, key_name, headers=None, version_id=None, mfa_token=None):
def copy_key(self, new_key_name, src_bucket_name, src_key_name, metadata=None, src_version_id=None, storage_class='STANDARD', preserve_acl=False, encrypt_key=False, headers=None, query_args=None):
def set_subresource(self, subresource, value, key_name='', headers=None, version_id=None):
def get_subresource(self, subresource, key_name='', headers=None, version_id=None):
def add_email_grant(self, permission, email_address, recursive=False, headers=None):
def add_user_grant(self, permission, user_id, recursive=False, headers=None, display_name=None):
def get_location(self):
def set_xml_logging(self, logging_str, headers=None):
def enable_logging(self, target_bucket, target_prefix='', grants=None, headers=None):
def disable_logging(self, headers=None):
def get_logging_status(self, headers=None):
def set_as_logging_target(self, headers=None):
def configure_versioning(self, versioning, mfa_delete=False, mfa_token=None, headers=None):
def get_versioning_status(self, headers=None):
def configure_lifecycle(self, lifecycle_config, headers=None):
def get_lifecycle_config(self, headers=None):
def delete_lifecycle_configuration(self, headers=None):
def configure_website(self, suffix=None, error_key=None, redirect_all_requests_to=None, routing_rules=None, headers=None):
def set_website_configuration(self, config, headers=None):
def set_website_configuration_xml(self, xml, headers=None):
def get_website_configuration(self, headers=None):
def get_website_configuration_obj(self, headers=None):
def get_website_configuration_with_xml(self, headers=None):
def get_website_configuration_xml(self, headers=None):
def delete_website_configuration(self, headers=None):
def get_website_endpoint(self):
def get_policy(self, headers=None):
def set_policy(self, policy, headers=None):
def set_cors_xml(self, cors_xml, headers=None):
def set_cors(self, cors_config, headers=None):
def get_cors_xml(self, headers=None):
def get_cors(self, headers=None):
def delete_cors(self, headers=None):
def initiate_multipart_upload(self, key_name, headers=None, reduced_redundancy=False, metadata=None, encrypt_key=False, policy=None):
def complete_multipart_upload(self, key_name, upload_id, xml_body, headers=None):
def cancel_multipart_upload(self, key_name, upload_id, headers=None):
def __init__(self, tracker_file_name=None, num_retries=None):
def _attempt_resumable_download(self, key, fp, headers, cb, num_cb, torrent, version_id, hash_algs):
def get_file(self, key, fp, headers, cb=None, num_cb=10, torrent=False, version_id=None, hash_algs=None):
def set_bucket_class(self, bucket_class):
def build_post_policy(self, expiration_time, conditions):
def build_post_form_args(self, bucket_name, key, expires_in=6000, acl=None, success_action_redirect=None, max_content_length=None, http_method='http', fields=None, conditions=None, storage_class='STANDARD', server_side_encryption=None):
def get_canonical_user_id(self, headers=None):
def get_bucket(self, bucket_name, validate=True, headers=None):
def head_bucket(self, bucket_name, headers=None):
def lookup(self, bucket_name, validate=True, headers=None):
def create_bucket(self, bucket_name, headers=None, location=Location.DEFAULT, policy=None):
def delete_bucket(self, bucket, headers=None):
def get_md5_from_hexdigest(self, md5_hexdigest):
def handle_addl_headers(self, headers):
def open_read(self, headers=None, query_args='', override_num_retries=None, response_headers=None):
def open_write(self, headers=None, override_num_retries=None):
def close(self, fast=False):
def next(self):
def change_storage_class(self, new_storage_class, dst_bucket=None, validate_dst_bucket=True):
def copy(self, dst_bucket, dst_key, metadata=None, reduced_redundancy=False, preserve_acl=False, encrypt_key=False, validate_dst_bucket=True):
def exists(self, headers=None):
def delete(self, headers=None):
def get_redirect(self):
def set_redirect(self, redirect_location, headers=None):
def generate_url(self, expires_in, method='GET', headers=None, query_auth=True, force_http=False, response_headers=None, expires_in_absolute=False, version_id=None, policy=None, reduced_redundancy=False, encrypt_key=False):
def send_file(self, fp, headers=None, cb=None, num_cb=10, query_args=None, chunked_transfer=False, size=None):
def compute_md5(self, fp, size=None):
def set_contents_from_stream(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, reduced_redundancy=False, query_args=None, size=None):
def set_contents_from_file(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=False, query_args=None, encrypt_key=False, size=None, rewind=False):
def set_contents_from_filename(self, filename, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=False, encrypt_key=False):
def set_contents_from_string(self, string_data, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=False, encrypt_key=False):
def get_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, override_num_retries=None, response_headers=None):
def get_torrent_file(self, fp, headers=None, cb=None, num_cb=10):
def get_contents_to_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, res_download_handler=None, response_headers=None):
def get_contents_to_filename(self, filename, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, res_download_handler=None, response_headers=None):
def get_contents_as_string(self, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, response_headers=None, encoding=None):
def add_email_grant(self, permission, email_address, headers=None):
def add_user_grant(self, permission, user_id, headers=None, display_name=None):
def _get_remote_metadata(self, headers=None):
def restore(self, days, headers=None):
def to_xml(self):
def add_rule(self, allowed_method, allowed_origin, id=None, allowed_header=None, max_age_seconds=None, expose_header=None):
def get_all_parts(self, max_parts=None, part_number_marker=None, encoding_type=None):
def upload_part_from_file(self, fp, part_num, headers=None, replace=True, cb=None, num_cb=10, md5=None, size=None):
def copy_part_from_key(self, src_bucket_name, src_key_name, part_num, start=None, end=None, src_version_id=None, headers=None):
def complete_upload(self):
def cancel_upload(self):
def add_event_source(self, event_source, function_name, role, batch_size=None, parameters=None):
def delete_function(self, function_name):
def get_event_source(self, uuid):
def get_function(self, function_name):
def get_function_configuration(self, function_name):
def invoke_async(self, function_name, invoke_args):
def list_event_sources(self, event_source_arn=None, function_name=None, marker=None, max_items=None):
def list_functions(self, marker=None, max_items=None):
def remove_event_source(self, uuid):
def update_function_configuration(self, function_name, role=None, handler=None, description=None, timeout=None, memory_size=None):
def upload_function(self, function_name, function_zip, runtime, role, handler, mode, description=None, timeout=None, memory_size=None):
def load_credential_file(self, path):
def save_option(self, path, section, option, value):
def add_cron(self, name, minute, hour, mday, month, wday, who, command, env=None):
def add_env(self, key, value):
def stop(self, service_name):
def start(self, service_name):
def install(self):
def add_cron(self, name, command, minute='*', hour='*', mday='*', month='*', wday='*', who='root', env=None):
def add_init_script(self, file, name):
def add_env(self, key, value):
def create_user(self, user):
def install(self):
def validateStartTag(self, tag, parent):
def validateEndTag(self, tag):
def validate(self):
def to_xml(self):
def to_xml(self):
def add_rule(self, action, action_text, conditions):
def get_key(self, key_name, headers=None, version_id=None, response_headers=None, generation=None):
def copy_key(self, new_key_name, src_bucket_name, src_key_name, metadata=None, src_version_id=None, storage_class='STANDARD', preserve_acl=False, encrypt_key=False, headers=None, query_args=None, src_generation=None):
def list_versions(self, prefix='', delimiter='', marker='', generation_marker='', headers=None):
def validate_get_all_versions_params(self, params):
def delete_key(self, key_name, headers=None, version_id=None, mfa_token=None, generation=None):
def set_acl(self, acl_or_str, key_name='', headers=None, version_id=None, generation=None, if_generation=None, if_metageneration=None):
def set_def_acl(self, acl_or_str, headers=None):
def _get_xml_acl_helper(self, key_name, headers, query_args):
def _get_acl_helper(self, key_name, headers, query_args):
def get_acl(self, key_name='', headers=None, version_id=None, generation=None):
def get_xml_acl(self, key_name='', headers=None, version_id=None, generation=None):
def get_def_acl(self, headers=None):
def _set_acl_helper(self, acl_or_str, key_name, headers, query_args, generation, if_generation, if_metageneration, canned=False):
def set_xml_acl(self, acl_str, key_name='', headers=None, version_id=None, query_args='acl', generation=None, if_generation=None, if_metageneration=None):
def set_canned_acl(self, acl_str, key_name='', headers=None, version_id=None, generation=None, if_generation=None, if_metageneration=None):
def set_def_canned_acl(self, acl_str, headers=None):
def set_def_xml_acl(self, acl_str, headers=None):
def get_cors(self, headers=None):
def set_cors(self, cors, headers=None):
def get_storage_class(self):
def set_storage_class(self, storage_class, headers=None):
def add_email_grant(self, permission, email_address, recursive=False, headers=None):
def add_user_grant(self, permission, user_id, recursive=False, headers=None):
def add_group_email_grant(self, permission, email_address, recursive=False, headers=None):
def list_grants(self, headers=None):
def disable_logging(self, headers=None):
def enable_logging(self, target_bucket, target_prefix=None, headers=None):
def get_logging_config_with_xml(self, headers=None):
def get_logging_config(self, headers=None):
def configure_website(self, main_page_suffix=None, error_key=None, headers=None):
def get_website_configuration(self, headers=None):
def get_website_configuration_with_xml(self, headers=None):
def delete_website_configuration(self, headers=None):
def get_versioning_status(self, headers=None):
def configure_versioning(self, enabled, headers=None):
def get_lifecycle_config(self, headers=None):
def configure_lifecycle(self, lifecycle_config, headers=None):
def __init__(self, tracker_file_name=None, num_retries=None):
def _save_tracker_uri_to_file(self):
def _set_tracker_uri(self, uri):
def get_tracker_uri(self):
def get_upload_id(self):
def _query_server_state(self, conn, file_length):
def _query_server_pos(self, conn, file_length):
def _start_new_resumable_upload(self, key, headers=None):
def _upload_file_bytes(self, conn, http_conn, fp, file_length, total_bytes_uploaded, cb, num_cb, headers):
def _attempt_resumable_upload(self, key, fp, file_length, headers, cb, num_cb):
def _check_final_md5(self, key, etag):
def send_file(self, key, fp, headers, cb=None, num_cb=10, hash_algs=None):
def create_bucket(self, bucket_name, headers=None, location=Location.DEFAULT, policy=None, storage_class='STANDARD'):
def get_bucket(self, bucket_name, validate=True, headers=None):
def open_read(self, headers=None, query_args='', override_num_retries=None, response_headers=None):
def get_contents_to_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False, version_id=None, res_download_handler=None, response_headers=None, hash_algs=None):
def compute_hash(self, fp, algorithm, size=None):
def send_file(self, fp, headers=None, cb=None, num_cb=10, query_args=None, chunked_transfer=False, size=None, hash_algs=None):
def add_email_grant(self, permission, email_address):
def add_user_grant(self, permission, user_id):
def add_group_email_grant(self, permission, email_address, headers=None):
def add_group_grant(self, permission, group_id):
def set_contents_from_file(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, res_upload_handler=None, size=None, rewind=False, if_generation=None):
def set_contents_from_filename(self, filename, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, reduced_redundancy=None, res_upload_handler=None, if_generation=None):
def set_contents_from_string(self, s, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None, if_generation=None):
def set_contents_from_stream(self, *args, **kwargs):
def set_acl(self, acl_or_str, headers=None, generation=None, if_generation=None, if_metageneration=None):
def get_acl(self, headers=None, generation=None):
def get_xml_acl(self, headers=None, generation=None):
def set_xml_acl(self, acl_str, headers=None, generation=None, if_generation=None, if_metageneration=None):
def set_canned_acl(self, acl_str, headers=None, generation=None, if_generation=None, if_metageneration=None):
def compose(self, components, content_type=None, headers=None):
def validateParseLevel(self, tag, level):
def startElement(self, name, attrs, connection):
def endElement(self, name, value, connection):
def to_xml(self):
def allocate_connection_on_interconnect(self, bandwidth, connection_name, owner_account, interconnect_id, vlan):
def allocate_private_virtual_interface(self, connection_id, owner_account, new_private_virtual_interface_allocation):
def allocate_public_virtual_interface(self, connection_id, owner_account, new_public_virtual_interface_allocation):
def confirm_connection(self, connection_id):
def confirm_private_virtual_interface(self, virtual_interface_id, virtual_gateway_id):
def confirm_public_virtual_interface(self, virtual_interface_id):
def create_connection(self, location, bandwidth, connection_name):
def create_interconnect(self, interconnect_name, bandwidth, location):
def create_private_virtual_interface(self, connection_id, new_private_virtual_interface):
def create_public_virtual_interface(self, connection_id, new_public_virtual_interface):
def delete_connection(self, connection_id):
def delete_interconnect(self, interconnect_id):
def delete_virtual_interface(self, virtual_interface_id):
def describe_connections(self, connection_id=None):
def describe_connections_on_interconnect(self, interconnect_id):
def describe_interconnects(self, interconnect_id=None):
def describe_locations(self):
def describe_virtual_gateways(self):
def describe_virtual_interfaces(self, connection_id=None, virtual_interface_id=None):
def __init__(self, table_name, schema=None, throughput=None, indexes=None, global_indexes=None, connection=None):
@classmethod DCNL def create(cls, table_name, schema, throughput=None, indexes=None, global_indexes=None, connection=None):
def _introspect_schema(self, raw_schema, raw_attributes=None):
def _introspect_all_indexes(self, raw_indexes, map_indexes_projection):
def _introspect_indexes(self, raw_indexes):
def _introspect_global_indexes(self, raw_global_indexes):
def describe(self):
def update(self, throughput=None, global_indexes=None):
def create_global_secondary_index(self, global_index):
def delete_global_secondary_index(self, global_index_name):
def update_global_secondary_index(self, global_indexes):
def delete(self):
def _encode_keys(self, keys):
def get_item(self, consistent=False, attributes=None, **kwargs):
def has_item(self, **kwargs):
def lookup(self, *args, **kwargs):
def new_item(self, *args):
def put_item(self, data, overwrite=False):
def _put_item(self, item_data, expects=None):
def _update_item(self, key, item_data, expects=None):
def delete_item(self, expected=None, conditional_operator=None, **kwargs):
def get_key_fields(self):
def batch_write(self):
def _build_filters(self, filter_kwargs, using=QUERY_OPERATORS):
def query(self, limit=None, index=None, reverse=False, consistent=False, attributes=None, max_page_size=None, **filter_kwargs):
def query_2(self, limit=None, index=None, reverse=False, consistent=False, attributes=None, max_page_size=None, query_filter=None, conditional_operator=None, **filter_kwargs):
def query_count(self, index=None, consistent=False, conditional_operator=None, query_filter=None, scan_index_forward=True, limit=None, exclusive_start_key=None, **filter_kwargs):
def _query(self, limit=None, index=None, reverse=False, consistent=False, exclusive_start_key=None, select=None, attributes_to_get=None, query_filter=None, conditional_operator=None, **filter_kwargs):
def scan(self, limit=None, segment=None, total_segments=None, max_page_size=None, attributes=None, conditional_operator=None, **filter_kwargs):
def _scan(self, limit=None, exclusive_start_key=None, segment=None, total_segments=None, attributes=None, conditional_operator=None, **filter_kwargs):
def batch_get(self, keys, consistent=False, attributes=None):
def _batch_get(self, keys, consistent=False, attributes=None):
def count(self):
def __init__(self, name, data_type=STRING):
def definition(self):
def schema(self):
def definition(self):
def schema(self):
def schema(self):
def batch_get_item(self, request_items, return_consumed_capacity=None):
def batch_write_item(self, request_items, return_consumed_capacity=None, return_item_collection_metrics=None):
def create_table(self, attribute_definitions, table_name, key_schema, provisioned_throughput, local_secondary_indexes=None, global_secondary_indexes=None):
def delete_item(self, table_name, key, expected=None, conditional_operator=None, return_values=None, return_consumed_capacity=None, return_item_collection_metrics=None, condition_expression=None, expression_attribute_names=None, expression_attribute_values=None):
def delete_table(self, table_name):
def describe_table(self, table_name):
def get_item(self, table_name, key, attributes_to_get=None, consistent_read=None, return_consumed_capacity=None, projection_expression=None, expression_attribute_names=None):
def list_tables(self, exclusive_start_table_name=None, limit=None):
def put_item(self, table_name, item, expected=None, return_values=None, return_consumed_capacity=None, return_item_collection_metrics=None, conditional_operator=None, condition_expression=None, expression_attribute_names=None, expression_attribute_values=None):
def query(self, table_name, key_conditions, index_name=None, select=None, attributes_to_get=None, limit=None, consistent_read=None, query_filter=None, conditional_operator=None, scan_index_forward=None, exclusive_start_key=None, return_consumed_capacity=None, projection_expression=None, filter_expression=None, expression_attribute_names=None, expression_attribute_values=None):
def scan(self, table_name, attributes_to_get=None, limit=None, select=None, scan_filter=None, conditional_operator=None, exclusive_start_key=None, return_consumed_capacity=None, total_segments=None, segment=None, projection_expression=None, filter_expression=None, expression_attribute_names=None, expression_attribute_values=None):
def update_item(self, table_name, key, attribute_updates=None, expected=None, conditional_operator=None, return_values=None, return_consumed_capacity=None, return_item_collection_metrics=None, update_expression=None, condition_expression=None, expression_attribute_names=None, expression_attribute_values=None):
def update_table(self, table_name, provisioned_throughput=None, global_secondary_index_updates=None, attribute_definitions=None):
def __init__(self, table, data=None, loaded=False):
def _determine_alterations(self):
def needs_save(self, data=None):
def mark_clean(self):
def mark_dirty(self):
def load(self, data):
def get_keys(self):
def get_raw_keys(self):
def build_expects(self, fields=None):
def prepare_full(self):
def prepare_partial(self):
def partial_save(self):
def save(self, overwrite=False):
def delete(self):
def _reset(self):
def to_call(self, the_callable, *args, **kwargs):
def fetch_more(self):
def authorize_cluster_security_group_ingress(self, cluster_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_owner_id=None):
def authorize_snapshot_access(self, snapshot_identifier, account_with_restore_access, snapshot_cluster_identifier=None):
def copy_cluster_snapshot(self, source_snapshot_identifier, target_snapshot_identifier, source_snapshot_cluster_identifier=None):
def create_cluster(self, cluster_identifier, node_type, master_username, master_user_password, db_name=None, cluster_type=None, cluster_security_groups=None, vpc_security_group_ids=None, cluster_subnet_group_name=None, availability_zone=None, preferred_maintenance_window=None, cluster_parameter_group_name=None, automated_snapshot_retention_period=None, port=None, cluster_version=None, allow_version_upgrade=None, number_of_nodes=None, publicly_accessible=None, encrypted=None, hsm_client_certificate_identifier=None, hsm_configuration_identifier=None, elastic_ip=None):
def create_cluster_parameter_group(self, parameter_group_name, parameter_group_family, description):
def create_cluster_security_group(self, cluster_security_group_name, description):
def create_cluster_snapshot(self, snapshot_identifier, cluster_identifier):
def create_cluster_subnet_group(self, cluster_subnet_group_name, description, subnet_ids):
def create_event_subscription(self, subscription_name, sns_topic_arn, source_type=None, source_ids=None, event_categories=None, severity=None, enabled=None):
def create_hsm_client_certificate(self, hsm_client_certificate_identifier):
def create_hsm_configuration(self, hsm_configuration_identifier, description, hsm_ip_address, hsm_partition_name, hsm_partition_password, hsm_server_public_certificate):
def delete_cluster(self, cluster_identifier, skip_final_cluster_snapshot=None, final_cluster_snapshot_identifier=None):
def delete_cluster_parameter_group(self, parameter_group_name):
def delete_cluster_security_group(self, cluster_security_group_name):
def delete_cluster_snapshot(self, snapshot_identifier, snapshot_cluster_identifier=None):
def delete_cluster_subnet_group(self, cluster_subnet_group_name):
def delete_event_subscription(self, subscription_name):
def delete_hsm_client_certificate(self, hsm_client_certificate_identifier):
def delete_hsm_configuration(self, hsm_configuration_identifier):
def describe_cluster_parameter_groups(self, parameter_group_name=None, max_records=None, marker=None):
def describe_cluster_parameters(self, parameter_group_name, source=None, max_records=None, marker=None):
def describe_cluster_security_groups(self, cluster_security_group_name=None, max_records=None, marker=None):
def describe_cluster_snapshots(self, cluster_identifier=None, snapshot_identifier=None, snapshot_type=None, start_time=None, end_time=None, max_records=None, marker=None, owner_account=None):
def describe_cluster_subnet_groups(self, cluster_subnet_group_name=None, max_records=None, marker=None):
def describe_cluster_versions(self, cluster_version=None, cluster_parameter_group_family=None, max_records=None, marker=None):
def describe_clusters(self, cluster_identifier=None, max_records=None, marker=None):
def describe_default_cluster_parameters(self, parameter_group_family, max_records=None, marker=None):
def describe_event_categories(self, source_type=None):
def describe_event_subscriptions(self, subscription_name=None, max_records=None, marker=None):
def describe_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, duration=None, max_records=None, marker=None):
def describe_hsm_client_certificates(self, hsm_client_certificate_identifier=None, max_records=None, marker=None):
def describe_hsm_configurations(self, hsm_configuration_identifier=None, max_records=None, marker=None):
def describe_logging_status(self, cluster_identifier):
def describe_orderable_cluster_options(self, cluster_version=None, node_type=None, max_records=None, marker=None):
def describe_reserved_node_offerings(self, reserved_node_offering_id=None, max_records=None, marker=None):
def describe_reserved_nodes(self, reserved_node_id=None, max_records=None, marker=None):
def describe_resize(self, cluster_identifier):
def disable_logging(self, cluster_identifier):
def disable_snapshot_copy(self, cluster_identifier):
def enable_logging(self, cluster_identifier, bucket_name, s3_key_prefix=None):
def enable_snapshot_copy(self, cluster_identifier, destination_region, retention_period=None):
def modify_cluster(self, cluster_identifier, cluster_type=None, node_type=None, number_of_nodes=None, cluster_security_groups=None, vpc_security_group_ids=None, master_user_password=None, cluster_parameter_group_name=None, automated_snapshot_retention_period=None, preferred_maintenance_window=None, cluster_version=None, allow_version_upgrade=None, hsm_client_certificate_identifier=None, hsm_configuration_identifier=None, new_cluster_identifier=None):
def modify_cluster_parameter_group(self, parameter_group_name, parameters):
def modify_cluster_subnet_group(self, cluster_subnet_group_name, subnet_ids, description=None):
def modify_event_subscription(self, subscription_name, sns_topic_arn=None, source_type=None, source_ids=None, event_categories=None, severity=None, enabled=None):
def modify_snapshot_copy_retention_period(self, cluster_identifier, retention_period):
def purchase_reserved_node_offering(self, reserved_node_offering_id, node_count=None):
def reboot_cluster(self, cluster_identifier):
def reset_cluster_parameter_group(self, parameter_group_name, reset_all_parameters=None, parameters=None):
def restore_from_cluster_snapshot(self, cluster_identifier, snapshot_identifier, snapshot_cluster_identifier=None, port=None, availability_zone=None, allow_version_upgrade=None, cluster_subnet_group_name=None, publicly_accessible=None, owner_account=None, hsm_client_certificate_identifier=None, hsm_configuration_identifier=None, elastic_ip=None, cluster_parameter_group_name=None, cluster_security_groups=None, vpc_security_group_ids=None, preferred_maintenance_window=None, automated_snapshot_retention_period=None):
def revoke_cluster_security_group_ingress(self, cluster_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_owner_id=None):
def revoke_snapshot_access(self, snapshot_identifier, account_with_restore_access, snapshot_cluster_identifier=None):
def rotate_encryption_key(self, cluster_identifier):
def create_log_group(self, log_group_name):
def create_log_stream(self, log_group_name, log_stream_name):
def delete_log_group(self, log_group_name):
def delete_log_stream(self, log_group_name, log_stream_name):
def delete_metric_filter(self, log_group_name, filter_name):
def delete_retention_policy(self, log_group_name):
def describe_log_groups(self, log_group_name_prefix=None, next_token=None, limit=None):
def describe_log_streams(self, log_group_name, log_stream_name_prefix=None, next_token=None, limit=None):
def describe_metric_filters(self, log_group_name, filter_name_prefix=None, next_token=None, limit=None):
def get_log_events(self, log_group_name, log_stream_name, start_time=None, end_time=None, next_token=None, limit=None, start_from_head=None):
def put_log_events(self, log_group_name, log_stream_name, log_events, sequence_token=None):
def put_metric_filter(self, log_group_name, filter_name, filter_pattern, metric_transformations):
def put_retention_policy(self, log_group_name, retention_in_days):
def set_retention(self, log_group_name, retention_in_days):
def test_metric_filter(self, filter_pattern, log_event_messages):
def create_cluster(self, cluster_name=None):
def delete_cluster(self, cluster):
def deregister_container_instance(self, container_instance, cluster=None, force=None):
def deregister_task_definition(self, task_definition):
def describe_clusters(self, clusters=None):
def describe_container_instances(self, container_instances, cluster=None):
def describe_task_definition(self, task_definition):
def describe_tasks(self, tasks, cluster=None):
def discover_poll_endpoint(self, container_instance=None):
def list_clusters(self, next_token=None, max_results=None):
def list_container_instances(self, cluster=None, next_token=None, max_results=None):
def list_task_definitions(self, family_prefix=None, next_token=None, max_results=None):
def list_tasks(self, cluster=None, container_instance=None, family=None, next_token=None, max_results=None):
def register_container_instance(self, cluster=None, instance_identity_document=None, instance_identity_document_signature=None, total_resources=None):
def register_task_definition(self, family, container_definitions):
def run_task(self, task_definition, cluster=None, overrides=None, count=None):
def start_task(self, task_definition, container_instances, cluster=None, overrides=None):
def stop_task(self, task, cluster=None):
def submit_container_state_change(self, cluster=None, task=None, container_name=None, status=None, exit_code=None, reason=None, network_bindings=None):
def submit_task_state_change(self, cluster=None, task=None, status=None, reason=None):
def __init__(self, mailhost, username, password, fromaddr, toaddrs, subject):
def emit(self, record):
def __init__(self, str=None, hashfunc=None):
def create_trail(self, name, s3_bucket_name, s3_key_prefix=None, sns_topic_name=None, include_global_service_events=None, cloud_watch_logs_log_group_arn=None, cloud_watch_logs_role_arn=None):
def delete_trail(self, name):
def describe_trails(self, trail_name_list=None):
def get_trail_status(self, name):
def lookup_events(self, lookup_attributes=None, start_time=None, end_time=None, max_results=None, next_token=None):
def start_logging(self, name):
def stop_logging(self, name):
def update_trail(self, name, s3_bucket_name=None, s3_key_prefix=None, sns_topic_name=None, include_global_service_events=None, cloud_watch_logs_log_group_arn=None, cloud_watch_logs_role_arn=None):
@classmethod DCNL def _normalize_request_dict(cls, data):
def json_request(self, action, data, object_hook=None):
def make_request(self, action, body='', object_hook=None):
def poll_for_activity_task(self, domain, task_list, identity=None):
def respond_activity_task_completed(self, task_token, result=None):
def respond_activity_task_failed(self, task_token, details=None, reason=None):
def respond_activity_task_canceled(self, task_token, details=None):
def record_activity_task_heartbeat(self, task_token, details=None):
def poll_for_decision_task(self, domain, task_list, identity=None, maximum_page_size=None, next_page_token=None, reverse_order=None):
def respond_decision_task_completed(self, task_token, decisions=None, execution_context=None):
def request_cancel_workflow_execution(self, domain, workflow_id, run_id=None):
def start_workflow_execution(self, domain, workflow_id, workflow_name, workflow_version, task_list=None, child_policy=None, execution_start_to_close_timeout=None, input=None, tag_list=None, task_start_to_close_timeout=None):
def signal_workflow_execution(self, domain, signal_name, workflow_id, input=None, run_id=None):
def terminate_workflow_execution(self, domain, workflow_id, child_policy=None, details=None, reason=None, run_id=None):
def register_activity_type(self, domain, name, version, task_list=None, default_task_heartbeat_timeout=None, default_task_schedule_to_close_timeout=None, default_task_schedule_to_start_timeout=None, default_task_start_to_close_timeout=None, description=None):
def deprecate_activity_type(self, domain, activity_name, activity_version):
def register_workflow_type(self, domain, name, version, task_list=None, default_child_policy=None, default_execution_start_to_close_timeout=None, default_task_start_to_close_timeout=None, description=None):
def deprecate_workflow_type(self, domain, workflow_name, workflow_version):
def register_domain(self, name, workflow_execution_retention_period_in_days, description=None):
def deprecate_domain(self, name):
def list_activity_types(self, domain, registration_status, name=None, maximum_page_size=None, next_page_token=None, reverse_order=None):
def describe_activity_type(self, domain, activity_name, activity_version):
def list_workflow_types(self, domain, registration_status, maximum_page_size=None, name=None, next_page_token=None, reverse_order=None):
def describe_workflow_type(self, domain, workflow_name, workflow_version):
def describe_workflow_execution(self, domain, run_id, workflow_id):
def get_workflow_execution_history(self, domain, run_id, workflow_id, maximum_page_size=None, next_page_token=None, reverse_order=None):
def count_open_workflow_executions(self, domain, latest_date, oldest_date, tag=None, workflow_id=None, workflow_name=None, workflow_version=None):
def list_open_workflow_executions(self, domain, oldest_date, latest_date=None, tag=None, workflow_id=None, workflow_name=None, workflow_version=None, maximum_page_size=None, next_page_token=None, reverse_order=None):
def count_closed_workflow_executions(self, domain, start_latest_date=None, start_oldest_date=None, close_latest_date=None, close_oldest_date=None, close_status=None, tag=None, workflow_id=None, workflow_name=None, workflow_version=None):
def list_closed_workflow_executions(self, domain, start_latest_date=None, start_oldest_date=None, close_latest_date=None, close_oldest_date=None, close_status=None, tag=None, workflow_id=None, workflow_name=None, workflow_version=None, maximum_page_size=None, next_page_token=None, reverse_order=None):
def list_domains(self, registration_status, maximum_page_size=None, next_page_token=None, reverse_order=None):
def describe_domain(self, name):
def count_pending_decision_tasks(self, domain, task_list):
def count_pending_activity_tasks(self, domain, task_list):
def schedule_activity_task(self, activity_id, activity_type_name, activity_type_version, task_list=None, control=None, heartbeat_timeout=None, schedule_to_close_timeout=None, schedule_to_start_timeout=None, start_to_close_timeout=None, input=None):
def request_cancel_activity_task(self, activity_id):
def record_marker(self, marker_name, details=None):
def complete_workflow_execution(self, result=None):
def fail_workflow_execution(self, reason=None, details=None):
def cancel_workflow_executions(self, details=None):
def continue_as_new_workflow_execution(self, child_policy=None, execution_start_to_close_timeout=None, input=None, tag_list=None, task_list=None, start_to_close_timeout=None, workflow_type_version=None):
def start_timer(self, start_to_fire_timeout, timer_id, control=None):
def cancel_timer(self, timer_id):
def signal_external_workflow_execution(self, workflow_id, signal_name, run_id=None, control=None, input=None):
def request_cancel_external_workflow_execution(self, workflow_id, control=None, run_id=None):
def start_child_workflow_execution(self, workflow_type_name, workflow_type_version, workflow_id, child_policy=None, control=None, execution_start_to_close_timeout=None, input=None, tag_list=None, task_list=None, task_start_to_close_timeout=None):
@wraps(Layer1.describe_domain) DCNL def describe(self):
@wraps(Layer1.deprecate_domain) DCNL def deprecate(self):
@wraps(Layer1.register_domain) DCNL def register(self):
@wraps(Layer1.list_activity_types) DCNL def activities(self, status='REGISTERED', **kwargs):
@wraps(Layer1.list_workflow_types) DCNL def workflows(self, status='REGISTERED', **kwargs):
def executions(self, closed=False, **kwargs):
@wraps(Layer1.count_pending_activity_tasks) DCNL def count_pending_activity_tasks(self, task_list):
@wraps(Layer1.count_pending_decision_tasks) DCNL def count_pending_decision_tasks(self, task_list):
def run(self):
@wraps(Layer1.respond_activity_task_canceled) DCNL def cancel(self, task_token=None, details=None):
@wraps(Layer1.respond_activity_task_completed) DCNL def complete(self, task_token=None, result=None):
@wraps(Layer1.respond_activity_task_failed) DCNL def fail(self, task_token=None, details=None, reason=None):
@wraps(Layer1.record_activity_task_heartbeat) DCNL def heartbeat(self, task_token=None, details=None):
@wraps(Layer1.poll_for_activity_task) DCNL def poll(self, **kwargs):
@wraps(Layer1.respond_decision_task_completed) DCNL def complete(self, task_token=None, decisions=None, **kwargs):
@wraps(Layer1.poll_for_decision_task) DCNL def poll(self, **kwargs):
@wraps(Layer1.describe_workflow_type) DCNL def describe(self):
@wraps(Layer1.register_workflow_type) DCNL def register(self, **kwargs):
@wraps(Layer1.deprecate_workflow_type) DCNL def deprecate(self):
@wraps(Layer1.start_workflow_execution) DCNL def start(self, **kwargs):
@wraps(Layer1.signal_workflow_execution) DCNL def signal(self, signame, **kwargs):
@wraps(Layer1.terminate_workflow_execution) DCNL def terminate(self, **kwargs):
@wraps(Layer1.get_workflow_execution_history) DCNL def history(self, **kwargs):
@wraps(Layer1.describe_workflow_execution) DCNL def describe(self):
@wraps(Layer1.request_cancel_workflow_execution) DCNL def request_cancel(self):
@wraps(Layer1.deprecate_activity_type) DCNL def deprecate(self):
@wraps(Layer1.describe_activity_type) DCNL def describe(self):
@wraps(Layer1.register_activity_type) DCNL def register(self, **kwargs):
@classmethod DCNL def Inventory(cls):
def set_config(self, config):
def attach_volume(self, volume, device='/dev/sdp'):
def detach_volume(self, volume):
def add_source_identifier_to_subscription(self, subscription_name, source_identifier):
def add_tags_to_resource(self, resource_name, tags):
def authorize_db_security_group_ingress(self, db_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_id=None, ec2_security_group_owner_id=None):
def copy_db_snapshot(self, source_db_snapshot_identifier, target_db_snapshot_identifier, tags=None):
def create_db_instance(self, db_instance_identifier, allocated_storage, db_instance_class, engine, master_username, master_user_password, db_name=None, db_security_groups=None, vpc_security_group_ids=None, availability_zone=None, db_subnet_group_name=None, preferred_maintenance_window=None, db_parameter_group_name=None, backup_retention_period=None, preferred_backup_window=None, port=None, multi_az=None, engine_version=None, auto_minor_version_upgrade=None, license_model=None, iops=None, option_group_name=None, character_set_name=None, publicly_accessible=None, tags=None):
def create_db_instance_read_replica(self, db_instance_identifier, source_db_instance_identifier, db_instance_class=None, availability_zone=None, port=None, auto_minor_version_upgrade=None, iops=None, option_group_name=None, publicly_accessible=None, tags=None):
def create_db_parameter_group(self, db_parameter_group_name, db_parameter_group_family, description, tags=None):
def create_db_security_group(self, db_security_group_name, db_security_group_description, tags=None):
def create_db_snapshot(self, db_snapshot_identifier, db_instance_identifier, tags=None):
def create_db_subnet_group(self, db_subnet_group_name, db_subnet_group_description, subnet_ids, tags=None):
def create_event_subscription(self, subscription_name, sns_topic_arn, source_type=None, event_categories=None, source_ids=None, enabled=None, tags=None):
def create_option_group(self, option_group_name, engine_name, major_engine_version, option_group_description, tags=None):
def delete_db_instance(self, db_instance_identifier, skip_final_snapshot=None, final_db_snapshot_identifier=None):
def delete_db_parameter_group(self, db_parameter_group_name):
def delete_db_security_group(self, db_security_group_name):
def delete_db_snapshot(self, db_snapshot_identifier):
def delete_db_subnet_group(self, db_subnet_group_name):
def delete_event_subscription(self, subscription_name):
def delete_option_group(self, option_group_name):
def describe_db_engine_versions(self, engine=None, engine_version=None, db_parameter_group_family=None, max_records=None, marker=None, default_only=None, list_supported_character_sets=None):
def describe_db_instances(self, db_instance_identifier=None, filters=None, max_records=None, marker=None):
def describe_db_log_files(self, db_instance_identifier, filename_contains=None, file_last_written=None, file_size=None, max_records=None, marker=None):
def describe_db_parameter_groups(self, db_parameter_group_name=None, filters=None, max_records=None, marker=None):
def describe_db_parameters(self, db_parameter_group_name, source=None, max_records=None, marker=None):
def describe_db_security_groups(self, db_security_group_name=None, filters=None, max_records=None, marker=None):
def describe_db_snapshots(self, db_instance_identifier=None, db_snapshot_identifier=None, snapshot_type=None, filters=None, max_records=None, marker=None):
def describe_db_subnet_groups(self, db_subnet_group_name=None, filters=None, max_records=None, marker=None):
def describe_engine_default_parameters(self, db_parameter_group_family, max_records=None, marker=None):
def describe_event_categories(self, source_type=None):
def describe_event_subscriptions(self, subscription_name=None, filters=None, max_records=None, marker=None):
def describe_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, duration=None, event_categories=None, max_records=None, marker=None):
def describe_option_group_options(self, engine_name, major_engine_version=None, max_records=None, marker=None):
def describe_option_groups(self, option_group_name=None, filters=None, marker=None, max_records=None, engine_name=None, major_engine_version=None):
def describe_orderable_db_instance_options(self, engine, engine_version=None, db_instance_class=None, license_model=None, vpc=None, max_records=None, marker=None):
def describe_reserved_db_instances(self, reserved_db_instance_id=None, reserved_db_instances_offering_id=None, db_instance_class=None, duration=None, product_description=None, offering_type=None, multi_az=None, filters=None, max_records=None, marker=None):
def describe_reserved_db_instances_offerings(self, reserved_db_instances_offering_id=None, db_instance_class=None, duration=None, product_description=None, offering_type=None, multi_az=None, max_records=None, marker=None):
def download_db_log_file_portion(self, db_instance_identifier, log_file_name, marker=None, number_of_lines=None):
def list_tags_for_resource(self, resource_name):
def modify_db_instance(self, db_instance_identifier, allocated_storage=None, db_instance_class=None, db_security_groups=None, vpc_security_group_ids=None, apply_immediately=None, master_user_password=None, db_parameter_group_name=None, backup_retention_period=None, preferred_backup_window=None, preferred_maintenance_window=None, multi_az=None, engine_version=None, allow_major_version_upgrade=None, auto_minor_version_upgrade=None, iops=None, option_group_name=None, new_db_instance_identifier=None):
def modify_db_parameter_group(self, db_parameter_group_name, parameters):
def modify_db_subnet_group(self, db_subnet_group_name, subnet_ids, db_subnet_group_description=None):
def modify_event_subscription(self, subscription_name, sns_topic_arn=None, source_type=None, event_categories=None, enabled=None):
def modify_option_group(self, option_group_name, options_to_include=None, options_to_remove=None, apply_immediately=None):
def promote_read_replica(self, db_instance_identifier, backup_retention_period=None, preferred_backup_window=None):
def purchase_reserved_db_instances_offering(self, reserved_db_instances_offering_id, reserved_db_instance_id=None, db_instance_count=None, tags=None):
def reboot_db_instance(self, db_instance_identifier, force_failover=None):
def remove_source_identifier_from_subscription(self, subscription_name, source_identifier):
def remove_tags_from_resource(self, resource_name, tag_keys):
def reset_db_parameter_group(self, db_parameter_group_name, reset_all_parameters=None, parameters=None):
def restore_db_instance_from_db_snapshot(self, db_instance_identifier, db_snapshot_identifier, db_instance_class=None, port=None, availability_zone=None, db_subnet_group_name=None, multi_az=None, publicly_accessible=None, auto_minor_version_upgrade=None, license_model=None, db_name=None, engine=None, iops=None, option_group_name=None, tags=None):
def restore_db_instance_to_point_in_time(self, source_db_instance_identifier, target_db_instance_identifier, restore_time=None, use_latest_restorable_time=None, db_instance_class=None, port=None, availability_zone=None, db_subnet_group_name=None, multi_az=None, publicly_accessible=None, auto_minor_version_upgrade=None, license_model=None, db_name=None, engine=None, iops=None, option_group_name=None, tags=None):
def revoke_db_security_group_ingress(self, db_security_group_name, cidrip=None, ec2_security_group_name=None, ec2_security_group_id=None, ec2_security_group_owner_id=None):
def put_attributes(self, item_name, attributes, replace=True, expected_value=None):
def batch_put_attributes(self, items, replace=True):
def get_attributes(self, item_name, attribute_name=None, consistent_read=False, item=None):
def delete_attributes(self, item_name, attributes=None, expected_values=None):
def batch_delete_attributes(self, items):
def select(self, query='', next_token=None, consistent_read=False, max_items=None):
def get_item(self, item_name, consistent_read=False):
def to_xml(self, f=None):
def from_xml(self, doc):
def delete(self):
def __init__(self, sequence_string, rollover=False):
def __call__(self, val, last=None):
def _inc(self, val):
def __init__(self, id=None, domain_name=None, fnc=increment_by_one, init_val=None):
def set(self, val):
def get(self):
def _connect(self):
def delete(self):
def fetch(self, limit, offset=0):
def put(self, expected_value=None):
def put_attributes(self, attrs):
def delete_attributes(self, attrs):
@classmethod DCNL def find_subclass(cls, name):
def __init__(self, verbose_name=None, name=None, default='', required=False, validator=None, choices=None, unique=False, hashfunc=None):
def __set__(self, obj, value):
def __get__(self, model_instance, model_class):
def __set__(self, model_instance, value):
def __set__(self, obj, value):
def __set__(self, obj, value):
def _make_request(self, method, url, post_data=None, body=None):
def get_props_from_doc(self, cls, id, doc):
def save_object(self, obj, expected_value=None):
def unmarshal_props(self, fp, cls=None, id=None):
def decode_map_element(self, item_type, value):
def encode_float(self, value):
def decode_datetime(self, value):
def decode_time(self, value):
def encode_string(self, value):
def decode_string(self, value):
def count(self, cls, filters, quick=True, sort_by=None, select=None):
def _build_filter_part(self, cls, filters, order_by=None, select=None):
def _get_all_decendents(self, cls):
def __init__(self, domain, name='', active=False):
def load(self):
def save(self, replace=True):
def add_value(self, key, value):
def delete(self):
def __init__(self, name, domain_name, item_names):
def run(self):
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', converter=None, security_token=None, validate_certs=True, profile_name=None):
def set_item_cls(self, cls):
def get_usage(self):
def print_usage(self):
def get_domain(self, domain_name, validate=True):
def lookup(self, domain_name, validate=True):
def get_all_domains(self, max_domains=None, next_token=None):
def create_domain(self, domain_name):
def get_domain_and_name(self, domain_or_name):
def delete_domain(self, domain_or_name):
def domain_metadata(self, domain_or_name):
def put_attributes(self, domain_or_name, item_name, attributes, replace=True, expected_value=None):
def batch_put_attributes(self, domain_or_name, items, replace=True):
def get_attributes(self, domain_or_name, item_name, attribute_names=None, consistent_read=False, item=None):
def delete_attributes(self, domain_or_name, item_name, attr_names=None, expected_value=None):
def batch_delete_attributes(self, domain_or_name, items):
def select(self, domain_or_name, query='', next_token=None, consistent_read=False):
def __init__(self, host, cert, reason):
def __init__(self, host, port=default_port, key_file=None, cert_file=None, ca_certs=None, strict=None, **kwargs):
def connect(self):
def _post_request(self, request, params, parser, body='', headers=None):
def method_for(self, name):
def iter_call(self, call, *args, **kw):
def iter_response(self, response):
@requires(['FeedType']) DCNL @boolean_arguments('PurgeAndReplace') DCNL @http_body('FeedContent') DCNL @structured_lists('MarketplaceIdList.Id') DCNL @api_action('Feeds', 15, 120) DCNL def submit_feed(self, request, response, headers=None, body='', **kw):
@structured_lists('FeedSubmissionIdList.Id', 'FeedTypeList.Type', 'FeedProcessingStatusList.Status') DCNL @api_action('Feeds', 10, 45) DCNL def get_feed_submission_list(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Feeds', 0, 0) DCNL def get_feed_submission_list_by_next_token(self, request, response, **kw):
@structured_lists('FeedTypeList.Type', 'FeedProcessingStatusList.Status') DCNL @api_action('Feeds', 10, 45) DCNL def get_feed_submission_count(self, request, response, **kw):
@structured_lists('FeedSubmissionIdList.Id', 'FeedTypeList.Type') DCNL @api_action('Feeds', 10, 45) DCNL def cancel_feed_submissions(self, request, response, **kw):
@requires(['FeedSubmissionId']) DCNL @api_action('Feeds', 15, 60) DCNL def get_feed_submission_result(self, request, response, **kw):
def get_service_status(self, **kw):
@requires(['ReportType']) DCNL @structured_lists('MarketplaceIdList.Id') DCNL @boolean_arguments('ReportOptions=ShowSalesChannel') DCNL @api_action('Reports', 15, 60) DCNL def request_report(self, request, response, **kw):
@structured_lists('ReportRequestIdList.Id', 'ReportTypeList.Type', 'ReportProcessingStatusList.Status') DCNL @api_action('Reports', 10, 45) DCNL def get_report_request_list(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Reports', 0, 0) DCNL def get_report_request_list_by_next_token(self, request, response, **kw):
@structured_lists('ReportTypeList.Type', 'ReportProcessingStatusList.Status') DCNL @api_action('Reports', 10, 45) DCNL def get_report_request_count(self, request, response, **kw):
@api_action('Reports', 10, 45) DCNL def cancel_report_requests(self, request, response, **kw):
@boolean_arguments('Acknowledged') DCNL @structured_lists('ReportRequestIdList.Id', 'ReportTypeList.Type') DCNL @api_action('Reports', 10, 60) DCNL def get_report_list(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Reports', 0, 0) DCNL def get_report_list_by_next_token(self, request, response, **kw):
@boolean_arguments('Acknowledged') DCNL @structured_lists('ReportTypeList.Type') DCNL @api_action('Reports', 10, 45) DCNL def get_report_count(self, request, response, **kw):
@requires(['ReportId']) DCNL @api_action('Reports', 15, 60) DCNL def get_report(self, request, response, **kw):
@requires(['ReportType', 'Schedule']) DCNL @api_action('Reports', 10, 45) DCNL def manage_report_schedule(self, request, response, **kw):
@structured_lists('ReportTypeList.Type') DCNL @api_action('Reports', 10, 45) DCNL def get_report_schedule_list(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Reports', 0, 0) DCNL def get_report_schedule_list_by_next_token(self, request, response, **kw):
@structured_lists('ReportTypeList.Type') DCNL @api_action('Reports', 10, 45) DCNL def get_report_schedule_count(self, request, response, **kw):
@requires(['ReportIdList']) DCNL @boolean_arguments('Acknowledged') DCNL @structured_lists('ReportIdList.Id') DCNL @api_action('Reports', 10, 45) DCNL def update_report_acknowledgements(self, request, response, **kw):
@requires(['ShipFromAddress', 'InboundShipmentPlanRequestItems']) DCNL @structured_objects('ShipFromAddress', 'InboundShipmentPlanRequestItems') DCNL @api_action('Inbound', 30, 0.5) DCNL def create_inbound_shipment_plan(self, request, response, **kw):
@requires(['ShipmentId', 'InboundShipmentHeader', 'InboundShipmentItems']) DCNL @structured_objects('InboundShipmentHeader', 'InboundShipmentItems') DCNL @api_action('Inbound', 30, 0.5) DCNL def create_inbound_shipment(self, request, response, **kw):
@requires(['ShipmentId']) DCNL @structured_objects('InboundShipmentHeader', 'InboundShipmentItems') DCNL @api_action('Inbound', 30, 0.5) DCNL def update_inbound_shipment(self, request, response, **kw):
@requires_some_of('ShipmentIdList', 'ShipmentStatusList') DCNL @structured_lists('ShipmentIdList.Id', 'ShipmentStatusList.Status') DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipments(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipments_by_next_token(self, request, response, **kw):
@requires(['ShipmentId'], ['LastUpdatedAfter', 'LastUpdatedBefore']) DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipment_items(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Inbound', 30, 0.5) DCNL def list_inbound_shipment_items_by_next_token(self, request, response, **kw):
@api_action('Inbound', 2, 300, 'GetServiceStatus') DCNL def get_inbound_service_status(self, request, response, **kw):
@requires(['SellerSkus'], ['QueryStartDateTime']) DCNL @structured_lists('SellerSkus.member') DCNL @api_action('Inventory', 30, 0.5) DCNL def list_inventory_supply(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Inventory', 30, 0.5) DCNL def list_inventory_supply_by_next_token(self, request, response, **kw):
@api_action('Inventory', 2, 300, 'GetServiceStatus') DCNL def get_inventory_service_status(self, request, response, **kw):
@requires(['PackageNumber']) DCNL @api_action('Outbound', 30, 0.5) DCNL def get_package_tracking_details(self, request, response, **kw):
@requires(['Address', 'Items']) DCNL @structured_objects('Address', 'Items') DCNL @api_action('Outbound', 30, 0.5) DCNL def get_fulfillment_preview(self, request, response, **kw):
@requires(['SellerFulfillmentOrderId', 'DisplayableOrderId', 'ShippingSpeedCategory', 'DisplayableOrderDateTime', 'DestinationAddress', 'DisplayableOrderComment', 'Items']) DCNL @structured_objects('DestinationAddress', 'Items') DCNL @api_action('Outbound', 30, 0.5) DCNL def create_fulfillment_order(self, request, response, **kw):
@requires(['SellerFulfillmentOrderId']) DCNL @api_action('Outbound', 30, 0.5) DCNL def get_fulfillment_order(self, request, response, **kw):
@api_action('Outbound', 30, 0.5) DCNL def list_all_fulfillment_orders(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Outbound', 30, 0.5) DCNL def list_all_fulfillment_orders_by_next_token(self, request, response, **kw):
@requires(['SellerFulfillmentOrderId']) DCNL @api_action('Outbound', 30, 0.5) DCNL def cancel_fulfillment_order(self, request, response, **kw):
@api_action('Outbound', 2, 300, 'GetServiceStatus') DCNL def get_outbound_service_status(self, request, response, **kw):
@requires(['CreatedAfter'], ['LastUpdatedAfter']) DCNL @requires(['MarketplaceId']) DCNL @exclusive(['CreatedAfter'], ['LastUpdatedAfter']) DCNL @dependent('CreatedBefore', ['CreatedAfter']) DCNL @exclusive(['LastUpdatedAfter'], ['BuyerEmail'], ['SellerOrderId']) DCNL @dependent('LastUpdatedBefore', ['LastUpdatedAfter']) DCNL @exclusive(['CreatedAfter'], ['LastUpdatedBefore']) DCNL @structured_objects('OrderTotal', 'ShippingAddress', 'PaymentExecutionDetail') DCNL @structured_lists('MarketplaceId.Id', 'OrderStatus.Status', 'FulfillmentChannel.Channel', 'PaymentMethod.') DCNL @api_action('Orders', 6, 60) DCNL def list_orders(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Orders', 6, 60) DCNL def list_orders_by_next_token(self, request, response, **kw):
@requires(['AmazonOrderId']) DCNL @structured_lists('AmazonOrderId.Id') DCNL @api_action('Orders', 6, 60) DCNL def get_order(self, request, response, **kw):
@requires(['AmazonOrderId']) DCNL @api_action('Orders', 30, 2) DCNL def list_order_items(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Orders', 30, 2) DCNL def list_order_items_by_next_token(self, request, response, **kw):
@api_action('Orders', 2, 300, 'GetServiceStatus') DCNL def get_orders_service_status(self, request, response, **kw):
@requires(['MarketplaceId', 'Query']) DCNL @api_action('Products', 20, 20) DCNL def list_matching_products(self, request, response, **kw):
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 20) DCNL def get_matching_product(self, request, response, **kw):
@requires(['MarketplaceId', 'IdType', 'IdList']) DCNL @structured_lists('IdList.Id') DCNL @api_action('Products', 20, 20) DCNL def get_matching_product_for_id(self, request, response, **kw):
@requires(['MarketplaceId', 'SellerSKUList']) DCNL @structured_lists('SellerSKUList.SellerSKU') DCNL @api_action('Products', 20, 10, 'GetCompetitivePricingForSKU') DCNL def get_competitive_pricing_for_sku(self, request, response, **kw):
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 10, 'GetCompetitivePricingForASIN') DCNL def get_competitive_pricing_for_asin(self, request, response, **kw):
@requires(['MarketplaceId', 'SellerSKUList']) DCNL @structured_lists('SellerSKUList.SellerSKU') DCNL @api_action('Products', 20, 5, 'GetLowestOfferListingsForSKU') DCNL def get_lowest_offer_listings_for_sku(self, request, response, **kw):
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 5, 'GetLowestOfferListingsForASIN') DCNL def get_lowest_offer_listings_for_asin(self, request, response, **kw):
@requires(['MarketplaceId', 'SellerSKU']) DCNL @api_action('Products', 20, 20, 'GetProductCategoriesForSKU') DCNL def get_product_categories_for_sku(self, request, response, **kw):
@requires(['MarketplaceId', 'ASIN']) DCNL @api_action('Products', 20, 20, 'GetProductCategoriesForASIN') DCNL def get_product_categories_for_asin(self, request, response, **kw):
@api_action('Products', 2, 300, 'GetServiceStatus') DCNL def get_products_service_status(self, request, response, **kw):
@requires(['MarketplaceId', 'SellerSKUList']) DCNL @structured_lists('SellerSKUList.SellerSKU') DCNL @api_action('Products', 20, 10, 'GetMyPriceForSKU') DCNL def get_my_price_for_sku(self, request, response, **kw):
@requires(['MarketplaceId', 'ASINList']) DCNL @structured_lists('ASINList.ASIN') DCNL @api_action('Products', 20, 10, 'GetMyPriceForASIN') DCNL def get_my_price_for_asin(self, request, response, **kw):
@api_action('Sellers', 15, 60) DCNL def list_marketplace_participations(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Sellers', 15, 60) DCNL def list_marketplace_participations_by_next_token(self, request, response, **kw):
@requires(['MarketplaceId']) DCNL @api_action('Recommendations', 5, 2) DCNL def get_last_updated_time_for_recommendations(self, request, response, **kw):
@requires(['MarketplaceId']) DCNL @structured_lists('CategoryQueryList.CategoryQuery') DCNL @api_action('Recommendations', 5, 2) DCNL def list_recommendations(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('Recommendations', 5, 2) DCNL def list_recommendations_by_next_token(self, request, response, **kw):
@api_action('Recommendations', 2, 300, 'GetServiceStatus') DCNL def get_recommendations_service_status(self, request, response, **kw):
@api_action('CustomerInfo', 15, 12) DCNL def list_customers(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('CustomerInfo', 50, 3) DCNL def list_customers_by_next_token(self, request, response, **kw):
@requires(['CustomerIdList']) DCNL @structured_lists('CustomerIdList.CustomerId') DCNL @api_action('CustomerInfo', 15, 12) DCNL def get_customers_for_customer_id(self, request, response, **kw):
@api_action('CustomerInfo', 2, 300, 'GetServiceStatus') DCNL def get_customerinfo_service_status(self, request, response, **kw):
@requires(['DateRangeStart']) DCNL @api_action('CartInfo', 15, 12) DCNL def list_carts(self, request, response, **kw):
@requires(['NextToken']) DCNL @api_action('CartInfo', 50, 3) DCNL def list_carts_by_next_token(self, request, response, **kw):
@requires(['CartIdList']) DCNL @structured_lists('CartIdList.CartId') DCNL @api_action('CartInfo', 15, 12) DCNL def get_carts(self, request, response, **kw):
@api_action('CartInfo', 2, 300, 'GetServiceStatus') DCNL def get_cartinfo_service_status(self, request, response, **kw):
@requires(['MarketplaceId', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def register_destination(self, request, response, **kw):
@requires(['MarketplaceId', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def deregister_destination(self, request, response, **kw):
@requires(['MarketplaceId']) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def list_registered_destinations(self, request, response, **kw):
@requires(['MarketplaceId', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def send_test_notification_to_destination(self, request, response, **kw):
@requires(['MarketplaceId', 'Subscription']) DCNL @structured_objects('Subscription', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def create_subscription(self, request, response, **kw):
@requires(['MarketplaceId', 'NotificationType', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def get_subscription(self, request, response, **kw):
@requires(['MarketplaceId', 'NotificationType', 'Destination']) DCNL @structured_objects('Destination', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def delete_subscription(self, request, response, **kw):
@requires(['MarketplaceId']) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def list_subscriptions(self, request, response, **kw):
@requires(['MarketplaceId', 'Subscription']) DCNL @structured_objects('Subscription', members=True) DCNL @api_action('Subscriptions', 25, 0.5) DCNL def update_subscription(self, request, response, **kw):
@api_action('Subscriptions', 2, 300, 'GetServiceStatus') DCNL def get_subscriptions_service_status(self, request, response, **kw):
@requires(['AmazonOrderReferenceId', 'OrderReferenceAttributes']) DCNL @structured_objects('OrderReferenceAttributes') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def set_order_reference_details(self, request, response, **kw):
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_order_reference_details(self, request, response, **kw):
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def confirm_order_reference(self, request, response, **kw):
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def cancel_order_reference(self, request, response, **kw):
@requires(['AmazonOrderReferenceId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def close_order_reference(self, request, response, **kw):
@requires(['AmazonOrderReferenceId', 'AuthorizationReferenceId', 'AuthorizationAmount']) DCNL @structured_objects('AuthorizationAmount') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def authorize(self, request, response, **kw):
@requires(['AmazonAuthorizationId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_authorization_details(self, request, response, **kw):
@requires(['AmazonAuthorizationId', 'CaptureReferenceId', 'CaptureAmount']) DCNL @structured_objects('CaptureAmount') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def capture(self, request, response, **kw):
@requires(['AmazonCaptureId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_capture_details(self, request, response, **kw):
@requires(['AmazonAuthorizationId']) DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def close_authorization(self, request, response, **kw):
@requires(['AmazonCaptureId', 'RefundReferenceId', 'RefundAmount']) DCNL @structured_objects('RefundAmount') DCNL @api_action('OffAmazonPayments', 10, 1) DCNL def refund(self, request, response, **kw):
@requires(['AmazonRefundId']) DCNL @api_action('OffAmazonPayments', 20, 2) DCNL def get_refund_details(self, request, response, **kw):
@api_action('OffAmazonPayments', 2, 300, 'GetServiceStatus') DCNL def get_offamazonpayments_service_status(self, request, response, **kw):
def __init__(self, layer1, data):
def delete(self):
def get_analysis_schemes(self):
def get_availability_options(self):
def get_scaling_options(self):
def get_access_policies(self):
def index_documents(self):
def get_index_fields(self, field_names=None):
def create_index_field(self, field_name, field_type, default='', facet=False, returnable=False, searchable=False, sortable=False, highlight=False, source_field=None, analysis_scheme=None):
def get_expressions(self, names=None):
def create_expression(self, name, value):
def next_page(self):
def to_params(self):
def to_domain_connection_params(self):
def search(self, q=None, parser=None, fq=None, rank=None, return_fields=None, size=10, start=0, facet=None, highlight=None, sort=None, partial=None, options=None):
def __call__(self, query):
def get_all_paged(self, query, per_page):
def get_all_hits(self, query):
def get_num_hits(self, query):
def build_suggesters(self, domain_name):
def create_domain(self, domain_name):
def define_analysis_scheme(self, domain_name, analysis_scheme):
def define_expression(self, domain_name, expression):
def define_index_field(self, domain_name, index_field):
def define_suggester(self, domain_name, suggester):
def delete_analysis_scheme(self, domain_name, analysis_scheme_name):
def delete_domain(self, domain_name):
def delete_expression(self, domain_name, expression_name):
def delete_index_field(self, domain_name, index_field_name):
def delete_suggester(self, domain_name, suggester_name):
def describe_analysis_schemes(self, domain_name, analysis_scheme_names=None, deployed=None):
def describe_availability_options(self, domain_name, deployed=None):
def describe_domains(self, domain_names=None):
def describe_expressions(self, domain_name, expression_names=None, deployed=None):
def describe_index_fields(self, domain_name, field_names=None, deployed=None):
def describe_scaling_parameters(self, domain_name):
def describe_service_access_policies(self, domain_name, deployed=None):
def describe_suggesters(self, domain_name, suggester_names=None, deployed=None):
def index_documents(self, domain_name):
def list_domain_names(self):
def update_availability_options(self, domain_name, multi_az):
def update_scaling_parameters(self, domain_name, scaling_parameters):
def update_service_access_policies(self, domain_name, access_policies):
def build_complex_param(self, params, label, value):
def refresh(self, data=None):
def to_json(self):
def save(self):
def new_statement(self, arn, ip):
def allow_search_ip(self, ip):
def allow_doc_ip(self, ip):
def disallow_search_ip(self, ip):
def disallow_doc_ip(self, ip):
def add(self, _id, fields):
def delete(self, _id):
def get_sdf(self):
def clear_sdf(self):
def add_sdf_from_s3(self, key_obj):
def commit(self):
def _check_num_ops(self, type_, response_num):
def list_domains(self, domain_names=None):
def create_domain(self, domain_name):
def lookup(self, domain_name):
def __init__(self, connection=None):
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', security_token=None, validate_certs=True, profile_name=None):
def get_metric_statistics(self, period, start_time, end_time, metric_name, namespace, statistics, dimensions=None, unit=None):
def list_metrics(self, next_token=None, dimensions=None, metric_name=None, namespace=None):
def put_metric_data(self, namespace, name, value=None, timestamp=None, unit=None, dimensions=None, statistics=None):
def describe_alarms(self, action_prefix=None, alarm_name_prefix=None, alarm_names=None, max_records=None, state_value=None, next_token=None):
def describe_alarm_history(self, alarm_name=None, start_date=None, end_date=None, max_records=None, history_item_type=None, next_token=None):
def describe_alarms_for_metric(self, metric_name, namespace, period=None, statistic=None, dimensions=None, unit=None):
def put_metric_alarm(self, alarm):
def delete_alarms(self, alarms):
def set_alarm_state(self, alarm_name, state_reason, state_value, state_reason_data=None):
def enable_alarm_actions(self, alarm_names):
def disable_alarm_actions(self, alarm_names):
def __init__(self, connection=None):
def __init__(self, connection=None, name=None, metric=None, namespace=None, statistic=None, comparison=None, threshold=None, period=None, evaluation_periods=None, unit=None, description='', dimensions=None, alarm_actions=None, insufficient_data_actions=None, ok_actions=None):
def set_state(self, value, reason, data=None):
def add_alarm_action(self, action_arn=None):
def add_insufficient_data_action(self, action_arn=None):
def add_ok_action(self, action_arn=None):
def query(self, start_time, end_time, statistics, unit=None, period=60):
def create_alarm(self, name, comparison, threshold, period, evaluation_periods, statistic, enabled=True, description=None, dimensions=None, alarm_actions=None, ok_actions=None, insufficient_data_actions=None, unit=None):
def describe_alarms(self, period=None, statistic=None, dimensions=None, unit=None):
def delete(self, dry_run=False):
def save(self, directory_path):
def copy_to_region(self, region, dry_run=False):
def add_tag(self, key, value='', dry_run=False):
def add_tags(self, tags, dry_run=False):
def remove_tag(self, key, value=None, dry_run=False):
def remove_tags(self, tags, dry_run=False):
def __init__(self, connection=None, name=None, launch_config=None, availability_zones=None, load_balancers=None, default_cooldown=None, health_check_type=None, health_check_period=None, placement_group=None, vpc_zone_identifier=None, desired_capacity=None, min_size=None, max_size=None, tags=None, termination_policies=None, instance_id=None, **kwargs):
def set_capacity(self, capacity):
def update(self):
def shutdown_instances(self):
def delete(self, force_delete=False):
def get_activities(self, activity_ids=None, max_records=50):
def put_notification_configuration(self, topic, notification_types):
def delete_notification_configuration(self, topic):
def suspend_processes(self, scaling_processes=None):
def resume_processes(self, scaling_processes=None):
def build_params(self, params, i):
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', security_token=None, validate_certs=True, profile_name=None, use_block_device_types=False):
def build_list_params(self, params, items, label):
def attach_instances(self, name, instance_ids):
def detach_instances(self, name, instance_ids, decrement_capacity=True):
def create_auto_scaling_group(self, as_group):
def delete_auto_scaling_group(self, name, force_delete=False):
def create_launch_configuration(self, launch_config):
def get_account_limits(self):
def create_scaling_policy(self, scaling_policy):
def delete_launch_configuration(self, launch_config_name):
def get_all_groups(self, names=None, max_records=None, next_token=None):
def get_all_launch_configurations(self, **kwargs):
def get_all_activities(self, autoscale_group, activity_ids=None, max_records=None, next_token=None):
def get_termination_policies(self):
def delete_scheduled_action(self, scheduled_action_name, autoscale_group=None):
def terminate_instance(self, instance_id, decrement_capacity=True):
def delete_policy(self, policy_name, autoscale_group=None):
def get_all_autoscaling_instances(self, instance_ids=None, max_records=None, next_token=None):
def get_all_metric_collection_types(self):
def get_all_policies(self, as_group=None, policy_names=None, max_records=None, next_token=None):
def get_all_scaling_process_types(self):
def suspend_processes(self, as_group, scaling_processes=None):
def resume_processes(self, as_group, scaling_processes=None):
def create_scheduled_group_action(self, as_group, name, time=None, desired_capacity=None, min_size=None, max_size=None, start_time=None, end_time=None, recurrence=None):
def disable_metrics_collection(self, as_group, metrics=None):
def enable_metrics_collection(self, as_group, granularity, metrics=None):
def put_notification_configuration(self, autoscale_group, topic, notification_types):
def delete_notification_configuration(self, autoscale_group, topic):
def set_instance_health(self, instance_id, health_status, should_respect_grace_period=True):
def set_desired_capacity(self, group_name, desired_capacity, honor_cooldown=False):
def get_all_tags(self, filters=None, max_records=None, next_token=None):
def create_or_update_tags(self, tags):
def delete_tags(self, tags):
def __init__(self, connection=None, **kwargs):
def __init__(self, connection=None, name=None, image_id=None, key_name=None, security_groups=None, user_data=None, instance_type='m1.small', kernel_id=None, ramdisk_id=None, block_device_mappings=None, instance_monitoring=False, spot_price=None, instance_profile_name=None, ebs_optimized=False, associate_public_ip_address=None, volume_type=None, delete_on_termination=True, iops=None, use_block_device_types=False, classic_link_vpc_id=None, classic_link_vpc_security_groups=None):
def delete(self):
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, host=None, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', api_version=None, security_token=None, validate_certs=True, profile_name=None):
def get_params(self):
def get_all_images(self, image_ids=None, owners=None, executable_by=None, filters=None, dry_run=False):
def get_all_kernels(self, kernel_ids=None, owners=None, dry_run=False):
def get_all_ramdisks(self, ramdisk_ids=None, owners=None, dry_run=False):
def get_image(self, image_id, dry_run=False):
def register_image(self, name=None, description=None, image_location=None, architecture=None, kernel_id=None, ramdisk_id=None, root_device_name=None, block_device_map=None, dry_run=False, virtualization_type=None, sriov_net_support=None, snapshot_id=None, delete_root_volume_on_termination=False):
def deregister_image(self, image_id, delete_snapshot=False, dry_run=False):
def create_image(self, instance_id, name, description=None, no_reboot=False, block_device_mapping=None, dry_run=False):
def get_image_attribute(self, image_id, attribute='launchPermission', dry_run=False):
def modify_image_attribute(self, image_id, attribute='launchPermission', operation='add', user_ids=None, groups=None, product_codes=None, dry_run=False):
def reset_image_attribute(self, image_id, attribute='launchPermission', dry_run=False):
def get_all_instances(self, instance_ids=None, filters=None, dry_run=False, max_results=None):
def get_only_instances(self, instance_ids=None, filters=None, dry_run=False, max_results=None):
def get_all_reservations(self, instance_ids=None, filters=None, dry_run=False, max_results=None, next_token=None):
def get_all_instance_status(self, instance_ids=None, max_results=None, next_token=None, filters=None, dry_run=False, include_all_instances=False):
def run_instances(self, image_id, min_count=1, max_count=1, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, block_device_map=None, disable_api_termination=False, instance_initiated_shutdown_behavior=None, private_ip_address=None, placement_group=None, client_token=None, security_group_ids=None, additional_info=None, instance_profile_name=None, instance_profile_arn=None, tenancy=None, ebs_optimized=False, network_interfaces=None, dry_run=False):
def terminate_instances(self, instance_ids=None, dry_run=False):
def stop_instances(self, instance_ids=None, force=False, dry_run=False):
def start_instances(self, instance_ids=None, dry_run=False):
def get_console_output(self, instance_id, dry_run=False):
def reboot_instances(self, instance_ids=None, dry_run=False):
def confirm_product_instance(self, product_code, instance_id, dry_run=False):
def get_instance_attribute(self, instance_id, attribute, dry_run=False):
def modify_network_interface_attribute(self, interface_id, attr, value, attachment_id=None, dry_run=False):
def modify_instance_attribute(self, instance_id, attribute, value, dry_run=False):
def reset_instance_attribute(self, instance_id, attribute, dry_run=False):
def get_all_spot_instance_requests(self, request_ids=None, filters=None, dry_run=False):
def get_spot_price_history(self, start_time=None, end_time=None, instance_type=None, product_description=None, availability_zone=None, dry_run=False, max_results=None, next_token=None, filters=None):
def request_spot_instances(self, price, image_id, count=1, type='one-time', valid_from=None, valid_until=None, launch_group=None, availability_zone_group=None, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, placement_group=None, block_device_map=None, instance_profile_arn=None, instance_profile_name=None, security_group_ids=None, ebs_optimized=False, network_interfaces=None, dry_run=False):
def cancel_spot_instance_requests(self, request_ids, dry_run=False):
def get_spot_datafeed_subscription(self, dry_run=False):
def create_spot_datafeed_subscription(self, bucket, prefix, dry_run=False):
def delete_spot_datafeed_subscription(self, dry_run=False):
def get_all_zones(self, zones=None, filters=None, dry_run=False):
def get_all_addresses(self, addresses=None, filters=None, allocation_ids=None, dry_run=False):
def allocate_address(self, domain=None, dry_run=False):
def assign_private_ip_addresses(self, network_interface_id=None, private_ip_addresses=None, secondary_private_ip_address_count=None, allow_reassignment=False, dry_run=False):
def associate_address(self, instance_id=None, public_ip=None, allocation_id=None, network_interface_id=None, private_ip_address=None, allow_reassociation=False, dry_run=False):
def associate_address_object(self, instance_id=None, public_ip=None, allocation_id=None, network_interface_id=None, private_ip_address=None, allow_reassociation=False, dry_run=False):
def disassociate_address(self, public_ip=None, association_id=None, dry_run=False):
def release_address(self, public_ip=None, allocation_id=None, dry_run=False):
def unassign_private_ip_addresses(self, network_interface_id=None, private_ip_addresses=None, dry_run=False):
def get_all_volumes(self, volume_ids=None, filters=None, dry_run=False):
def get_all_volume_status(self, volume_ids=None, max_results=None, next_token=None, filters=None, dry_run=False):
def enable_volume_io(self, volume_id, dry_run=False):
def get_volume_attribute(self, volume_id, attribute='autoEnableIO', dry_run=False):
def modify_volume_attribute(self, volume_id, attribute, new_value, dry_run=False):
def create_volume(self, size, zone, snapshot=None, volume_type=None, iops=None, encrypted=False, kms_key_id=None, dry_run=False):
def delete_volume(self, volume_id, dry_run=False):
def attach_volume(self, volume_id, instance_id, device, dry_run=False):
def detach_volume(self, volume_id, instance_id=None, device=None, force=False, dry_run=False):
def get_all_snapshots(self, snapshot_ids=None, owner=None, restorable_by=None, filters=None, dry_run=False):
def create_snapshot(self, volume_id, description=None, dry_run=False):
def delete_snapshot(self, snapshot_id, dry_run=False):
def copy_snapshot(self, source_region, source_snapshot_id, description=None, dry_run=False):
def trim_snapshots(self, hourly_backups=8, daily_backups=7, weekly_backups=4, monthly_backups=True):
def get_snapshot_attribute(self, snapshot_id, attribute='createVolumePermission', dry_run=False):
def modify_snapshot_attribute(self, snapshot_id, attribute='createVolumePermission', operation='add', user_ids=None, groups=None, dry_run=False):
def reset_snapshot_attribute(self, snapshot_id, attribute='createVolumePermission', dry_run=False):
def get_all_key_pairs(self, keynames=None, filters=None, dry_run=False):
def get_key_pair(self, keyname, dry_run=False):
def create_key_pair(self, key_name, dry_run=False):
def delete_key_pair(self, key_name, dry_run=False):
def import_key_pair(self, key_name, public_key_material, dry_run=False):
def get_all_security_groups(self, groupnames=None, group_ids=None, filters=None, dry_run=False):
def create_security_group(self, name, description, vpc_id=None, dry_run=False):
def delete_security_group(self, name=None, group_id=None, dry_run=False):
def authorize_security_group_deprecated(self, group_name, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, dry_run=False):
def authorize_security_group(self, group_name=None, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, group_id=None, src_security_group_group_id=None, dry_run=False):
def authorize_security_group_egress(self, group_id, ip_protocol, from_port=None, to_port=None, src_group_id=None, cidr_ip=None, dry_run=False):
def revoke_security_group_deprecated(self, group_name, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, dry_run=False):
def revoke_security_group(self, group_name=None, src_security_group_name=None, src_security_group_owner_id=None, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, group_id=None, src_security_group_group_id=None, dry_run=False):
def revoke_security_group_egress(self, group_id, ip_protocol, from_port=None, to_port=None, src_group_id=None, cidr_ip=None, dry_run=False):
def get_all_regions(self, region_names=None, filters=None, dry_run=False):
def get_all_reserved_instances_offerings(self, reserved_instances_offering_ids=None, instance_type=None, availability_zone=None, product_description=None, filters=None, instance_tenancy=None, offering_type=None, include_marketplace=None, min_duration=None, max_duration=None, max_instance_count=None, next_token=None, max_results=None, dry_run=False):
def get_all_reserved_instances(self, reserved_instances_id=None, filters=None, dry_run=False):
def purchase_reserved_instance_offering(self, reserved_instances_offering_id, instance_count=1, limit_price=None, dry_run=False):
def create_reserved_instances_listing(self, reserved_instances_id, instance_count, price_schedules, client_token, dry_run=False):
def cancel_reserved_instances_listing(self, reserved_instances_listing_ids=None, dry_run=False):
def modify_reserved_instances(self, client_token, reserved_instance_ids, target_configurations):
def describe_reserved_instances_modifications(self, reserved_instances_modification_ids=None, next_token=None, filters=None):
def monitor_instances(self, instance_ids, dry_run=False):
def monitor_instance(self, instance_id, dry_run=False):
def unmonitor_instances(self, instance_ids, dry_run=False):
def unmonitor_instance(self, instance_id, dry_run=False):
def bundle_instance(self, instance_id, s3_bucket, s3_prefix, s3_upload_policy, dry_run=False):
def get_all_bundle_tasks(self, bundle_ids=None, filters=None, dry_run=False):
def cancel_bundle_task(self, bundle_id, dry_run=False):
def get_password_data(self, instance_id, dry_run=False):
def get_all_placement_groups(self, groupnames=None, filters=None, dry_run=False):
def create_placement_group(self, name, strategy='cluster', dry_run=False):
def delete_placement_group(self, name, dry_run=False):
def get_all_tags(self, filters=None, dry_run=False, max_results=None):
def create_tags(self, resource_ids, tags, dry_run=False):
def delete_tags(self, resource_ids, tags, dry_run=False):
def get_all_network_interfaces(self, network_interface_ids=None, filters=None, dry_run=False):
def create_network_interface(self, subnet_id, private_ip_address=None, description=None, groups=None, dry_run=False):
def attach_network_interface(self, network_interface_id, instance_id, device_index, dry_run=False):
def detach_network_interface(self, attachment_id, force=False, dry_run=False):
def delete_network_interface(self, network_interface_id, dry_run=False):
def get_all_instance_types(self):
def copy_image(self, source_region, source_image_id, name=None, description=None, client_token=None, dry_run=False, encrypted=None, kms_key_id=None):
def describe_account_attributes(self, attribute_names=None, dry_run=False):
def describe_vpc_attribute(self, vpc_id, attribute=None, dry_run=False):
def modify_vpc_attribute(self, vpc_id, enable_dns_support=None, enable_dns_hostnames=None, dry_run=False):
def get_all_classic_link_instances(self, instance_ids=None, filters=None, dry_run=False, max_results=None, next_token=None):
def __init__(self, load_balancer=None, description=None, state=None, instance_id=None, reason_code=None):
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', security_token=None, validate_certs=True, profile_name=None):
def get_all_load_balancers(self, load_balancer_names=None, marker=None):
def create_load_balancer(self, name, zones, listeners=None, subnets=None, security_groups=None, scheme='internet-facing', complex_listeners=None):
def create_load_balancer_listeners(self, name, listeners=None, complex_listeners=None):
def delete_load_balancer(self, name):
def delete_load_balancer_listeners(self, name, ports):
def enable_availability_zones(self, load_balancer_name, zones_to_add):
def disable_availability_zones(self, load_balancer_name, zones_to_remove):
def modify_lb_attribute(self, load_balancer_name, attribute, value):
def get_all_lb_attributes(self, load_balancer_name):
def get_lb_attribute(self, load_balancer_name, attribute):
def register_instances(self, load_balancer_name, instances):
def deregister_instances(self, load_balancer_name, instances):
def describe_instance_health(self, load_balancer_name, instances=None):
def configure_health_check(self, name, health_check):
def set_lb_listener_SSL_certificate(self, lb_name, lb_port, ssl_certificate_id):
def create_app_cookie_stickiness_policy(self, name, lb_name, policy_name):
def create_lb_cookie_stickiness_policy(self, cookie_expiration_period, lb_name, policy_name):
def create_lb_policy(self, lb_name, policy_name, policy_type, policy_attributes):
def delete_lb_policy(self, lb_name, policy_name):
def set_lb_policies_of_listener(self, lb_name, lb_port, policies):
def set_lb_policies_of_backend_server(self, lb_name, instance_port, policies):
def apply_security_groups_to_lb(self, name, security_groups):
def attach_lb_to_subnets(self, name, subnets):
def detach_lb_from_subnets(self, name, subnets):
def __init__(self, access_point=None, interval=30, target=None, healthy_threshold=3, timeout=5, unhealthy_threshold=5):
def update(self):
def __init__(self, connection=None, name=None, endpoints=None):
def enable_zones(self, zones):
def disable_zones(self, zones):
def get_attributes(self, force=False):
def is_cross_zone_load_balancing(self, force=False):
def enable_cross_zone_load_balancing(self):
def disable_cross_zone_load_balancing(self):
def register_instances(self, instances):
def deregister_instances(self, instances):
def delete(self):
def configure_health_check(self, health_check):
def get_instance_health(self, instances=None):
def delete_policy(self, policy_name):
def attach_subnets(self, subnets):
def detach_subnets(self, subnets):
def apply_security_groups(self, security_groups):
def update(self, validate=False, dry_run=False):
def attach(self, instance_id, device_index, dry_run=False):
def detach(self, force=False, dry_run=False):
def update(self, validate=False, dry_run=False):
def delete(self, dry_run=False):
def attach(self, instance_id, device, dry_run=False):
def detach(self, force=False, dry_run=False):
def create_snapshot(self, description=None, dry_run=False):
def volume_state(self):
def attachment_state(self):
def snapshots(self, owner=None, restorable_by=None, dry_run=False):
def update(self, validate=False, dry_run=False):
def create_volume(self, zone, size=None, volume_type=None, iops=None, dry_run=False):
def __init__(self, connection=None, id=None, state=None):
def release(self, dry_run=False):
def associate(self, instance_id=None, network_interface_id=None, private_ip_address=None, allow_reassociation=False, dry_run=False):
def disassociate(self, dry_run=False):
def update(self, validate=False, dry_run=False):
def run(self, min_count=1, max_count=1, key_name=None, security_groups=None, user_data=None, addressing_type=None, instance_type='m1.small', placement=None, kernel_id=None, ramdisk_id=None, monitoring_enabled=False, subnet_id=None, block_device_map=None, disable_api_termination=False, instance_initiated_shutdown_behavior=None, private_ip_address=None, placement_group=None, security_group_ids=None, additional_info=None, instance_profile_name=None, instance_profile_arn=None, tenancy=None, dry_run=False):
def update(self, validate=False, dry_run=False):
def terminate(self, dry_run=False):
def stop(self, force=False, dry_run=False):
def start(self, dry_run=False):
def get_console_output(self, dry_run=False):
def use_ip(self, ip_address, dry_run=False):
def get_attribute(self, attribute, dry_run=False):
def modify_attribute(self, attribute, value, dry_run=False):
def reset_attribute(self, attribute, dry_run=False):
def create_image(self, name, description=None, no_reboot=False, dry_run=False):
def add_rule(self, ip_protocol, from_port, to_port, src_group_name, src_group_owner_id, cidr_ip, src_group_group_id, dry_run=False):
def remove_rule(self, ip_protocol, from_port, to_port, src_group_name, src_group_owner_id, cidr_ip, src_group_group_id, dry_run=False):
def authorize(self, ip_protocol=None, from_port=None, to_port=None, cidr_ip=None, src_group=None, dry_run=False):
def copy_to_region(self, region, name=None, dry_run=False):
def instances(self, dry_run=False):
def assign_instance(self, instance_id, layer_ids):
def assign_volume(self, volume_id, instance_id=None):
def associate_elastic_ip(self, elastic_ip, instance_id=None):
def attach_elastic_load_balancer(self, elastic_load_balancer_name, layer_id):
def clone_stack(self, source_stack_id, service_role_arn, name=None, region=None, vpc_id=None, attributes=None, default_instance_profile_arn=None, default_os=None, hostname_theme=None, default_availability_zone=None, default_subnet_id=None, custom_json=None, configuration_manager=None, chef_configuration=None, use_custom_cookbooks=None, use_opsworks_security_groups=None, custom_cookbooks_source=None, default_ssh_key_name=None, clone_permissions=None, clone_app_ids=None, default_root_device_type=None):
def create_app(self, stack_id, name, type, shortname=None, description=None, data_sources=None, app_source=None, domains=None, enable_ssl=None, ssl_configuration=None, attributes=None, environment=None):
def create_deployment(self, stack_id, command, app_id=None, instance_ids=None, comment=None, custom_json=None):
def create_instance(self, stack_id, layer_ids, instance_type, auto_scaling_type=None, hostname=None, os=None, ami_id=None, ssh_key_name=None, availability_zone=None, virtualization_type=None, subnet_id=None, architecture=None, root_device_type=None, install_updates_on_boot=None, ebs_optimized=None):
def create_layer(self, stack_id, type, name, shortname, attributes=None, custom_instance_profile_arn=None, custom_security_group_ids=None, packages=None, volume_configurations=None, enable_auto_healing=None, auto_assign_elastic_ips=None, auto_assign_public_ips=None, custom_recipes=None, install_updates_on_boot=None, use_ebs_optimized_instances=None, lifecycle_event_configuration=None):
def create_stack(self, name, region, service_role_arn, default_instance_profile_arn, vpc_id=None, attributes=None, default_os=None, hostname_theme=None, default_availability_zone=None, default_subnet_id=None, custom_json=None, configuration_manager=None, chef_configuration=None, use_custom_cookbooks=None, use_opsworks_security_groups=None, custom_cookbooks_source=None, default_ssh_key_name=None, default_root_device_type=None):
def create_user_profile(self, iam_user_arn, ssh_username=None, ssh_public_key=None, allow_self_management=None):
def delete_app(self, app_id):
def delete_instance(self, instance_id, delete_elastic_ip=None, delete_volumes=None):
def delete_layer(self, layer_id):
def delete_stack(self, stack_id):
def delete_user_profile(self, iam_user_arn):
def deregister_elastic_ip(self, elastic_ip):
def deregister_instance(self, instance_id):
def deregister_rds_db_instance(self, rds_db_instance_arn):
def deregister_volume(self, volume_id):
def describe_apps(self, stack_id=None, app_ids=None):
def describe_commands(self, deployment_id=None, instance_id=None, command_ids=None):
def describe_deployments(self, stack_id=None, app_id=None, deployment_ids=None):
def describe_elastic_ips(self, instance_id=None, stack_id=None, ips=None):
def describe_elastic_load_balancers(self, stack_id=None, layer_ids=None):
def describe_instances(self, stack_id=None, layer_id=None, instance_ids=None):
def describe_layers(self, stack_id=None, layer_ids=None):
def describe_load_based_auto_scaling(self, layer_ids):
def describe_my_user_profile(self):
def describe_permissions(self, iam_user_arn=None, stack_id=None):
def describe_raid_arrays(self, instance_id=None, stack_id=None, raid_array_ids=None):
def describe_rds_db_instances(self, stack_id, rds_db_instance_arns=None):
def describe_service_errors(self, stack_id=None, instance_id=None, service_error_ids=None):
def describe_stack_provisioning_parameters(self, stack_id):
def describe_stack_summary(self, stack_id):
def describe_stacks(self, stack_ids=None):
def describe_time_based_auto_scaling(self, instance_ids):
def describe_user_profiles(self, iam_user_arns=None):
def describe_volumes(self, instance_id=None, stack_id=None, raid_array_id=None, volume_ids=None):
def detach_elastic_load_balancer(self, elastic_load_balancer_name, layer_id):
def disassociate_elastic_ip(self, elastic_ip):
def get_hostname_suggestion(self, layer_id):
def reboot_instance(self, instance_id):
def register_elastic_ip(self, elastic_ip, stack_id):
def register_instance(self, stack_id, hostname=None, public_ip=None, private_ip=None, rsa_public_key=None, rsa_public_key_fingerprint=None, instance_identity=None):
def register_rds_db_instance(self, stack_id, rds_db_instance_arn, db_user, db_password):
def register_volume(self, stack_id, ec_2_volume_id=None):
def set_load_based_auto_scaling(self, layer_id, enable=None, up_scaling=None, down_scaling=None):
def set_permission(self, stack_id, iam_user_arn, allow_ssh=None, allow_sudo=None, level=None):
def set_time_based_auto_scaling(self, instance_id, auto_scaling_schedule=None):
def start_instance(self, instance_id):
def start_stack(self, stack_id):
def stop_instance(self, instance_id):
def stop_stack(self, stack_id):
def unassign_instance(self, instance_id):
def unassign_volume(self, volume_id):
def update_app(self, app_id, name=None, description=None, data_sources=None, type=None, app_source=None, domains=None, enable_ssl=None, ssl_configuration=None, attributes=None, environment=None):
def update_elastic_ip(self, elastic_ip, name=None):
def update_instance(self, instance_id, layer_ids=None, instance_type=None, auto_scaling_type=None, hostname=None, os=None, ami_id=None, ssh_key_name=None, architecture=None, install_updates_on_boot=None, ebs_optimized=None):
def update_layer(self, layer_id, name=None, shortname=None, attributes=None, custom_instance_profile_arn=None, custom_security_group_ids=None, packages=None, volume_configurations=None, enable_auto_healing=None, auto_assign_elastic_ips=None, auto_assign_public_ips=None, custom_recipes=None, install_updates_on_boot=None, use_ebs_optimized_instances=None, lifecycle_event_configuration=None):
def update_my_user_profile(self, ssh_public_key=None):
def update_rds_db_instance(self, rds_db_instance_arn, db_user=None, db_password=None):
def update_stack(self, stack_id, name=None, attributes=None, service_role_arn=None, default_instance_profile_arn=None, default_os=None, hostname_theme=None, default_availability_zone=None, default_subnet_id=None, custom_json=None, configuration_manager=None, chef_configuration=None, use_custom_cookbooks=None, custom_cookbooks_source=None, default_ssh_key_name=None, default_root_device_type=None, use_opsworks_security_groups=None):
def update_user_profile(self, iam_user_arn, ssh_username=None, ssh_public_key=None, allow_self_management=None):
def update_volume(self, volume_id, name=None, mount_point=None):
def delete_delivery_channel(self, delivery_channel_name):
def deliver_config_snapshot(self, delivery_channel_name):
def describe_configuration_recorder_status(self, configuration_recorder_names=None):
def describe_configuration_recorders(self, configuration_recorder_names=None):
def describe_delivery_channel_status(self, delivery_channel_names=None):
def describe_delivery_channels(self, delivery_channel_names=None):
def get_resource_config_history(self, resource_type, resource_id, later_time=None, earlier_time=None, chronological_order=None, limit=None, next_token=None):
def put_configuration_recorder(self, configuration_recorder):
def put_delivery_channel(self, delivery_channel):
def start_configuration_recorder(self, configuration_recorder_name):
def stop_configuration_recorder(self, configuration_recorder_name):
def get_all_dbinstances(self, instance_id=None, max_records=None, marker=None):
def create_dbinstance(self, id, allocated_storage, instance_class, master_username, master_password, port=3306, engine='MySQL5.1', db_name=None, param_group=None, security_groups=None, availability_zone=None, preferred_maintenance_window=None, backup_retention_period=None, preferred_backup_window=None, multi_az=False, engine_version=None, auto_minor_version_upgrade=True, character_set_name=None, db_subnet_group_name=None, license_model=None, option_group_name=None, iops=None, vpc_security_groups=None):
def create_dbinstance_read_replica(self, id, source_id, instance_class=None, port=3306, availability_zone=None, auto_minor_version_upgrade=None):
def promote_read_replica(self, id, backup_retention_period=None, preferred_backup_window=None):
def modify_dbinstance(self, id, param_group=None, security_groups=None, preferred_maintenance_window=None, master_password=None, allocated_storage=None, instance_class=None, backup_retention_period=None, preferred_backup_window=None, multi_az=False, apply_immediately=False, iops=None, vpc_security_groups=None, new_instance_id=None):
def delete_dbinstance(self, id, skip_final_snapshot=False, final_snapshot_id=''):
def reboot_dbinstance(self, id):
def get_all_dbparameter_groups(self, groupname=None, max_records=None, marker=None):
def get_all_dbparameters(self, groupname, source=None, max_records=None, marker=None):
def create_parameter_group(self, name, engine='MySQL5.1', description=''):
def modify_parameter_group(self, name, parameters=None):
def reset_parameter_group(self, name, reset_all_params=False, parameters=None):
def delete_parameter_group(self, name):
def get_all_dbsecurity_groups(self, groupname=None, max_records=None, marker=None):
def create_dbsecurity_group(self, name, description=None):
def delete_dbsecurity_group(self, name):
def authorize_dbsecurity_group(self, group_name, cidr_ip=None, ec2_security_group_name=None, ec2_security_group_owner_id=None):
def revoke_dbsecurity_group(self, group_name, ec2_security_group_name=None, ec2_security_group_owner_id=None, cidr_ip=None):
def get_all_dbsnapshots(self, snapshot_id=None, instance_id=None, max_records=None, marker=None):
def get_all_logs(self, dbinstance_id, max_records=None, marker=None, file_size=None, filename_contains=None, file_last_written=None):
def get_log_file(self, dbinstance_id, log_file_name, marker=None, number_of_lines=None, max_records=None):
def create_dbsnapshot(self, snapshot_id, dbinstance_id):
def copy_dbsnapshot(self, source_snapshot_id, target_snapshot_id):
def delete_dbsnapshot(self, identifier):
def restore_dbinstance_from_dbsnapshot(self, identifier, instance_id, instance_class, port=None, availability_zone=None, multi_az=None, auto_minor_version_upgrade=None, db_subnet_group_name=None):
def restore_dbinstance_from_point_in_time(self, source_instance_id, target_instance_id, use_latest=False, restore_time=None, dbinstance_class=None, port=None, availability_zone=None, db_subnet_group_name=None):
def get_all_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, max_records=None, marker=None):
def create_db_subnet_group(self, name, desc, subnet_ids):
def delete_db_subnet_group(self, name):
def get_all_db_subnet_groups(self, name=None, max_records=None, marker=None):
def modify_db_subnet_group(self, name, description=None, subnet_ids=None):
def create_option_group(self, name, engine_name, major_engine_version, description=None):
def delete_option_group(self, name):
def describe_option_groups(self, name=None, engine_name=None, major_engine_version=None, max_records=100, marker=None):
def describe_option_group_options(self, engine_name=None, major_engine_version=None, max_records=100, marker=None):
def authorize(self, cidr_ip=None, ec2_group=None):
def revoke(self, cidr_ip=None, ec2_group=None):
def update(self, validate=False):
@property DCNL def security_group(self):
@property DCNL def parameter_group(self):
def snapshot(self, snapshot_id):
def reboot(self):
def update(self, validate=False):
def stop(self, skip_final_snapshot=False, final_snapshot_id=''):
def modify(self, param_group=None, security_groups=None, preferred_maintenance_window=None, master_password=None, allocated_storage=None, instance_class=None, backup_retention_period=None, preferred_backup_window=None, multi_az=False, iops=None, vpc_security_groups=None, apply_immediately=False, new_instance_id=None):
def headers_to_sign(self, http_request):
def canonical_headers(self, headers_to_sign):
def string_to_sign(self, http_request):
def add_auth(self, req, **kwargs):
def headers_to_sign(self, http_request):
def canonical_headers(self, headers_to_sign):
def string_to_sign(self, http_request, canonical_request):
def add_auth(self, req, **kwargs):
def headers_to_sign(self, http_request):
def mangle_path_and_params(self, req):
def presign(self, req, expires, iso_date=None):
def __init__(self, endpoint_data, service_rename_map=None):
def get_all_available_regions(self, service_name):
def get_available_services(self):
def _is_global_service(self, service_name, partition_name='aws'):
def _get_partition_data(self, partition_name):
def _endpoint_prefix(self, service_name):
def _service_name(self, endpoint_prefix):
def __init__(self, endpoint_data, service_rename_map=None):
def resolve_hostname(self, service_name, region_name):
def get_all_available_regions(self, service_name):
def get_available_services(self):
def __init__(self, resolver):
def build_static_endpoints(self, service_names=None):
def connect(self, **kw_params):
def __init__(self, ip_addr, port, hc_type, resource_path, fqdn=None, string_match=None, request_interval=30, failure_threshold=3):
def get_all_hosted_zones(self, start_marker=None, zone_list=None):
def get_hosted_zone(self, hosted_zone_id):
def get_hosted_zone_by_name(self, hosted_zone_name):
def create_hosted_zone(self, domain_name, caller_ref=None, comment='', private_zone=False, vpc_id=None, vpc_region=None):
def delete_hosted_zone(self, hosted_zone_id):
def create_health_check(self, health_check, caller_ref=None):
def get_list_health_checks(self, maxitems=None, marker=None):
def get_checker_ip_ranges(self):
def delete_health_check(self, health_check_id):
def get_all_rrsets(self, hosted_zone_id, type=None, name=None, identifier=None, maxitems=None):
def change_rrsets(self, hosted_zone_id, xml_body):
def get_change(self, change_id):
def create_zone(self, name, private_zone=False, vpc_id=None, vpc_region=None):
def get_zone(self, name):
def get_zones(self):
def _make_qualified(self, value):
def update(self):
def _commit(self, changes):
def _new_record(self, changes, resource_type, name, value, ttl, identifier, comment=''):
def add_record(self, resource_type, name, value, ttl=60, identifier=None, comment=''):
def update_record(self, old_record, new_value, new_ttl=None, new_identifier=None, comment=''):
def delete_record(self, record, comment=''):
def add_cname(self, name, value, ttl=None, identifier=None, comment=''):
def add_a(self, name, value, ttl=None, identifier=None, comment=''):
def add_mx(self, name, records, ttl=None, identifier=None, comment=''):
def find_records(self, name, type, desired=1, all=False, identifier=None):
def get_cname(self, name, all=False):
def get_a(self, name, all=False):
def get_mx(self, name, all=False):
def update_cname(self, name, value, ttl=None, identifier=None, comment=''):
def update_a(self, name, value, ttl=None, identifier=None, comment=''):
def update_mx(self, name, value, ttl=None, identifier=None, comment=''):
def delete_cname(self, name, identifier=None, all=False):
def delete_a(self, name, identifier=None, all=False):
def delete_mx(self, name, identifier=None, all=False):
def get_records(self):
def delete(self):
def get_nameservers(self):
def check_domain_availability(self, domain_name, idn_lang_code=None):
def disable_domain_transfer_lock(self, domain_name):
def enable_domain_transfer_lock(self, domain_name):
def get_domain_detail(self, domain_name):
def get_operation_detail(self, operation_id):
def list_domains(self, marker=None, max_items=None):
def list_operations(self, marker=None, max_items=None):
def register_domain(self, domain_name, duration_in_years, admin_contact, registrant_contact, tech_contact, idn_lang_code=None, auto_renew=None, privacy_protect_admin_contact=None, privacy_protect_registrant_contact=None, privacy_protect_tech_contact=None):
def retrieve_domain_auth_code(self, domain_name):
def transfer_domain(self, domain_name, duration_in_years, nameservers, admin_contact, registrant_contact, tech_contact, idn_lang_code=None, auth_code=None, auto_renew=None, privacy_protect_admin_contact=None, privacy_protect_registrant_contact=None, privacy_protect_tech_contact=None):
def update_domain_contact(self, domain_name, admin_contact=None, registrant_contact=None, tech_contact=None):
def update_domain_contact_privacy(self, domain_name, admin_privacy=None, registrant_privacy=None, tech_privacy=None):
def update_domain_nameservers(self, domain_name, nameservers):
def add_change(self, action, name, type, ttl=600, alias_hosted_zone_id=None, alias_dns_name=None, identifier=None, weight=None, region=None, alias_evaluate_target_health=None, health_check=None, failover=None):
def add_change_record(self, action, change):
def to_xml(self):
def commit(self):
def endElement(self, name, value, connection):
def __iter__(self):
def add_value(self, value):
def set_alias(self, alias_hosted_zone_id, alias_dns_name, alias_evaluate_target_health=False):
def to_xml(self):
def __init__(self):
def __repr__(self):
def equals(self, uri):
def connect(self, access_key_id=None, secret_access_key=None, **kwargs):
def __init__(self, scheme, bucket_name=None, object_name=None, debug=0, connection_args=None, suppress_consec_slashes=True, version_id=None, generation=None, is_latest=False):
def clone_replace_name(self, new_name):
def clone_replace_key(self, key):
def get_acl(self, validate=False, headers=None, version_id=None):
def get_def_acl(self, validate=False, headers=None):
def get_cors(self, validate=False, headers=None):
def set_cors(self, cors, validate=False, headers=None):
def set_storage_class(self, storage_class, validate=False, headers=None):
def is_file_uri(self):
def is_cloud_uri(self):
def names_container(self):
def names_singleton(self):
def names_directory(self):
def names_provider(self):
def names_bucket(self):
def names_file(self):
def names_object(self):
def is_stream(self):
def set_acl(self, acl_or_str, key_name='', validate=False, headers=None, version_id=None, if_generation=None, if_metageneration=None):
def set_xml_acl(self, xmlstring, key_name='', validate=False, headers=None, version_id=None, if_generation=None, if_metageneration=None):
def set_def_xml_acl(self, xmlstring, validate=False, headers=None):
def set_def_acl(self, acl_or_str, validate=False, headers=None, version_id=None):
def set_canned_acl(self, acl_str, validate=False, headers=None, version_id=None):
def set_def_canned_acl(self, acl_str, validate=False, headers=None, version_id=None):
def copy_key(self, src_bucket_name, src_key_name, metadata=None, src_version_id=None, storage_class='STANDARD', preserve_acl=False, encrypt_key=False, headers=None, query_args=None, src_generation=None):
def get_lifecycle_config(self, validate=False, headers=None):
def configure_lifecycle(self, lifecycle_config, validate=False, headers=None):
def exists(self, headers=None):
def __init__(self, object_name, debug, is_stream=False):
def clone_replace_name(self, new_name):
def is_file_uri(self):
def is_cloud_uri(self):
def names_container(self):
def names_singleton(self):
def names_directory(self):
def names_provider(self):
def names_bucket(self):
def names_file(self):
def names_object(self):
def is_stream(self):
def close(self):
def exists(self, _headers_not_used=None):
def search(self, query, cursor=None, expr=None, facet=None, filter_query=None, highlight=None, partial=None, query_options=None, query_parser=None, ret=None, size=None, sort=None, start=None):
def suggest(self, query, suggester, size=None):
def upload_documents(self, documents, content_type):
def __init__(self, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, region=None, path='/', converter=None, validate_certs=True, anon=False, security_token=None, profile_name=None):
def get_session_token(self, duration=None, force_new=False, mfa_serial_number=None, mfa_token=None):
def get_federation_token(self, name, duration=None, policy=None):
def assume_role(self, role_arn, role_session_name, policy=None, duration_seconds=None, external_id=None, mfa_serial_number=None, mfa_token=None):
def assume_role_with_saml(self, role_arn, principal_arn, saml_assertion, policy=None, duration_seconds=None):
def assume_role_with_web_identity(self, role_arn, role_session_name, web_identity_token, provider_id=None, policy=None, duration_seconds=None):
def decode_authorization_message(self, encoded_message):
@classmethod DCNL def from_json(cls, json_doc):
@classmethod DCNL def load(cls, file_path):
def to_dict(self):
def save(self, file_path):
def is_expired(self, time_offset_seconds=0):
def create_batch_prediction(self, batch_prediction_id, ml_model_id, batch_prediction_data_source_id, output_uri, batch_prediction_name=None):
def create_data_source_from_rds(self, data_source_id, rds_data, role_arn, data_source_name=None, compute_statistics=None):
def create_data_source_from_redshift(self, data_source_id, data_spec, role_arn, data_source_name=None, compute_statistics=None):
def create_data_source_from_s3(self, data_source_id, data_spec, data_source_name=None, compute_statistics=None):
def create_evaluation(self, evaluation_id, ml_model_id, evaluation_data_source_id, evaluation_name=None):
def create_ml_model(self, ml_model_id, ml_model_type, training_data_source_id, ml_model_name=None, parameters=None, recipe=None, recipe_uri=None):
def create_realtime_endpoint(self, ml_model_id):
def delete_batch_prediction(self, batch_prediction_id):
def delete_data_source(self, data_source_id):
def delete_evaluation(self, evaluation_id):
def delete_ml_model(self, ml_model_id):
def delete_realtime_endpoint(self, ml_model_id):
def describe_batch_predictions(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None):
def describe_data_sources(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None):
def describe_evaluations(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None):
def describe_ml_models(self, filter_variable=None, eq=None, gt=None, lt=None, ge=None, le=None, ne=None, prefix=None, sort_order=None, next_token=None, limit=None):
def get_batch_prediction(self, batch_prediction_id):
def get_data_source(self, data_source_id, verbose=None):
def get_evaluation(self, evaluation_id):
def get_ml_model(self, ml_model_id, verbose=None):
def predict(self, ml_model_id, record, predict_endpoint):
def update_batch_prediction(self, batch_prediction_id, batch_prediction_name):
def update_data_source(self, data_source_id, data_source_name):
def update_evaluation(self, evaluation_id, evaluation_name):
def update_ml_model(self, ml_model_id, ml_model_name=None, score_threshold=None):
def create_alias(self, alias_name, target_key_id):
def create_grant(self, key_id, grantee_principal, retiring_principal=None, operations=None, constraints=None, grant_tokens=None):
def create_key(self, policy=None, description=None, key_usage=None):
def decrypt(self, ciphertext_blob, encryption_context=None, grant_tokens=None):
def delete_alias(self, alias_name):
def describe_key(self, key_id):
def disable_key(self, key_id):
def disable_key_rotation(self, key_id):
def enable_key(self, key_id):
def enable_key_rotation(self, key_id):
def encrypt(self, key_id, plaintext, encryption_context=None, grant_tokens=None):
def generate_data_key(self, key_id, encryption_context=None, number_of_bytes=None, key_spec=None, grant_tokens=None):
def generate_data_key_without_plaintext(self, key_id, encryption_context=None, key_spec=None, number_of_bytes=None, grant_tokens=None):
def generate_random(self, number_of_bytes=None):
def get_key_policy(self, key_id, policy_name):
def get_key_rotation_status(self, key_id):
def list_aliases(self, limit=None, marker=None):
def list_grants(self, key_id, limit=None, marker=None):
def list_key_policies(self, key_id, limit=None, marker=None):
def list_keys(self, limit=None, marker=None):
def put_key_policy(self, key_id, policy_name, policy):
def re_encrypt(self, ciphertext_blob, destination_key_id, source_encryption_context=None, destination_encryption_context=None, grant_tokens=None):
def retire_grant(self, grant_token):
def revoke_grant(self, key_id, grant_id):
def update_key_description(self, key_id, description):
def delete_dataset(self, identity_pool_id, identity_id, dataset_name):
def describe_dataset(self, identity_pool_id, identity_id, dataset_name):
def describe_identity_pool_usage(self, identity_pool_id):
def describe_identity_usage(self, identity_pool_id, identity_id):
def get_identity_pool_configuration(self, identity_pool_id):
def list_datasets(self, identity_pool_id, identity_id, next_token=None, max_results=None):
def list_identity_pool_usage(self, next_token=None, max_results=None):
def list_records(self, identity_pool_id, identity_id, dataset_name, last_sync_count=None, next_token=None, max_results=None, sync_session_token=None):
def register_device(self, identity_pool_id, identity_id, platform, token):
def set_identity_pool_configuration(self, identity_pool_id, push_sync=None):
def subscribe_to_dataset(self, identity_pool_id, identity_id, dataset_name, device_id):
def unsubscribe_from_dataset(self, identity_pool_id, identity_id, dataset_name, device_id):
def update_records(self, identity_pool_id, identity_id, dataset_name, sync_session_token, device_id=None, record_patches=None, client_context=None):
def create_identity_pool(self, identity_pool_name, allow_unauthenticated_identities, supported_login_providers=None, developer_provider_name=None, open_id_connect_provider_ar_ns=None):
def delete_identity_pool(self, identity_pool_id):
def describe_identity_pool(self, identity_pool_id):
def get_id(self, account_id, identity_pool_id, logins=None):
def get_open_id_token(self, identity_id, logins=None):
def get_open_id_token_for_developer_identity(self, identity_pool_id, logins, identity_id=None, token_duration=None):
def list_identities(self, identity_pool_id, max_results, next_token=None):
def list_identity_pools(self, max_results, next_token=None):
def lookup_developer_identity(self, identity_pool_id, identity_id=None, developer_user_identifier=None, max_results=None, next_token=None):
def merge_developer_identities(self, source_user_identifier, destination_user_identifier, developer_provider_name, identity_pool_id):
def unlink_developer_identity(self, identity_id, identity_pool_id, developer_provider_name, developer_user_identifier):
def unlink_identity(self, identity_id, logins, logins_to_remove):
def update_identity_pool(self, identity_pool_id, identity_pool_name, allow_unauthenticated_identities, supported_login_providers=None, developer_provider_name=None, open_id_connect_provider_ar_ns=None):
def connect(self, **kw_params):
def get_response(self, action, params, path='/', parent=None, verb='POST', list_marker='Set'):
def get_all_groups(self, path_prefix='/', marker=None, max_items=None):
def get_group(self, group_name, marker=None, max_items=None):
def create_group(self, group_name, path='/'):
def delete_group(self, group_name):
def update_group(self, group_name, new_group_name=None, new_path=None):
def add_user_to_group(self, group_name, user_name):
def remove_user_from_group(self, group_name, user_name):
def put_group_policy(self, group_name, policy_name, policy_json):
def get_all_group_policies(self, group_name, marker=None, max_items=None):
def get_group_policy(self, group_name, policy_name):
def delete_group_policy(self, group_name, policy_name):
def get_all_users(self, path_prefix='/', marker=None, max_items=None):
def create_user(self, user_name, path='/'):
def delete_user(self, user_name):
def get_user(self, user_name=None):
def update_user(self, user_name, new_user_name=None, new_path=None):
def get_all_user_policies(self, user_name, marker=None, max_items=None):
def put_user_policy(self, user_name, policy_name, policy_json):
def get_user_policy(self, user_name, policy_name):
def delete_user_policy(self, user_name, policy_name):
def get_groups_for_user(self, user_name, marker=None, max_items=None):
def get_all_access_keys(self, user_name, marker=None, max_items=None):
def create_access_key(self, user_name=None):
def update_access_key(self, access_key_id, status, user_name=None):
def delete_access_key(self, access_key_id, user_name=None):
def get_all_signing_certs(self, marker=None, max_items=None, user_name=None):
def update_signing_cert(self, cert_id, status, user_name=None):
def upload_signing_cert(self, cert_body, user_name=None):
def delete_signing_cert(self, cert_id, user_name=None):
def list_server_certs(self, path_prefix='/', marker=None, max_items=None):
def update_server_cert(self, cert_name, new_cert_name=None, new_path=None):
def upload_server_cert(self, cert_name, cert_body, private_key, cert_chain=None, path=None):
def get_server_certificate(self, cert_name):
def delete_server_cert(self, cert_name):
def get_all_mfa_devices(self, user_name, marker=None, max_items=None):
def enable_mfa_device(self, user_name, serial_number, auth_code_1, auth_code_2):
def deactivate_mfa_device(self, user_name, serial_number):
def resync_mfa_device(self, user_name, serial_number, auth_code_1, auth_code_2):
def get_login_profiles(self, user_name):
def create_login_profile(self, user_name, password):
def delete_login_profile(self, user_name):
def update_login_profile(self, user_name, password):
def create_account_alias(self, alias):
def delete_account_alias(self, alias):
def get_account_alias(self):
def get_signin_url(self, service='ec2'):
def get_account_summary(self):
def add_role_to_instance_profile(self, instance_profile_name, role_name):
def create_instance_profile(self, instance_profile_name, path=None):
def create_role(self, role_name, assume_role_policy_document=None, path=None):
def delete_instance_profile(self, instance_profile_name):
def delete_role(self, role_name):
def delete_role_policy(self, role_name, policy_name):
def get_instance_profile(self, instance_profile_name):
def get_role(self, role_name):
def get_role_policy(self, role_name, policy_name):
def list_instance_profiles(self, path_prefix=None, marker=None, max_items=None):
def list_instance_profiles_for_role(self, role_name, marker=None, max_items=None):
def list_role_policies(self, role_name, marker=None, max_items=None):
def list_roles(self, path_prefix=None, marker=None, max_items=None):
def put_role_policy(self, role_name, policy_name, policy_document):
def remove_role_from_instance_profile(self, instance_profile_name, role_name):
def update_assume_role_policy(self, role_name, policy_document):
def create_saml_provider(self, saml_metadata_document, name):
def list_saml_providers(self):
def get_saml_provider(self, saml_provider_arn):
def update_saml_provider(self, saml_provider_arn, saml_metadata_document):
def delete_saml_provider(self, saml_provider_arn):
def generate_credential_report(self):
def get_credential_report(self):
def create_virtual_mfa_device(self, path, device_name):
def get_account_password_policy(self):
def delete_account_password_policy(self):
def update_account_password_policy(self, allow_users_to_change_password=None, hard_expiry=None, max_password_age=None, minimum_password_length=None, password_reuse_prevention=None, require_lowercase_characters=None, require_numbers=None, require_symbols=None, require_uppercase_characters=None):
def create_policy(self, policy_name, policy_document, path='/', description=None):
def create_policy_version(self, policy_arn, policy_document, set_as_default=None):
def delete_policy(self, policy_arn):
def delete_policy_version(self, policy_arn, version_id):
def get_policy(self, policy_arn):
def get_policy_version(self, policy_arn, version_id):
def list_policies(self, marker=None, max_items=None, only_attached=None, path_prefix=None, scope=None):
def list_policy_versions(self, policy_arn, marker=None, max_items=None):
def set_default_policy_version(self, policy_arn, version_id):
def list_entities_for_policy(self, policy_arn, path_prefix=None, marker=None, max_items=None, entity_filter=None):
def attach_group_policy(self, policy_arn, group_name):
def attach_role_policy(self, policy_arn, role_name):
def attach_user_policy(self, policy_arn, user_name):
def detach_group_policy(self, policy_arn, group_name):
def detach_role_policy(self, policy_arn, role_name):
def detach_user_policy(self, policy_arn, user_name):
def _build_list_params(self, params, items, label):
def _make_request(self, action, params=None):
def _handle_error(self, response, body):
def send_email(self, source, subject, body, to_addresses, cc_addresses=None, bcc_addresses=None, format='text', reply_addresses=None, return_path=None, text_body=None, html_body=None):
def send_raw_email(self, raw_message, source=None, destinations=None):
def list_verified_email_addresses(self):
def get_send_quota(self):
def get_send_statistics(self):
def delete_verified_email_address(self, email_address):
def verify_email_address(self, email_address):
def verify_domain_dkim(self, domain):
def set_identity_dkim_enabled(self, identity, dkim_enabled):
def get_identity_dkim_attributes(self, identities):
def list_identities(self):
def get_identity_verification_attributes(self, identities):
def verify_domain_identity(self, domain):
def verify_email_identity(self, email_address):
def delete_identity(self, identity):
def set_identity_notification_topic(self, identity, notification_type, sns_topic=None):
def set_identity_feedback_forwarding_enabled(self, identity, forwarding_enabled=True):
def size(self):
def put(self, conn):
def get(self):
def _conn_ready(self, conn):
def clean(self):
def _pair_stale(self, pair):
def size(self):
def get_http_connection(self, host, port, is_secure):
def put_http_connection(self, host, port, is_secure, conn):
def clean(self):
def __init__(self, method, protocol, host, port, path, auth_path, params, headers, body):
def read(self, amt=None):
def __init__(self, host, aws_access_key_id=None, aws_secret_access_key=None, is_secure=True, port=None, proxy=None, proxy_port=None, proxy_user=None, proxy_pass=None, debug=0, https_connection_factory=None, path='/', provider='aws', security_token=None, suppress_consec_slashes=True, validate_certs=True, profile_name=None):
def _mexe(self, request, sender=None, override_num_retries=None, retry_handler=None):
def make_request(self, method, path, headers=None, data='', host=None, auth_path=None, sender=None, override_num_retries=None, params=None, retry_handler=None):
def close(self):
def build_complex_list_params(self, params, items, label, names):
def connect(self, **kw_params):
def get_policy(self):
def set_policy(self, stack_policy_body=None, stack_policy_url=None):
def _build_create_or_update_params(self, stack_name, template_body, template_url, parameters, disable_rollback, timeout_in_minutes, notification_arns, capabilities, on_failure, stack_policy_body, stack_policy_url, tags, use_previous_template=None, stack_policy_during_update_body=None, stack_policy_during_update_url=None):
def _do_request(self, call, params, path, method):
def create_stack(self, stack_name, template_body=None, template_url=None, parameters=None, notification_arns=None, disable_rollback=None, timeout_in_minutes=None, capabilities=None, tags=None, on_failure=None, stack_policy_body=None, stack_policy_url=None):
def update_stack(self, stack_name, template_body=None, template_url=None, parameters=None, notification_arns=None, disable_rollback=False, timeout_in_minutes=None, capabilities=None, tags=None, use_previous_template=None, stack_policy_during_update_body=None, stack_policy_during_update_url=None, stack_policy_body=None, stack_policy_url=None):
def delete_stack(self, stack_name_or_id):
def describe_stack_events(self, stack_name_or_id=None, next_token=None):
def describe_stack_resource(self, stack_name_or_id, logical_resource_id):
def describe_stack_resources(self, stack_name_or_id=None, logical_resource_id=None, physical_resource_id=None):
def describe_stacks(self, stack_name_or_id=None, next_token=None):
def get_template(self, stack_name_or_id):
def list_stack_resources(self, stack_name_or_id, next_token=None):
def list_stacks(self, stack_status_filters=None, next_token=None):
def validate_template(self, template_body=None, template_url=None):
def cancel_update_stack(self, stack_name_or_id=None):
def estimate_template_cost(self, template_body=None, template_url=None, parameters=None):
def get_stack_policy(self, stack_name_or_id):
def set_stack_policy(self, stack_name_or_id, stack_policy_body=None, stack_policy_url=None):
@needs_caller_reference DCNL @complex_amounts('SettlementAmount') DCNL @requires(['CreditInstrumentId', 'SettlementAmount.Value', 'SenderTokenId', 'SettlementAmount.CurrencyCode']) DCNL @api_action() DCNL def settle_debt(self, action, response, **kw):
@requires(['TransactionId']) DCNL @api_action() DCNL def get_transaction_status(self, action, response, **kw):
@requires(['StartDate']) DCNL @api_action() DCNL def get_account_activity(self, action, response, **kw):
@requires(['TransactionId']) DCNL @api_action() DCNL def get_transaction(self, action, response, **kw):
@api_action() DCNL def get_outstanding_debt_balance(self, action, response):
@requires(['PrepaidInstrumentId']) DCNL @api_action() DCNL def get_prepaid_balance(self, action, response, **kw):
@api_action() DCNL def get_total_prepaid_liability(self, action, response):
@api_action() DCNL def get_account_balance(self, action, response):
@needs_caller_reference DCNL @requires(['PaymentInstruction', 'TokenType']) DCNL @api_action() DCNL def install_payment_instruction(self, action, response, **kw):
@needs_caller_reference DCNL @requires(['returnURL', 'pipelineName']) DCNL def cbui_url(self, **kw):
@needs_caller_reference DCNL @complex_amounts('TransactionAmount') DCNL @requires(['SenderTokenId', 'TransactionAmount.Value', 'TransactionAmount.CurrencyCode']) DCNL @api_action() DCNL def reserve(self, action, response, **kw):
@needs_caller_reference DCNL @complex_amounts('TransactionAmount') DCNL @requires(['SenderTokenId', 'TransactionAmount.Value', 'TransactionAmount.CurrencyCode']) DCNL @api_action() DCNL def pay(self, action, response, **kw):
@requires(['TransactionId']) DCNL @api_action() DCNL def cancel(self, action, response, **kw):
@complex_amounts('TransactionAmount') DCNL @requires(['ReserveTransactionId', 'TransactionAmount.Value', 'TransactionAmount.CurrencyCode']) DCNL @api_action() DCNL def settle(self, action, response, **kw):
@complex_amounts('RefundAmount') DCNL @requires(['TransactionId', 'RefundAmount.Value', 'CallerReference', 'RefundAmount.CurrencyCode']) DCNL @api_action() DCNL def refund(self, action, response, **kw):
@requires(['RecipientTokenId']) DCNL @api_action() DCNL def get_recipient_verification_status(self, action, response, **kw):
@requires(['CallerReference'], ['TokenId']) DCNL @api_action() DCNL def get_token_by_caller(self, action, response, **kw):
@requires(['UrlEndPoint', 'HttpParameters']) DCNL @api_action() DCNL def verify_signature(self, action, response, **kw):
@api_action() DCNL def get_tokens(self, action, response, **kw):
@requires(['TokenId']) DCNL @api_action() DCNL def get_token_usage(self, action, response, **kw):
@requires(['TokenId']) DCNL @api_action() DCNL def cancel_token(self, action, response, **kw):
@needs_caller_reference DCNL @complex_amounts('FundingAmount') DCNL @requires(['PrepaidInstrumentId', 'FundingAmount.Value', 'SenderTokenId', 'FundingAmount.CurrencyCode']) DCNL @api_action() DCNL def fund_prepaid(self, action, response, **kw):
@requires(['CreditInstrumentId']) DCNL @api_action() DCNL def get_debt_balance(self, action, response, **kw):
@needs_caller_reference DCNL @complex_amounts('AdjustmentAmount') DCNL @requires(['CreditInstrumentId', 'AdjustmentAmount.Value', 'AdjustmentAmount.CurrencyCode']) DCNL @api_action() DCNL def write_off_debt(self, action, response, **kw):
@requires(['SubscriptionId']) DCNL @api_action() DCNL def get_transactions_for_subscription(self, action, response, **kw):
@requires(['SubscriptionId']) DCNL @api_action() DCNL def get_subscription_details(self, action, response, **kw):
@needs_caller_reference DCNL @complex_amounts('RefundAmount') DCNL @requires(['SubscriptionId']) DCNL @api_action() DCNL def cancel_subscription_and_refund(self, action, response, **kw):
@requires(['TokenId']) DCNL @api_action() DCNL def get_payment_instruction(self, action, response, **kw):
def connect(self, num_retries=5):
def open_sftp(self):
def get_file(self, src, dst):
def put_file(self, src, dst):
def open(self, filename, mode='r', bufsize=(-1)):
def listdir(self, path):
def isdir(self, path):
def exists(self, path):
def shell(self):
def run(self, command):
def run_pty(self, command):
def close(self):
def get_file(self, src, dst):
def put_file(self, src, dst):
def listdir(self, path):
def isdir(self, path):
def exists(self, path):
def run(self):
@classmethod DCNL def create(cls, config_file=None, logical_volume=None, cfg=None, **params):
def get_snapshots(self):
def trim_snapshots(self, delete=False):
def check(self):
def add_tags_to_stream(self, stream_name, tags):
def create_stream(self, stream_name, shard_count):
def delete_stream(self, stream_name):
def describe_stream(self, stream_name, limit=None, exclusive_start_shard_id=None):
def get_records(self, shard_iterator, limit=None, b64_decode=True):
def get_shard_iterator(self, stream_name, shard_id, shard_iterator_type, starting_sequence_number=None):
def list_streams(self, limit=None, exclusive_start_stream_name=None):
def list_tags_for_stream(self, stream_name, exclusive_start_tag_key=None, limit=None):
def merge_shards(self, stream_name, shard_to_merge, adjacent_shard_to_merge):
def put_record(self, stream_name, data, partition_key, explicit_hash_key=None, sequence_number_for_ordering=None, exclusive_minimum_sequence_number=None, b64_encode=True):
def put_records(self, records, stream_name, b64_encode=True):
def remove_tags_from_stream(self, stream_name, tag_keys):
def split_shard(self, stream_name, shard_to_split, new_starting_hash_key):
def process_args(self, **args):
def cli_formatter(self, data):
@classmethod DCNL def convert_boolean(cls, param, value):
def convert(self, value):
def check_for_credential_file(self):
def check_for_env_url(self):
def delete(self):
def upload_archive(self, filename, description=None):
def _upload_archive_single_operation(self, filename, description):
def create_archive_writer(self, part_size=DefaultPartSize, description=None):
def create_archive_from_file(self, filename=None, file_obj=None, description=None, upload_id_callback=None):
def resume_archive_from_file(self, upload_id, filename=None, file_obj=None):
def concurrent_create_archive_from_file(self, filename, description, **kwargs):
def retrieve_archive(self, archive_id, sns_topic=None, description=None):
def retrieve_inventory(self, sns_topic=None, description=None, byte_range=None, start_date=None, end_date=None, limit=None):
def retrieve_inventory_job(self, **kwargs):
def delete_archive(self, archive_id):
def get_job(self, job_id):
def list_jobs(self, completed=None, status_code=None):
def list_all_parts(self, upload_id):
def read(self, amt=None):
def get_output(self, byte_range=None, validate_checksum=False):
def download_to_file(self, filename, chunk_size=DefaultPartSize, verify_hashes=True, retry_exceptions=(socket.error,)):
def download_to_fileobj(self, output_file, chunk_size=DefaultPartSize, verify_hashes=True, retry_exceptions=(socket.error,)):
def list_vaults(self, limit=None, marker=None):
def describe_vault(self, vault_name):
def create_vault(self, vault_name):
def delete_vault(self, vault_name):
def get_vault_notifications(self, vault_name):
def set_vault_notifications(self, vault_name, notification_config):
def delete_vault_notifications(self, vault_name):
def list_jobs(self, vault_name, completed=None, status_code=None, limit=None, marker=None):
def describe_job(self, vault_name, job_id):
def initiate_job(self, vault_name, job_data):
def get_job_output(self, vault_name, job_id, byte_range=None):
def upload_archive(self, vault_name, archive, linear_hash, tree_hash, description=None):
def delete_archive(self, vault_name, archive_id):
def initiate_multipart_upload(self, vault_name, part_size, description=None):
def complete_multipart_upload(self, vault_name, upload_id, sha256_treehash, archive_size):
def abort_multipart_upload(self, vault_name, upload_id):
def list_multipart_uploads(self, vault_name, limit=None, marker=None):
def list_parts(self, vault_name, upload_id, limit=None, marker=None):
def upload_part(self, vault_name, upload_id, linear_hash, tree_hash, byte_range, part_data):
def __init__(self, api, vault_name, part_size=DEFAULT_PART_SIZE, num_threads=10):
def upload(self, filename, description=None):
def __init__(self, job, part_size=DEFAULT_PART_SIZE, num_threads=10):
def download(self, filename):
def _wait_for_download_threads(self, filename, result_queue, total_parts):
def __init__(self, job, worker_queue, result_queue, num_retries=5, time_between_retries=5, retry_exceptions=Exception):
def _process_chunk(self, work):
def _download_chunk(self, work):
def create_vault(self, name):
def delete_vault(self, name):
def get_vault(self, name):
def list_vaults(self):
def upload_part(self, part_index, part_data):
def skip_part(self, part_index, part_tree_hash, part_length):
@property DCNL def current_tree_hash(self):
@property DCNL def current_uploaded_size(self):
def activate_pipeline(self, pipeline_id):
def create_pipeline(self, name, unique_id, description=None):
def delete_pipeline(self, pipeline_id):
def describe_objects(self, object_ids, pipeline_id, marker=None, evaluate_expressions=None):
def describe_pipelines(self, pipeline_ids):
def evaluate_expression(self, pipeline_id, expression, object_id):
def get_pipeline_definition(self, pipeline_id, version=None):
def list_pipelines(self, marker=None):
def poll_for_task(self, worker_group, hostname=None, instance_identity=None):
def put_pipeline_definition(self, pipeline_objects, pipeline_id):
def query_objects(self, pipeline_id, sphere, marker=None, query=None, limit=None):
def report_task_progress(self, task_id):
def report_task_runner_heartbeat(self, taskrunner_id, worker_group=None, hostname=None):
def set_status(self, object_ids, status, pipeline_id):
def set_task_status(self, task_id, task_status, error_id=None, error_message=None, error_stack_trace=None):
def validate_pipeline_definition(self, pipeline_objects, pipeline_id):
def batch_get_applications(self, application_names=None):
def batch_get_deployments(self, deployment_ids=None):
def create_application(self, application_name):
def create_deployment(self, application_name, deployment_group_name=None, revision=None, deployment_config_name=None, description=None, ignore_application_stop_failures=None):
def create_deployment_config(self, deployment_config_name, minimum_healthy_hosts=None):
def create_deployment_group(self, application_name, deployment_group_name, deployment_config_name=None, ec_2_tag_filters=None, auto_scaling_groups=None, service_role_arn=None):
def delete_application(self, application_name):
def delete_deployment_config(self, deployment_config_name):
def delete_deployment_group(self, application_name, deployment_group_name):
def get_application(self, application_name):
def get_application_revision(self, application_name, revision):
def get_deployment(self, deployment_id):
def get_deployment_config(self, deployment_config_name):
def get_deployment_group(self, application_name, deployment_group_name):
def get_deployment_instance(self, deployment_id, instance_id):
def list_application_revisions(self, application_name, sort_by=None, sort_order=None, s_3_bucket=None, s_3_key_prefix=None, deployed=None, next_token=None):
def list_applications(self, next_token=None):
def list_deployment_configs(self, next_token=None):
def list_deployment_groups(self, application_name, next_token=None):
def list_deployment_instances(self, deployment_id, next_token=None, instance_status_filter=None):
def list_deployments(self, application_name=None, deployment_group_name=None, include_only_statuses=None, create_time_range=None, next_token=None):
def register_application_revision(self, application_name, revision, description=None):
def stop_deployment(self, deployment_id):
def update_application(self, application_name=None, new_application_name=None):
def update_deployment_group(self, application_name, current_deployment_group_name, new_deployment_group_name=None, deployment_config_name=None, ec_2_tag_filters=None, auto_scaling_groups=None, service_role_arn=None):
def add_attachments_to_set(self, attachments, attachment_set_id=None):
def add_communication_to_case(self, communication_body, case_id=None, cc_email_addresses=None, attachment_set_id=None):
def create_case(self, subject, communication_body, service_code=None, severity_code=None, category_code=None, cc_email_addresses=None, language=None, issue_type=None, attachment_set_id=None):
def describe_attachment(self, attachment_id):
def describe_cases(self, case_id_list=None, display_id=None, after_time=None, before_time=None, include_resolved_cases=None, next_token=None, max_results=None, language=None, include_communications=None):
def describe_communications(self, case_id, before_time=None, after_time=None, next_token=None, max_results=None):
def describe_services(self, service_code_list=None, language=None):
def describe_severity_levels(self, language=None):
def describe_trusted_advisor_check_refresh_statuses(self, check_ids):
def describe_trusted_advisor_check_result(self, check_id, language=None):
def describe_trusted_advisor_check_summaries(self, check_ids):
def describe_trusted_advisor_checks(self, language):
def refresh_trusted_advisor_check(self, check_id):
def resolve_case(self, case_id=None):
def cancel_job(self, id=None):
def create_job(self, pipeline_id=None, input_name=None, output=None, outputs=None, output_key_prefix=None, playlists=None):
def create_pipeline(self, name=None, input_bucket=None, output_bucket=None, role=None, notifications=None, content_config=None, thumbnail_config=None):
def create_preset(self, name=None, description=None, container=None, video=None, audio=None, thumbnails=None):
def delete_pipeline(self, id=None):
def delete_preset(self, id=None):
def list_jobs_by_pipeline(self, pipeline_id=None, ascending=None, page_token=None):
def list_jobs_by_status(self, status=None, ascending=None, page_token=None):
def list_pipelines(self, ascending=None, page_token=None):
def list_presets(self, ascending=None, page_token=None):
def read_job(self, id=None):
def read_pipeline(self, id=None):
def read_preset(self, id=None):
def test_role(self, role=None, input_bucket=None, output_bucket=None, topics=None):
def update_pipeline(self, id, name=None, input_bucket=None, role=None, notifications=None, content_config=None, thumbnail_config=None):
def update_pipeline_notifications(self, id=None, notifications=None):
def update_pipeline_status(self, id=None, status=None):
def encode(self, value):
def set_message_class(self, message_class):
def get_attributes(self, attributes='All'):
def set_attribute(self, attribute, value):
def get_timeout(self):
def set_timeout(self, visibility_timeout):
def add_permission(self, label, aws_account_id, action_name):
def remove_permission(self, label):
def read(self, visibility_timeout=None, wait_time_seconds=None, message_attributes=None):
def write(self, message, delay_seconds=None):
def write_batch(self, messages):
def new_message(self, body='', **kwargs):
def get_messages(self, num_messages=1, visibility_timeout=None, attributes=None, wait_time_seconds=None, message_attributes=None):
def delete_message(self, message):
def delete_message_batch(self, messages):
def change_message_visibility_batch(self, messages):
def delete(self):
def purge(self):
def clear(self, page_size=10, vtimeout=10):
def count(self, page_size=10, vtimeout=10):
def count_slow(self, page_size=10, vtimeout=10):
def dump(self, file_name, page_size=10, vtimeout=10, sep='\n'):
def save_to_file(self, fp, sep='\n'):
def save_to_filename(self, file_name, sep='\n'):
def save_to_s3(self, bucket):
def load_from_s3(self, bucket, prefix=None):
def load_from_file(self, fp, sep='\n'):
def load_from_filename(self, file_name, sep='\n'):
def create_queue(self, queue_name, visibility_timeout=None):
def delete_queue(self, queue, force_deletion=False):
def purge_queue(self, queue):
def get_queue_attributes(self, queue, attribute='All'):
def set_queue_attribute(self, queue, attribute, value):
def receive_message(self, queue, number_messages=1, visibility_timeout=None, attributes=None, wait_time_seconds=None, message_attributes=None):
def delete_message(self, queue, message):
def delete_message_batch(self, queue, messages):
def delete_message_from_handle(self, queue, receipt_handle):
def send_message(self, queue, message_content, delay_seconds=None, message_attributes=None):
def send_message_batch(self, queue, messages):
def change_message_visibility(self, queue, receipt_handle, visibility_timeout):
def change_message_visibility_batch(self, queue, messages):
def get_all_queues(self, prefix=''):
def get_queue(self, queue_name, owner_acct_id=None):
def get_dead_letter_source_queues(self, queue):
def add_permission(self, queue, label, aws_account_id, action_name):
def remove_permission(self, queue, label):
def encode(self, value):
def decode(self, value):
def set_body(self, body):
def get_body_encoded(self):
def get_response(self, action, params, page=0, itemSet=None):
def item_search(self, search_index, **params):
def item_lookup(self, **params):
def __init__(self, connection=None, nodename=None):
def __init__(self, connection=None):
def __next__(self):
def to_xml(self):
def get_account_balance(self):
def register_hit_type(self, title, description, reward, duration, keywords=None, approval_delay=None, qual_req=None):
def set_email_notification(self, hit_type, email, event_types=None):
def set_rest_notification(self, hit_type, url, event_types=None):
def set_sqs_notification(self, hit_type, queue_url, event_types=None):
def send_test_event_notification(self, hit_type, url, event_types=None, test_event_type='Ping'):
def _set_notification(self, hit_type, transport, destination, request_type, event_types=None, test_event_type=None):
def create_hit(self, hit_type=None, question=None, hit_layout=None, lifetime=datetime.timedelta(days=7), max_assignments=1, title=None, description=None, keywords=None, reward=None, duration=datetime.timedelta(days=7), approval_delay=None, annotation=None, questions=None, qualifications=None, layout_params=None, response_groups=None):
def change_hit_type_of_hit(self, hit_id, hit_type):
def get_reviewable_hits(self, hit_type=None, status='Reviewable', sort_by='Expiration', sort_direction='Ascending', page_size=10, page_number=1):
@staticmethod DCNL def _get_pages(page_size, total_records):
def get_all_hits(self):
def search_hits(self, sort_by='CreationTime', sort_direction='Ascending', page_size=10, page_number=1, response_groups=None):
def get_assignment(self, assignment_id, response_groups=None):
def get_assignments(self, hit_id, status=None, sort_by='SubmitTime', sort_direction='Ascending', page_size=10, page_number=1, response_groups=None):
def approve_assignment(self, assignment_id, feedback=None):
def reject_assignment(self, assignment_id, feedback=None):
def approve_rejected_assignment(self, assignment_id, feedback=None):
def get_file_upload_url(self, assignment_id, question_identifier):
def get_hit(self, hit_id, response_groups=None):
def set_reviewing(self, hit_id, revert=None):
def disable_hit(self, hit_id, response_groups=None):
def dispose_hit(self, hit_id):
def expire_hit(self, hit_id):
def extend_hit(self, hit_id, assignments_increment=None, expiration_increment=None):
def get_help(self, about, help_type='Operation'):
def grant_bonus(self, worker_id, assignment_id, bonus_price, reason):
def block_worker(self, worker_id, reason):
def unblock_worker(self, worker_id, reason):
def notify_workers(self, worker_ids, subject, message_text):
def create_qualification_type(self, name, description, status, keywords=None, retry_delay=None, test=None, answer_key=None, answer_key_xml=None, test_duration=None, auto_granted=False, auto_granted_value=1):
def dispose_qualification_type(self, qualification_type_id):
def search_qualification_types(self, query=None, sort_by='Name', sort_direction='Ascending', page_size=10, page_number=1, must_be_requestable=True, must_be_owned_by_caller=True):
def get_qualification_requests(self, qualification_type_id, sort_by='Expiration', sort_direction='Ascending', page_size=10, page_number=1):
def grant_qualification(self, qualification_request_id, integer_value=1):
def revoke_qualification(self, subject_id, qualification_type_id, reason=None):
def get_qualification_score(self, qualification_type_id, worker_id):
def update_qualification_score(self, qualification_type_id, worker_id, value):
def _process_request(self, request_type, params, marker_elems=None):
def _process_response(self, response, marker_elems=None):
@staticmethod DCNL def get_keywords_as_string(keywords):
@staticmethod DCNL def get_price_as_price(reward):
def _has_expired(self):
def __init__(self, d):
def verify(self, secret_key):
def get_all_vpcs(self, vpc_ids=None, filters=None, dry_run=False):
def create_vpc(self, cidr_block, instance_tenancy=None, dry_run=False):
def delete_vpc(self, vpc_id, dry_run=False):
def modify_vpc_attribute(self, vpc_id, enable_dns_support=None, enable_dns_hostnames=None, dry_run=False):
def get_all_route_tables(self, route_table_ids=None, filters=None, dry_run=False):
def associate_route_table(self, route_table_id, subnet_id, dry_run=False):
def disassociate_route_table(self, association_id, dry_run=False):
def create_route_table(self, vpc_id, dry_run=False):
def delete_route_table(self, route_table_id, dry_run=False):
def _replace_route_table_association(self, association_id, route_table_id, dry_run=False):
def replace_route_table_assocation(self, association_id, route_table_id, dry_run=False):
def replace_route_table_association_with_assoc(self, association_id, route_table_id, dry_run=False):
def create_route(self, route_table_id, destination_cidr_block, gateway_id=None, instance_id=None, interface_id=None, vpc_peering_connection_id=None, dry_run=False):
def replace_route(self, route_table_id, destination_cidr_block, gateway_id=None, instance_id=None, interface_id=None, vpc_peering_connection_id=None, dry_run=False):
def delete_route(self, route_table_id, destination_cidr_block, dry_run=False):
def get_all_network_acls(self, network_acl_ids=None, filters=None):
def associate_network_acl(self, network_acl_id, subnet_id):
def disassociate_network_acl(self, subnet_id, vpc_id=None):
def create_network_acl(self, vpc_id):
def delete_network_acl(self, network_acl_id):
def create_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action, cidr_block, egress=None, icmp_code=None, icmp_type=None, port_range_from=None, port_range_to=None):
def replace_network_acl_entry(self, network_acl_id, rule_number, protocol, rule_action, cidr_block, egress=None, icmp_code=None, icmp_type=None, port_range_from=None, port_range_to=None):
def delete_network_acl_entry(self, network_acl_id, rule_number, egress=None):
def get_all_internet_gateways(self, internet_gateway_ids=None, filters=None, dry_run=False):
def create_internet_gateway(self, dry_run=False):
def delete_internet_gateway(self, internet_gateway_id, dry_run=False):
def attach_internet_gateway(self, internet_gateway_id, vpc_id, dry_run=False):
def detach_internet_gateway(self, internet_gateway_id, vpc_id, dry_run=False):
def get_all_customer_gateways(self, customer_gateway_ids=None, filters=None, dry_run=False):
def create_customer_gateway(self, type, ip_address, bgp_asn, dry_run=False):
def delete_customer_gateway(self, customer_gateway_id, dry_run=False):
def get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None, dry_run=False):
def create_vpn_gateway(self, type, availability_zone=None, dry_run=False):
def delete_vpn_gateway(self, vpn_gateway_id, dry_run=False):
def attach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False):
def detach_vpn_gateway(self, vpn_gateway_id, vpc_id, dry_run=False):
def get_all_subnets(self, subnet_ids=None, filters=None, dry_run=False):
def create_subnet(self, vpc_id, cidr_block, availability_zone=None, dry_run=False):
def delete_subnet(self, subnet_id, dry_run=False):
def get_all_dhcp_options(self, dhcp_options_ids=None, filters=None, dry_run=False):
def create_dhcp_options(self, domain_name=None, domain_name_servers=None, ntp_servers=None, netbios_name_servers=None, netbios_node_type=None, dry_run=False):
def delete_dhcp_options(self, dhcp_options_id, dry_run=False):
def associate_dhcp_options(self, dhcp_options_id, vpc_id, dry_run=False):
def get_all_vpn_connections(self, vpn_connection_ids=None, filters=None, dry_run=False):
def create_vpn_connection(self, type, customer_gateway_id, vpn_gateway_id, static_routes_only=None, dry_run=False):
def delete_vpn_connection(self, vpn_connection_id, dry_run=False):
def disable_vgw_route_propagation(self, route_table_id, gateway_id, dry_run=False):
def enable_vgw_route_propagation(self, route_table_id, gateway_id, dry_run=False):
def create_vpn_connection_route(self, destination_cidr_block, vpn_connection_id, dry_run=False):
def delete_vpn_connection_route(self, destination_cidr_block, vpn_connection_id, dry_run=False):
def get_all_vpc_peering_connections(self, vpc_peering_connection_ids=None, filters=None, dry_run=False):
def create_vpc_peering_connection(self, vpc_id, peer_vpc_id, peer_owner_id=None, dry_run=False):
def delete_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
def reject_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
def accept_vpc_peering_connection(self, vpc_peering_connection_id, dry_run=False):
def get_all_classic_link_vpcs(self, vpc_ids=None, filters=None, dry_run=False):
def attach_classic_link_vpc(self, vpc_id, instance_id, groups, dry_run=False):
def detach_classic_link_vpc(self, vpc_id, instance_id, dry_run=False):
def disable_vpc_classic_link(self, vpc_id, dry_run=False):
def enable_vpc_classic_link(self, vpc_id, dry_run=False):
def __init__(self, connection=None):
def update_classic_link_enabled(self, validate=False, dry_run=False):
def disable_classic_link(self, dry_run=False):
def enable_classic_link(self, dry_run=False):
def attach_classic_instance(self, instance_id, groups, dry_run=False):
def detach_classic_instance(self, instance_id, dry_run=False):
def __init__(self):
def __init__(self, connection=None):
@classmethod DCNL def is_capable(cls, requested_capability):
def get_obj(self, name):
def check_dns_availability(self, cname_prefix):
def create_application(self, application_name, description=None):
def create_application_version(self, application_name, version_label, description=None, s3_bucket=None, s3_key=None, auto_create_application=None):
def create_configuration_template(self, application_name, template_name, solution_stack_name=None, source_configuration_application_name=None, source_configuration_template_name=None, environment_id=None, description=None, option_settings=None):
def create_environment(self, application_name, environment_name, version_label=None, template_name=None, solution_stack_name=None, cname_prefix=None, description=None, option_settings=None, options_to_remove=None, tier_name=None, tier_type=None, tier_version='1.0'):
def create_storage_location(self):
def delete_application(self, application_name, terminate_env_by_force=None):
def delete_application_version(self, application_name, version_label, delete_source_bundle=None):
def delete_configuration_template(self, application_name, template_name):
def delete_environment_configuration(self, application_name, environment_name):
def describe_application_versions(self, application_name=None, version_labels=None):
def describe_applications(self, application_names=None):
def describe_configuration_options(self, application_name=None, template_name=None, environment_name=None, solution_stack_name=None, options=None):
def describe_configuration_settings(self, application_name, template_name=None, environment_name=None):
def describe_environment_resources(self, environment_id=None, environment_name=None):
def describe_environments(self, application_name=None, version_label=None, environment_ids=None, environment_names=None, include_deleted=None, included_deleted_back_to=None):
def describe_events(self, application_name=None, version_label=None, template_name=None, environment_id=None, environment_name=None, request_id=None, severity=None, start_time=None, end_time=None, max_records=None, next_token=None):
def list_available_solution_stacks(self):
def rebuild_environment(self, environment_id=None, environment_name=None):
def request_environment_info(self, info_type='tail', environment_id=None, environment_name=None):
def restart_app_server(self, environment_id=None, environment_name=None):
def retrieve_environment_info(self, info_type='tail', environment_id=None, environment_name=None):
def swap_environment_cnames(self, source_environment_id=None, source_environment_name=None, destination_environment_id=None, destination_environment_name=None):
def terminate_environment(self, environment_id=None, environment_name=None, terminate_resources=None):
def update_application(self, application_name, description=None):
def update_application_version(self, application_name, version_label, description=None):
def update_configuration_template(self, application_name, template_name, description=None, option_settings=None, options_to_remove=None):
def update_environment(self, environment_id=None, environment_name=None, version_label=None, template_name=None, description=None, option_settings=None, options_to_remove=None, tier_name=None, tier_type=None, tier_version='1.0'):
def validate_configuration_settings(self, application_name, option_settings, template_name=None, environment_name=None):
def create_hapg(self, label):
def create_hsm(self, subnet_id, ssh_key, iam_role_arn, subscription_type, eni_ip=None, external_id=None, client_token=None, syslog_ip=None):
def create_luna_client(self, certificate, label=None):
def delete_hapg(self, hapg_arn):
def delete_hsm(self, hsm_arn):
def delete_luna_client(self, client_arn):
def describe_hapg(self, hapg_arn):
def describe_hsm(self, hsm_arn=None, hsm_serial_number=None):
def describe_luna_client(self, client_arn=None, certificate_fingerprint=None):
def get_config(self, client_arn, client_version, hapg_list):
def list_available_zones(self):
def list_hapgs(self, next_token=None):
def list_hsms(self, next_token=None):
def list_luna_clients(self, next_token=None):
def modify_hapg(self, hapg_arn, label=None, partition_serial_list=None):
def modify_hsm(self, hsm_arn, subnet_id=None, eni_ip=None, iam_role_arn=None, external_id=None, syslog_ip=None):
def modify_luna_client(self, client_arn, certificate):
def authorize_cache_security_group_ingress(self, cache_security_group_name, ec2_security_group_name, ec2_security_group_owner_id):
def create_cache_cluster(self, cache_cluster_id, num_cache_nodes=None, cache_node_type=None, engine=None, replication_group_id=None, engine_version=None, cache_parameter_group_name=None, cache_subnet_group_name=None, cache_security_group_names=None, security_group_ids=None, snapshot_arns=None, preferred_availability_zone=None, preferred_maintenance_window=None, port=None, notification_topic_arn=None, auto_minor_version_upgrade=None):
def create_cache_parameter_group(self, cache_parameter_group_name, cache_parameter_group_family, description):
def create_cache_security_group(self, cache_security_group_name, description):
def create_cache_subnet_group(self, cache_subnet_group_name, cache_subnet_group_description, subnet_ids):
def create_replication_group(self, replication_group_id, primary_cluster_id, replication_group_description):
def delete_cache_cluster(self, cache_cluster_id):
def delete_cache_parameter_group(self, cache_parameter_group_name):
def delete_cache_security_group(self, cache_security_group_name):
def delete_cache_subnet_group(self, cache_subnet_group_name):
def delete_replication_group(self, replication_group_id):
def describe_cache_clusters(self, cache_cluster_id=None, max_records=None, marker=None, show_cache_node_info=None):
def describe_cache_engine_versions(self, engine=None, engine_version=None, cache_parameter_group_family=None, max_records=None, marker=None, default_only=None):
def describe_cache_parameter_groups(self, cache_parameter_group_name=None, max_records=None, marker=None):
def describe_cache_parameters(self, cache_parameter_group_name, source=None, max_records=None, marker=None):
def describe_cache_security_groups(self, cache_security_group_name=None, max_records=None, marker=None):
def describe_cache_subnet_groups(self, cache_subnet_group_name=None, max_records=None, marker=None):
def describe_engine_default_parameters(self, cache_parameter_group_family, max_records=None, marker=None):
def describe_events(self, source_identifier=None, source_type=None, start_time=None, end_time=None, duration=None, max_records=None, marker=None):
def describe_replication_groups(self, replication_group_id=None, max_records=None, marker=None):
def describe_reserved_cache_nodes(self, reserved_cache_node_id=None, reserved_cache_nodes_offering_id=None, cache_node_type=None, duration=None, product_description=None, offering_type=None, max_records=None, marker=None):
def describe_reserved_cache_nodes_offerings(self, reserved_cache_nodes_offering_id=None, cache_node_type=None, duration=None, product_description=None, offering_type=None, max_records=None, marker=None):
def modify_cache_cluster(self, cache_cluster_id, num_cache_nodes=None, cache_node_ids_to_remove=None, cache_security_group_names=None, security_group_ids=None, preferred_maintenance_window=None, notification_topic_arn=None, cache_parameter_group_name=None, notification_topic_status=None, apply_immediately=None, engine_version=None, auto_minor_version_upgrade=None):
def modify_cache_parameter_group(self, cache_parameter_group_name, parameter_name_values):
def modify_cache_subnet_group(self, cache_subnet_group_name, cache_subnet_group_description=None, subnet_ids=None):
def modify_replication_group(self, replication_group_id, replication_group_description=None, cache_security_group_names=None, security_group_ids=None, preferred_maintenance_window=None, notification_topic_arn=None, cache_parameter_group_name=None, notification_topic_status=None, apply_immediately=None, engine_version=None, auto_minor_version_upgrade=None, primary_cluster_id=None):
def purchase_reserved_cache_nodes_offering(self, reserved_cache_nodes_offering_id, reserved_cache_node_id=None, cache_node_count=None):
def reboot_cache_cluster(self, cache_cluster_id, cache_node_ids_to_reboot):
def reset_cache_parameter_group(self, cache_parameter_group_name, parameter_name_values, reset_all_parameters=None):
def revoke_cache_security_group_ingress(self, cache_security_group_name, ec2_security_group_name, ec2_security_group_owner_id):
def __init__(self, connection=None, origin=None, enabled=False, caller_reference='', cnames=None, comment='', trusted_signers=None, default_root_object=None, logging=None):
def update(self, enabled=None, cnames=None, comment=None):
def enable(self):
def disable(self):
def delete(self):
def get_objects(self):
def set_permissions(self, object, replace=False):
def set_permissions_all(self, replace=False):
def add_object(self, name, content, headers=None, replace=True):
def create_signed_url(self, url, keypair_id, expire_time=None, valid_after_time=None, ip_address=None, policy_url=None, private_key_file=None, private_key_string=None):
def _create_signing_params(self, url, keypair_id, expire_time=None, valid_after_time=None, ip_address=None, policy_url=None, private_key_file=None, private_key_string=None):
@staticmethod DCNL def _canned_policy(resource, expires):
@staticmethod DCNL def _custom_policy(resource, expires=None, valid_after=None, ip_address=None):
@staticmethod DCNL def _sign_string(message, private_key_file=None, private_key_string=None):
@staticmethod DCNL def _url_base64_encode(msg):
def update(self, enabled=None, cnames=None, comment=None):
def create_invalidation_request(self, distribution_id, paths, caller_reference=None):
def get_invalidation_requests(self, distribution_id, marker=None, max_items=None):
def __init__(self, dns_name=None, origin_access_identity=None):
def __init__(self, dns_name=None, http_port=80, https_port=443, origin_protocol_policy=None):
def __init__(self, paths=None, connection=None, distribution=None, caller_reference=''):
def add(self, path):
def remove(self, path):
def escape(self, p):
def to_xml(self):
def __iter__(self):
def get_distribution(self):
def get_invalidation_request(self):
def describe_cluster(self, cluster_id):
def describe_jobflow(self, jobflow_id):
def describe_jobflows(self, states=None, jobflow_ids=None, created_after=None, created_before=None):
def describe_step(self, cluster_id, step_id):
def list_bootstrap_actions(self, cluster_id, marker=None):
def list_clusters(self, created_after=None, created_before=None, cluster_states=None, marker=None):
def list_instance_groups(self, cluster_id, marker=None):
def list_instances(self, cluster_id, instance_group_id=None, instance_group_types=None, marker=None):
def list_steps(self, cluster_id, step_states=None, marker=None):
def add_tags(self, resource_id, tags):
def remove_tags(self, resource_id, tags):
def terminate_jobflow(self, jobflow_id):
def terminate_jobflows(self, jobflow_ids):
def add_jobflow_steps(self, jobflow_id, steps):
def add_instance_groups(self, jobflow_id, instance_groups):
def modify_instance_groups(self, instance_group_ids, new_sizes):
def run_jobflow(self, name, log_uri=None, ec2_keyname=None, availability_zone=None, master_instance_type='m1.small', slave_instance_type='m1.small', num_instances=1, action_on_failure='TERMINATE_JOB_FLOW', keep_alive=False, enable_debugging=False, hadoop_version=None, steps=None, bootstrap_actions=[], instance_groups=None, additional_info=None, ami_version=None, api_params=None, visible_to_all_users=None, job_flow_role=None, service_role=None):
def set_termination_protection(self, jobflow_id, termination_protection_status):
def set_visible_to_all_users(self, jobflow_id, visibility):
def _build_instance_common_args(self, ec2_keyname, availability_zone, keep_alive, hadoop_version):
def _build_instance_count_and_type_args(self, master_instance_type, slave_instance_type, num_instances):
def _build_instance_group_args(self, instance_group):
def _build_instance_group_list_args(self, instance_groups):
def jar(self):
def args(self):
def main_class(self):
def __init__(self, name, jar, main_class=None, action_on_failure='TERMINATE_JOB_FLOW', step_args=None):
def __init__(self, name, mapper, reducer=None, combiner=None, action_on_failure='TERMINATE_JOB_FLOW', cache_files=None, cache_archives=None, step_args=None, input=None, output=None, jar='/home/hadoop/contrib/streaming/hadoop-streaming.jar'):
def delete(self):
def get_stemming(self):
def get_stopwords(self):
def get_synonyms(self):
def get_access_policies(self):
def index_documents(self):
def get_index_fields(self, field_names=None):
def create_index_field(self, field_name, field_type, default='', facet=False, result=False, searchable=False, source_attributes=[]):
def get_rank_expressions(self, rank_names=None):
def create_rank_expression(self, name, expression):
def next_page(self):
def to_params(self):
def search(self, q=None, bq=None, rank=None, return_fields=None, size=10, start=0, facet=None, facet_constraints=None, facet_sort=None, facet_top_n=None, t=None):
def __call__(self, query):
def get_all_paged(self, query, per_page):
def get_all_hits(self, query):
def get_num_hits(self, query):
def create_domain(self, domain_name):
def define_index_field(self, domain_name, field_name, field_type, default='', facet=False, result=False, searchable=False, source_attributes=None):
def define_rank_expression(self, domain_name, rank_name, rank_expression):
def delete_domain(self, domain_name):
def delete_index_field(self, domain_name, field_name):
def delete_rank_expression(self, domain_name, rank_name):
def describe_default_search_field(self, domain_name):
def describe_domains(self, domain_names=None):
def describe_index_fields(self, domain_name, field_names=None):
def describe_rank_expressions(self, domain_name, rank_names=None):
def describe_service_access_policies(self, domain_name):
def describe_stemming_options(self, domain_name):
def describe_stopword_options(self, domain_name):
def describe_synonym_options(self, domain_name):
def index_documents(self, domain_name):
def update_default_search_field(self, domain_name, default_search_field):
def update_service_access_policies(self, domain_name, access_policies):
def update_stemming_options(self, domain_name, stems):
def update_stopword_options(self, domain_name, stopwords):
def update_synonym_options(self, domain_name, synonyms):
def refresh(self, data=None):
def to_json(self):
def save(self):
def wait_for_state(self, state):
def new_statement(self, arn, ip):
def allow_search_ip(self, ip):
def allow_doc_ip(self, ip):
def disallow_search_ip(self, ip):
def disallow_doc_ip(self, ip):
def add(self, _id, version, fields, lang='en'):
def delete(self, _id, version):
def get_sdf(self):
def clear_sdf(self):
def add_sdf_from_s3(self, key_obj):
def commit(self):
def _check_num_ops(self, type_, response_num):
def list_domains(self, domain_names=None):
def create_domain(self, domain_name):
def lookup(self, domain_name):
def __init__(self, name, contained_key):
def delete_key(self, key_name, headers=None, version_id=None, mfa_token=None):
def get_all_keys(self, headers=None, **params):
def get_key(self, key_name, headers=None, version_id=None, key_type=Key.KEY_REGULAR_FILE):
def new_key(self, key_name=None, key_type=Key.KEY_REGULAR_FILE):
def get_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False):
def set_contents_from_file(self, fp, headers=None, replace=True, cb=None, num_cb=10, policy=None, md5=None):
def get_contents_to_file(self, fp, headers=None, cb=None, num_cb=None, torrent=False, version_id=None, res_download_handler=None, response_headers=None):
def get_contents_as_string(self, headers=None, cb=None, num_cb=10, torrent=False):
def close(self):
def _build_dict_as_list_params(self, params, dictionary, name):
def get_all_topics(self, next_token=None):
def get_topic_attributes(self, topic):
def set_topic_attributes(self, topic, attr_name, attr_value):
def add_permission(self, topic, label, account_ids, actions):
def remove_permission(self, topic, label):
def create_topic(self, topic):
def delete_topic(self, topic):
def publish(self, topic=None, message=None, subject=None, target_arn=None, message_structure=None, message_attributes=None):
def subscribe(self, topic, protocol, endpoint):
def subscribe_sqs_queue(self, topic, queue):
def confirm_subscription(self, topic, token, authenticate_on_unsubscribe=False):
def unsubscribe(self, subscription):
def get_all_subscriptions(self, next_token=None):
def get_all_subscriptions_by_topic(self, topic, next_token=None):
def create_platform_application(self, name=None, platform=None, attributes=None):
def set_platform_application_attributes(self, platform_application_arn=None, attributes=None):
def get_platform_application_attributes(self, platform_application_arn=None):
def list_platform_applications(self, next_token=None):
def list_endpoints_by_platform_application(self, platform_application_arn=None, next_token=None):
def delete_platform_application(self, platform_application_arn=None):
def create_platform_endpoint(self, platform_application_arn=None, token=None, custom_user_data=None, attributes=None):
def delete_endpoint(self, endpoint_arn=None):
def set_endpoint_attributes(self, endpoint_arn=None, attributes=None):
def get_endpoint_attributes(self, endpoint_arn=None):
def __init__(self, layer2, response):
@classmethod DCNL def create_from_schema(cls, layer2, name, schema):
def update_from_response(self, response):
def refresh(self, wait_for_active=False, retry_seconds=5):
def update_throughput(self, read_units, write_units):
def delete(self):
def get_item(self, hash_key, range_key=None, attributes_to_get=None, consistent_read=False, item_class=Item):
def has_item(self, hash_key, range_key=None, consistent_read=False):
def new_item(self, hash_key=None, range_key=None, attrs=None, item_class=Item):
def query(self, hash_key, *args, **kw):
def scan(self, *args, **kw):
def batch_get_item(self, keys, attributes_to_get=None):
def add_attribute(self, attr_name, attr_value):
def delete_attribute(self, attr_name, attr_value=None):
def put_attribute(self, attr_name, attr_value):
def save(self, expected_value=None, return_values=None):
def delete(self, expected_value=None, return_values=None):
def put(self, expected_value=None, return_values=None):
def __setitem__(self, key, value):
def __delitem__(self, key):
def make_request(self, action, body='', object_hook=None):
def list_tables(self, limit=None, start_table=None):
def describe_table(self, table_name):
def create_table(self, table_name, schema, provisioned_throughput):
def update_table(self, table_name, provisioned_throughput):
def delete_table(self, table_name):
def get_item(self, table_name, key, attributes_to_get=None, consistent_read=False, object_hook=None):
def batch_get_item(self, request_items, object_hook=None):
def batch_write_item(self, request_items, object_hook=None):
def put_item(self, table_name, item, expected=None, return_values=None, object_hook=None):
def update_item(self, table_name, key, attribute_updates, expected=None, return_values=None, object_hook=None):
def delete_item(self, table_name, key, expected=None, return_values=None, object_hook=None):
def query(self, table_name, hash_key_value, range_key_conditions=None, attributes_to_get=None, limit=None, consistent_read=False, scan_index_forward=True, exclusive_start_key=None, object_hook=None, count=False):
def scan(self, table_name, scan_filter=None, attributes_to_get=None, limit=None, exclusive_start_key=None, object_hook=None, count=False):
def to_dict(self):
def to_dict(self):
def add_batch(self, table, keys, attributes_to_get=None, consistent_read=False):
def resubmit(self):
def to_dict(self):
def add_batch(self, table, puts=None, deletes=None):
def to_dict(self):
@classmethod DCNL def create(cls, hash_key, range_key=None):
def encode(self, attr):
def decode(self, attr):
@property DCNL def count(self):
@property DCNL def scanned_count(self):
@property DCNL def consumed_units(self):
@property DCNL def response(self):
def next_response(self):
def use_decimals(self, use_boolean=False):
def dynamize_attribute_updates(self, pending_updates):
def dynamize_range_key_condition(self, range_key_condition):
def dynamize_scan_filter(self, scan_filter):
def dynamize_expected_value(self, expected_value):
def dynamize_last_evaluated_key(self, last_evaluated_key):
def build_key_from_values(self, schema, hash_key, range_key=None):
def new_batch_list(self):
def new_batch_write_list(self):
def list_tables(self, limit=None):
def describe_table(self, name):
def table_from_schema(self, name, schema):
def get_table(self, name):
def create_table(self, name, schema, read_units, write_units):
def update_throughput(self, table, read_units, write_units):
def delete_table(self, table):
def create_schema(self, hash_key_name, hash_key_proto_value, range_key_name=None, range_key_proto_value=None):
def get_item(self, table, hash_key, range_key=None, attributes_to_get=None, consistent_read=False, item_class=Item):
def batch_get_item(self, batch_list):
def batch_write_item(self, batch_list):
def put_item(self, item, expected_value=None, return_values=None):
def update_item(self, item, expected_value=None, return_values=None):
def delete_item(self, item, expected_value=None, return_values=None):
def query(self, table, hash_key, range_key_condition=None, attributes_to_get=None, request_limit=None, max_results=None, consistent_read=False, scan_index_forward=True, exclusive_start_key=None, item_class=Item, count=False):
def scan(self, table, scan_filter=None, attributes_to_get=None, request_limit=None, max_results=None, exclusive_start_key=None, item_class=Item, count=False):
def is_package(self, fullname):
def get_code(self, fullname):
def construct_endpoint(self, service_name, region_name=None):
def get_available_partitions(self):
def get_available_endpoints(self, service_name, partition_name='aws', allow_non_regional=False):
def __init__(self, endpoint_data):
def __init__(self, host, config, provider):
def add_auth(self, http_request):
def setup_class(cls):
def teardown_class(cls):
def test_find(self):
def test_like_filter(self):
def test_equals_filter(self):
def test_or_filter(self):
def test_and_filter(self):
def test_none_filter(self):
def test_greater_filter(self):
def test_less_filter(self):
def test_query_on_list(self):
def test_like(self):
def setup_class(cls):
def teardown_class(cls):
def test_list_order(self):
def test_old_compat(self):
def test_query_equals(self):
def test_query_not_equals(self):
def setup_class(cls):
def teardown_class(cls):
def test_sequence_generator_no_rollover(self):
def test_sequence_generator_with_rollover(self):
def test_sequence_simple_int(self):
def test_fib(self):
def test_sequence_fib(self):
def test_sequence_string(self):
def set_etag(self):
def compute_md5(self, fp):
def __repr__(self):
def test_tagging_from_objects(self):
def testSetAclXml(self):
def test_non_resumable_upload(self):
def test_upload_without_persistent_tracker(self):
def test_failed_upload_with_persistent_tracker(self):
def test_retryable_exception_recovery(self):
def test_broken_pipe_recovery(self):
def test_non_retryable_exception_handling(self):
def test_failed_and_restarted_upload_with_persistent_tracker(self):
def test_multiple_in_process_failures_then_succeed(self):
def test_multiple_in_process_failures_then_succeed_with_tracker_file(self):
def test_upload_with_inital_partial_upload_before_failure(self):
def test_empty_file_upload(self):
def test_upload_retains_metadata(self):
def test_upload_with_file_size_change_between_starts(self):
def test_upload_with_file_size_change_during_upload(self):
def test_upload_with_file_content_change_during_upload(self):
def test_upload_with_content_length_header_set(self):
def test_upload_with_syntactically_invalid_tracker_uri(self):
def test_upload_with_invalid_upload_id_in_tracker_file(self):
def test_upload_with_unwritable_tracker_file(self):
def _GetConnection(self):
def _MakeTempName(self):
def _MakeBucketName(self):
def _MakeBucket(self):
def _MakeKey(self, data='', bucket=None, set_contents=True):
def _MakeVersionedBucket(self):
def _MakeTempDir(self):
def call(self, total_bytes_transferred, unused_total_size):
def test_non_resumable_download(self):
def test_download_without_persistent_tracker(self):
def test_failed_download_with_persistent_tracker(self):
def test_retryable_exception_recovery(self):
def test_broken_pipe_recovery(self):
def test_non_retryable_exception_handling(self):
def test_failed_and_restarted_download_with_persistent_tracker(self):
def test_multiple_in_process_failures_then_succeed(self):
def test_multiple_in_process_failures_then_succeed_with_tracker_file(self):
def test_download_with_inital_partial_download_before_failure(self):
def test_zero_length_object_download(self):
def test_download_with_invalid_tracker_etag(self):
def test_download_with_inconsistent_etag_in_tracker(self):
def test_download_with_unwritable_tracker_file(self):
def test_read_write(self):
def test_get_all_keys(self):
def test_bucket_lookup(self):
def test_metadata(self):
def test_list_iterator(self):
def test_acl(self):
def test_logging(self):
def test_copy_key(self):
def test_default_object_acls(self):
def test_default_object_acls_storage_uri(self):
def test_cors_xml_bucket(self):
def test_cors_xml_storage_uri(self):
def test_lifecycle_config_bucket(self):
def test_lifecycle_config_storage_uri(self):
def run_decider(self):
def run_worker(self):
def sample_service_call(self, conn):
def setUp(self):
def tearDown(self):
def post_terminate_cleanup(self):
def terminate_instances(self):
def test_create_health_check_invalid_request_interval(self):
def test_create_health_check_invalid_failure_threshold(self):
def test_lookup_hash(self):
def test_lookup_hash_and_range(self):
def assert_request_parameters(self, params, ignore_params_values=None):
def test_cloudsearch_results_meta(self):
def test_cloudsearch_results_info(self):
def test_cloudsearch_results_matched(self):
def test_cloudsearch_results_hits(self):
def test_cloudsearch_results_iterator(self):
def test_cloudsearch_results_internal_consistancy(self):
def test_cloudsearch_search_nextpage(self):
def test_cloudsearch_connect_result_endpoints(self):
def test_cloudsearch_connect_result_statuses(self):
def test_cloudsearch_connect_result_details(self):
def test_cloudsearch_deletion(self):
def test_cloudsearch_index_documents(self):
def test_cloudsearch_index_documents_resp(self):
def test_cloudsearch_add_basics(self):
def test_cloudsearch_add_single_basic(self):
def test_cloudsearch_add_single_fields(self):
def test_cloudsearch_add_single_result(self):
def test_cloudsearch_add_basics(self):
def test_cloudsearch_add_results(self):
def test_cloudsearch_delete(self):
def test_cloudsearch_delete_results(self):
def _setup_mock(self):
def _verify_attributes(self, attributes, attr_tests):
def test_get_all_lb_attributes(self):
def test_get_lb_attribute(self):
def test_modify_lb_attribute(self):
def test_lb_get_attributes(self):
def test_lb_is_cross_zone_load_balancing(self):
def test_lb_enable_cross_zone_load_balancing(self):
def test_lb_disable_cross_zone_load_balancing(self):
def test_lb_get_connection_settings(self):
def _get_snapshots(self):
def test_trim_defaults(self):
def test_trim_months(self):
def test_none_token(self):
def test_binary_input(self):
def test_non_binary_input_for_blobs_fails(self):
def test_binary_ouput(self):
def test_multi_commands(self):
def test_connection_close(self):
def test_required_launch_params(self):
def test_wildcard_escape(self):
def test_manual_pagination(self, num_invals=30, max_items=4):
def test_auto_pagination(self, num_invals=1024):
def test_encode_custom_policy_1(self):
def test_encode_custom_policy_2(self):
def test_sign_canned_policy(self):
def test_sign_canned_policy_pk_file(self):
def test_sign_canned_policy_pk_file_name(self):
def test_sign_canned_policy_pk_file_like(self):
def test_sign_canned_policy_unicode(self):
def test_sign_custom_policy_1(self):
def test_sign_custom_policy_2(self):
def test_create_canned_policy(self):
def test_custom_policy_expires_and_policy_url(self):
def test_custom_policy_valid_after(self):
def test_custom_policy_ip_address(self):
def test_custom_policy_ip_range(self):
def test_custom_policy_all(self):
def test_params_canned_policy(self):
def test_canned_policy(self):
def test_bidprice_missing_spot(self):
def test_bidprice_missing_ondemand(self):
def test_bidprice_Decimal(self):
def test_bidprice_float(self):
def test_bidprice_string(self):
def test_cloudsearch_results_meta(self):
def test_cloudsearch_results_info(self):
def test_cloudsearch_results_matched(self):
def test_cloudsearch_results_hits(self):
def test_cloudsearch_results_iterator(self):
def test_cloudsearch_results_internal_consistancy(self):
def test_cloudsearch_search_nextpage(self):
def test_cloudsearch_connect_result_endpoints(self):
def test_cloudsearch_connect_result_statuses(self):
def test_cloudsearch_connect_result_details(self):
def test_cloudsearch_deletion(self):
def test_cloudsearch_index_documents(self):
def test_cloudsearch_index_documents_resp(self):
def test_cloudsearch_add_basics(self):
def test_cloudsearch_add_single_basic(self):
def test_cloudsearch_add_single_fields(self):
def test_cloudsearch_add_single_result(self):
def test_cloudsearch_add_basics(self):
def test_cloudsearch_add_results(self):
def test_cloudsearch_delete(self):
def test_cloudsearch_delete_results(self):
def clstest(self, cls):
def test_decoding_full_doc(self):
def test_pickle_deserialized_version(self):
def __new__(cls, s, *args):
@property DCNL def msg(self):
def __new__(cls, ace, acl, permission, principals, context):
@property DCNL def authenticated_userid(self):
@property DCNL def unauthenticated_userid(self):
@property DCNL def effective_principals(self):
def has_permission(self, permission, context=None):
def permits(self, context, principals, permission):
def principals_allowed_by_permission(self, context, permission):
def invoke_exception_view(self, exc_info=None, request=None, secure=True, reraise=False):
@classmethod DCNL def make_property(cls, callable, name=None, reify=False):
@classmethod DCNL def apply_properties(cls, target, properties):
@classmethod DCNL def set_property(cls, target, callable, name=None, reify=False):
def add_property(self, callable, name=None, reify=False):
def apply(self, target):
def set_property(self, callable, name=None, reify=False):
def add(self, item):
def _remove_by_id(self, oid):
def remove(self, item):
def empty(self):
def remove(self, name):
def add(self, name, val, after=None, before=None):
def sorted(self):
def resolve(self, spec):
def resolve(self, dotted):
def maybe_resolve(self, dotted):
def _pkg_resources_style(self, value, package):
def _zope_dottedname_style(self, value, package):
def test_reset_reify(self):
def test_reset_reify(self):
def test__process_response_callback_adding_response_callback(self):
def translate(self, tstring, domain=None, mapping=None):
def pluralize(self, singular, plural, n, domain=None, mapping=None):
def __init__(self, fileobj=None, domain=DEFAULT_DOMAIN):
@classmethod DCNL def load(cls, dirname=None, locales=None, domain=DEFAULT_DOMAIN):
def add(self, translations, merge=True):
def merge(self, translations):
def dgettext(self, domain, message):
def ldgettext(self, domain, message):
def dugettext(self, domain, message):
def dngettext(self, domain, singular, plural, num):
def ldngettext(self, domain, singular, plural, num):
def dungettext(self, domain, singular, plural, num):
@reify DCNL def localizer(self):
@action_method DCNL def set_authentication_policy(self, policy):
@action_method DCNL def set_authorization_policy(self, policy):
@action_method DCNL def set_default_permission(self, permission):
def add_permission(self, permission_name):
@action_method DCNL def set_default_csrf_options(self, require_csrf=True, token='csrf_token', header='X-CSRF-Token', safe_methods=('GET', 'HEAD', 'OPTIONS', 'TRACE'), callback=None):
@action_method DCNL def set_csrf_storage_policy(self, policy):
def setup_registry(self, settings=None, root_factory=None, authentication_policy=None, authorization_policy=None, renderers=None, debug_logger=None, locale_negotiator=None, request_factory=None, response_factory=None, default_permission=None, session_factory=None, default_view_mapper=None, exceptionresponse_view=default_exceptionresponse_view):
def _fix_registry(self):
def action(self, discriminator, callable=None, args=(), kw=None, order=0, introspectables=(), **extra):
def commit(self):
def include(self, callable, route_prefix=None):
def add_directive(self, name, directive, action_wrap=True):
def with_package(self, package):
def maybe_dotted(self, dotted):
def absolute_asset_spec(self, relative_spec):
def begin(self, request=_marker):
def end(self):
def scan(self, package=None, categories=None, onerror=None, ignore=None, **kw):
def make_wsgi_app(self):
def processSpec(self, spec):
def action(self, discriminator, callable=None, args=(), kw=None, order=0, includepath=(), info=None, introspectables=(), **extra):
def execute_actions(self, clear=True, introspector=None):
@action_method DCNL def set_locale_negotiator(self, negotiator):
@action_method DCNL def add_translation_dirs(self, *specs, **kw):
def add_settings(self, settings=None, **kw):
def get_settings(self):
def get_resource_filename(self, manager, resource_name):
def get_resource_stream(self, manager, resource_name):
def get_resource_string(self, manager, resource_name):
def get_data(self, path):
def is_package(self, fullname):
def get_code(self, fullname):
def get_source(self, fullname):
@action_method DCNL def override_asset(self, to_override, override_with, _override=None):
def testing_securitypolicy(self, userid=None, groupids=(), permissive=True, remember_result=None, forget_result=None):
def testing_resources(self, resources):
@action_method DCNL def testing_add_subscriber(self, event_iface=None):
def testing_add_renderer(self, path, renderer=None):
@action_method DCNL def add_renderer(self, name, factory):
def hook_zca(self):
def unhook_zca(self):
@action_method DCNL def add_route(self, name, pattern=None, permission=None, factory=None, for_=None, header=None, xhr=None, accept=None, path_info=None, request_method=None, request_param=None, traverse=None, custom_predicates=(), use_global_views=False, path=None, pregenerator=None, static=False, **predicates):
@action_method DCNL def add_route_predicate(self, name, factory, weighs_more_than=None, weighs_less_than=None):
def get_routes_mapper(self):
def add_tween(self, tween_factory, under=None, over=None):
@viewdefaults DCNL @action_method DCNL def add_view(self, view=None, name='', for_=None, permission=None, request_type=None, route_name=None, request_method=None, request_param=None, containment=None, attr=None, renderer=None, wrapper=None, xhr=None, accept=None, header=None, path_info=None, custom_predicates=(), context=None, decorator=None, mapper=None, http_cache=None, match_param=None, check_csrf=None, require_csrf=None, exception_only=False, **view_options):
@action_method DCNL def add_view_predicate(self, name, factory, weighs_more_than=None, weighs_less_than=None):
@action_method DCNL def add_view_deriver(self, deriver, name=None, under=None, over=None):
def derive_view(self, view, attr=None, renderer=None):
@viewdefaults DCNL @action_method DCNL def add_forbidden_view(self, view=None, attr=None, renderer=None, wrapper=None, route_name=None, request_type=None, request_method=None, request_param=None, containment=None, xhr=None, accept=None, header=None, path_info=None, custom_predicates=(), decorator=None, mapper=None, match_param=None, **view_options):
@viewdefaults DCNL @action_method DCNL def add_notfound_view(self, view=None, attr=None, renderer=None, wrapper=None, route_name=None, request_type=None, request_method=None, request_param=None, containment=None, xhr=None, accept=None, header=None, path_info=None, custom_predicates=(), decorator=None, mapper=None, match_param=None, append_slash=False, **view_options):
@viewdefaults DCNL @action_method DCNL def add_exception_view(self, view=None, context=None, **view_options):
@action_method DCNL def set_view_mapper(self, mapper):
@action_method DCNL def add_static_view(self, name, path, **kw):
def add_cache_buster(self, path, cachebust, explicit=False):
@action_method DCNL def set_root_factory(self, factory):
@action_method DCNL def set_session_factory(self, factory):
@action_method DCNL def set_request_factory(self, factory):
@action_method DCNL def set_response_factory(self, factory):
@action_method DCNL def add_request_method(self, callable=None, name=None, property=False, reify=False):
@action_method DCNL def set_request_property(self, callable, name=None, reify=False):
@action_method DCNL def set_execution_policy(self, policy):
@action_method DCNL def add_subscriber(self, subscriber, iface=None, **predicates):
@action_method DCNL def add_subscriber_predicate(self, name, factory, weighs_more_than=None, weighs_less_than=None):
@action_method DCNL def add_response_adapter(self, adapter, type_or_iface):
@action_method DCNL def add_traverser(self, adapter, iface=None):
@action_method DCNL def add_resource_url_adapter(self, adapter, resource_iface=None):
def loads(self, bstruct):
def dumps(self, appstruct):
def invoke_subrequest(self, request, use_tweens=False):
def request_context(self, environ):
def invoke_request(self, request, _use_tweens=True):
def __call__(self, environ, start_response):
def __getattr__(self, k):
def assert_(self, **kw):
def __init__(self, __name__=None, __parent__=None, __provides__=None, **kw):
def __setitem__(self, name, val):
def __getitem__(self, name):
def values(self):
def items(self):
def keys(self):
def clone(self, __name__=_marker, __parent__=_marker, **kw):
def _find_view(self, request):
def pre(self, command, output_dir, vars):
def post(self, command, output_dir, vars):
def render_template(self, content, vars, filename=None):
def template_dir(self):
def pre(self, command, output_dir, vars):
def post(self, command, output_dir, vars):
def parse_manifest(self, content):
@property DCNL def manifest(self):
def __init__(self, serializer=json.dumps, adapters=(), **kw):
def add_adapter(self, type_or_iface, adapter):
def __call__(self, info):
def __call__(self, info):
def authenticated_userid(self, request):
def effective_principals(self, request):
def authenticated_userid(self, request):
def unauthenticated_userid(self, request):
def effective_principals(self, request):
def remember(self, request, userid, **kw):
def forget(self, request):
def unauthenticated_userid(self, request):
def remember(self, request, userid, **kw):
def forget(self, request):
def unauthenticated_userid(self, request):
def remember(self, request, userid, **kw):
def forget(self, request):
def identify(self, request):
def forget(self, request):
def remember(self, request, userid, max_age=None, tokens=()):
def remember(self, request, userid, **kw):
def forget(self, request):
def unauthenticated_userid(self, request):
def remember(self, request, userid, **kw):
def forget(self, request):
def new_csrf_token(self, request):
def get_csrf_token(self, request):
def check_csrf_token(self, request, supplied_token):
def new_csrf_token(self, request):
def get_csrf_token(self, request):
def check_csrf_token(self, request, supplied_token):
def new_csrf_token(self, request):
def get_csrf_token(self, request):
def check_csrf_token(self, request, supplied_token):
def _partial_application_url(self, scheme=None, host=None, port=None):
def route_url(self, route_name, *elements, **kw):
def route_path(self, route_name, *elements, **kw):
def resource_url(self, resource, *elements, **kw):
def resource_path(self, resource, *elements, **kw):
def static_url(self, path, **kw):
def static_path(self, path, **kw):
def current_route_url(self, *elements, **kw):
def current_route_path(self, *elements, **kw):
def add_response_callback(self, callback):
def add_finished_callback(self, callback):
@reify DCNL def session(self):
@reify DCNL def response(self):
def is_response(self, ob):
@classmethod DCNL def create_new(cls):
@classmethod DCNL def enqueue(cls, job_id, additional_job_params=None):
@classmethod DCNL def register_start(cls, job_id, metadata=None):
@classmethod DCNL def register_completion(cls, job_id, output_list):
@classmethod DCNL def _compress_output_list(cls, output_list, test_only_max_output_len_chars=None):
@classmethod DCNL def register_failure(cls, job_id, error):
@classmethod DCNL def cancel(cls, job_id, user_id):
@classmethod DCNL def is_active(cls, job_id):
@classmethod DCNL def has_finished(cls, job_id):
@classmethod DCNL def cancel_all_unfinished_jobs(cls, user_id):
@classmethod DCNL def _real_enqueue(cls, job_id, additional_job_params):
@classmethod DCNL def get_status_code(cls, job_id):
@classmethod DCNL def get_time_queued_msec(cls, job_id):
@classmethod DCNL def get_time_started_msec(cls, job_id):
@classmethod DCNL def get_time_finished_msec(cls, job_id):
@classmethod DCNL def get_metadata(cls, job_id):
@classmethod DCNL def get_output(cls, job_id):
@classmethod DCNL def get_error(cls, job_id):
@classmethod DCNL def _require_valid_transition(cls, job_id, old_status_code, new_status_code):
@classmethod DCNL def _require_correct_job_type(cls, job_type):
@classmethod DCNL def _run(cls, additional_job_params):
@classmethod DCNL def _run_job(cls, job_id, additional_job_params):
@classmethod DCNL def _real_enqueue(cls, job_id, additional_job_params):
def run(self, job_id, job_class_str, kwargs):
def finalized(self):
def run(self, job_id, job_class_str, output):
def write(self, data):
@staticmethod DCNL def get_mapper_param(param_name):
@classmethod DCNL def entity_classes_to_map_over(cls):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, values):
@classmethod DCNL def _real_enqueue(cls, job_id, additional_job_params):
@staticmethod DCNL def _entity_created_before_job_queued(entity):
@classmethod DCNL def from_json(cls, input_shard_state):
def to_json(self):
@classmethod DCNL def split_input(cls, mapper_spec):
@classmethod DCNL def validate(cls, unused_mapper_spec):
@classmethod DCNL def _get_continuous_computation_class(cls):
@staticmethod DCNL def _get_job_queued_msec():
@staticmethod DCNL def _entity_created_before_job_queued(entity):
@classmethod DCNL def get_realtime_id(cls, layer_index, raw_entity_id):
@classmethod DCNL def delete_layer(cls, layer_index, latest_created_on_datetime):
@classmethod DCNL def _is_valid_realtime_id(cls, realtime_id):
@classmethod DCNL def get(cls, entity_id, strict=True):
def put(self):
@classmethod DCNL def get_event_types_listened_to(cls):
@classmethod DCNL def _get_realtime_datastore_class(cls):
@classmethod DCNL def _get_batch_job_manager_class(cls):
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args, **kwargs):
@classmethod DCNL def _get_active_realtime_index(cls):
@classmethod DCNL def get_active_realtime_layer_id(cls, entity_id):
@classmethod DCNL def get_multi_active_realtime_layer_ids(cls, entity_ids):
@classmethod DCNL def _switch_active_realtime_class(cls):
@classmethod DCNL def _clear_inactive_realtime_layer(cls, latest_created_on_datetime):
@classmethod DCNL def _kickoff_batch_job(cls):
@classmethod DCNL def _register_end_of_batch_job_and_return_status(cls):
@classmethod DCNL def get_status_code(cls):
@classmethod DCNL def start_computation(cls):
@classmethod DCNL def stop_computation(cls, user_id):
@classmethod DCNL def on_incoming_event(cls, event_type, *args, **kwargs):
@classmethod DCNL def _process_job_completion_and_return_status(cls):
@classmethod DCNL def _kickoff_batch_job_after_previous_one_ends(cls):
@classmethod DCNL def on_batch_job_completion(cls):
@classmethod DCNL def on_batch_job_canceled(cls):
@classmethod DCNL def on_batch_job_failure(cls):
@classmethod DCNL def entity_classes_to_map_over(cls):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, stringified_values):
@classmethod DCNL def import_models(cls, model_names):
@classmethod DCNL def import_transaction_services(cls):
@classmethod DCNL def import_current_user_services(cls):
@classmethod DCNL def import_datastore_services(cls):
@classmethod DCNL def import_app_identity_services(cls):
@classmethod DCNL def import_email_services(cls):
@classmethod DCNL def import_memcache_services(cls):
@classmethod DCNL def import_taskqueue_services(cls):
@classmethod DCNL def import_search_services(cls):
@classmethod DCNL def _get(cls):
@classmethod DCNL def import_models(cls, model_names):
@classmethod DCNL def import_current_user_services(cls):
@classmethod DCNL def import_datastore_services(cls):
@classmethod DCNL def import_transaction_services(cls):
@classmethod DCNL def import_app_identity_services(cls):
@classmethod DCNL def import_email_services(cls):
@classmethod DCNL def import_memcache_services(cls):
@classmethod DCNL def import_taskqueue_services(cls):
@classmethod DCNL def import_search_services(cls):
def _get_put_error(self, num_res, transient=None):
def _get_delete_error(self, num_res, transient=None):
def test_create_new(self):
def test_enqueue_job(self):
def test_deferred_job_with_additional_params(self):
def test_status_code_transitions(self):
def _populate_data(self):
def setUp(self):
def setUp(self):
@classmethod DCNL def _kickoff_batch_job_after_previous_one_ends(cls):
@classmethod DCNL def get_count(cls, exploration_id):
def setUp(self):
def test_continuous_computation_workflow(self):
def test_wrapper_calls_subclass_methods(self):
def test_wrapper_calls_passed_method(self):
def test_wrapper_calls_passed_class_method(self):
def test_wrapper_calls_passed_static_method(self):
def _validate(self):
def get_request_count(self):
def get_total_page_size_bytes(self):
def get_page_load_time_millisecs(self):
def get_dom_ready_time_millisecs(self):
def get_request_time_millisecs(self):
def get_ready_start_time_millisecs(self):
def get_redirect_time_millisecs(self):
def get_appcache_time_millisecs(self):
def get_unload_event_time_millisecs(self):
def get_lookup_domain_time_millisecs(self):
def get_connect_time_millisecs(self):
def get_init_dom_tree_time_millisecs(self):
def get_load_event_time_millisecs(self):
def print_details(self):
def get_average_page_load_time_millisecs(self):
def get_average_dom_ready_time_millisecs(self):
def get_average_request_time_millisecs(self):
def __init__(self, browser, preload_option, username=None):
def load_url(self, page_url):
def get_page_metrics_from_uncached_session(self, page_url):
def get_page_metrics_from_cached_session(self, page_url):
def get_page_timings_from_uncached_session(self, page_url):
def get_page_timings_from_cached_session(self, page_url):
def _setup_driver(self, proxy=None, use_proxy=False):
def _is_current_user_logged_in(self, driver):
def __init__(self):
@measure_runtime DCNL def train(self, num):
def generate_training_benchmarks(self):
@measure_runtime DCNL def predict(self, num):
def generate_prediction_benchmarks(self):
def _assert_validation_error(self, item, error_substring):
def signup_superadmin_user(self):
def log_line(self, line):
def _stash_current_user_env(self):
def _restore_stashed_user_env(self):
def shortDescription(self):
def get_expected_login_url(self, slug):
def get_expected_logout_url(self, slug):
def _parse_json_response(self, json_response, expect_errors=False):
def get_json(self, url, params=None, expect_errors=False):
def post_json(self, url, payload, csrf_token=None, expect_errors=False, expected_status_int=200, upload_files=None):
def put_json(self, url, payload, csrf_token=None, expect_errors=False, expected_status_int=200):
def get_csrf_token_from_response(self, response):
def signup(self, email, username):
def set_config_property(self, config_obj, new_config_value):
def set_admins(self, admin_usernames):
def set_moderators(self, moderator_usernames):
def set_banned_users(self, banned_usernames):
def set_collection_editors(self, collection_editor_usernames):
def set_email_senders(self, email_sender_usernames):
def save_new_default_exploration(self, exploration_id, owner_id, title='A DCSP title'):
def save_new_valid_exploration(self, exploration_id, owner_id, title='A DCSP title', category='A DCSP category', objective='An DCSP objective', language_code=constants.DEFAULT_LANGUAGE_CODE, end_state_name=None, interaction_id='TextInput'):
def save_new_exp_with_states_schema_v0(self, exp_id, user_id, title):
def save_new_default_collection(self, collection_id, owner_id, title='A DCSP title', category='A DCSP category', objective='An DCSP objective', language_code=constants.DEFAULT_LANGUAGE_CODE):
def get_updated_param_dict(self, param_dict, param_changes, exp_param_specs):
def get_static_asset_filepath(self):
def get_static_asset_url(self, asset_suffix):
@contextlib.contextmanager DCNL def swap(self, obj, attr, newvalue):
@contextlib.contextmanager DCNL def urlfetch_mock(self, content='', status_code=200, headers=None):
def count_jobs_in_taskqueue(self, queue_name=None):
def get_pending_tasks(self, queue_name=None):
def process_and_flush_pending_tasks(self, queue_name=None):
def __init__(self, func):
def __init__(self, f):
def __init__(self, f, exception, num_tries_before_success):
@acl_decorators.can_access_creator_dashboard DCNL def get(self):
@acl_decorators.can_access_creator_dashboard DCNL def get(self):
@acl_decorators.can_access_creator_dashboard DCNL def get(self):
@acl_decorators.can_create_exploration DCNL def post(self):
@acl_decorators.can_create_collection DCNL def post(self):
@acl_decorators.can_upload_exploration DCNL def post(self):
@acl_decorators.can_manage_email_dashboard DCNL def get(self):
@acl_decorators.can_manage_email_dashboard DCNL def post(self):
def _validate(self, data):
@acl_decorators.can_perform_cron_tasks DCNL def get(self):
@acl_decorators.can_perform_cron_tasks DCNL def get(self):
@acl_decorators.can_perform_cron_tasks DCNL def get(self):
@acl_decorators.can_perform_cron_tasks DCNL def get(self):
@acl_decorators.can_perform_cron_tasks DCNL def get(self):
@acl_decorators.can_play_collection DCNL def get(self, collection_id):
@acl_decorators.can_play_collection DCNL def get(self, collection_id):
def test_library_page(self):
def test_library_handler_demo_exploration(self):
def test_library_handler_for_created_explorations(self):
def test_library_group_pages(self):
def test_handler_for_recently_published_library_group_page(self):
def test_handler_for_top_rated_library_group_page(self):
def get(self):
def dispatch(self):
def get(self, *args, **kwargs):
def post(self, *args):
def put(self, *args):
def delete(self, *args):
def render_json(self, values):
def render_template(self, filepath, iframe_restriction='DENY', redirect_url_on_logout=None):
def _render_exception(self, error_code, values):
def handle_exception(self, exception, unused_debug_mode):
@classmethod DCNL def init_csrf_secret(cls):
@classmethod DCNL def _create_token(cls, user_id, issued_on):
@classmethod DCNL def is_csrf_token_valid(cls, user_id, token):
@acl_decorators.open_access DCNL def get(self, username):
@acl_decorators.open_access DCNL def get(self, username):
@acl_decorators.can_manage_own_profile DCNL def get(self):
@acl_decorators.can_manage_own_profile DCNL def get(self):
@acl_decorators.can_manage_own_profile DCNL def put(self):
@acl_decorators.can_manage_own_profile DCNL def get(self):
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def get(self):
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def get(self):
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def post(self):
@acl_decorators.require_user_id_else_redirect_to_homepage DCNL def post(self):
@acl_decorators.can_manage_own_profile DCNL def put(self):
def setUp(self):
def setUp(self):
def test_classification_handler(self):
def test_give_feedback_handler(self):
def test_get_init_params(self):
def test_update_learner_params(self):
def test_assign_and_read_ratings(self):
def test_non_logged_in_users_cannot_rate(self):
def test_ratings_by_different_users(self):
def test_that_emails_are_sent(self):
def test_non_logged_in_users_cannot_report(self):
def test_independent_exp_complete_event_handler(self):
def test_exp_complete_event_in_collection(self):
def test_exp_incomplete_event_handler(self):
def test_remove_exp_from_incomplete_list_handler(self):
def test_remove_collection_from_incomplete_list_handler(self):
def test_logged_out_homepage(self):
def test_notifications_dashboard_redirects_for_logged_out_users(self):
def test_logged_in_notifications_dashboard(self):
def _record_start(self, exp_id, exp_version, state):
def _rate_exploration(self, exp_id, ratings):
def _get_recent_notifications_mock_by_viewer(self, unused_user_id):
def _get_recent_notifications_mock_by_anonymous_user(self, unused_user_id):
def test_author_ids_are_handled_correctly(self):
def test_new_exploration_ids(self):
def test_exploration_upload_button(self):
def setUp(self):
def test_welcome_collection(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self, obj_type):
@acl_decorators.open_access DCNL def get(self, generator_id):
@acl_decorators.open_access DCNL def get(self, exploration_id, encoded_filepath):
@acl_decorators.open_access DCNL def get(self, exploration_id, filename):
def test_about_page(self):
def setUp(self):
def test_admin_page_rights(self):
def test_change_configuration_property(self):
def test_change_about_page_config_property(self):
def setUp(self):
def setUp(self):
def setUp(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def get(self, *args, **kwargs):
def setUp(self):
def assert_can_edit(self, response_body):
def assert_cannot_edit(self, response_body):
def test_editor_page(self):
def test_new_state_template(self):
def test_that_default_exploration_cannot_be_published(self):
def test_add_new_state_error_cases(self):
def test_deletion_rights_for_unpublished_exploration(self):
def test_deletion_rights_for_published_exploration(self):
def test_logging_info_after_deletion(self):
def setUp(self):
def test_reverting_to_old_exploration(self):
def test_versioning_for_default_exploration(self):
def test_user_banning(self):
def test_exploration_rights_handler(self):
def test_user_exploration_emails_handler(self):
@acl_decorators.can_access_moderator_page DCNL def get(self):
def setUp(self):
def test_image_upload_and_download(self):
def test_upload_empty_image(self):
def test_upload_bad_image(self):
def test_get_invalid_image(self):
def test_invalid_extension_is_detected(self):
def test_upload_empty_audio(self):
def test_upload_bad_audio(self):
def test_missing_extensions_are_detected(self):
def test_exceed_max_length_detected(self):
def test_non_matching_extensions_are_detected(self):
def setUp(self):
def test_access_collection_editor_page(self):
def test_editable_collection_handler_put_cannot_access(self):
def test_editable_collection_handler_put_can_access(self):
def test_dev_indicator_appears_in_dev_and_not_in_production(self):
def test_that_no_get_results_in_500_error(self):
def test_requests_for_invalid_paths(self):
def test_redirect_in_logged_out_states(self):
def get(self):
def post(self):
def test_logout_page(self):
def _get_tags(self, input_string, key, filename):
def test_i18n_keys(self):
def test_alphabetic_i18n_keys(self):
def test_keys_match_en_qqq(self):
def test_keys_in_source_code_match_en(self):
def test_html_in_translations_is_preserved_correctly(self):
@acl_decorators.can_access_admin_page DCNL def get(self):
@acl_decorators.can_access_admin_page DCNL def get(self):
@acl_decorators.can_access_admin_page DCNL def post(self):
def _generate_dummy_explorations(self, num_dummy_exps_to_generate, num_dummy_exps_to_publish):
@acl_decorators.can_access_admin_page DCNL def get(self):
@acl_decorators.open_access DCNL def get(self, challenge):
def test_email_preferences_updates(self):
def test_save_site_language_handler(self):
@acl_decorators.can_access_moderator_page DCNL def get(self):
@acl_decorators.can_access_moderator_page DCNL def get(self):
@acl_decorators.can_access_moderator_page DCNL def post(self):
@acl_decorators.can_send_moderator_emails DCNL def get(self, action):
@acl_decorators.can_access_learner_dashboard DCNL def get(self):
@acl_decorators.can_access_learner_dashboard DCNL def get(self, exploration_id, thread_id):
def test_moderator_page(self):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.can_edit_collection DCNL def get(self, collection_id):
def _require_valid_version(self, version_from_payload, collection_version):
@acl_decorators.can_edit_collection DCNL def get(self, collection_id):
@acl_decorators.can_edit_collection DCNL def put(self, collection_id):
@acl_decorators.can_edit_collection DCNL def get(self, collection_id):
@acl_decorators.can_manage_collection_publish_status DCNL def put(self, collection_id):
@acl_decorators.open_access DCNL def get(self):
@acl_decorators.open_access DCNL def post(self):
def test_subscribe_handler(self):
def test_unsubscribe_handler(self):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
def _get_exploration_data(self, exploration_id, apply_draft=False, version=None):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_edit_exploration DCNL def put(self, exploration_id):
@acl_decorators.can_delete_exploration DCNL def delete(self, exploration_id):
@acl_decorators.can_modify_exploration_roles DCNL def put(self, exploration_id):
def _publish_exploration(self, exploration_id):
def _unpublicize_exploration(self, exploration_id):
@acl_decorators.can_access_moderator_page DCNL def put(self, exploration_id):
@acl_decorators.can_edit_exploration DCNL def put(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id, escaped_state_name):
@acl_decorators.can_download_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, unused_exploration_id):
@acl_decorators.can_edit_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_view_exploration_stats DCNL def get(self, exploration_id, exploration_version):
@acl_decorators.can_view_exploration_stats DCNL def get(self, exploration_id):
@acl_decorators.can_view_exploration_stats DCNL def get(self, exploration_id, escaped_state_name):
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, unused_exploration_id):
@acl_decorators.can_edit_exploration DCNL def put(self, exploration_id):
@acl_decorators.can_edit_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, unused_exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def post(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@acl_decorators.can_rate_exploration DCNL def put(self, exploration_id):
@acl_decorators.can_play_exploration DCNL def get(self, exploration_id):
@classmethod DCNL def dispatch_event(cls, event_type, *args, **kwargs):
@classmethod DCNL def is_normalized_username_taken(cls, normalized_username):
@classmethod DCNL def get_by_normalized_username(cls, normalized_username):
@classmethod DCNL def get_by_role(cls, role):
@classmethod DCNL def create(cls, user_id, exploration_id):
@classmethod DCNL def get(cls, user_id, exploration_id):
@classmethod DCNL def get_or_create(cls, user_id):
@classmethod DCNL def create(cls, user_id, exploration_id):
@classmethod DCNL def get(cls, user_id, exploration_id):
@classmethod DCNL def get_multi(cls, user_ids, exploration_id):
@classmethod DCNL def create(cls, user_id, collection_id):
@classmethod DCNL def get(cls, user_id, collection_id):
@classmethod DCNL def get_multi(cls, user_id, collection_ids):
@classmethod DCNL def get_or_create(cls, user_id, collection_id):
@classmethod DCNL def fetch_page(cls, page_size, cursor):
@classmethod DCNL def _generate_id(cls, intent):
@classmethod DCNL def create(cls, recipient_id, recipient_email, sender_id, sender_email, intent, subject, html_body, sent_datetime):
def put(self):
@classmethod DCNL def get_by_hash(cls, email_hash, sent_datetime_lower_bound=None):
@classmethod DCNL def _generate_hash(cls, recipient_id, email_subject, email_body):
@classmethod DCNL def check_duplicate_message(cls, recipient_id, email_subject, email_body):
@classmethod DCNL def create(cls, instance_id, recipient_ids, sender_id, sender_email, intent, subject, html_body, sent_datetime):
@classmethod DCNL def create(cls, user_id, exploration_id, thread_id):
@property DCNL def id(self):
def _pre_put_hook(self):
@classmethod DCNL def get(cls, entity_id, strict=True):
@classmethod DCNL def get_multi(cls, entity_ids, include_deleted=False):
@classmethod DCNL def put_multi(cls, entities):
def delete(self):
@classmethod DCNL def get_all(cls, include_deleted=False):
@classmethod DCNL def get_new_id(cls, entity_name):
@classmethod DCNL def _fetch_page_sorted_by_last_updated(cls, query, page_size, urlsafe_start_cursor):
def _compute_snapshot(self):
def _reconstitute_from_snapshot_id(self, snapshot_id):
@classmethod DCNL def _get_snapshot_id(cls, instance_id, version_number):
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds):
def delete(self, committer_id, commit_message, force_deletion=False):
def put(self, *args, **kwargs):
def commit(self, committer_id, commit_message, commit_cmds):
@classmethod DCNL def revert(cls, model, committer_id, commit_message, version_number):
@classmethod DCNL def get_version(cls, entity_id, version_number):
@classmethod DCNL def get(cls, entity_id, strict=True, version=None):
@classmethod DCNL def get_snapshots_metadata(cls, model_instance_id, version_numbers, allow_deleted=False):
def get_unversioned_instance_id(self):
def get_version_string(self):
def get_unversioned_instance_id(self):
def get_version_string(self):
def tearDown(self):
@classmethod DCNL def get_collection_count(cls):
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds):
def save(self, committer_id, commit_message, commit_cmds):
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds):
@classmethod DCNL def get_all_commits(cls, page_size, urlsafe_start_cursor):
@classmethod DCNL def get_non_private(cls):
@classmethod DCNL def get_private_at_least_viewable(cls, user_id):
@classmethod DCNL def get_at_least_editable(cls, user_id):
@classmethod DCNL def generate_new_thread_id(cls, exploration_id):
@classmethod DCNL def generate_full_thread_id(cls, exploration_id, thread_id):
@classmethod DCNL def get_exploration_and_thread_ids(cls, full_thread_ids):
@property DCNL def thread_id(self):
@classmethod DCNL def create(cls, exploration_id, thread_id):
@classmethod DCNL def get_by_exp_and_thread_id(cls, exploration_id, thread_id):
@classmethod DCNL def get_threads(cls, exploration_id, limit=feconf.DEFAULT_QUERY_LIMIT):
@classmethod DCNL def _generate_id(cls, exploration_id, thread_id, message_id):
@classmethod DCNL def create(cls, exploration_id, thread_id, message_id):
@classmethod DCNL def get(cls, exploration_id, thread_id, message_id, strict=True):
@classmethod DCNL def get_messages(cls, exploration_id, thread_id):
@classmethod DCNL def get_most_recent_message(cls, exploration_id, thread_id):
@classmethod DCNL def get_message_count(cls, exploration_id, thread_id):
@classmethod DCNL def get(cls, user_id, exploration_id, thread_id):
@classmethod DCNL def create(cls, user_id, exploration_id, thread_id):
@classmethod DCNL def get_multi(cls, user_id, exploration_ids, thread_ids):
@classmethod DCNL def create(cls, model_id, num_open_threads, num_total_threads):
@classmethod DCNL def _convert_suggestion_html_to_legacy_state_content(cls, suggestion_html):
@classmethod DCNL def _get_instance_id(cls, exploration_id, thread_id):
@classmethod DCNL def create(cls, exploration_id, thread_id, author_id, exploration_version, state_name, description, suggestion_html):
def get_suggestion_html(self):
@classmethod DCNL def get_by_exploration_and_thread_id(cls, exploration_id, thread_id):
def _get_suggestion_models_for_test(self, suggestions_list):
@classmethod DCNL def get_exploration_count(cls):
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds):
def _trusted_commit(self, committer_id, commit_type, commit_message, commit_cmds):
@classmethod DCNL def get_all_commits(cls, page_size, urlsafe_start_cursor):
@classmethod DCNL def get_all_non_private_commits(cls, page_size, urlsafe_start_cursor, max_age=None):
@classmethod DCNL def get_non_private(cls):
@classmethod DCNL def get_top_rated(cls, limit):
@classmethod DCNL def get_private_at_least_viewable(cls, user_id):
@classmethod DCNL def get_at_least_editable(cls, user_id):
@classmethod DCNL def get_recently_published(cls, limit):
@classmethod DCNL def get_or_create(cls, list_name):
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, params, play_type, unused_version=1):
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, client_time_spent_in_secs, params, play_type):
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, client_time_spent_in_secs, params, play_type):
@classmethod DCNL def create(cls, exp_id, user_id, rating, old_rating):
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, session_id, params, play_type):
@classmethod DCNL def create(cls, exp_id, version, num_starts, num_completions, state_hit_counts):
@classmethod DCNL def get_master_model(cls, exploration_id, exploration_version, state_name):
@classmethod DCNL def get_all_models(cls, exploration_id, exploration_version, state_name):
@classmethod DCNL def _insert_submitted_answers_unsafe(cls, exploration_id, exploration_version, state_name, interaction_id, new_submitted_answer_dict_list):
@classmethod DCNL def insert_submitted_answers(cls, exploration_id, exploration_version, state_name, interaction_id, new_submitted_answer_dict_list):
@classmethod DCNL def _shard_answers(cls, current_answer_list, current_answer_list_size, new_answer_list):
@classmethod DCNL def _get_answer_dict_size(cls, answer_dict):
@classmethod DCNL def create(cls, classifier_id, exp_id, exp_version_when_created, state_name, algorithm_id, classifier_data, data_schema_version):
@classmethod DCNL def _generate_id(cls, exp_id):
@classmethod DCNL def create(cls, algorithm_id, interaction_id, exp_id, exp_version, training_data, state_name, status):
@classmethod DCNL def create_multi(cls, job_dicts_list):
@classmethod DCNL def _generate_id(cls, exp_id, exp_version, state_name):
@classmethod DCNL def get_models(cls, exp_id, exp_version, state_names):
@classmethod DCNL def create(cls, exp_id, exp_version, state_name, job_id):
@classmethod DCNL def create_multi(cls, job_exploration_mappings):
@classmethod DCNL def get_new_id(cls, entity_name):
@classmethod DCNL def get_recent_jobs(cls, limit, recency_msec):
@classmethod DCNL def get_all_unfinished_jobs(cls, limit):
@classmethod DCNL def get_unfinished_jobs(cls, job_type):
@classmethod DCNL def do_unfinished_jobs_exist(cls, job_type):
@classmethod DCNL def get_undeleted(cls):
@classmethod DCNL def _construct_id(cls, exploration_id, filepath):
@classmethod DCNL def create(cls, exploration_id, filepath):
@classmethod DCNL def get_model(cls, exploration_id, filepath, strict=False):
@classmethod DCNL def get_version(cls, exploration_id, filepath, version_number):
def commit(self, committer_id, commit_cmds):
def _reconstitute(self, snapshot_blob):
def _compute_snapshot(self):
@classmethod DCNL def _construct_id(cls, exploration_id, filepath):
@classmethod DCNL def create(cls, exploration_id, filepath):
@classmethod DCNL def get_model(cls, exploration_id, filepath, strict=False):
def commit(self, committer_id, commit_cmds):
@classmethod DCNL def get_version(cls, exploration_id, filepath, version_number):
def __init__(self, incomplete_exp_summaries, incomplete_collection_summaries, completed_exp_summaries, completed_collection_summaries, exploration_playlist, collection_playlist):
@classmethod DCNL def _notify_continuous_computation_listeners_async(cls, *args, **kwargs):
@classmethod DCNL def _handle_event(cls, *args, **kwargs):
@classmethod DCNL def record(cls, *args, **kwargs):
@classmethod DCNL def _handle_event(cls, exploration_id, exploration_version, state_name, interaction_id, answer_group_index, rule_spec_index, classification_categorization, session_id, time_spent_in_secs, params, normalized_answer):
@classmethod DCNL def _refresh_registry(cls):
@classmethod DCNL def get_event_class_by_type(cls, event_type):
def _run_one_off_job(self, query_id):
def setUp(self):
def _assert_validation_error(self, expected_error_substring):
def test_initial_validation(self):
def test_is_demo_property(self):
def test_collection_export_import(self):
def test_add_delete_node(self):
def test_add_skill(self):
def test_update_skill(self):
def test_adding_duplicate_skill_raises_error(self):
def test_adding_after_deleting_skill_increments_skill_id(self):
def test_delete_skill(self):
def test_initial_explorations(self):
def test_next_explorations(self):
def test_yaml_import_and_export(self):
def test_correct_collection_contents_schema_conversion_methods_exist(self):
def test_correct_collection_schema_conversion_methods_exist(self):
def test_load_from_v1(self):
def test_load_from_v2(self):
def test_load_from_v3(self):
def test_load_from_v4(self):
def _run_computation(self):
def _generate_user_ids(self, count):
def _record_start(self, exp_id, exp_version, state):
def _rate_exploration(self, exp_id, num_ratings, rating):
def test_stats_for_user_with_no_explorations(self):
def test_only_yield_when_rating_greater_than_two(self):
def test_impact_for_exp_with_no_answers(self):
def test_impact_for_exp_with_no_ratings(self):
def setUp(self):
def test_legacy_user(self):
def setUp(self):
def test_legacy_user(self):
def setUp(self):
def test_legacy_user(self):
@classmethod DCNL def get_all_classifier_algorithm_ids(cls):
@classmethod DCNL def _refresh(cls):
@classmethod DCNL def get_all_classifiers(cls):
@classmethod DCNL def get_classifier_by_algorithm_id(cls, classifier_algorithm_id):
@classmethod DCNL def get_dependency_html(cls, dependency_id):
@classmethod DCNL def get_angular_modules(cls, dependency_id):
@classmethod DCNL def get_deps_html_and_angular_modules(cls, dependency_ids):
def _is_camel_cased(self, name):
def _is_alphanumeric_string(self, input_string):
def _listdir_omit_ignored(self, directory):
def test_allowed_rich_text_components_and_counts(self):
def test_image_thumbnails_for_rte_components(self):
def test_default_rte_components_are_valid(self):
@classmethod DCNL def get_html_template(cls):
@classmethod DCNL def get_js_template(cls):
def generate_value(self, *args, **kwargs):
@classmethod DCNL def _refresh_registry(cls):
@classmethod DCNL def get_all_generator_classes(cls):
@classmethod DCNL def get_generator_class_by_id(cls, generator_id):
def __init__(self, user_id, email, role, username=None, last_agreed_to_terms=None, last_started_state_editor_tutorial=None, last_logged_in=None, last_created_an_exploration=None, last_edited_an_exploration=None, profile_picture_data_url=None, default_dashboard=None, user_bio='', subject_interests=None, first_contribution_msec=None, preferred_language_codes=None, preferred_site_language_code=None):
def validate(self):
@property DCNL def truncated_email(self):
@property DCNL def is_known_user(self):
@property DCNL def normalized_username(self):
@classmethod DCNL def normalize_username(cls, username):
@classmethod DCNL def require_valid_username(cls, username):
def __init__(self, user_id, created_exploration_ids, edited_exploration_ids):
def validate(self):
@abc.abstractmethod DCNL def from_dict(self, model):
@abc.abstractmethod DCNL def to_dict(self, model):
@abc.abstractmethod DCNL def predict(self, predicting_data):
@abc.abstractmethod DCNL def train(self, training_data):
@abc.abstractmethod DCNL def validate(self, classifier_data):
@property DCNL def value(self):
def set_value(self, committer_id, raw_value):
@classmethod DCNL def get_config_property_schemas(cls):
@classmethod DCNL def get_all_interaction_ids(cls):
@classmethod DCNL def get_all_interactions(cls):
@classmethod DCNL def get_interaction_by_id(cls, interaction_id):
@classmethod DCNL def get_interaction_html(cls, interaction_ids):
@classmethod DCNL def get_deduplicated_dependency_ids(cls, interaction_ids):
@classmethod DCNL def get_all_specs(cls):
def test_get_object_class_by_type_method(self):
def test_fake_class_is_not_gettable(self):
def test_base_object_is_not_gettable(self):
def test_all_rule_input_fields_have_default_values(self):
def test_get_object_default_values_is_valid(self):
def test_string_classifier_classification(self):
def test_creation_of_jobs_and_mappings(self):
def test_handle_trainable_states(self):
def test_handle_non_retrainable_states(self):
def test_retrieval_of_classifiers(self):
def test_deletion_of_classifiers(self):
def test_creation_of_classifiers(self):
def test_retrieval_of_classifier_training_jobs(self):
def test_deletion_of_classifier_training_jobs(self):
def test_mark_training_job_complete(self):
def test_retrieval_of_classifier_training_jobs_from_exploration_attributes(self):
def __init__(self, can_receive_email_updates, can_receive_editor_role_email, can_receive_feedback_message_email, can_receive_subscription_email):
@classmethod DCNL def create_default_prefs(cls):
def __init__(self, mute_feedback_notifications, mute_suggestion_notifications):
@classmethod DCNL def create_default_prefs(cls):
def to_dict(self):
def update_last_played_information(self, last_played_exp_version, last_played_state_name):
def add_exploration_id(self, exploration_id):
def remove_exploration_id(self, exploration_id):
def add_collection_id(self, collection_id):
def remove_collection_id(self, collection_id):
def add_exploration_id(self, exploration_id):
def remove_exploration_id(self, exploration_id):
def add_collection_id(self, collection_id):
def remove_collection_id(self, collection_id):
def insert_exploration_id_at_given_position(self, exploration_id, position_to_be_inserted):
def add_exploration_id_to_list(self, exploration_id):
def insert_collection_id_at_given_position(self, collection_id, position_to_be_inserted):
def add_collection_id_to_list(self, collection_id):
def remove_exploration_id(self, exploration_id):
def remove_collection_id(self, collection_id):
def setUp(self):
def test_retrieval_of_explorations(self):
def test_soft_deletion_of_explorations(self):
def test_hard_deletion_of_explorations(self):
def test_summaries_of_hard_deleted_explorations(self):
def test_explorations_are_removed_from_index_when_deleted(self):
def test_loading_and_validation_and_deletion_of_demo_explorations(self):
def test_export_to_zip_file(self):
def test_export_to_zip_file_with_assets(self):
def test_export_by_versions(self):
def test_export_to_dict(self):
def test_export_by_versions(self):
def test_add_gadget_cmd(self):
def test_rename_gadget_cmd(self):
def test_delete_gadget_cmd(self):
def test_add_state_cmd(self):
def test_rename_state_cmd(self):
def test_rename_state_cmd_with_unicode(self):
def test_delete_state_cmd(self):
def test_update_param_changes(self):
def test_update_invalid_param_changes(self):
def test_update_invalid_generator(self):
def test_update_interaction_id(self):
def test_update_interaction_customization_args(self):
def test_update_interaction_handlers_fails(self):
def test_update_interaction_answer_groups(self):
def test_update_interaction_fallbacks(self):
def test_update_interaction_fallbacks_invalid_dest(self):
def test_update_state_invalid_state(self):
def test_update_state_missing_keys(self):
def test_update_state_variable_types(self):
def test_update_content(self):
def test_update_content_missing_key(self):
def test_record_commit_message(self):
def test_demand_commit_message(self):
def test_unpublished_explorations_can_accept_commit_message(self):
def setUp(self):
def test_contributors_not_updated_on_revert(self):
def setUp(self):
def test_migration_then_reversion_maintains_valid_exploration(self):
def test_loading_old_exploration_does_not_break_domain_object_ctor(self):
def __init__(self, change_dict):
def __init__(self, created_on, last_updated, user_id, username, exploration_id, commit_type, commit_message, commit_cmds, version, post_commit_status, post_commit_community_owned, post_commit_is_private):
def to_dict(self):
def to_dict(self):
@classmethod DCNL def from_dict(cls, audio_translation_dict):
def __init__(self, filename, file_size_bytes, needs_update):
def validate(self):
def __init__(self, html, audio_translations):
def to_dict(self):
@classmethod DCNL def from_dict(cls, subtitled_html_dict):
def validate(self):
def to_html(self, params):
def to_dict(self):
@classmethod DCNL def from_dict(cls, rulespec_dict):
def __init__(self, rule_type, inputs):
def validate(self, rule_params_list, exp_param_specs_dict):
def to_dict(self):
@classmethod DCNL def from_dict(cls, outcome_dict):
def __init__(self, dest, feedback, param_changes):
def validate(self):
def to_dict(self):
@classmethod DCNL def from_dict(cls, answer_group_dict):
def __init__(self, outcome, rule_specs, correct):
def validate(self, interaction, exp_param_specs_dict):
def get_classifier_rule_index(self):
def __init__(self, trigger_type, customization_args):
def to_dict(self):
@classmethod DCNL def from_dict(cls, trigger_dict):
def validate(self):
def __init__(self, trigger, outcome):
def to_dict(self):
@classmethod DCNL def from_dict(cls, fallback_dict):
def __init__(self, hint_text):
def to_dict(self):
@classmethod DCNL def from_dict(cls, hint_dict):
def validate(self):
def __init__(self, interaction_id, answer_is_exclusive, correct_answer, explanation):
def to_dict(self):
@classmethod DCNL def from_dict(cls, interaction_id, solution_dict):
def validate(self, interaction_id):
def to_dict(self):
@classmethod DCNL def from_dict(cls, interaction_dict):
def __init__(self, interaction_id, customization_args, answer_groups, default_outcome, confirmed_unclassified_answers, fallbacks, hints, solution):
@property DCNL def is_terminal(self):
def get_all_non_fallback_outcomes(self):
def get_all_outcomes(self):
def validate(self, exp_param_specs_dict):
@classmethod DCNL def create_default_interaction(cls, default_dest_state_name):
def __init__(self, gadget_type, gadget_name, visible_in_states, customization_args):
@property DCNL def gadget(self):
@property DCNL def width(self):
@property DCNL def height(self):
@staticmethod DCNL def _validate_gadget_name(gadget_name):
def validate(self):
def to_dict(self):
@classmethod DCNL def from_dict(cls, gadget_dict):
def update_customization_args(self, customization_args):
def update_visible_in_states(self, visible_in_states):
def _get_full_customization_args(self):
def __init__(self, skin_id, skin_customizations):
@staticmethod DCNL def _get_default_skin_customizations():
def validate_gadget_panel(self, panel_name, gadget_list):
def validate(self):
def to_dict(self):
@classmethod DCNL def from_dict(cls, skin_dict):
def get_state_names_required_by_gadgets(self):
def __init__(self, content, param_changes, interaction, classifier_model_id=None):
def validate(self, exp_param_specs_dict, allow_null_interaction):
def get_training_data(self):
def can_undergo_classification(self):
def update_content(self, content_dict):
def update_param_changes(self, param_change_dicts):
def update_interaction_id(self, interaction_id):
def update_interaction_customization_args(self, customization_args):
def update_interaction_answer_groups(self, answer_groups_list):
def update_interaction_default_outcome(self, default_outcome_dict):
def update_interaction_confirmed_unclassified_answers(self, confirmed_unclassified_answers):
def update_interaction_fallbacks(self, fallbacks_list):
def update_interaction_hints(self, hints_list):
def update_interaction_solution(self, solution_dict):
def add_hint(self, hint_text):
def delete_hint(self, index):
def to_dict(self):
@classmethod DCNL def from_dict(cls, state_dict):
@classmethod DCNL def create_default_state(cls, default_dest_state_name, is_initial_state=False):
def __init__(self, exploration_id, title, category, objective, language_code, tags, blurb, author_notes, skin_customizations, states_schema_version, init_state_name, states_dict, param_specs_dict, param_changes_list, version, created_on=None, last_updated=None):
@classmethod DCNL def create_default_exploration(cls, exploration_id, title=feconf.DEFAULT_EXPLORATION_TITLE, category=feconf.DEFAULT_EXPLORATION_CATEGORY, objective=feconf.DEFAULT_EXPLORATION_OBJECTIVE, language_code=constants.DEFAULT_LANGUAGE_CODE):
@classmethod DCNL def from_dict(cls, exploration_dict, exploration_version=0, exploration_created_on=None, exploration_last_updated=None):
@classmethod DCNL def _require_valid_state_name(cls, name):
def validate(self, strict=False):
def _verify_all_states_reachable(self):
def _verify_no_dead_ends(self):
@property DCNL def init_state(self):
@property DCNL def param_specs_dict(self):
@property DCNL def param_change_dicts(self):
@classmethod DCNL def is_demo_exploration_id(cls, exploration_id):
@property DCNL def is_demo(self):
def update_title(self, title):
def update_category(self, category):
def update_objective(self, objective):
def update_language_code(self, language_code):
def update_tags(self, tags):
def update_blurb(self, blurb):
def update_author_notes(self, author_notes):
def update_param_specs(self, param_specs_dict):
def update_param_changes(self, param_changes_list):
def update_init_state_name(self, init_state_name):
def add_states(self, state_names):
def rename_state(self, old_state_name, new_state_name):
def delete_state(self, state_name):
def get_state_names_mapping(self, change_list):
def get_trainable_states_dict(self, old_states, new_to_old_state_names):
def add_gadget(self, gadget_dict, panel):
def rename_gadget(self, old_gadget_name, new_gadget_name):
def delete_gadget(self, gadget_name):
def get_gadget_instance_by_name(self, gadget_name):
def get_all_gadget_names(self):
def _get_panel_for_gadget(self, gadget_name):
def _update_gadget_visibilities_for_renamed_state(self, old_state_name, new_state_name):
def _update_gadget_visibilities_for_deleted_state(self, state_name):
def _get_gadget_instances_visible_in_state(self, state_name):
@classmethod DCNL def _convert_states_v0_dict_to_v1_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v1_dict_to_v2_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v2_dict_to_v3_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v3_dict_to_v4_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v4_dict_to_v5_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v5_dict_to_v6_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v6_dict_to_v7_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v7_dict_to_v8_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v8_dict_to_v9_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v9_dict_to_v10_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v10_dict_to_v11_dict(cls, states_dict):
@classmethod DCNL def _convert_states_v11_dict_to_v12_dict(cls, states_dict):
@classmethod DCNL def update_states_from_model(cls, versioned_exploration_states, current_states_schema_version):
@classmethod DCNL def _convert_v1_dict_to_v2_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v2_dict_to_v3_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v3_dict_to_v4_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v4_dict_to_v5_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v5_dict_to_v6_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v6_dict_to_v7_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v7_dict_to_v8_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v8_dict_to_v9_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v9_dict_to_v10_dict(cls, exploration_dict, title, category):
@classmethod DCNL def _convert_v10_dict_to_v11_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v11_dict_to_v12_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v12_dict_to_v13_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v13_dict_to_v14_dict(cls, exploration_dict):
@classmethod DCNL def _convert_v14_dict_to_v15_dict(cls, exploration_dict):
@classmethod DCNL def _migrate_to_latest_yaml_version(cls, yaml_content, title=None, category=None):
@classmethod DCNL def from_yaml(cls, exploration_id, yaml_content):
@classmethod DCNL def from_untitled_yaml(cls, exploration_id, title, category, yaml_content):
def to_yaml(self):
def to_dict(self):
def to_player_dict(self):
def get_gadget_types(self):
def get_interaction_ids(self):
def __init__(self, exploration_id, title, category, objective, language_code, tags, ratings, scaled_average_rating, status, community_owned, owner_ids, editor_ids, viewer_ids, contributor_ids, contributors_summary, version, exploration_model_created_on, exploration_model_last_updated, first_published_msec):
def to_metadata_dict(self):
def test_interaction_registry(self):
def test_get_all_specs(self):
def test_validation(self):
def test_validation(self):
def test_validation(self):
def __init__(self, exploration_id, exploration_version, state_name, interaction_id, submitted_answer_list, schema_version=feconf.CURRENT_STATE_ANSWERS_SCHEMA_VERSION):
def get_submitted_answer_dict_list(self):
def validate(self):
def validate(self):
def __init__(self, exploration_id, exploration_version, state_name, calculation_id, calculation_output):
def save(self):
def validate(self):
def __init__(self, content, version, metadata):
def read(self):
def _get_file_metadata(self, filepath, version):
def _get_file_data(self, filepath, version):
def _save_file(self, user_id, filepath, raw_bytes):
def get(self, filepath, version=None, mode=None):
def commit(self, user_id, filepath, raw_bytes, unused_mimetype):
def delete(self, user_id, filepath):
def isfile(self, filepath):
def listdir(self, dir_name):
def __init__(self, root):
def isfile(self, filepath):
def get(self, filepath, version=None, mode='r'):
def _check_filepath(self, filepath):
def isfile(self, filepath):
def open(self, filepath, version=None, mode='r'):
def get(self, filepath, version=None, mode='r'):
def commit(self, user_id, filepath, raw_bytes, mimetype=None):
def delete(self, user_id, filepath):
def listdir(self, dir_name):
def setUp(self):
def test_retrieval_of_collections(self):
def test_soft_deletion_of_collections(self):
def test_hard_deletion_of_collections(self):
def test_summaries_of_hard_deleted_collections(self):
def test_collections_are_removed_from_index_when_deleted(self):
def test_loading_and_validation_and_deletion_of_demo_collections(self):
def test_add_node_with_private_exploration_in_public_collection(self):
def test_add_node_with_public_exploration_in_private_collection(self):
def test_record_commit_message(self):
def test_demand_commit_message(self):
def test_unpublished_collections_can_accept_commit_message(self):
def setUp(self):
def test_answers_across_multiple_exp_versions_different_interactions(self):
def test_param_spec_validation(self):
def test_param_change_validation(self):
def test_param_change_class(self):
def __init__(self, obj_type):
def to_dict(self):
@classmethod DCNL def from_dict(cls, param_spec_dict):
def validate(self):
def __init__(self, name, generator_id, customization_args):
@property DCNL def name(self):
@property DCNL def generator(self):
@property DCNL def customization_args(self):
@classmethod DCNL def from_dict(cls, param_change_dict):
def _get_value(self, context_params):
def get_normalized_value(self, obj_type, context_params):
def validate(self):
@classmethod DCNL def get_all_gadget_types(cls):
@classmethod DCNL def get_all_gadgets(cls):
@classmethod DCNL def get_gadget_by_type(cls, gadget_type):
@classmethod DCNL def get_gadget_html(cls, gadget_types):
@classmethod DCNL def get_deduplicated_dependency_ids(cls, gadget_types):
@classmethod DCNL def get_all_specs(cls):
def test_sending_email_with_different_recipient_but_same_hash(self):
def test_sending_email_with_different_subject_but_same_hash(self):
def test_sending_email_with_different_body_but_same_hash(self):
def test_migration_job_does_not_convert_up_to_date_collection(self):
def test_migration_job_skips_deleted_collection(self):
def test_migrate_colections_failing_strict_validation(self):
def test_migration_job_migrates_collection_nodes(self):
def test_dicts_have_same_keys(self):
def test_dicts_have_list_value(self):
def test_every_dict_entry_is_string(self):
def test_valid_parents(self):
def test_that_role_graph_has_no_directed_cycles(self):
def test_get_all_actions(self):
def __init__(self, change_dict):
def __init__(self, created_on, last_updated, user_id, username, collection_id, commit_type, commit_message, commit_cmds, version, post_commit_status, post_commit_community_owned, post_commit_is_private):
def to_dict(self):
def __init__(self, exploration_id, prerequisite_skill_ids, acquired_skill_ids):
def to_dict(self):
@classmethod DCNL def from_dict(cls, node_dict):
@property DCNL def skills(self):
def update_prerequisite_skill_ids(self, prerequisite_skill_ids):
def update_acquired_skill_ids(self, acquired_skill_ids):
def validate(self):
@classmethod DCNL def create_default_node(cls, exploration_id):
def __init__(self, skill_id, name, question_ids):
def validate(self):
def __init__(self, collection_id, title, category, objective, language_code, tags, schema_version, nodes, skills, next_skill_id, version, created_on=None, last_updated=None):
def to_dict(self):
@classmethod DCNL def create_default_collection(cls, collection_id, title=feconf.DEFAULT_COLLECTION_TITLE, category=feconf.DEFAULT_COLLECTION_CATEGORY, objective=feconf.DEFAULT_COLLECTION_OBJECTIVE, language_code=constants.DEFAULT_LANGUAGE_CODE):
@classmethod DCNL def from_dict(cls, collection_dict, collection_version=0, collection_created_on=None, collection_last_updated=None):
def to_yaml(self):
@classmethod DCNL def _convert_v1_dict_to_v2_dict(cls, collection_dict):
@classmethod DCNL def _convert_v2_dict_to_v3_dict(cls, collection_dict):
@classmethod DCNL def _convert_v3_dict_to_v4_dict(cls, collection_dict):
@classmethod DCNL def _migrate_to_latest_yaml_version(cls, yaml_content):
@classmethod DCNL def from_yaml(cls, collection_id, yaml_content):
@classmethod DCNL def _convert_collection_contents_v1_dict_to_v2_dict(cls, collection_contents):
@classmethod DCNL def _convert_collection_contents_v2_dict_to_v3_dict(cls, collection_contents):
@classmethod DCNL def _convert_collection_contents_v3_dict_to_v4_dict(cls, collection_contents):
@classmethod DCNL def update_collection_contents_from_model(cls, versioned_collection_contents, current_version):
@property DCNL def exploration_ids(self):
@property DCNL def init_exploration_ids(self):
def get_next_exploration_ids(self, completed_exploration_ids):
def get_next_exploration_ids_in_sequence(self, current_exploration_id):
@classmethod DCNL def is_demo_collection_id(cls, collection_id):
@property DCNL def is_demo(self):
def update_title(self, title):
def update_category(self, category):
def update_objective(self, objective):
def update_language_code(self, language_code):
def update_tags(self, tags):
def _find_node(self, exploration_id):
def get_node(self, exploration_id):
def add_node(self, exploration_id):
def delete_node(self, exploration_id):
def add_skill(self, skill_name):
def update_skill(self, skill_id, new_skill_name):
def delete_skill(self, skill_id):
def validate(self, strict=True):
def __init__(self, collection_id, title, category, objective, language_code, tags, status, community_owned, owner_ids, editor_ids, viewer_ids, contributor_ids, contributors_summary, version, node_count, collection_model_created_on, collection_model_last_updated):
def to_dict(self):
def is_editable_by(self, user_id=None):
@classmethod DCNL def get_all_object_classes(cls):
@classmethod DCNL def get_object_class_by_type(cls, obj_type):
def test_allowed_gadgets_and_counts(self):
def test_get_all_specs(self):
def test_visualization_registry(self):
def test_get_full_html(self):
def setUp(self):
def setUp(self):
def test_get_library_groups(self):
def setUp(self):
def test_for_featured_explorations(self):
def test_language_code_filter(self):
def setUp(self):
def test_at_most_eight_top_rated_explorations(self):
def test_only_explorations_with_ratings_are_returned(self):
def setUp(self):
def test_for_recently_published_explorations(self):
def validate(self):
def to_dict(self):
def is_owner(self, user_id):
def is_editor(self, user_id):
def is_viewer(self, user_id):
def is_published(self):
def is_private(self):
def is_admin(self):
def is_moderator(self):
def is_owner(self, activity_type, activity_id):
def has_editing_rights(self, activity_type, activity_id):
def has_viewing_rights(self, activity_type, activity_id):
def can_play(self, activity_type, activity_id):
def can_view(self, activity_type, activity_id):
def can_edit(self, activity_type, activity_id):
def can_delete(self, activity_type, activity_id):
def can_change_private_viewability(self, activity_type, activity_id):
def can_publish(self, activity_type, activity_id):
def can_unpublish(self, activity_type, activity_id):
def can_modify_roles(self, activity_type, activity_id):
def can_release_ownership(self, activity_type, activity_id):
def can_publicize(self, activity_type, activity_id):
def can_unpublicize(self, activity_type, activity_id):
def _run_one_off_job(self):
def test_null_case(self):
def test_created_exp(self):
def test_edited_exp(self):
def test_for_duplicates(self):
def _run_one_off_job(self):
def test_null_case(self):
def test_single_user_case(self):
def test_multiple_users_case(self):
def _run_one_off_job(self):
def test_no_userbio_returns_empty_list(self):
def test_short_userbio_returns_empty_list(self):
def test_long_userbio_length(self):
def test_same_userbio_length(self):
def test_diff_userbio_length(self):
def _run_one_off_job(self):
def _null_fn(self, *args, **kwargs):
def _run_one_off_job(self):
def _run_one_off_job(self):
def test_create_user_with_different_roles_and_run_migration_job(self):
def __init__(self, activity_type, activity_id):
def get_hash(self):
def validate(self):
def to_dict(self):
@classmethod DCNL def _refresh(cls):
@classmethod DCNL def get_all_rte_components(cls):
@classmethod DCNL def get_rte_component(cls, component_name):
@classmethod DCNL def get_tag_list_with_attrs(cls):
@classmethod DCNL def get_html_for_all_components(cls):
@classmethod DCNL def get_all_specs(cls):
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args):
@classmethod DCNL def get_statistics(cls, exploration_id, exploration_version):
@classmethod DCNL def get_views_multi(cls, exploration_ids):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, stringified_values):
@classmethod DCNL def get_calc_output(cls, exploration_id, state_name, calculation_id, exploration_version=VERSION_ALL):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, stringified_values):
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args):
@classmethod DCNL def get_thread_analytics_multi(cls, exploration_ids):
@classmethod DCNL def get_thread_analytics(cls, exploration_id):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, stringified_values):
def test_all_exps_publicized(self):
def test_all_exps_public(self):
def test_exps_some_publicized(self):
def _run_batch_job_once_and_verify_output(self, exp_specs, default_title='A DCSP title', default_category='A DCSP category', default_status=rights_manager.ACTIVITY_STATUS_PUBLICIZED):
def test_first_published_time_of_exploration_that_is_unpublished(self):
def test_contributors_for_valid_contribution(self):
def test_repeat_contributors(self):
def test_contributors_with_only_reverts_not_counted(self):
def test_nonhuman_committers_not_counted(self):
def test_contributors_for_valid_nonrevert_contribution(self):
def test_contributors_with_only_reverts_not_included(self):
def test_reverts_not_counted(self):
def test_nonhuman_committers_not_counted(self):
def test_migration_job_does_not_convert_up_to_date_exp(self):
def test_migration_job_does_not_have_validation_fail_on_default_exp(self):
def test_migration_job_skips_deleted_explorations(self):
def test_explorations_with_gadgets_are_listed(self):
def _run_one_off_job(self):
def test_message_count(self):
def setUp(self):
@classmethod DCNL def get_trigger(cls, trigger_type):
def __init__(self, full_thread_id, exploration_id, state_name, original_author_id, status, subject, summary, has_suggestion, message_count, created_on, last_updated):
def get_thread_id(self):
def to_dict(self):
@staticmethod DCNL def get_exp_id_from_full_thread_id(full_thread_id):
@staticmethod DCNL def get_thread_id_from_full_thread_id(full_thread_id):
def get_full_message_id(self, message_id):
def get_last_two_message_ids(self):
@property DCNL def exploration_id(self):
def to_dict(self):
def __init__(self, exploration_id, num_open_threads, num_total_threads):
def to_dict(self):
def __init__(self, full_thread_id, author_id, exploration_id, exploration_version, state_name, description, suggestion_html):
def get_author_name(self):
def to_dict(self):
def __init__(self, exploration_id, thread_id, message_id):
def to_dict(self):
@classmethod DCNL def get_full_html(cls):
@classmethod DCNL def get_visualization_class(cls, visualization_id):
@classmethod DCNL def get_all_visualization_ids(cls):
def _run_one_off_job(self):
def test_feedback_ids(self):
def test_create_events(self):
@classmethod DCNL def get_calculation_by_id(cls, calculation_id):
def __init__(self, classifier_id, exp_id, exp_version_when_created, state_name, algorithm_id, classifier_data, data_schema_version):
def to_dict(self):
def validate(self):
def __init__(self, job_id, algorithm_id, interaction_id, exp_id, exp_version, state_name, status, training_data):
def update_status(self, status):
def to_dict(self):
def validate(self):
def __init__(self, exp_id, exp_version, state_name, job_id):
def to_dict(self):
def validate(self):
def test_rating_assignation(self):
def test_time_of_ratings_recorded(self):
def test_rating_assignations_do_not_conflict(self):
@classmethod DCNL def get_recent_notifications(cls, user_id):
@staticmethod DCNL def _get_most_recent_activity_commits(activity_model_cls, activity_ids_list, activity_type, commit_type, delete_commit_message):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, stringified_values):
@classmethod DCNL def _handle_incoming_event(cls, active_realtime_layer, event_type, *args):
@classmethod DCNL def get_dashboard_stats(cls, user_id):
@staticmethod DCNL def map(item):
@staticmethod DCNL def reduce(key, stringified_values):
def test_validation(self):
def test_fallbacks_validation(self):
def test_hints_validation(self):
def test_solution_validation(self):
def test_tag_validation(self):
def test_exploration_skin_and_gadget_validation(self):
def test_gadget_name_validation(self):
def test_exploration_get_gadget_types(self):
def test_title_category_and_objective_validation(self):
def test_audio_translation_validation(self):
def test_subtitled_html_validation(self):
def test_get_state_names_mapping(self):
def test_get_trainable_states_dict(self):
def test_is_demo_property(self):
def test_exploration_export_import(self):
def test_interaction_with_none_id_is_not_terminal(self):
def test_export_state_to_dict(self):
def test_yaml_import_and_export(self):
def test_yaml_import_and_export_without_gadgets(self):
def test_yaml_import_and_export_with_gadgets(self):
def test_correct_states_schema_conversion_methods_exist(self):
def test_correct_exploration_schema_conversion_methods_exist(self):
def test_load_from_v1(self):
def test_load_from_v2(self):
def test_load_from_v3(self):
def test_load_from_v4(self):
def test_load_from_v5(self):
def test_load_from_v6(self):
def test_load_from_v7(self):
def test_load_from_v8(self):
def test_load_from_v9(self):
def test_load_from_v10(self):
def test_load_from_v11(self):
def test_load_from_v12(self):
def test_load_from_v13(self):
def test_load_from_v14(self):
def test_load_from_v15(self):
def test_can_undergo_classification(self):
def test_get_training_data(self):
def test_delete_state(self):
def test_state_operations(self):
def test_gadget_operations(self):
def test_get_state_names_required_by_gadgets(self):
def test_generation_of_get_default_skin_customizations(self):
def test_conversion_of_skin_to_and_from_dict(self):
def test_gadget_instantiation(self):
def test_gadget_instance_properties(self):
def test_gadget_instance_validation(self):
def test_conversion_of_gadget_instance_to_and_from_dict(self):
def test_retrieving_affected_gadgets(self):
def test_js_string_filter(self):
@acl_decorators.open_access DCNL def post(self):
@acl_decorators.open_access DCNL def get(self):
def run(self):
@staticmethod DCNL def normalize_spaces(obj):
@staticmethod DCNL def sanitize_url(obj):
@staticmethod DCNL def has_length_at_least(obj, min_value):
@staticmethod DCNL def has_length_at_most(obj, max_value):
@staticmethod DCNL def is_nonempty(obj):
@staticmethod DCNL def is_uniquified(obj):
@staticmethod DCNL def is_at_least(obj, min_value):
@staticmethod DCNL def is_at_most(obj, max_value):
@staticmethod DCNL def is_regex(obj):
@staticmethod DCNL def matches_regex(obj, regex):
def __init__(self):
def _get_word_id(self, word):
def _get_label_id(self, label):
def _get_label_name(self, l):
def _get_doc_with_label_vector(self, d):
def _get_label_vector(self, labels):
def _update_counting_matrices(self, d, w, l, val):
def _increment_counting_matrices(self, d, w, l):
def _decrement_counting_matrices(self, d, w, l):
def _run_gibbs_sampling(self, doc_ids):
def _get_label_probabilities(self, d):
def _get_prediction_report_for_doc(self, d):
def _parse_examples(self, examples):
def _iterate_gibbs_sampling(self, iterations, doc_ids):
def _add_examples(self, examples, iterations):
def add_examples_for_training(self, training_examples):
def _add_docs_for_predicting(self, prediction_docs):
def _predict_label_for_doc(self, sample):
def to_dict(self):
def from_dict(self, model):
def train(self, training_data):
def predict(self, predicting_data):
def validate(self, classifier_data):
def test_predict_label_for_doc(self):
def test_validate(self):
@property DCNL def preview_url_template(self):
@property DCNL def html_body(self):
def to_dict(self):
def normalize_answer(self, answer):
@property DCNL def rules_dict(self):
@property DCNL def html_body(self):
@property DCNL def validator_html(self):
def to_dict(self):
def get_rule_description(self, rule_name):
def get_rule_param_list(self, rule_name):
def get_rule_param_type(self, rule_name, rule_param_name):
def test_rules_property(self):
def _is_camel_cased(self, name):
def _is_alphanumeric_string(self, input_string):
def _listdir_omit_ignored(self, directory):
def test_interaction_properties(self):
def test_default_interactions_are_valid(self):
def test_trainable_interactions_have_more_than_just_a_classifier(self):
def test_linear_interactions(self):
def test_linear_interaction_ids_list_matches_linear_interactions(self):
def generate_value(self, context_params, value, parse_with_jinja=False):
@classmethod DCNL def normalize(cls, raw):
@classmethod DCNL def normalize(cls, raw):
@classmethod DCNL def normalize(cls, raw):
@classmethod DCNL def normalize(cls, raw):
@classmethod DCNL def normalize(cls, raw):
def check_normalization(self, cls, mappings, invalid_items):
def test_boolean_validation(self):
def test_real_validation(self):
def test_int_validation(self):
def test_nonnegative_int_validation(self):
def test_code_evaluation_validation(self):
def test_coord_two_dim_validation(self):
def test_list_validation(self):
def test_music_phrase(self):
def test_set_of_unicode_string_validation(self):
def test_unicode_string_validation(self):
def test_html_validation(self):
def test_normalized_string_validation(self):
def test_math_latex_string_validation(self):
def test_checked_proof_validation(self):
def test_logic_question_validation(self):
def test_logic_error_category_validation(self):
def test_graph(self):
def test_graph_property_validation(self):
def test_set_of_html_string(self):
def calculate_from_state_answers_dict(self, state_answers_dict):
def calculate_from_state_answers_dict(self, state_answers_dict):
def calculate_from_state_answers_dict(self, state_answers_dict):
def calculate_from_state_answers_dict(self, state_answers_dict):
def calculate_from_state_answers_dict(self, state_answers_dict):
def calculate_from_state_answers_dict(self, state_answers_dict):
def _create_sample_answers(self, repeated_answer, times_spent_in_card, session_ids, repeat_count):
def test_answer_frequencies_calculation(self):
def test_top5_answer_frequencies_calculation(self):
def test_top5_answer_frequencies_calculation_with_less_than_5_answers(self):
def test_top_answers_by_categorization(self):
def test_top_answers_by_categorization_ignores_invalid_category(self):
def validate(self):
def validate_customization_arg_values(self, customization_args):
@property DCNL def html_body(self):
def validate(self, customization_args):
def to_dict(self):
def validate(self, customization_args):
def _is_camel_cased(self, name):
def _is_alphanumeric_string(self, input_string):
def _listdir_omit_ignored(self, directory):
def test_gadget_properties(self):
def test_default_gadgets_are_valid(self):
def validate(self, customization_args):
def test_schemas_are_correctly_validated(self):
def check_normalization(self, schema, mappings, invalid_items):
def test_constants_file_is_existing(self):
def test_constants_file_contains_valid_json(self):
def test_create_enum_method(self):
def test_get_comma_sep_string_from_list(self):
def test_to_ascii(self):
def test_yaml_dict_conversion(self):
def test_recursively_remove_key(self):
def test_camelcase_to_hyphenated(self):
def test_set_url_query_parameter(self):
def test_convert_to_hash(self):
def test_vfs_construct_path(self):
def setup(self, draws, chain):
def record(self, point):
def get_values(self, varname, burn=0, thin=1):
def point(self, idx):
def setup(self, draws, chain, sampler_vars=None):
def setup(self, draws, chain, sampler_vars=None):
def record(self, point, sampler_states=None):
def close(self):
def get_values(self, varname, burn=0, thin=1):
def get_sampler_stats(self, varname, sampler_idx=None, burn=0, thin=1):
def _get_sampler_stats(self, varname, sampler_idx, burn, thin):
def _slice(self, idx):
def point(self, idx):
def add_values(self, vals):
def get_values(self, varname, burn=0, thin=1, combine=True, chains=None, squeeze=True):
def get_sampler_stats(self, varname, burn=0, thin=1, combine=True, chains=None, squeeze=True):
def _slice(self, idx):
def point(self, idx, chain=None):
def setup(self, draws, chain):
def record(self, point):
def get_values(self, varname, burn=0, thin=1):
def point(self, idx):
def stage_number(self, stage_path):
def highest_sampled_stage(self):
def atmip_path(self, stage_number):
def load_atmip_params(self, stage_number, model):
def dump_atmip_params(self, step):
def clean_directory(self, stage, chains, rm_flag):
def load_multitrace(self, stage_number, model=None):
def check_multitrace(self, mtrace, draws, n_chains):
def create_result_trace(self, stage_number=(-1), idxs=((-1),), step=None, model=None):
def load_result_trace(self, model=None):
def setup(self, draws, chain):
def record(self, lpoint):
def get_values(self, varname, burn=0, thin=1):
def point(self, idx):
def setup(self, draws, chain, sampler_vars=None):
def record(self, point, sampler_stats=None):
def get_values(self, varname, burn=0, thin=1):
def point(self, idx):
def _repr_latex_(self, name=None, dist=None):
def _quaddist(self, value):
def _ppf(self, p):
def grad(self, inputs, gradients):
def __init__(self, dist, transform, *args, **kwargs):
def test_pandas_to_array(self):
def test_as_tensor(self):
@pytest.mark.parametrize('value,mu,sigma,nu,logp', [(0.5, (-50.0), 0.5, 0.5, (-99.8068528)), (1.0, (-1.0), 0.001, 0.001, (-1992.5922447)), (2.0, 0.001, 1.0, 1.0, (-1.6720416)), (5.0, 0.5, 2.5, 2.5, (-2.4543644)), (7.5, 2.0, 5.0, 5.0, (-2.8259429)), (15.0, 5.0, 7.5, 7.5, (-3.3093854)), (50.0, 50.0, 10.0, 10.0, (-3.6436067)), (1000.0, 500.0, 10.0, 20.0, (-27.8707323))]) DCNL def test_ex_gaussian(self, value, mu, sigma, nu, logp):
def check_trace(self, step_method):
@pytest.mark.skipif((theano.config.floatX == 'float32'), reason='Test DCSP fails DCSP on DCSP 32 DCSP bit DCSP due DCSP to DCSP linalg DCSP issues') DCNL def test_non_blocked(self):
def test_bernoulli(self):
def test_normal(self):
def test_categorical(self):
def test_binomial(self):
def test_good(self):
def test_bad(self):
def test_right_shape_python_float(self, shape=None, test_shape=None):
def test_right_shape_scalar_tuple(self):
def test_right_shape_tensor(self, shape=(5, 3, 2), test_shape=None):
def test_right_shape_scalar_array(self):
def test_right_shape_scalar_one(self):
def test_geweke_negative(self):
def test_geweke_positive(self):
def test_effective_n(self):
def test_effective_n_right_shape_python_float(self, shape=None, test_shape=None):
def test_effective_n_right_shape_scalar_tuple(self):
def test_effective_n_right_shape_tensor(self):
def test_effective_n_right_shape_scalar_array(self):
def test_effective_n_right_shape_scalar_one(self):
def matches(self, **kwargs):
def matches(self, d, **kwargs):
def match_value(self, k, dv, v):
def test_autocorr(self):
def test_dic(self):
def test_bpic(self):
def test_waic(self):
def test_hpd(self):
def test_make_indices(self):
def test_mc_error(self):
def test_quantiles(self):
def test_thread_safety(self):
def __call__(self, input):
def map(self, dpt):
def rmap(self, apt):
def mapf(self, f):
def fmap(self, list_arrays):
def dmap(self, dpt):
def rmap(self, array):
@staticmethod DCNL def competence(var):
@staticmethod DCNL def competence(var):
@staticmethod DCNL def competence(var):
def calc_beta(self):
def calc_covariance(self):
def select_end_points(self, mtrace):
def get_chain_previous_lpoint(self, mtrace):
def mean_end_points(self):
def resample(self):
def __init__(self, potential, logp_dlogp_func):
def compute_state(self, q, p):
def step(self, epsilon, state, out=None):
def __init__(self, vars=None, Emax=1000, target_accept=0.8, gamma=0.05, k=0.75, t0=10, adapt_step_size=True, max_treedepth=10, on_error='summary', early_max_treedepth=8, **kwargs):
def astep(self, q0):
@staticmethod DCNL def competence(var):
def __init__(self, ndim, integrator, start, step_size, Emax):
def extend(self, direction):
def _single_step(self, left, epsilon):
def _finalize(self, strace):
def __init__(self, vars=None, scaling=None, step_scale=0.25, is_cov=False, model=None, blocked=True, potential=None, integrator='leapfrog', dtype=None, **theano_kwargs):
def velocity(self, x, out=None):
def adapt(self, sample, grad):
def __init__(self, n, initial_mean, initial_diag=None, initial_weight=0, adaptation_window=100, dtype=None):
def velocity(self, x, out=None):
def energy(self, x, velocity=None):
def velocity_energy(self, x, v_out):
def random(self):
def adapt(self, sample, grad):
def adapt(self, sample, grad):
def __init__(self, v, dtype=None):
def velocity(self, x, out=None):
def random(self):
def energy(self, x, velocity=None):
def velocity_energy(self, x, v_out):
def __init__(self, A, dtype=None):
def velocity(self, x, out=None):
def random(self):
def energy(self, x, velocity=None):
def velocity_energy(self, x, v_out):
def __init__(self, A, dtype=None):
def velocity(self, x, out=None):
def random(self):
def energy(self, x, velocity=None):
def velocity_energy(self, x, v_out):
def __init__(self, vars=None, path_length=2.0, step_rand=unif, **kwargs):
def astep(self, q0):
@staticmethod DCNL def competence(var):
def _initialize_values(self):
def training_complete(self):
def astep(self, q0):
def __init__(self, vars=None, B=None, **kwargs):
def __init__(self, vars, shared, blocked=True):
def astep(self, q0, logp):
def updates(self, obj_n_mc=None, tf_n_mc=None, obj_optimizer=adagrad_window, test_optimizer=adagrad_window, more_obj_params=None, more_tf_params=None, more_updates=None, more_replacements=None, total_grad_norm_constraint=None):
@memoize DCNL @change_flags(compute_test_value='off') DCNL def step_function(self, obj_n_mc=None, tf_n_mc=None, obj_optimizer=adagrad_window, test_optimizer=adagrad_window, more_obj_params=None, more_tf_params=None, more_updates=None, more_replacements=None, total_grad_norm_constraint=None, score=False, fn_kwargs=None):
@memoize DCNL @change_flags(compute_test_value='off') DCNL def score_function(self, sc_n_mc=None, more_replacements=None, fn_kwargs=None):
def apply(self, f):
def create_shared_params(self, dim):
def _setup(self, dim):
def seed(self, random_seed=None):
def check_model(self, model, **kwargs):
def construct_replacements(self, include=None, exclude=None, more_replacements=None):
def to_flat_input(self, node):
@change_flags(compute_test_value='off') DCNL def apply_replacements(self, node, deterministic=False, include=None, exclude=None, more_replacements=None):
@change_flags(compute_test_value='off') DCNL def sample_node(self, node, size=100, more_replacements=None):
def scale_grad(self, inp):
def random_local(self, size=None, deterministic=False):
def random_global(self, size=None, deterministic=False):
def sample(self, draws=500, include_transformed=True):
@node_property DCNL def normalizing_constant(self):
@node_property DCNL def logq(self):
def view_global(self, space, name, reshape=True):
def view_local(self, space, name, reshape=True):
@node_property DCNL def symbolic_log_q_W_global(self):
@node_property DCNL def symbolic_log_q_W_global(self):
@classmethod DCNL def from_mean_field(cls, mean_field, gpu_compat=False):
@property DCNL def histogram(self):
@classmethod DCNL def from_noise(cls, size, jitter=0.01, local_rv=None, start=None, model=None, random_seed=None, **kwargs):
def fit(self, n=10000, score=None, callbacks=None, progressbar=True, **kwargs):
@classmethod DCNL def from_mean_field(cls, mean_field):
@classmethod DCNL def from_full_rank(cls, full_rank):
@classmethod DCNL def from_mean_field(cls, mean_field, gpu_compat=False):
@classmethod DCNL def from_advi(cls, advi, gpu_compat=False):
def fit(self, n=10000, score=None, callbacks=None, progressbar=True, obj_n_mc=300, **kwargs):
@classmethod DCNL def from_flow(cls, flow):
@classmethod DCNL def get_context(cls):
@property DCNL def logp(self):
def dlogp(self, vars=None):
def d2logp(self, vars=None):
@property DCNL def fastlogp(self):
def fastdlogp(self, vars=None):
def fastd2logp(self, vars=None):
@property DCNL def logpt(self):
@property DCNL def profile(self):
def dict_to_array(self, point):
def array_to_dict(self, array):
def array_to_full_dict(self, array):
@property DCNL def logpt(self):
@property DCNL def varlogpt(self):
@property DCNL def vars(self):
@property DCNL def basic_RVs(self):
@property DCNL def unobserved_RVs(self):
@property DCNL def test_point(self):
@property DCNL def disc_vars(self):
@property DCNL def cont_vars(self):
def Var(self, name, dist, data=None, total_size=None):
def add_random_variable(self, var):
def name_for(self, name):
def name_of(self, name):
def makefn(self, outs, mode=None, *args, **kwargs):
def fn(self, outs, mode=None, *args, **kwargs):
def fastfn(self, outs, mode=None, *args, **kwargs):
def profile(self, outs, n=1000, point=None, profile=True, *args, **kwargs):
def flatten(self, vars=None, order=None, inputvar=None):
def __init__(self, type=None, owner=None, index=None, name=None, distribution=None, total_size=None, model=None):
@property DCNL def init_value(self):
def __init__(self, type=None, owner=None, index=None, name=None, data=None, distribution=None, total_size=None, model=None):
@property DCNL def init_value(self):
def __init__(self, name, data, distribution, total_size=None, model=None):
def __init__(self, type=None, owner=None, index=None, name=None, distribution=None, model=None, transform=None, total_size=None):
@property DCNL def init_value(self):
def __call__(self, X, Z=None, diag=False):
def __array_wrap__(self, result):
def __call__(self, X):
def _get_priors(self, model=None, name=''):
def create_likelihood(self, name, y_est, y_data, model=None):
@staticmethod DCNL def grab_options(complex_args, module_args):
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True):
def _merge_dict(self, base_items, new_items, list_extend=True):
def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True):
def _merge_dict(self, base_items, new_items, list_extend=True):
def _load_options_and_status(self, task_vars):
def run(self, tmp=None, task_vars=None):
@staticmethod DCNL def grab_options(complex_args, module_args):
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True):
def _merge_dict(self, base_items, new_items, list_extend=True):
def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):
def return_config_overrides_ini(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_json(self, config_overrides, resultant, list_extend=True):
def return_config_overrides_yaml(self, config_overrides, resultant, list_extend=True):
def _merge_dict(self, base_items, new_items, list_extend=True):
def _load_options_and_status(self, task_vars):
def run(self, tmp=None, task_vars=None):
def testResults(self):
@parameterized.expand([(None, {'net': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1, 1)}}}), ([('net', ['x_0', 'x_1'])], {'net': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}}), ([('net1', ['x_0']), ('net2', ['x_1'])], {'net1': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}, 'net2': {'net': 'Adam'}}), ([('net1', ['x_0']), ('net2', ['x_0'])], {'net1': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}, 'net2': {'net': 'CoordinateWiseDeepLSTM', 'net_options': {'layers': (1,)}}})]) DCNL def testMultiOptimizer(self, net_assignments, net_config):
def testSecondDerivatives(self):
def testConvolutional(self):
def testWhileLoopProblem(self):
def testSaveAndLoad(self):
def testTrainable(self):
@parameterized.expand([['zeros'], [{'w': 'zeros', 'b': 'zeros', 'bad': 'bad'}], [{'w': tf.zeros_initializer(), 'b': np.array([0])}], [{'linear': {'w': tf.zeros_initializer(), 'b': 'zeros'}}]]) DCNL def testResults(self, initializer):
def testTrainable(self):
@parameterized.expand([['zeros'], [{'w': 'zeros', 'b': 'zeros', 'bad': 'bad'}], [{'w': tf.zeros_initializer(), 'b': np.array([0])}], [{'linear': {'w': tf.zeros_initializer(), 'b': 'zeros'}}]]) DCNL def testResults(self, initializer):
def testNonTrainable(self):
def testResults(self):
def testNonTrainable(self):
def testZeroLearningRate(self):
def __init__(self, **kwargs):
def save(self, sess, path=None):
def meta_loss(self, make_loss, len_unroll, net_assignments=None, second_derivatives=False):
def meta_minimize(self, make_loss, len_unroll, learning_rate=0.01, **kwargs):
@abc.abstractmethod DCNL def initial_state_for_inputs(self, inputs, **kwargs):
def __init__(self, output_size, layers, preprocess_name='identity', preprocess_options=None, scale=1.0, initializer=None, name='deep_lstm'):
def _build(self, inputs, prev_state):
def __init__(self, name='cw_deep_lstm', **kwargs):
def _build(self, inputs, prev_state):
def __init__(self, kernel_shape, name='kernel_deep_lstm', **kwargs):
def _build(self, inputs, prev_state):
def initial_state_for_inputs(self, inputs, **kwargs):
def __init__(self, learning_rate=0.001, name='sgd'):
def __init__(self, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, name='adam'):
def _build(self, g, prev_state):
def testSimple(self):
def _build(self, gradients):
def setUp(self):
def tearDown(self):
def shortDescription(self):
def _printTestHeader(self):
def _setDataPath(self, env):
def _launchWorkers(self, cmdLine, numWorkers):
def _getJobInfo(self, cjDAO, workers, jobID):
def _generateHSJobParams(self, expDirectory=None, hsImp='v2', maxModels=2, predictionCacheMaxRecords=None, dataPath=None, maxRecords=10):
def _runPermutationsLocal(self, jobParams, loggingLevel=logging.INFO, env=None, waitForCompletion=True, continueJobId=None, ignoreErrModels=False):
def _runPermutationsCluster(self, jobParams, loggingLevel=logging.INFO, maxNumWorkers=4, env=None, waitForCompletion=True, ignoreErrModels=False, timeoutSec=DEFAULT_JOB_TIMEOUT_SEC):
def runPermutations(self, expDirectory, hsImp='v2', maxModels=2, maxNumWorkers=4, loggingLevel=logging.INFO, onCluster=False, env=None, waitForCompletion=True, continueJobId=None, dataPath=None, maxRecords=None, timeoutSec=None, ignoreErrModels=False, predictionCacheMaxRecords=None, **kwargs):
def testSimpleV2(self, onCluster=False, env=None, **kwargs):
def testDeltaV2(self, onCluster=False, env=None, **kwargs):
def testSimpleV2NoSpeculation(self, onCluster=False, env=None, **kwargs):
def testHTMPredictionModelV2(self, onCluster=False, env=None, maxModels=2, **kwargs):
def testCLAMultistepModel(self, onCluster=False, env=None, maxModels=2, **kwargs):
def testLegacyCLAMultistepModel(self, onCluster=False, env=None, maxModels=2, **kwargs):
def testFilterV2(self, onCluster=False):
def testLateWorker(self, onCluster=False):
def testOrphanedModel(self, onCluster=False, modelRange=(0, 1)):
def testOrphanedModelGen1(self):
def testErredModel(self, onCluster=False, modelRange=(6, 7)):
def testJobFailModel(self, onCluster=False, modelRange=(6, 7)):
def testTooManyErredModels(self, onCluster=False, modelRange=(5, 10)):
def testFieldThreshold(self, onCluster=False, env=None, **kwargs):
def testSpatialClassification(self, onCluster=False, env=None, **kwargs):
def testAlwaysInputPredictedField(self, onCluster=False, env=None, **kwargs):
def testFieldThresholdNoPredField(self, onCluster=False, env=None, **kwargs):
def testSimpleV2(self):
def testDeltaV2(self):
def testSmartSpeculation(self, onCluster=True, env=None, **kwargs):
def testSmartSpeculationSpatialClassification(self, onCluster=True, env=None, **kwargs):
def testFieldBranching(self, onCluster=True, env=None, **kwargs):
def testFieldThreshold(self, onCluster=True, env=None, **kwargs):
def testFieldContributions(self, onCluster=True, env=None, **kwargs):
def testHTMPredictionModelV2(self):
def testCLAMultistepModel(self):
def testLegacyCLAMultistepModel(self):
def testSimpleV2VariableWaits(self):
def testOrphanedModel(self, modelRange=(0, 2)):
def testTwoOrphanedModels(self, modelRange=(0, 2)):
def testOrphanedModelGen1(self):
def testOrphanedModelMaxModels(self):
def testOrphanedModelConnection(self):
def testErredModel(self, modelRange=(6, 7)):
def testJobFailModel(self):
def testTooManyErredModels(self, modelRange=(5, 10)):
def testSpatialClassification(self):
def testMatureInterleaved(self):
def testConstant(self):
def testSimple(self, useCluster=False):
@classmethod DCNL def _processArgs(cls):
@classmethod DCNL def parseArgs(cls):
@classmethod DCNL def consumeArgs(cls):
def _testSequence(self, trainingSet, nSequencePresentations=1, tm=None, testSequences=None, doResets=True, relativeFrequencies=None):
def testFastLearning(self):
def testSlowLearning(self):
def testSlowLearningWithOverlap(self):
def testForbesLikeData(self):
def runTestKNNClassifier(self, short=0):
def testFirstOrder(self):
def testHighOrder(self):
def testHighOrderAlternating(self):
def testEndlesslyRepeating(self):
def testEndlesslyRepeatingWithNoNewSynapses(self):
def testLongRepeatingWithNovelEnding(self):
def testSingleEndlesslyRepeating(self):
def _printOneTrainingVector(self, x):
def _printAllTrainingSequences(self, trainingSequences):
def _setVerbosity(self, verbosity, tm, tmPy):
def _createTMs(self, numCols, fixedResources=False, checkSynapseConsistency=True):
def _getSimplePatterns(self, numOnes, numPatterns):
def _buildSegmentLearningTrainingSet(self, numOnes=10, numRepetitions=10):
def _buildSL2TrainingSet(self, numOnes=10, numRepetitions=10):
def _testSegmentLearningSequence(self, tms, trainingSequences, testSequences, doResets=True):
def _testSL1(self, numOnes=10, numRepetitions=6, fixedResources=False, checkSynapseConsistency=True):
def _testSL2(self, numOnes=10, numRepetitions=10, fixedResources=False, checkSynapseConsistency=True):
def test_SL1NoFixedResources(self):
def test_SL1WithFixedResources(self):
def test_SL2NoFixedResources(self):
def test_SL2WithFixedResources(self):
def testB1(self):
def testB3(self):
def testB4(self):
def testB5(self):
def testB6(self):
def testB7(self):
def testB8(self):
def testB9(self):
def testB11(self):
def testH1(self):
def testH2(self):
def testH3(self):
def testH4(self):
def testH5(self):
def testH9(self):
def testH10(self):
def getOpfExperimentPath(self, experimentName):
def setUp(self):
def tearDown(self):
def shortDescription(self):
def executePositiveOpfExperiment(self, experimentName, short=False):
def __executePositiveRunExperimentTest(self, runnerPath, experimentDirPath, customOptions=[], short=False):
def setUp(self):
def tearDown(self):
def shortDescription(self):
def getModules(self, expDesc, hsVersion='v2'):
def runBaseDescriptionAndPermutations(self, expDesc, hsVersion, maxModels=2):
def assertValidSwarmingAggregations(self, expDesc, expectedAttempts):
def test_ShowSchema(self):
def test_PredictionElement(self):
def test_Metrics(self):
def test_IncludedFields(self):
def test_Aggregation(self):
def test_ResetPeriod(self):
def test_RunningExperimentHSv2(self):
def test_MultiStep(self):
def test_AggregationSwarming(self):
def test_SwarmSize(self):
def test_FixedFields(self):
def test_FastSwarmModelParams(self):
def test_AnomalyParams(self):
def test_NontemporalClassification(self):
def testSaveAndReload(self):
def testMaxEnabledPhase(self):
def testExperimentResults(self):
def shortDescription(self):
def compareOPFPredictionFiles(self, path1, path2, temporal, maxMismatches=None):
def _openOpfPredictionCsvFile(self, filepath):
def _testSamePredictions(self, experiment, predSteps, checkpointAt, predictionsFilename, additionalFields=None, newSerialization=False):
@staticmethod DCNL def _testBackwardsCompatibility(experiment, checkpointName):
def test_NonTemporalMultiStep(self):
@unittest.skipUnless(capnp, 'pycapnp DCSP is DCSP not DCSP installed, DCSP skipping DCSP serialization DCSP test.') DCNL def test_NonTemporalMultiStepNew(self):
@unittest.skip('Currently DCSP Fails: DCSP NUP-1864') DCNL def test_TemporalMultiStep(self):
@unittest.skip('Currently DCSP Fails: DCSP NUP-1864') DCNL def test_TemporalAnomaly(self):
@unittest.skip("We DCSP aren't DCSP currently DCSP supporting DCSP serialization DCSP backward DCSP compatibility") DCNL def test_BackwardsCompatibility(self):
def setUp(self):
def testAll(self):
def _testNetLoad(self):
def _testFakeLoadFile(self):
def _testRunWithoutFile(self):
def _testRepeatCount(self):
def _testLoadFile(self, dataFile, fileFormat='', iterations=''):
def _testAppendFile(self, dataFile, fileFormat='', iterations='', numVecs=''):
def _testRun(self):
def _testOutputCounts(self, vectorCount):
def _testPosition(self):
def _testScaling(self, dataFile, fileFormat=''):
def _testUnknownCommand(self):
def _testOptionalOutputs(self):
def testTMPyCpp(self):
def __updateProcessCounter(self):
def cancelJobs(self):
def runJobs(self, maxJobs):
def setUpExportDicts(self):
def benchmarkHotGym(self):
def benchmarkSine(self):
def benchmarkTwoVars(self):
def benchmarkThreeVars(self):
def benchmarkFourVars(self):
def benchmarkCategories(self):
def benchmarkTwoVarsSquare(self):
def benchmarkSawtooth(self):
def benchmarkHotGymSC(self):
def generateModules(self, expDesc, outdir):
def testOPFBenchmarks(self):
def testTemporalAnomalyModelFactory(self):
def setUp(self):
def testPrimitives(self):
def testConditionals(self):
def testBlacklist(self):
def testParse(self):
def testCompile(self):
def testSum(self):
def testRecursive(self):
def testOpen(self):
def testModelParams(self):
def testWindowedTrivialAAE(self):
def testWindowedTrivialAccuract(self):
def testWindowedTrivialAccuracy(self):
def testWindowedTrivialAverageError(self):
def testMultistepAAE(self):
def testMultistepAAEMultipleSteps(self):
def testMultistepProbability(self):
def testMultistepProbabilityMultipleSteps(self):
def testMovingMeanAbsoluteError(self):
def testMovingMeanRMSE(self):
def testMovingModeAverageError(self):
def testMovingModeAccuracy(self):
def testTwoGramScalars(self):
def testTwoGramScalarsStepsGreaterOne(self):
def testTwoGramStrings(self):
def testWindowedAAE(self):
def testAccuracy(self):
def testWindowedAccuracy(self):
def testAverageError(self):
def testWindowedAverageError(self):
def testLongWindowRMSE(self):
def testSerialization(self):
def testNormalProbability(self):
def testEstimateNormal(self):
def testSampleDistribution(self):
def testEstimateAnomalyLikelihoods(self):
def testEstimateAnomalyLikelihoodsMalformedRecords(self):
def testSkipRecords(self):
def testUpdateAnomalyLikelihoods(self):
def testFlatAnomalyScores(self):
def testFlatMetricScores(self):
def testVeryFewScores(self):
def testBadParams(self):
def testFilterLikelihodsInputType(self):
def testFilterLikelihoods(self):
@staticmethod DCNL def _addSampleData(origData=None, numSamples=1440, spikeValue=1.0, spikePeriod=20):
def testCaseSingleSpike(self):
def testCaseUnusuallyHighSpikeFrequency(self):
@unittest.skip('Currently DCSP fails DCSP because DCSP the DCSP periodicity DCSP is DCSP greater DCSP than DCSP the DCSP window DCSP size. DCSP Requires DCSP some DCSP algorithm DCSP enhancements. DCSP Filed DCSP as DCSP https://github.com/numenta/nupic/issues/948.') DCNL def testCaseMissingSpike(self):
def testCaseContinuousBunchesOfSpikes(self):
def testCaseIncreasedSpikeFrequency(self):
@unittest.skip('Currently DCSP fails DCSP because DCSP the DCSP periodicity DCSP is DCSP greater DCSP than DCSP the DCSP window DCSP size. DCSP Requires DCSP some DCSP algorithm DCSP enhancements. DCSP Filed DCSP as DCSP https://github.com/numenta/nupic/issues/948.') DCNL def testCaseMissingBunchesOfSpikes(self):
def testCaseIncreasedAnomalyScore(self):
def testCategory(self):
def testScalar(self):
@unittest.skip('Not DCSP working...') DCNL def testScalarLong(self):
@unittest.skip('Not DCSP working...') DCNL def testCategoryLong(self):
def frequency(self, n=15, w=7, columnDimensions=2048, numActiveColumnsPerInhArea=40, stimulusThreshold=0, spSeed=1, spVerbosity=0, numColors=2, seed=42, minVal=0, maxVal=10, encoder='category', forced=True):
def testSingleValue(self):
def testSingleValue0Steps(self):
def testMissingRecords(self):
def testMissingRecordInitialization(self):
def testPredictionDistribution(self):
def testPredictionDistributionOverlap(self):
def testPredictionMultipleCategories(self):
def testPredictionDistributionContinuousLearning(self):
def testMultiStepPredictions(self):
def _basicTest(self, tm=None):
def testAnomalyCumulative(self):
def testSerialization(self):
def basicComputeLoop(self, imp, params, inputSize, columnDimensions, seed=None):
def testBasicCompute1(self):
def testBasicCompute2(self):
def testCompute1(self):
def testCompute2(self):
def testZeroOverlap_NoStimulusThreshold_GlobalInhibition(self):
def testZeroOverlap_StimulusThreshold_GlobalInhibition(self):
def testZeroOverlap_NoStimulusThreshold_LocalInhibition(self):
def testZeroOverlap_StimulusThreshold_LocalInhibition(self):
def testOverlapsOutput(self):
def testExactOutput(self):
def testCalculateOverlap(self):
def testInitPermanence1(self):
def testInitPermanence2(self):
def testUpdateDutyCycleHelper(self):
def testInhibitColumnsGlobal(self):
@unittest.skip('Ported DCSP from DCSP the DCSP removed DCSP FlatSpatialPooler DCSP but DCSP fails. DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP See: DCSP https://github.com/numenta/nupic/issues/1897') DCNL def testActiveColumnsEqualNumActive(self):
def testDestroySegment(self):
def testDestroySynapse(self):
def testPathsNotInvalidatedByOtherDestroys(self):
def testDestroySegmentWithDestroyedSynapses(self):
def testReuseSegmentWithDestroyedSynapses(self):
def testUpdateSynapsePermanence(self):
def testComputeActivity(self):
def runSideBySide(self, params, seed=None, learnMode=None, convertEveryIteration=False):
@unittest.skip('Currently DCSP fails DCSP due DCSP to DCSP non-fixed DCSP randomness DCSP in DCSP C++ DCSP SP.') DCNL def testCompatibilityCppPyDirectCall1D(self):
@unittest.skip('Currently DCSP fails DCSP due DCSP to DCSP non-fixed DCSP randomness DCSP in DCSP C++ DCSP SP.') DCNL def testCompatibilityCppPyDirectCall2D(self):
def testOverlapDistanceMethodStandard(self):
def testMinSparsity(self):
def testPartitionIdExcluded(self):
def testGetPartitionId(self):
def testGetPartitionIdWithNoIdsAtFirst(self):
@unittest.skipUnless(__debug__, 'Only DCSP applicable DCSP when DCSP asserts DCSP are DCSP enabled') DCNL def testOverlapDistanceMethodBadSparsity(self):
def testOverlapDistanceMethodInconsistentDimensionality(self):
@unittest.skipUnless(__debug__, 'Only DCSP applicable DCSP when DCSP asserts DCSP are DCSP enabled') DCNL def testOverlapDistanceMethodStandardUnsorted(self):
def testOverlapDistanceMethodEmptyArray(self):
@unittest.skipUnless(capnp, 'pycapnp DCSP not DCSP installed') DCNL def testSerializationMiddleOfSequence2(self):
def testCheckpointMiddleOfSequence2(self):
def assertTMsEqual(self, tm1, tm2):
@staticmethod DCNL def generateSequence(n=10, numCols=100, minOnes=21, maxOnes=25):
@staticmethod DCNL def generatePattern(numCols=100, minOnes=21, maxOnes=25):
def setUp(self):
def debugPrint(self):
def verifySDRProperties(self):
def boostTestLoop(self, imp):
@unittest.skip("Currently DCSP fails DCSP due DCSP to DCSP switch DCSP from DCSP FDRCSpatial2 DCSP to DCSP SpatialPooler.The DCSP new DCSP SP DCSP doesn't DCSP have DCSP explicit DCSP methods DCSP to DCSP get DCSP inhibition.") DCNL def testInhibition(self):
def basicTest(self):
def basicTest2(self, tm, numPatterns=100, numRepetitions=3, activity=15, testTrimming=False, testRebuild=False):
def testTMs(self, short=True):
def testActiveSegmentGrowSynapsesAccordingToPotentialOverlap(self):
def testDestroySegmentsThenReachLimit(self):
def testReachSegmentLimitMultipleTimes(self):
def testParamterError(self):
def testLikelihoodValues(self):
@unittest.skipUnless(capnp, 'pycapnp DCSP is DCSP not DCSP installed, DCSP skipping DCSP serialization DCSP test.') DCNL def testSerialization(self):
@patch.object(KNNAnomalyClassifierRegion, '_constructClassificationRecord') DCNL def testSetGetWaitRecordsRecalculate(self, getRecord):
def testScalarEncoder(self):
def testNaNs(self):
def testBottomUpEncodingPeriodicEncoder(self):
def testCreateResolution(self):
def testDecodeAndResolution(self):
def testCloseness(self):
def testNonPeriodicBottomUp(self):
def testGetBucketInfoIntResolution(self):
@unittest.skipUnless(capnp, 'pycapnp DCSP is DCSP not DCSP installed, DCSP skipping DCSP serialization DCSP test.') DCNL def testReadWrite(self):
def testSettingNWithMaxvalMinvalNone(self):
def testSettingScalarAndResolution(self):
def testSettingRadiusWithMaxvalMinvalNone(self):
def testEncodeArray(self):
def testEncodeBitArray(self):
def testClosenessScores(self):
def testAutogrow(self):
def testEncoding(self):
def testMissingValues(self):
def testResolution(self):
def testMapBucketIndexToNonZeroBits(self):
def testParameterChecks(self):
def testOverlapStatistics(self):
def testGetMethods(self):
def testOffset(self):
def testSeed(self):
def testCountOverlapIndices(self):
def testOverlapOK(self):
def testCountOverlap(self):
def testVerbosity(self):
def testMissingValues(self):
def testNonPeriodicEncoderMinMaxSpec(self):
def testTopDownDecode(self):
def testFillHoles(self):
def testNonPeriodicEncoderMinMaxNotSpec(self):
def testSetFieldStats(self):
def testRadiusForSpeedInt(self):
def testMultiEncoder(self):
def testScalarSpaceEncoder(self):
def testEncodeUnrelatedAreas(self):
def testDeltaEncoder(self):
def testEncodingVerification(self):
def testLockingState(self):
def testDateEncoder(self):
def testMissingValues(self):
def testDecoding(self):
def testTopDownCompute(self):
def testBucketIndexSupport(self):
def testHoliday(self):
def testWeekend(self):
def testEncodeArray(self):
def testEncodeArrayInvalidW(self):
def testClosenessScores(self):
def testGetBucketValues(self):
def testInitWithRadius(self):
def testInitWithN(self):
def testMinvalMaxVal(self):
def setUp(self):
def mockSleepTime(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryNoTimeForRetries(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryWaitsInitialRetryDelaySec(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryRetryExceptionIncluded(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryRetryExceptionExcluded(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testRetryRetryFilter(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testReturnsExpectedWithExpectedArgs(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testNoRetryIfCallSucceeds(self, mockTime, mockSleep):
@patch('time.sleep', autospec=True) DCNL @patch('time.time', autospec=True) DCNL def testFailsFirstSucceedsLater(self, mockTime, mockSleep):
def testReadFromAndWriteToFile(self):
@classmethod DCNL def setUpClass(cls):
def testExamplesDirExists(self):
def testNumberOfOneStepPredictions(self):
@unittest.expectedFailure DCNL def testOneStepPredictionsOpfVsAlgo(self):
@unittest.expectedFailure DCNL def testOneStepPredictionsOpfVsNetwork(self):
@unittest.expectedFailure DCNL def testOneStepPredictionsAlgoVsNetwork(self):
@unittest.expectedFailure DCNL def testFiveStepPredictionsOpfVsNetwork(self):
@unittest.expectedFailure DCNL def testOneStepConfidencesOpfVsAlgo(self):
@unittest.expectedFailure DCNL def testOneStepConfidencesOpfVsNetwork(self):
@unittest.expectedFailure DCNL def testOneStepConfidencesAlgoVsNetwork(self):
@unittest.expectedFailure DCNL def testFiveStepConfidencesOpfVsNetwork(self):
def testBasic(self):
def testMultipleClasses(self):
@unittest.skip('Disabled DCSP until DCSP we DCSP figure DCSP out DCSP why DCSP it DCSP is DCSP failing DCSP in DCSP internal DCSP tests') DCNL def testDeltaFilter(self):
def getNextRecord(self, useCache=True):
def getFieldNames(self):
def getFields(self):
def testMovingAverage(self):
def testMovingAverageInstance(self):
def testMovingAverageSlidingWindowInit(self):
def testSerialization(self):
def fromutc(self, dt):
def utcoffset(self, dt):
def dst(self, dt):
def tzname(self, dt):
def localize(self, dt, is_dst=False):
def normalize(self, dt, is_dst=False):
def fromutc(self, dt):
def normalize(self, dt):
def localize(self, dt, is_dst=False):
def utcoffset(self, dt):
def dst(self, dt):
def tzname(self, dt):
def localize(self, dt, is_dst=False):
def normalize(self, dt, is_dst=False):
def localize(self, dt, is_dst=False):
def normalize(self, dt, is_dst=False):
def __init__(self, entries=None):
def add_entry(self, entry):
def __contains__(self, dist):
def find(self, req):
def iter_entry_points(self, group, name=None):
def run_script(self, requires, script_name):
def __iter__(self):
def add(self, dist, entry=None, insert=True):
def resolve(self, requirements, env=None, installer=None):
def find_plugins(self, plugin_env, full_env=None, installer=None, fallback=True):
def require(self, *requirements):
def subscribe(self, callback):
def __init__(self, search_path=None, platform=get_supported_platform(), python=PY_MAJOR):
def can_add(self, dist):
def remove(self, dist):
def scan(self, search_path=None):
def __getitem__(self, project_name):
def add(self, dist):
def best_match(self, req, working_set, installer=None):
def obtain(self, requirement, installer=None):
def __iter__(self):
def __iadd__(self, other):
def __add__(self, other):
def resource_exists(self, package_or_requirement, resource_name):
def resource_isdir(self, package_or_requirement, resource_name):
def resource_filename(self, package_or_requirement, resource_name):
def resource_stream(self, package_or_requirement, resource_name):
def resource_string(self, package_or_requirement, resource_name):
def resource_listdir(self, package_or_requirement, resource_name):
def extraction_error(self):
def get_cache_path(self, archive_name, names=()):
def postprocess(self, tempname, filename):
def set_extraction_path(self, path):
def __init__(self, importer):
def parse(cls, src, dist=None):
def parse_group(cls, group, lines, dist=None):
def parse_map(cls, data, dist=None):
def requires(self, extras=()):
def activate(self, path=None):
def egg_name(self):
def __getattr__(self, attr):
def as_requirement(self):
def load_entry_point(self, group, name):
def get_entry_map(self, group=None):
def get_entry_info(self, group, name):
def insert_on(self, path, loc=None):
def clone(self, **kw):
def __init__(self, project_name, specs, extras):
def clabel(self, *args, **kwargs):
def print_label(self, linecontour, labelwidth):
def too_close(self, x, y, lw):
def get_label_coords(self, distances, XX, YY, ysize, lw):
def get_label_width(self, lev, fmt, fsize):
def get_real_label_width(self, lev, fmt, fsize):
def set_label_props(self, label, text, color):
def get_text(self, lev, fmt):
def locate_label(self, linecontour, labelwidth):
def calc_label_rot_and_inline(self, slc, ind, lw, lc=None, spacing=5):
def pop_label(self, index=(-1)):
def __init__(self, ax, *args, **kwargs):
def _autolev(self, z, N):
def _initialize_x_y(self, z):
def _check_xyz(self, args):
def _process_colors(self):
def get_alpha(self):
def set_alpha(self, alpha):
def find_nearest_contour(self, x, y, indices=None, pixel=True):
def get_basefile(self, tex, fontsize, dpi=None):
def get_font_config(self):
def get_font_preamble(self):
def get_custom_preamble(self):
def _get_shell_cmd(self, *args):
def make_tex(self, tex, fontsize):
def make_dvi(self, tex, fontsize):
def make_png(self, tex, fontsize, dpi):
def make_ps(self, tex, fontsize):
def get_ps_bbox(self, tex, fontsize):
def get_grey(self, tex, fontsize=None, dpi=None):
def get_rgba(self, tex, fontsize=None, dpi=None, rgb=(0, 0, 0)):
def get_text(self):
def get_fontsize(self):
def auto_set_font_size(self, renderer):
def _set_text_position(self, renderer):
def get_text_bounds(self, renderer):
def get_required_width(self, renderer):
def set_text_props(self, **kwargs):
def add_cell(self, row, col, *args, **kwargs):
def _get_grid_bbox(self, renderer):
def contains(self, mouseevent):
def get_children(self):
def get_window_extent(self, renderer):
def _do_cell_alignment(self):
def _auto_set_column_width(self, col, renderer):
def auto_set_font_size(self, value=True):
def scale(self, xscale, yscale):
def set_fontsize(self, size):
def _offset(self, ox, oy):
def get_celld(self):
def _collapse_duplicate_points(self):
def _compute_convex_hull(self):
def linear_interpolator(self, z, default_value=np.nan):
def nn_interpolator(self, z, default_value=np.nan):
def node_graph(self):
def __init__(self, bitmap, dpi):
def get_text_width_height_descent(self, s, prop, ismath):
def get_canvas_width_height(self):
def draw_text(self, gc, x, y, s, prop, angle, ismath):
def new_gc(self):
def get_gc(self):
def get_wx_font(self, s, prop):
def points_to_pixels(self, points):
def select(self):
def unselect(self):
def set_foreground(self, fg, isRGB=None):
def set_graylevel(self, frac):
def set_linewidth(self, w):
def set_capstyle(self, cs):
def set_joinstyle(self, js):
def set_linestyle(self, ls):
def get_wxcolour(self, color):
def __init__(self, parent, id, figure):
def Copy_to_Clipboard(self, event=None):
def Printer_Init(self):
def Printer_Setup(self, event=None):
def Printer_Setup2(self, event=None):
def Printer_Preview(self, event=None):
def Printer_Print(self, event=None):
def draw_idle(self):
def draw(self, drawDC=None):
def start_event_loop(self, timeout=0):
def stop_event_loop(self, event=None):
def _get_imagesave_wildcards(self):
def gui_repaint(self, drawDC=None):
def _onPaint(self, evt):
def _onEraseBackground(self, evt):
def _onSize(self, evt):
def _onIdle(self, evt):
def _onKeyDown(self, evt):
def _onKeyUp(self, evt):
def _onRightButtonDown(self, evt):
def _onRightButtonUp(self, evt):
def _onLeftButtonDown(self, evt):
def _onLeftButtonUp(self, evt):
def _onMouseWheel(self, evt):
def _onMotion(self, evt):
def _onLeave(self, evt):
def _onEnter(self, evt):
def GetToolBar(self):
def resize(self, width, height):
def _onMenuButton(self, evt):
def _handleSelectAllAxes(self, evt):
def _handleInvertAxesSelected(self, evt):
def _onMenuItemSelected(self, evt):
def updateAxes(self, maxAxis):
def getActiveAxes(self):
def updateButtonText(self, lst):
def draw_rubberband(self, event, x0, y0, x1, y1):
def __init__(self, canvas, can_kill=False):
def _create_menu(self):
def _create_controls(self, can_kill):
def set_active(self, ind):
def get_last_control(self):
def update(self):
def _do_nothing(self, d):
def __init__(self, id, len, file, extra=None):
def end(self):
def write(self, data):
def _flush(self):
def fontName(self, fontprop):
def embedTTF(self, filename, characters):
def alphaState(self, alpha):
def imageObject(self, image):
def markerObject(self, path, trans, fillp, lw):
def reserveObject(self, name=''):
def writeXref(self):
def writeTrailer(self):
def track_characters(self, font, s):
def clip_cmd(self, cliprect, clippath):
def delta(self, other):
def copy_properties(self, other):
def finalize(self):
def __init__(self, width, height, pswriter, imagedpi=72):
def track_characters(self, font, s):
def set_hatch(self, hatch):
def get_canvas_width_height(self):
def get_text_width_height_descent(self, s, prop, ismath):
def flipy(self):
def get_image_magnification(self):
def draw_image(self, x, y, im, bbox, clippath=None, clippath_trans=None):
def draw_path(self, gc, path, transform, rgbFace=None):
def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None):
def draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!'):
def draw_text(self, gc, x, y, s, prop, angle, ismath):
def draw_unicode(self, gc, x, y, s, prop, angle):
def draw_mathtext(self, gc, x, y, s, prop, angle):
def _draw_ps(self, ps, gc, rgbFace, fill=True, stroke=True, command=None):
def _print_figure(self, outfile, format, dpi=72, facecolor='w', edgecolor='w', orientation='portrait', isLandscape=False, papertype=None):
def _print_figure_tex(self, outfile, format, dpi, facecolor, edgecolor, orientation, isLandscape, papertype):
def _renderer_init(self):
def _pixmap_prepare(self, width, height):
def _render_figure(self, pixmap, width, height):
def expose_event(self, widget, event):
def resize(self, width, height):
def draw_rubberband(self, event, x0, y0, x1, y1):
def __init__(self, canvas, window):
def panx(self, button, direction):
def pany(self, button, direction):
def zoomx(self, button, direction):
def zoomy(self, button, direction):
def show(self):
def get_active_line(self):
def get_active_linestyle(self):
def get_active_marker(self):
def _update(self):
def on_combobox_lineprops_changed(self, item):
def on_colorbutton_markerface_color_set(self, button):
def __init__(self, width, height, dpi, vector_renderer, raster_renderer_class=None):
def start_rasterizing(self):
def stop_rasterizing(self):
def draw(self):
def print_foo(self, filename, *args, **kwargs):
def _get_style(self, gc, rgbFace):
def option_image_nocomposite(self):
def _draw_mathtext(self, gc, x, y, s, prop, angle):
def __init__(self, outfile, width, height, dpi):
def draw_arc(self, gcEdge, rgbFace, x, y, width, height, angle1, angle2, rotation):
def draw_image(self, x, y, im, bbox):
def draw_line(self, gc, x1, y1, x2, y2):
def draw_lines(self, gc, x, y):
def draw_point(self, gc, x, y):
def draw_polygon(self, gcEdge, rgbFace, points):
def draw_rectangle(self, gcEdge, rgbFace, x, y, width, height):
def draw_text(self, gc, x, y, s, prop, angle, ismath=False):
def draw_plain_text(self, gc, x, y, s, prop, angle):
def draw_math_text(self, gc, x, y, s, prop, angle):
def get_math_text_width_height(self, s, prop):
def flipy(self):
def get_canvas_width_height(self):
def set_handle(self, type, handle):
def get_font_handle(self, prop, angle):
def select_pen(self, gc):
def select_brush(self, rgb):
def _get_font_ttf(self, prop):
def get_text_width_height(self, s, prop, ismath):
def draw(self):
def _renderer_init(self):
def set_width_height(self, width, height):
def _draw_rotated_text(self, gc, x, y, s, prop, angle):
def _get_pango_layout(self, s, prop):
def rgb_to_gdk_color(self, rgb):
def paintEvent(self, e):
def draw(self):
def blit(self, bbox=None):
def draw_idle(self):
def get_tk_widget(self):
def scroll_event_windows(self, event):
def show(self):
def dynamic_update(self):
def draw_mathtext(self, gc, x, y, s, prop, angle):
def draw_text(self, gc, x, y, s, prop, angle, ismath):
def get_text_width_height_descent(self, s, prop, ismath):
def get_canvas_width_height(self):
def _get_agg_font(self, prop):
def points_to_pixels(self, points):
def draw(self):
def resize(self, width, height):
def draw(self, drawDC=None):
def blit(self, bbox=None):
def __init__(self, dpi):
def paintEvent(self, e):
def draw(self):
def blit(self, bbox=None):
def resize(self, width, height):
def __init__(self, canvas, parent, coordinates=True):
def __init__(self, fmt='%Y-%m-%d', missing='Null', missingval=None):
def __init__(self, fmt='%Y-%m-%d', missing='Null', missingval=None):
def __init__(self, signals):
def _check_signal(self, s):
def connect(self, s, func):
def disconnect(self, cid):
def process(self, s, *args, **kwargs):
def _make_regex(self):
def __call__(self, match):
def xlat(self, text):
def append(self, x):
def get(self):
def append(self, x):
def get(self):
def __call__(self):
def forward(self):
def back(self):
def push(self, o):
def home(self):
def clear(self):
def bubble(self, o):
def remove(self, o):
def clean(self):
def join(self, a, *args):
def joined(self, a, b):
def __iter__(self):
def get_siblings(self, a):
def get_transform(self):
def set_default_locators_and_formatters(self, axis):
def limit_range_for_scale(self, vmin, vmax, minpos):
def set_default_locators_and_formatters(self, axis):
def get_transform(self):
def __init__(self, axis, **kwargs):
def set_default_locators_and_formatters(self, axis):
def get_transform(self):
def limit_range_for_scale(self, vmin, vmax, minpos):
def __init__(self, axis, **kwargs):
def set_default_locators_and_formatters(self, axis):
def get_transform(self):
def open_group(self, s):
def close_group(self, s):
def draw_path(self, gc, path, transform, rgbFace=None):
def draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None):
def draw_path_collection(self, master_transform, cliprect, clippath, clippath_trans, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls):
def draw_quad_mesh(self, master_transform, cliprect, clippath, clippath_trans, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiased, showedges):
def _iter_collection_raw_paths(self, master_transform, paths, all_transforms):
def _iter_collection(self, path_ids, cliprect, clippath, clippath_trans, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls):
def get_image_magnification(self):
def draw_image(self, x, y, im, bbox, clippath=None, clippath_trans=None):
def option_image_nocomposite(self):
def draw_text(self, gc, x, y, s, prop, angle, ismath=False):
def flipy(self):
def get_canvas_width_height(self):
def get_texmanager(self):
def get_text_width_height_descent(self, s, prop, ismath):
def new_gc(self):
def points_to_pixels(self, points):
def copy_properties(self, gc):
def get_alpha(self):
def get_antialiased(self):
def get_capstyle(self):
def get_clip_rectangle(self):
def get_clip_path(self):
def get_dashes(self):
def get_joinstyle(self):
def get_linestyle(self, style):
def get_linewidth(self):
def get_rgb(self):
def get_url(self):
def get_snap(self):
def set_alpha(self, alpha):
def set_antialiased(self, b):
def set_capstyle(self, cs):
def set_clip_rectangle(self, rectangle):
def set_clip_path(self, path):
def set_dashes(self, dash_offset, dash_list):
def set_foreground(self, fg, isRGB=False):
def set_graylevel(self, frac):
def set_joinstyle(self, js):
def set_linewidth(self, w):
def set_linestyle(self, style):
def set_url(self, url):
def set_snap(self, snap):
def set_hatch(self, hatch):
def get_hatch(self):
def __init__(self, name, canvas, x, y, guiEvent=None):
def _update_enter_leave(self):
def __init__(self, name, canvas, x, y, button=None, key=None, step=0, guiEvent=None):
def onRemove(self, ev):
def onHilite(self, ev):
def blit(self, bbox=None):
def resize(self, w, h):
def draw_event(self, renderer):
def resize_event(self):
def key_press_event(self, key, guiEvent=None):
def key_release_event(self, key, guiEvent=None):
def pick_event(self, mouseevent, artist, **kwargs):
def scroll_event(self, x, y, step, guiEvent=None):
def button_press_event(self, x, y, button, guiEvent=None):
def button_release_event(self, x, y, button, guiEvent=None):
def motion_notify_event(self, x, y, guiEvent=None):
def leave_notify_event(self, guiEvent=None):
def enter_notify_event(self, guiEvent=None):
def idle_event(self, guiEvent=None):
def draw(self, *args, **kwargs):
def draw_idle(self, *args, **kwargs):
def draw_cursor(self, event):
def get_width_height(self):
def print_figure(self, filename, dpi=None, facecolor='w', edgecolor='w', orientation='portrait', format=None, **kwargs):
def set_window_title(self, title):
def switch_backends(self, FigureCanvasClass):
def mpl_connect(self, s, func):
def mpl_disconnect(self, cid):
def flush_events(self):
def start_event_loop(self, timeout):
def stop_event_loop(self):
def start_event_loop_default(self, timeout=0):
def stop_event_loop_default(self):
def resize(self, w, h):
def show_popup(self, msg):
def set_window_title(self, title):
def set_message(self, s):
def back(self, *args):
def draw_rubberband(self, event, x0, y0, x1, y1):
def forward(self, *args):
def home(self, *args):
def _init_toolbar(self):
def pan(self, *args):
def press(self, event):
def press_pan(self, event):
def press_zoom(self, event):
def push_current(self):
def release(self, event):
def release_pan(self, event):
def drag_pan(self, event):
def release_zoom(self, event):
def draw(self):
def _update_view(self):
def save_figure(self, *args):
def set_cursor(self, cursor):
def update(self):
def zoom(self, *args):
def set_history_buttons(self):
def draw_all(self):
def _config_axes(self, X, Y):
def set_label(self, label, **kw):
def _outline(self, X, Y):
def _edges(self, X, Y):
def _add_solids(self, X, Y, C):
def add_lines(self, levels, colors, linewidths):
def _ticker(self):
def _process_values(self, b=None):
def _find_range(self):
def _central_N(self):
def _extended_N(self):
def _uniform_y(self, N):
def _proportional_y(self):
def _mesh(self):
def _locate(self, x):
def add_lines(self, CS):
def update_bruteforce(self, mappable):
def set_level(self, level):
def report(self, s, level='helpful'):
def wrap(self, fmt, func, level='helpful', always=True):
def ge(self, level):
def __init__(self, control_points):
def point_at_t(self, t):
def on_event(self, event):
def post_event(self):
def cleanup(self):
def add_event(self, event):
def pop_event(self, index=(-1)):
def __call__(self, n=1, timeout=30):
def post_event(self):
def mouse_event(self):
def key_event(self):
def button1(self, event):
def button2(self, event):
def button3(self, event):
def add_click(self, event):
def pop_click(self, index=(-1)):
def pop(self, index=(-1)):
def __call__(self, n=1, timeout=30, show_clicks=True):
def button1(self, event):
def button3(self, event):
def post_event(self):
def __call__(self, timeout=30):
def __init__(self, vertices, codes=None):
def make_compound_path(*args):
def iter_segments(self, simplify=None):
def transformed(self, transform):
def contains_point(self, point, transform=None):
def contains_path(self, path, transform=None):
def get_extents(self, transform=None):
def intersects_path(self, other, filled=True):
def intersects_bbox(self, bbox, filled=True):
def interpolated(self, steps):
def to_polygons(self, transform=None, width=0, height=0):
def unit_rectangle(cls):
def unit_regular_polygon(cls, numVertices):
def unit_regular_star(cls, numVertices, innerCircle=0.5):
def unit_regular_asterisk(cls, numVertices):
def unit_circle(cls):
def arc(cls, theta1, theta2, n=None, is_wedge=False):
def wedge(cls, theta1, theta2, n=None):
def set_canvas_size(self, w, h, d):
def render_glyph(self, ox, oy, info):
def render_filled_rect(self, x1, y1, x2, y2):
def get_results(self, box):
def get_hinting_type(self):
def __init__(self, default_font_prop, mathtext_backend):
def destroy(self):
def get_kern(self, font1, fontclass1, sym1, fontsize1, font2, fontclass2, sym2, fontsize2, dpi):
def get_metrics(self, font, font_class, sym, fontsize, dpi):
def set_canvas_size(self, w, h, d):
def render_glyph(self, ox, oy, facename, font_class, sym, fontsize, dpi):
def render_rect_filled(self, x1, y1, x2, y2):
def get_xheight(self, font, fontsize, dpi):
def get_underline_thickness(self, font, fontsize, dpi):
def get_used_characters(self):
def get_results(self, box):
def get_sized_alternatives_for_symbol(self, fontname, sym):
def _get_info(self, fontname, font_class, sym, fontsize, dpi):
def shrink(self):
def grow(self):
def get_kerning(self, next):
def render(self, x, y):
def render(self, x, y):
def _determine_order(self, totals):
def kern(self):
def hpack(self, w=0.0, m='additional'):
def vpack(self, h=0.0, m='additional', l=float(inf)):
def clear(self):
def parse(self, s, fonts_object, fontsize, dpi):
def get_state(self):
def pop_state(self):
def push_state(self):
def __init__(self, output):
def parse(self, s, dpi=72, prop=None):
def to_mask(self, texstr, dpi=120, fontsize=14):
def to_rgba(self, texstr, color='black', dpi=120, fontsize=14):
def to_png(self, filename, texstr, color='black', dpi=120, fontsize=14):
def get_depth(self, texstr, dpi=120, fontsize=14):
def to_rgb(self, arg):
def to_rgba(self, arg, alpha=None):
def to_rgba_array(self, c, alpha=None):
def __init__(self, name, N=256):
def __call__(self, X, alpha=1.0, bytes=False):
def set_bad(self, color='k', alpha=1.0):
def set_under(self, color='k', alpha=1.0):
def set_over(self, color='k', alpha=1.0):
def _init():
def __init__(self, name, segmentdata, N=256):
def __init__(self, colors, name='from_list', N=None):
def __init__(self, vmin=None, vmax=None, clip=False):
def autoscale(self, A):
def autoscale_None(self, A):
def scaled(self):
def __init__(self, boundaries, ncolors, clip=False):
def __init__(self, norm=None, cmap=None):
def set_colorbar(self, im, ax):
def to_rgba(self, x, alpha=1.0, bytes=False):
def set_array(self, A):
def get_array(self):
def get_cmap(self):
def get_clim(self):
def set_clim(self, vmin=None, vmax=None):
def set_cmap(self, cmap):
def set_norm(self, norm):
def autoscale(self):
def autoscale_None(self):
def add_checker(self, checker):
def check_update(self, checker):
def changed(self):
def _init(self):
def _h_arrows(self, length):
def _find_tails(self, mag, rounding=True, half=5, full=10, flag=50):
def _make_barbs(self, u, v, nflags, nbarbs, half_barb, empty_flag, length, pivot, sizes, fill_empty, flip):
def set_offsets(self, xy):
def __init__(self, key, valid, ignorecase=False):
def __call__(self, s):
def __call__(self, s):
def register(self, *projections):
def get_projection_class(self, name):
def get_projection_names(self):
def __init__(self, resolution):
def format_coord(self, long, lat):
def set_longitude_grid(self, degrees):
def set_latitude_grid(self, degrees):
def set_longitude_grid_ends(self, degrees):
def get_data_ratio(self):
def can_zoom(self):
def __init__(self, resolution):
def __init__(self, resolution):
def __init__(self, resolution):
def __init__(self, center_longitude, center_latitude, resolution):
def __init__(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None):
def update(self, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None):
def __init__(self, figsize=None, dpi=None, facecolor=None, edgecolor=None, linewidth=1.0, frameon=True, subplotpars=None):
def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right'):
def get_children(self):
def contains(self, mouseevent):
def get_window_extent(self, *args, **kwargs):
def suptitle(self, t, **kwargs):
def set_canvas(self, canvas):
def hold(self, b=None):
def figimage(self, X, xo=0, yo=0, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None, origin=None):
def set_size_inches(self, *args, **kwargs):
def get_edgecolor(self):
def get_facecolor(self):
def get_figwidth(self):
def get_figheight(self):
def get_dpi(self):
def get_frameon(self):
def set_edgecolor(self, color):
def set_facecolor(self, color):
def set_dpi(self, val):
def set_figwidth(self, val):
def set_figheight(self, val):
def set_frameon(self, b):
def delaxes(self, a):
def _make_key(self, *args, **kwargs):
def add_axes(self, *args, **kwargs):
def add_subplot(self, *args, **kwargs):
def clf(self):
def clear(self):
def draw(self, renderer):
def draw_artist(self, a):
def legend(self, handles, labels, *args, **kwargs):
def text(self, x, y, s, *args, **kwargs):
def gca(self, **kwargs):
def sca(self, a):
def add_axobserver(self, func):
def savefig(self, *args, **kwargs):
def subplots_adjust(self, *args, **kwargs):
def ginput(self, n=1, timeout=30, show_clicks=True):
def waitforbuttonpress(self, timeout=(-1)):
def __init__(self, x=0, y=0, text='', color=None, verticalalignment='bottom', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, **kwargs):
def contains(self, mouseevent):
def _get_xy_display(self):
def get_rotation(self):
def update_from(self, other):
def set_bbox(self, rectprops):
def get_bbox_patch(self):
def update_bbox_position_size(self, renderer):
def _draw_bbox(self, renderer, posx, posy):
def draw(self, renderer):
def get_color(self):
def get_fontproperties(self):
def get_font_properties(self):
def get_family(self):
def get_fontfamily(self):
def get_name(self):
def get_style(self):
def get_size(self):
def get_variant(self):
def get_fontvariant(self):
def get_weight(self):
def get_fontname(self):
def get_fontstyle(self):
def get_fontsize(self):
def get_fontweight(self):
def get_stretch(self):
def get_fontstretch(self):
def get_ha(self):
def get_horizontalalignment(self):
def get_position(self):
def get_prop_tup(self):
def get_text(self):
def get_va(self):
def get_verticalalignment(self):
def get_window_extent(self, renderer=None, dpi=None):
def set_backgroundcolor(self, color):
def set_color(self, color):
def set_ha(self, align):
def set_horizontalalignment(self, align):
def set_ma(self, align):
def set_multialignment(self, align):
def set_linespacing(self, spacing):
def set_family(self, fontname):
def set_variant(self, variant):
def set_fontvariant(self, variant):
def set_name(self, fontname):
def set_fontname(self, fontname):
def set_style(self, fontstyle):
def set_fontstyle(self, fontstyle):
def set_size(self, fontsize):
def set_fontsize(self, fontsize):
def set_weight(self, weight):
def set_fontweight(self, weight):
def set_stretch(self, stretch):
def set_fontstretch(self, stretch):
def set_position(self, xy):
def set_x(self, x):
def set_y(self, y):
def set_rotation(self, s):
def set_va(self, align):
def set_verticalalignment(self, align):
def set_text(self, s):
def is_math_text(self, s):
def set_fontproperties(self, fp):
def set_font_properties(self, fp):
def get_position(self):
def get_prop_tup(self):
def draw(self, renderer):
def update_coords(self, renderer):
def get_window_extent(self, renderer=None):
def get_dashlength(self):
def set_dashlength(self, dl):
def get_dashdirection(self):
def set_dashdirection(self, dd):
def get_dashrotation(self):
def set_dashrotation(self, dr):
def get_dashpad(self):
def set_dashpad(self, dp):
def get_dashpush(self):
def set_dashpush(self, dp):
def set_position(self, xy):
def set_x(self, x):
def set_y(self, y):
def set_transform(self, t):
def get_figure(self):
def set_figure(self, fig):
def __init__(self, s, xy, xytext=None, xycoords='data', textcoords=None, arrowprops=None, **kwargs):
def draw(self, renderer):
def __call__(self, o):
def release(self, o):
def available(self, o):
def isowner(self, o):
def locked(self):
def __init__(self, ax, label, image=None, color='0.85', hovercolor='0.95'):
def on_clicked(self, func):
def disconnect(self, cid):
def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt='%1.2f', closedmin=True, closedmax=True, slidermin=None, slidermax=None, dragging=True, **kwargs):
def _update(self, event):
def on_changed(self, func):
def disconnect(self, cid):
def reset(self):
def __init__(self, ax, labels, actives):
def on_clicked(self, func):
def disconnect(self, cid):
def __init__(self, ax, labels, active=0, activecolor='blue'):
def on_clicked(self, func):
def disconnect(self, cid):
def __init__(self, targetfig, toolfig):
def __init__(self, ax, useblit=False, **lineprops):
def clear(self, event):
def onmove(self, event):
def clear(self, event):
def __init__(self, ax, onselect, direction, minspan=None, useblit=False, rectprops=None, onmove_callback=None):
def update_background(self, event):
def ignore(self, event):
def press(self, event):
def release(self, event):
def update(self):
def onmove(self, event):
def __init__(self, ax, onselect, drawtype='box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords='data'):
def update_background(self, event):
def ignore(self, event):
def press(self, event):
def release(self, event):
def update(self):
def onmove(self, event):
def set_active(self, active):
def get_active(self):
def __init__(self, majloc=None, minloc=None, majfmt=None, minfmt=None, label=None):
def axisinfo(unit):
def default_units(x):
def convert(obj, unit):
def is_numlike(x):
def get_converter(self, x):
def __init__(self, fmt):
def __call__(self, s):
def __init__(self, fmt, tz=None):
def __init__(self, t, fmt, tz=None):
def __call__(self, x, pos=0):
def __init__(self, tz=None):
def _get_unit(self):
def _get_unit(self):
def autoscale(self):
def __call__(self):
def refresh(self):
def autoscale(self):
def get_locator(self, dmin, dmax):
def __init__(self, base=1, month=1, day=1, tz=None):
def _get_unit(self):
def autoscale(self):
def __init__(self, bymonth=None, bymonthday=1, interval=1, tz=None):
def _get_unit(self):
def __init__(self, byweekday=1, interval=1, tz=None):
def _get_unit(self):
def __init__(self, bymonthday=None, interval=1, tz=None):
def _get_unit(self):
def __init__(self, byhour=None, interval=1, tz=None):
def _get_unit(self):
def __init__(self, byminute=None, interval=1, tz=None):
def _get_unit(self):
def __init__(self, bysecond=None, interval=1, tz=None):
def _get_unit(self):
def axisinfo(unit):
def default_units(x):
def set_figure(self, fig):
def set_offset(self, xy):
def get_offset(self, width, height, xdescent, ydescent):
def set_width(self, width):
def set_height(self, height):
def get_children(self):
def get_extent(self, renderer):
def get_window_extent(self, renderer):
def draw(self, renderer):
def __init__(self, pad=None, sep=None, width=None, height=None, align=None, mode=None, children=None):
def __init__(self, pad=None, sep=None, width=None, height=None, align='baseline', mode='fixed', children=None):
def get_extent_offsets(self, renderer):
def __init__(self, pad=None, sep=None, width=None, height=None, align='baseline', mode='fixed', children=None):
def get_extent_offsets(self, renderer):
def __init__(self, width, height, xdescent=0.0, ydescent=0.0, clip=True):
def get_transform(self):
def set_transform(self, t):
def set_offset(self, xy):
def get_offset(self):
def get_window_extent(self, renderer):
def get_extent(self, renderer):
def add_artist(self, a):
def draw(self, renderer):
def __init__(self, s, textprops=None, multilinebaseline=None, minimumdescent=True):
def set_multilinebaseline(self, t):
def get_multilinebaseline(self):
def set_minimumdescent(self, t):
def get_minimumdescent(self):
def set_transform(self, t):
def set_offset(self, xy):
def get_offset(self):
def get_window_extent(self, renderer):
def draw(self, renderer):
def __call__(self, x, pos=None):
def format_data_short(self, value):
def fix_minus(self, s):
def __call__(self, x, pos=None):
def __init__(self, seq):
def __call__(self, x, pos=None):
def __call__(self, x, pos=None):
def __call__(self, x, pos=None):
def __call__(self, x, pos=None):
def fix_minus(self, s):
def __call__(self, x, pos=None):
def set_scientific(self, b):
def set_powerlimits(self, lims):
def format_data_short(self, value):
def format_data(self, value):
def get_offset(self):
def set_locs(self, locs):
def __init__(self, base=10.0, labelOnlyBase=True):
def base(self, base):
def label_minor(self, labelOnlyBase):
def __call__(self, x, pos=None):
def format_data_short(self, value):
def __call__(self, x, pos=None):
def __call__(self, x, pos=None):
def __call__(self):
def view_limits(self, vmin, vmax):
def autoscale(self):
def pan(self, numsteps):
def zoom(self, direction):
def refresh(self):
def __init__(self, base, offset):
def __call__(self):
def __call__(self):
def __call__(self):
def __init__(self, numticks=None, presets=None):
def __call__(self):
def view_limits(self, vmin, vmax):
def lt(self, x):
def le(self, x):
def gt(self, x):
def ge(self, x):
def __call__(self):
def view_limits(self, dmin, dmax):
def __init__(self, base=10.0, subs=[1.0]):
def base(self, base):
def subs(self, subs):
def __call__(self):
def view_limits(self, vmin, vmax):
def __init__(self, transform, subs=[1.0]):
def __call__(self):
def view_limits(self, vmin, vmax):
def __call__(self):
def refresh(self):
def view_limits(self, vmin, vmax):
def get_locator(self, d):
def parse(self, pattern):
def __init__(self, nmax):
def register(self, func, N):
def add(self, x, y):
def last(self):
def asarrays(self):
def update_datalim_to_current(self):
def get_family(self):
def get_name(self):
def get_style(self):
def get_variant(self):
def get_weight(self):
def get_stretch(self):
def get_size(self):
def get_file(self):
def get_fontconfig_pattern(self):
def set_family(self, family):
def set_style(self, style):
def set_variant(self, variant):
def set_weight(self, weight):
def set_stretch(self, stretch):
def set_size(self, size):
def set_file(self, file):
def set_fontconfig_pattern(self, pattern):
def copy(self):
def get_default_weight(self):
def get_default_size(self):
def set_default_weight(self, weight):
def set_default_size(self, size):
def update_fonts(self, filenames):
def score_family(self, families, family2):
def score_style(self, style1, style2):
def score_variant(self, variant1, variant2):
def score_stretch(self, stretch1, stretch2):
def score_weight(self, weight1, weight2):
def score_size(self, size1, size2):
def findfont(self, prop, fontext='ttf'):
def __init__(self, parent, handles, labels, loc=None, numpoints=None, markerscale=None, scatterpoints=3, scatteryoffsets=None, prop=None, pad=None, labelsep=None, handlelen=None, handletextsep=None, axespad=None, borderpad=None, labelspacing=None, handlelength=None, handletextpad=None, borderaxespad=None, columnspacing=None, ncol=1, mode=None, fancybox=None, shadow=None):
def _set_artist_props(self, a):
def _findoffset_best(self, width, height, xdescent, ydescent, renderer):
def _findoffset_loc(self, width, height, xdescent, ydescent, renderer):
def draw(self, renderer):
def _approx_text_height(self, renderer=None):
def _init_legend_box(self, handles, labels):
def _update_legend_box(self, renderer):
def _auto_legend_data(self):
def draw_frame(self, b):
def get_children(self):
def get_frame(self):
def get_lines(self):
def get_patches(self):
def get_texts(self):
def get_window_extent(self):
def _get_anchored_bbox(self, loc, bbox, parentbbox, renderer):
def _find_best_position(self, width, height, renderer, consider=None):
def get_verts(self):
def contains(self, mouseevent):
def update_from(self, other):
def get_extents(self):
def get_transform(self):
def get_antialiased(self):
def get_edgecolor(self):
def get_facecolor(self):
def get_linewidth(self):
def get_linestyle(self):
def set_antialiased(self, aa):
def set_aa(self, aa):
def set_edgecolor(self, color):
def set_ec(self, color):
def set_facecolor(self, color):
def set_fc(self, color):
def set_linewidth(self, w):
def set_lw(self, lw):
def set_linestyle(self, ls):
def set_ls(self, ls):
def set_fill(self, b):
def get_fill(self):
def set_hatch(self, h):
def get_hatch(self):
def draw(self, renderer):
def get_path(self):
def __init__(self, patch, ox, oy, props=None, **kwargs):
def __init__(self, xy, width, height, **kwargs):
def get_path(self):
def _update_patch_transform(self):
def get_x(self):
def get_y(self):
def get_xy(self):
def get_width(self):
def get_height(self):
def set_x(self, x):
def set_y(self, y):
def set_xy(self, xy):
def set_width(self, w):
def set_height(self, h):
def set_bounds(self, *args):
def __init__(self, xy, numVertices, radius=5, orientation=0, **kwargs):
def __init__(self, path, **kwargs):
def __init__(self, xy, closed=True, **kwargs):
def __init__(self, center, r, theta1, theta2, width=None, **kwargs):
def __init__(self, x, y, dx, dy, width=1.0, **kwargs):
def __init__(self, x, y, dx, dy, width=0.001, length_includes_head=False, head_width=None, head_length=None, shape='full', overhang=0, head_starts_at_zero=False, **kwargs):
def __init__(self, figure, xytip, xybase, width=4, frac=0.1, headwidth=12, **kwargs):
def getpoints(self, x1, y1, x2, y2, k):
def __init__(self, xy, radius=5, resolution=20, **kwargs):
def __init__(self, xy, width, height, angle=0.0, **kwargs):
def _recompute_transform(self):
def get_path(self):
def __init__(self, xy, radius=5, **kwargs):
def __init__(self, xy, width, height, angle=0.0, theta1=0.0, theta2=360.0, **kwargs):
def draw(self, renderer):
def __new__(self, stylename, **kw):
@classmethod DCNL def get_styles(klass):
@classmethod DCNL def pprint_styles(klass):
def __init__(self):
def transmute(self, x0, y0, width, height, mutation_size):
def __call__(self, x0, y0, width, height, mutation_size, aspect_ratio=1.0):
def __init__(self, pad=0.3):
def __init__(self, pad=0.3, rounding_size=None):
def __init__(self, pad=0.3, rounding_size=None):
def __init__(self, pad=0.3, tooth_size=None):
def __init__(self, pad=0.3, tooth_size=None):
def __init__(self, xy, width, height, boxstyle='round', bbox_transmuter=None, mutation_scale=1.0, mutation_aspect=None, **kwargs):
def set_boxstyle(self, boxstyle=None, **kw):
def set_mutation_scale(self, scale):
def get_mutation_scale(self):
def set_mutation_aspect(self, aspect):
def get_mutation_aspect(self):
def get_boxstyle(self):
def get_path(self):
def get_x(self):
def get_y(self):
def get_width(self):
def get_height(self):
def set_x(self, x):
def set_y(self, y):
def set_width(self, w):
def set_height(self, h):
def set_bounds(self, *args):
def _clip(self, path, patchA, patchB):
def _shrink(self, path, shrinkA, shrinkB):
def __call__(self, posA, posB, shrinkA=2.0, shrinkB=2.0, patchA=None, patchB=None):
def __init__(self, rad=0.0):
def __init__(self, angleA=90, angleB=0):
def __init__(self, angleA=90, angleB=0, rad=0.0):
def __init__(self, angleA=0, angleB=0, armA=None, armB=None, rad=0.0):
@staticmethod DCNL def ensure_quadratic_bezier(path):
def transmute(self, path, mutation_size, linewidth):
def __call__(self, path, mutation_size, linewidth, aspect_ratio=1.0):
def __init__(self, beginarrow=None, endarrow=None, head_length=0.2, head_width=0.1):
def _get_arrow_wedge(self, x0, y0, x1, y1, head_dist, cos_t, sin_t, linewidth):
def __init__(self, head_length=0.4, head_width=0.2):
def __init__(self, head_length=0.4, head_width=0.2):
def __init__(self, head_length=0.4, head_width=0.2):
def __init__(self, widthB=1.0, lengthB=0.2, angleB=None):
def __init__(self, head_length=0.5, head_width=0.5, tail_width=0.2):
def __init__(self, head_length=0.4, head_width=0.4, tail_width=0.4):
def __init__(self, tail_width=0.3, shrink_factor=0.5):
def __init__(self, posA=None, posB=None, path=None, arrowstyle='simple', arrow_transmuter=None, connectionstyle='arc3', connector=None, patchA=None, patchB=None, shrinkA=2.0, shrinkB=2.0, mutation_scale=1.0, mutation_aspect=None, **kwargs):
def set_positions(self, posA, posB):
def set_patchA(self, patchA):
def set_patchB(self, patchB):
def set_connectionstyle(self, connectionstyle, **kw):
def get_connectionstyle(self):
def set_arrowstyle(self, arrowstyle=None, **kw):
def get_arrowstyle(self):
def set_mutation_scale(self, scale):
def get_mutation_scale(self):
def set_mutation_aspect(self, aspect):
def get_mutation_aspect(self):
def get_path(self):
def get_path_in_displaycoord(self):
def _split(self, data):
def _parse(self):
def __init__(self, axes, loc, label, size=None, gridOn=None, tick1On=True, tick2On=True, label1On=True, label2On=False, major=True):
def contains(self, mouseevent):
def set_pad(self, val):
def get_pad(self):
def _get_text1(self):
def _get_text2(self):
def _get_tick1line(self):
def _get_tick2line(self):
def _get_gridline(self):
def get_loc(self):
def set_label1(self, s):
def set_label2(self, s):
def get_view_interval(self):
def _get_text1(self):
def _get_text2(self):
def _get_tick1line(self):
def _get_tick2line(self):
def _get_gridline(self):
def update_position(self, loc):
def get_view_interval(self):
def get_data_interval(self):
def _get_text1(self):
def _get_text2(self):
def _get_tick1line(self):
def _get_tick2line(self):
def _get_gridline(self):
def update_position(self, loc):
def get_view_interval(self):
def get_data_interval(self):
def __init__(self, axes, pickradius=15):
def set_label_coords(self, x, y, transform=None):
def cla(self):
def get_view_interval(self):
def get_data_interval(self):
def set_data_interval(self):
def iter_ticks(self):
def get_ticklabel_extents(self, renderer):
def draw(self, renderer, *args, **kwargs):
def get_gridlines(self):
def get_label(self):
def get_offset_text(self):
def get_pickradius(self):
def get_majorticklabels(self):
def get_minorticklabels(self):
def get_ticklabels(self, minor=False):
def get_majorticklines(self):
def get_minorticklines(self):
def get_ticklines(self, minor=False):
def get_majorticklocs(self):
def get_minorticklocs(self):
def get_ticklocs(self, minor=False):
def _get_tick(self, major):
def _copy_tick_props(self, src, dest):
def get_major_locator(self):
def get_minor_locator(self):
def get_major_formatter(self):
def get_minor_formatter(self):
def get_major_ticks(self, numticks=None):
def get_minor_ticks(self, numticks=None):
def grid(self, b=None, which='major', **kwargs):
def update_units(self, data):
def _update_axisinfo(self):
def set_units(self, u):
def get_units(self):
def set_major_formatter(self, formatter):
def set_minor_formatter(self, formatter):
def set_major_locator(self, locator):
def set_minor_locator(self, locator):
def set_pickradius(self, pickradius):
def set_ticklabels(self, ticklabels, *args, **kwargs):
def set_ticks(self, ticks, minor=False):
def _update_label_position(self, bboxes, bboxes2):
def _update_offset_text_postion(self, bboxes, bboxes2):
def pan(self, numsteps):
def zoom(self, direction):
def contains(self, mouseevent):
def get_label_position(self):
def set_label_position(self, position):
def _update_label_position(self, bboxes, bboxes2):
def _update_offset_text_position(self, bboxes, bboxes2):
def get_text_heights(self, renderer):
def set_ticks_position(self, position):
def tick_top(self):
def tick_bottom(self):
def get_ticks_position(self):
def get_view_interval(self):
def get_data_interval(self):
def set_data_interval(self, vmin, vmax, ignore=False):
def contains(self, mouseevent):
def get_label_position(self):
def set_label_position(self, position):
def _update_label_position(self, bboxes, bboxes2):
def _update_offset_text_position(self, bboxes, bboxes2):
def set_ticks_position(self, position):
def tick_right(self):
def tick_left(self):
def get_ticks_position(self):
def get_view_interval(self):
def get_data_interval(self):
def set_data_interval(self, vmin, vmax, ignore=False):
def __init__(self, xdata, ydata, linewidth=None, linestyle=None, color=None, marker=None, markersize=None, markeredgewidth=None, markeredgecolor=None, markerfacecolor=None, antialiased=None, dash_capstyle=None, solid_capstyle=None, dash_joinstyle=None, solid_joinstyle=None, pickradius=5, drawstyle=None, **kwargs):
def contains(self, mouseevent):
def get_pickradius(self):
def setpickradius(self, d):
def set_picker(self, p):
def set_data(self, *args):
def set_transform(self, t):
def _is_sorted(self, x):
def get_data(self, orig=True):
def get_xdata(self, orig=True):
def get_ydata(self, orig=True):
def get_path(self):
def get_xydata(self):
def set_antialiased(self, b):
def set_color(self, color):
def set_drawstyle(self, drawstyle):
def set_linewidth(self, w):
def set_linestyle(self, linestyle):
def set_marker(self, marker):
def set_markeredgecolor(self, ec):
def set_markeredgewidth(self, ew):
def set_markerfacecolor(self, fc):
def set_markersize(self, sz):
def set_xdata(self, x):
def set_ydata(self, y):
def set_dashes(self, seq):
def update_from(self, other):
def set_aa(self, val):
def set_c(self, val):
def set_ls(self, val):
def set_lw(self, val):
def set_mec(self, val):
def set_mew(self, val):
def set_mfc(self, val):
def set_ms(self, val):
def get_aa(self):
def get_c(self):
def get_ls(self):
def get_lw(self):
def get_mec(self):
def get_mew(self):
def get_mfc(self):
def get_ms(self):
def set_dash_joinstyle(self, s):
def set_solid_joinstyle(self, s):
def get_dash_joinstyle(self):
def get_solid_joinstyle(self):
def set_dash_capstyle(self, s):
def set_solid_capstyle(self, s):
def get_dash_capstyle(self):
def get_solid_capstyle(self):
def is_dashed(self):
def __init__(self, line):
def process_selected(self, ind, xs, ys):
def onpick(self, event):
def __init__(self):
def invalidate(self):
def set_children(self, *children):
def frozen(self):
def is_unit(self):
def containsx(self, x):
def containsy(self, y):
def contains(self, x, y):
def overlaps(self, other):
def fully_containsx(self, x):
def fully_containsy(self, y):
def fully_contains(self, x, y):
def fully_overlaps(self, other):
def transformed(self, transform):
def inverse_transformed(self, transform):
def anchored(self, c, container=None):
def shrunk(self, mx, my):
def shrunk_to_aspect(self, box_aspect, container=None, fig_aspect=1.0):
def splitx(self, *args):
def splity(self, *args):
def count_contains(self, vertices):
def count_overlaps(self, bboxes):
def expanded(self, sw, sh):
def padded(self, p):
def translated(self, tx, ty):
def corners(self):
def rotated(self, radians):
def union(bboxes):
def __init__(self, points):
def unit():
def from_bounds(x0, y0, width, height):
def from_extents(*args):
def ignore(self, value):
def update_from_data(self, x, y, ignore=None):
def update_from_path(self, path, ignore=None, updatex=True, updatey=True):
def update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True):
def get_points(self):
def set_points(self, points):
def set(self, other):
def __init__(self, bbox, transform):
def __add__(self, other):
def __radd__(self, other):
def __array__(self, *args, **kwargs):
def transform(self, values):
def transform_affine(self, values):
def transform_non_affine(self, values):
def get_affine(self):
def transform_point(self, point):
def transform_path(self, path):
def transform_path_affine(self, path):
def transform_path_non_affine(self, path):
def transform_angles(self, angles, pts, radians=False, pushoff=1e-05):
def inverted(self):
def __init__(self, child):
def set(self, child):
def _concat(a, b):
def get_matrix(self):
def to_values(self):
def matrix_from_values(a, b, c, d, e, f):
def __init__(self, matrix=None):
def from_values(a, b, c, d, e, f):
def get_matrix(self):
def set_matrix(self, mtx):
def set(self, other):
def identity():
def clear(self):
def rotate(self, theta):
def rotate_deg(self, degrees):
def rotate_around(self, x, y, theta):
def rotate_deg_around(self, x, y, degrees):
def translate(self, tx, ty):
def scale(self, sx, sy=None):
def __init__(self, x_transform, y_transform):
def __init__(self, x_transform, y_transform):
def __init__(self, a, b):
def __init__(self, a, b):
def __init__(self, boxin, boxout):
def __init__(self, boxout):
def __init__(self, path, transform):
def get_transformed_points_and_affine(self):
def get_transformed_path_and_affine(self):
def get_fully_transformed_path(self):
def __init__(self, ax, cmap=None, norm=None, interpolation=None, origin=None, extent=None, filternorm=1, filterrad=4.0, resample=False, **kwargs):
def get_size(self):
def set_alpha(self, alpha):
def changed(self):
def contains(self, mouseevent):
def write_png(self, fname, noscale=False):
def set_data(self, A, shape=None):
def set_array(self, A):
def set_extent(self, extent):
def get_interpolation(self):
def set_interpolation(self, s):
def get_extent(self):
def set_filternorm(self, filternorm):
def get_filternorm(self):
def set_filterrad(self, filterrad):
def get_filterrad(self):
def __init__(self, ax, x=None, y=None, A=None, cmap=None, norm=None, **kwargs):
def set_alpha(self, alpha):
def __init__(self, fig, cmap=None, norm=None, offsetx=0, offsety=0, origin=None, **kwargs):
def contains(self, mouseevent):
def get_size(self):
def get_extent(self):
def write_png(self, fname):
def get_window_extent(self, *args, **kwargs):
def _init_axis(self):
def set_figure(self, fig):
def _set_lim_and_transforms(self):
def get_xaxis_transform(self):
def get_xaxis_text1_transform(self, pad_points):
def get_xaxis_text2_transform(self, pad_points):
def get_yaxis_transform(self):
def get_yaxis_text1_transform(self, pad_points):
def get_yaxis_text2_transform(self, pad_points):
def get_position(self, original=False):
def set_position(self, pos, which='both'):
def reset_position(self):
def _set_artist_props(self, a):
def _gen_axes_patch(self):
def cla(self):
def clear(self):
def set_color_cycle(self, clist):
def ishold(self):
def hold(self, b=None):
def set_aspect(self, aspect, adjustable=None, anchor=None):
def set_adjustable(self, adjustable):
def set_anchor(self, anchor):
def get_data_ratio(self):
def apply_aspect(self, position=None):
def axis(self, *v, **kwargs):
def get_child_artists(self):
def get_frame(self):
def get_legend(self):
def get_images(self):
def get_lines(self):
def get_xaxis(self):
def get_xgridlines(self):
def get_xticklines(self):
def get_yaxis(self):
def get_ygridlines(self):
def get_yticklines(self):
def has_data(self):
def add_artist(self, a):
def add_collection(self, collection, autolim=True):
def add_line(self, line):
def add_patch(self, p):
def _update_patch_limits(self, patch):
def add_table(self, tab):
def relim(self):
def update_datalim(self, xys, updatex=True, updatey=True):
def update_datalim_numerix(self, x, y):
def update_datalim_bounds(self, bounds):
def _process_unit_info(self, xdata=None, ydata=None, kwargs=None):
def in_axes(self, mouseevent):
def get_autoscale_on(self):
def set_autoscale_on(self, b):
def autoscale_view(self, tight=False, scalex=True, scaley=True):
def draw(self, renderer=None, inframe=False):
def draw_artist(self, a):
def redraw_in_frame(self):
def get_frame_on(self):
def set_frame_on(self, b):
def get_axisbelow(self):
def set_axisbelow(self, b):
def grid(self, b=None, **kwargs):
def ticklabel_format(self, **kwargs):
def set_axis_off(self):
def set_axis_on(self):
def get_axis_bgcolor(self):
def set_axis_bgcolor(self, color):
def invert_xaxis(self):
def xaxis_inverted(self):
def get_xbound(self):
def set_xbound(self, lower=None, upper=None):
def get_xlim(self):
def set_xlim(self, xmin=None, xmax=None, emit=True, **kwargs):
def set_xscale(self, value, **kwargs):
def get_xticks(self, minor=False):
def set_xticks(self, ticks, minor=False):
def get_xmajorticklabels(self):
def get_xminorticklabels(self):
def get_xticklabels(self, minor=False):
def set_xticklabels(self, labels, fontdict=None, minor=False, **kwargs):
def invert_yaxis(self):
def yaxis_inverted(self):
def get_ybound(self):
def set_ybound(self, lower=None, upper=None):
def get_ylim(self):
def set_ylim(self, ymin=None, ymax=None, emit=True, **kwargs):
def set_yscale(self, value, **kwargs):
def get_yticks(self, minor=False):
def set_yticks(self, ticks, minor=False):
def get_ymajorticklabels(self):
def get_yminorticklabels(self):
def get_yticklabels(self, minor=False):
def set_yticklabels(self, labels, fontdict=None, minor=False, **kwargs):
def xaxis_date(self, tz=None):
def yaxis_date(self, tz=None):
def format_xdata(self, x):
def format_ydata(self, y):
def format_coord(self, x, y):
def can_zoom(self):
def get_navigate(self):
def set_navigate(self, b):
def get_navigate_mode(self):
def set_navigate_mode(self, b):
def start_pan(self, x, y, button):
def end_pan(self):
def drag_pan(self, button, key, x, y):
def get_cursor_props(self):
def set_cursor_props(self, *args):
def connect(self, s, func):
def disconnect(self, cid):
def get_children(self):
def contains(self, mouseevent):
def pick(self, *args):
def __pick(self, x, y, trans=None, among=None):
def get_title(self):
def set_title(self, label, fontdict=None, **kwargs):
def get_xlabel(self):
def set_xlabel(self, xlabel, fontdict=None, **kwargs):
def get_ylabel(self):
def set_ylabel(self, ylabel, fontdict=None, **kwargs):
def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):
def annotate(self, *args, **kwargs):
def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
def hlines(self, y, xmin, xmax, colors='k', linestyles='solid', label='', **kwargs):
def vlines(self, x, ymin, ymax, colors='k', linestyles='solid', label='', **kwargs):
def plot(self, *args, **kwargs):
def plot_date(self, x, y, fmt='bo', tz=None, xdate=True, ydate=False, **kwargs):
def loglog(self, *args, **kwargs):
def semilogx(self, *args, **kwargs):
def semilogy(self, *args, **kwargs):
def acorr(self, x, **kwargs):
def xcorr(self, x, y, normed=False, detrend=mlab.detrend_none, usevlines=False, maxlags=None, **kwargs):
def legend(self, *args, **kwargs):
def step(self, x, y, *args, **kwargs):
def bar(self, left, height, width=0.8, bottom=None, color=None, edgecolor=None, linewidth=None, yerr=None, xerr=None, ecolor=None, capsize=3, align='edge', orientation='vertical', log=False, **kwargs):
def barh(self, bottom, width, height=0.8, left=None, **kwargs):
def broken_barh(self, xranges, yrange, **kwargs):
def stem(self, x, y, linefmt='b-', markerfmt='bo', basefmt='r-'):
def pie(self, x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1):
def errorbar(self, x, y, yerr=None, xerr=None, fmt='-', ecolor=None, elinewidth=None, capsize=3, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, **kwargs):
def boxplot(self, x, notch=0, sym='b+', vert=1, whis=1.5, positions=None, widths=None):
def scatter(self, x, y, s=20, c='b', marker='o', cmap=None, norm=None, vmin=None, vmax=None, alpha=1.0, linewidths=None, faceted=True, verts=None, **kwargs):
def hexbin(self, x, y, C=None, gridsize=100, bins=None, xscale='linear', yscale='linear', cmap=None, norm=None, vmin=None, vmax=None, alpha=1.0, linewidths=None, edgecolors='none', reduce_C_function=np.mean, **kwargs):
def arrow(self, x, y, dx, dy, **kwargs):
def barbs(self, *args, **kw):
def fill(self, *args, **kwargs):
def fill_between(self, x, y1, y2=0, where=None, **kwargs):
def imshow(self, X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=1.0, vmin=None, vmax=None, origin=None, extent=None, shape=None, filternorm=1, filterrad=4.0, imlim=None, resample=None, url=None, **kwargs):
def pcolor(self, *args, **kwargs):
def pcolormesh(self, *args, **kwargs):
def pcolorfast(self, *args, **kwargs):
def table(self, **kwargs):
def twinx(self):
def twiny(self):
def get_shared_x_axes(self):
def get_shared_y_axes(self):
def hist(self, x, bins=10, range=None, normed=False, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, **kwargs):
def psd(self, x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None, **kwargs):
def csd(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None, **kwargs):
def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=0, pad_to=None, sides='default', scale_by_freq=None, **kwargs):
def specgram(self, x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none, window=mlab.window_hanning, noverlap=128, cmap=None, xextent=None, pad_to=None, sides='default', scale_by_freq=None):
def spy(self, Z, precision=0, marker=None, markersize=None, aspect='equal', **kwargs):
def matshow(self, Z, **kwargs):
def __init__(self, fig, *args, **kwargs):
def get_geometry(self):
def change_geometry(self, numrows, numcols, num):
def update_params(self):
def label_outer(self):
def __init__(self, filename, dpi):
def __iter__(self):
def close(self):
def _output(self):
def _read(self):
def _arg(self, nbytes, signed=False):
def _dispatch(self, byte):
def _width_of(self, char):
def _parse(self, file):
def _register(self, words):
def __init__(self, edgecolors=None, facecolors=None, linewidths=None, linestyles='solid', antialiaseds=None, offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5.0, urls=None, **kwargs):
def _prepare_points(self):
def contains(self, mouseevent):
def set_offsets(self, offsets):
def get_offsets(self):
def set_linewidth(self, lw):
def set_linewidths(self, lw):
def set_lw(self, lw):
def set_linestyle(self, ls):
def set_linestyles(self, ls):
def set_dashes(self, ls):
def set_antialiased(self, aa):
def set_antialiaseds(self, aa):
def set_color(self, c):
def set_facecolor(self, c):
def set_facecolors(self, c):
def set_edgecolor(self, c):
def set_edgecolors(self, c):
def set_alpha(self, alpha):
def update_scalarmappable(self):
def update_from(self, other):
def convert_mesh_to_paths(meshWidth, meshHeight, coordinates):
def __init__(self, verts, sizes=None, closed=True, **kwargs):
def set_verts(self, verts, closed=True):
def __init__(self, xranges, yrange, **kwargs):
@staticmethod DCNL def span_where(x, ymin, ymax, where, **kwargs):
def __init__(self, numsides, rotation=0, sizes=(1,), **kwargs):
def __init__(self, segments, linewidths=None, colors=None, antialiaseds=None, linestyles='solid', offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5, **kwargs):
def set_color(self, c):
def color(self, c):
def __init__(self, sizes, **kwargs):
def __init__(self, widths, heights, angles, units='points', **kwargs):
def __init__(self, patches, match_original=False, **kwargs):
def __init__(self, fh):
def string_width_height(self, s):
def get_str_bbox_and_descent(self, s):
def get_str_bbox(self, s):
def get_name_char(self, c, isord=False):
def get_width_char(self, c, isord=False):
def get_width_from_char_name(self, name):
def get_height_char(self, c, isord=False):
def get_kern_dist(self, c1, c2):
def get_kern_dist_from_name(self, name1, name2):
def get_fontname(self):
def get_fullname(self):
def get_familyname(self):
def get_weight(self):
def get_angle(self):
def get_capheight(self):
def get_xheight(self):
def get_underline_thickness(self):
def get_horizontal_stem_width(self):
def get_vertical_stem_width(self):
def remove(self):
def have_units(self):
def convert_xunits(self, x):
def convert_yunits(self, y):
def set_axes(self, axes):
def get_axes(self):
def add_callback(self, func):
def remove_callback(self, oid):
def pchanged(self):
def is_transform_set(self):
def set_transform(self, t):
def get_transform(self):
def hitlist(self, event):
def get_children(self):
def contains(self, mouseevent):
def set_contains(self, picker):
def get_contains(self):
def pickable(self):
def pick(self, mouseevent):
def set_picker(self, picker):
def get_picker(self):
def is_figure_set(self):
def get_url(self):
def set_url(self, url):
def get_snap(self):
def set_snap(self, snap):
def get_figure(self):
def set_figure(self, fig):
def set_clip_box(self, clipbox):
def set_clip_path(self, path, transform=None):
def get_alpha(self):
def get_visible(self):
def get_animated(self):
def get_clip_on(self):
def get_clip_box(self):
def get_clip_path(self):
def get_transformed_clip_path_and_affine(self):
def set_clip_on(self, b):
def _set_gc_clip(self, gc):
def draw(self, renderer, *args, **kwargs):
def set_alpha(self, alpha):
def set_lod(self, on):
def set_visible(self, b):
def set_animated(self, b):
def update(self, props):
def get_label(self):
def set_label(self, s):
def get_zorder(self):
def set_zorder(self, level):
def update_from(self, other):
def set(self, **kwargs):
def findobj(self, match=None):
def __init__(self, o):
def get_aliases(self):
def get_valid_values(self, attr):
def _get_setters_and_targets(self):
def get_setters(self):
def is_alias(self, o):
def aliased_name(self, s):
def aliased_name_rest(self, s, target):
def pprint_setters(self, prop=None, leadingspace=2):
def pprint_setters_rest(self, prop=None, leadingspace=2):
def pprint_getters(self):
def findobj(self, match=None):
def __getattr__(self, aname):
def markInputline(self, markerString='>!<'):
def keys(self):
def pop(self, index=(-1)):
def get(self, key, defaultValue=None):
def items(self):
def values(self):
def asList(self):
def asDict(self):
def copy(self):
def asXML(self, doctag=None, namedItemsOnly=False, indent='', formatted=True):
def getName(self):
def dump(self, indent='', depth=0):
def setDefaultWhitespaceChars(chars):
def copy(self):
def setName(self, name):
def setResultsName(self, name, listAllMatches=False):
def setBreak(self, breakFlag=True):
def _normalizeParseActionArgs(f):
def setParseAction(self, *fns, **kwargs):
def addParseAction(self, *fns, **kwargs):
def setFailAction(self, fn):
def enablePackrat():
def parseString(self, instring, parseAll=False):
def scanString(self, instring, maxMatches=_MAX_INT):
def transformString(self, instring):
def searchString(self, instring, maxMatches=_MAX_INT):
def __add__(self, other):
def __radd__(self, other):
def __sub__(self, other):
def __rsub__(self, other):
def __or__(self, other):
def __ror__(self, other):
def __xor__(self, other):
def __rxor__(self, other):
def __and__(self, other):
def __rand__(self, other):
def __invert__(self):
def __call__(self, name):
def suppress(self):
def leaveWhitespace(self):
def setWhitespaceChars(self, chars):
def parseWithTabs(self):
def ignore(self, other):
def setDebugActions(self, startAction, successAction, exceptionAction):
def setDebug(self, flag=True):
def validate(self, validateTrace=[]):
def parseFile(self, file_or_filename):
def setDefaultKeywordChars(chars):
def __init__(self, pattern, flags=0):
def __init__(self, quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None):
def leaveWhitespace(self):
def refreshGUI(self):
def __init__(self, inputDimensions, columnDimensions):
def createInput(self):
def run(self):
def addNoise(self, noiseLevel):
def compute(self, inputs, outputs):
@classmethod DCNL def getSpec(cls):
def testFastLearning(self):
def testSlowLearning(self):
def testSlowLearningWithOverlap(self):
def testForbesLikeData(self):
def _basicTest(self, tm=None):
def _printOneTrainingVector(self, x):
def _printAllTrainingSequences(self, trainingSequences):
def _setVerbosity(self, verbosity, tm, tmPy):
def _createTMs(self, numCols, fixedResources=False, checkSynapseConsistency=True):
def _getSimplePatterns(self, numOnes, numPatterns):
def _buildSegmentLearningTrainingSet(self, numOnes=10, numRepetitions=10):
def _buildSL2TrainingSet(self, numOnes=10, numRepetitions=10):
def _testSegmentLearningSequence(self, tms, trainingSequences, testSequences, doResets=True):
def _testSL1(self, numOnes=10, numRepetitions=6, fixedResources=False, checkSynapseConsistency=True):
def _testSL2(self, numOnes=10, numRepetitions=10, fixedResources=False, checkSynapseConsistency=True):
def test_SL1NoFixedResources(self):
def test_SL1WithFixedResources(self):
def test_SL2NoFixedResources(self):
def test_SL2WithFixedResources(self):
def __init__(self, requestedActivities):
def tick(self):
def __init__(self, dirPath, reason):
def __init__(self, problem, precursor):
@staticmethod DCNL def getInputElement(inferenceElement):
@staticmethod DCNL def isTemporal(inferenceElement):
@staticmethod DCNL def getTemporalDelay(inferenceElement, key=None):
@staticmethod DCNL def getMaxDelay(inferences):
@staticmethod DCNL def isTemporal(inferenceType):
def __init__(self, options, cmdLineArgs):
def _processUpdatedModels(self, cjDAO):
def run(self):
def __init__(self, modelID, jobID, params, predictedField, reportKeyPatterns, optimizeKeyPattern, jobsDAO, modelCheckpointGUID, logLevel=None, predictionCacheMaxRecords=None):
def _loadDummyModelParameters(self, params):
def _computModelDelay(self):
def _getMetrics(self):
def run(self):
def _createPredictionLogger(self):
def __shouldSysExit(self, iteration):
def __init__(self, hsObj):
def isDirty(self):
def isSearchOver(self):
def readStateFromDB(self):
def writeStateToDB(self):
def getEncoderNameFromKey(self, key):
def getEncoderKeyFromName(self, name):
def getFieldContributions(self):
def getAllSwarms(self, sprintIdx):
def getActiveSwarms(self, sprintIdx=None):
def getNonKilledSwarms(self, sprintIdx):
def getCompletedSwarms(self):
def getCompletingSwarms(self):
def bestModelInCompletedSwarm(self, swarmId):
def bestModelInCompletedSprint(self, sprintIdx):
def bestModelInSprint(self, sprintIdx):
def setSwarmState(self, swarmId, newStatus):
def anyGoodSprintsActive(self):
def isSprintCompleted(self, sprintIdx):
def killUselessSwarms(self):
def isSprintActive(self, sprintIdx):
def debug(self, msg, *args, **kwargs):
def info(self, msg, *args, **kwargs):
def warning(self, msg, *args, **kwargs):
def error(self, msg, *args, **kwargs):
def critical(self, msg, *args, **kwargs):
def log(self, level, msg, *args, **kwargs):
def recordDataPoint(self, swarmId, generation, errScore):
def getTerminationCallbacks(self, terminationFunc):
@classmethod DCNL def getString(cls, prop):
@classmethod DCNL def getBool(cls, prop):
@classmethod DCNL def getInt(cls, prop):
@classmethod DCNL def getFloat(cls, prop):
@classmethod DCNL def get(cls, prop, default=None):
@classmethod DCNL def set(cls, prop, value):
@classmethod DCNL def dict(cls):
@classmethod DCNL def readConfigFile(cls, filename, path=None):
@classmethod DCNL def _readConfigFile(cls, filename, path=None):
@classmethod DCNL def clear(cls):
@classmethod DCNL def findConfigFile(cls, filename):
@classmethod DCNL def getConfigPaths(cls):
@classmethod DCNL def setConfigPaths(cls, paths):
@classmethod DCNL def _readStdConfigFiles(cls):
@classmethod DCNL def getCustomDict(cls):
@classmethod DCNL def setCustomProperty(cls, propertyName, value):
@classmethod DCNL def setCustomProperties(cls, properties):
@classmethod DCNL def clear(cls):
@classmethod DCNL def resetCustomConfig(cls):
@classmethod DCNL def loadCustomConfig(cls):
@classmethod DCNL def _readStdConfigFiles(cls):
@classmethod DCNL def clear(cls, persistent=False):
@classmethod DCNL def getCustomDict(cls):
@classmethod DCNL def edit(cls, properties):
@classmethod DCNL def _setPath(cls):
@classmethod DCNL def getPath(cls):
def getState(self):
def setState(self, state):
def getPosition(self):
def agitate(self):
def newPosition(self, globalBestPosition, rng):
def pushAwayFrom(self, otherVars, rng):
def resetVelocity(self, rng):
def __init__(self, min, max, stepSize=None, inertia=None, cogRate=None, socRate=None):
def __repr__(self):
def getState(self):
def setState(self, state):
def getPosition(self):
def agitate(self):
def newPosition(self, globalBestPosition, rng):
def pushAwayFrom(self, otherPositions, rng):
def resetVelocity(self, rng):
def __repr__(self):
def getPosition(self):
def __repr__(self):
def getState(self):
def setState(self, state):
def setResultsPerChoice(self, resultsPerChoice):
def getPosition(self):
def agitate(self):
def newPosition(self, globalBestPosition, rng):
def pushAwayFrom(self, otherPositions, rng):
def resetVelocity(self, rng):
def __repr__(self):
def getDict(self, encoderName, flattenedChosenValues):
def _testValidPositions(self, varClass, minValue, maxValue, stepSize, iterations=100):
def _testConvergence(self, varClass, minValue, maxValue, targetValue, iterations=100):
def run(self):
def __init__(self, hsObj, resultsDB, flattenedPermuteVars, swarmId=None, newFarFrom=None, evolveFromState=None, newFromClone=None, newParticleId=False):
def getState(self):
def initStateFrom(self, particleId, particleState, newBest):
def copyEncoderStatesFrom(self, particleState):
def copyVarStatesFrom(self, particleState, varNames):
def getPosition(self):
@staticmethod DCNL def getPositionFromState(pState):
def agitate(self):
def newPosition(self, whichVars=None):
def __init__(self, jobID, jobsDAO, logLevel=None):
def updateResultsForJob(self, forceUpdate=True):
def __init__(self, options):
def runNewSearch(self):
def pickupSearch(self):
def monitorSearchJob(self):
def _launchWorkers(self, cmdLine, numWorkers):
def __startSearch(self):
def peekSearchJob(self):
def getDiscoveredMetricsKeys(self):
@classmethod DCNL def printModels(cls, options):
@classmethod DCNL def generateReport(cls, options, replaceReport, hyperSearchJob, metricsKeys):
@classmethod DCNL def loadSavedHyperSearchJob(cls, permWorkDir, outputLabel):
@classmethod DCNL def __saveHyperSearchJobID(cls, permWorkDir, outputLabel, hyperSearchJob):
@classmethod DCNL def __loadHyperSearchJobID(cls, permWorkDir, outputLabel):
@classmethod DCNL def __getHyperSearchJobIDFilePath(cls, permWorkDir, outputLabel):
def __init__(self, hyperSearchJob, metricsKeys, searchVar, outputDirAbsPath, outputLabel, replaceReport):
def emit(self, modelInfo):
def finalize(self):
def __openAndInitCSVFile(self, modelInfo):
def __init__(self, nupicJobID):
def __repr__(self):
def getJobStatus(self, workers):
def getJobID(self):
def getParams(self):
def __init__(self, nupicJobID, workers):
def statusAsString(self):
def isWaitingToStart(self):
def isStarting(self):
def isRunning(self):
def isFinished(self):
def getCompletionReason(self):
def getCompletionMsg(self):
def getWorkerCompletionMsg(self):
def getStartTime(self):
def getEndTime(self):
def getWorkerState(self):
def getResults(self):
def getModelMilestones(self):
def getEngStatus(self):
def __init__(self, reason):
def __init__(self, nupicJobID):
def queryModelIDs(self):
def getExpectedNumModels(self, searchMethod):
@classmethod DCNL def makeSearchJobParamsDict(cls, options, forRunning=False):
@classmethod DCNL def getOptimizationMetricInfo(cls, searchJobParams):
def __init__(self, rawInfo):
def __repr__(self):
def getModelID(self):
def statusAsString(self):
def getModelDescription(self):
def getGeneratedDescriptionFile(self):
def getNumRecords(self):
def getParamLabels(self):
def __unwrapParams(self):
def getReportMetrics(self):
def getOptimizationMetrics(self):
def getAllMetrics(self):
def __unwrapResults(self):
def isWaitingToStart(self):
def isRunning(self):
def isFinished(self):
def getCompletionReason(self):
def getCompletionMsg(self):
def getStartTime(self):
def getEndTime(self):
def __init__(self, hsObj):
def update(self, modelID, modelParams, modelParamsHash, metricResult, completed, completionReason, matured, numRecords):
def getNumErrModels(self):
def getErrModelIds(self):
def getNumCompletedModels(self):
def getModelIDFromParamsHash(self, paramsHash):
def numModels(self, swarmId=None, includeHidden=False):
def bestModelIdAndErrScore(self, swarmId=None, genIdx=None):
def getParticleInfo(self, modelId):
def getParticleInfos(self, swarmId=None, genIdx=None, completed=None, matured=None, lastDescendent=False):
def getOrphanParticleInfos(self, swarmId, genIdx):
def getMaturedSwarmGenerations(self):
def firstNonFullGeneration(self, swarmId, minNumParticles):
def highestGeneration(self, swarmId):
def getParticleBest(self, particleId):
def getResultsPerChoice(self, swarmId, maxGenIdx, varName):
def __init__(self, searchParams, workerID=None, cjDAO=None, jobID=None, logLevel=None):
def _getStreamDef(self, modelDescription):
def __del__(self):
def close(self):
def _readPermutationsFile(self, filename, modelDescription):
def getExpectedNumModels(self):
def getModelNames(self):
def getPermutationVariables(self):
def getComplexVariableLabelLookupDict(self):
def getOptimizationMetricInfo(self):
def _checkForOrphanedModels(self):
def _hsStatePeriodicUpdate(self, exhaustedSwarmId=None):
def _getCandidateParticleAndSwarm(self, exhaustedSwarmId=None):
def _okToExit(self):
def createModels(self, numModels=1):
def recordModelProgress(self, modelID, modelParams, modelParamsHash, results, completed, completionReason, matured, numRecords):
def runModel(self, modelID, jobID, modelParams, modelParamsHash, jobsDAO, modelCheckpointGUID):
def __init__(self, modelID, jobID, predictedField, experimentDir, reportKeyPatterns, optimizeKeyPattern, jobsDAO, modelCheckpointGUID, logLevel=None, predictionCacheMaxRecords=None):
def run(self):
def __runTaskMainLoop(self, numIters, learningOffAt=None):
def _finalize(self):
def __createModelCheckpoint(self):
def __deleteModelCheckpoint(self, modelID):
def _createPredictionLogger(self):
def __getOptimizedMetricLabel(self):
def _getMetricLabels(self):
def _getFieldStats(self):
def _getMetrics(self):
def _updateModelDBResults(self):
def __updateJobResultsPeriodic(self):
def __checkIfBestCompletedModel(self):
def __updateJobResults(self):
def _writePrediction(self, result):
def __writeRecordsCallback(self):
def __flushPredictionCache(self):
def __deleteOutputCache(self, modelID):
def _initPeriodicActivities(self):
def __checkCancelation(self):
def __checkMaturity(self):
def handleWarningSignal(self, signum, frame):
def __setAsOrphaned(self):
def GET(self):
def POST(self, name):
def POST(self, name):
def export(self):
def render(self, renderer=DEFAULT_RENDERER):
def __init__(self, filePath):
def __init__(self, filePath):
def finishLearning(self):
def setFieldStatistics(self, fieldStats):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
@classmethod DCNL def __getLogger(cls):
@staticmethod DCNL def create(modelConfig, logLevel=logging.ERROR):
@staticmethod DCNL def loadFromCheckpoint(savedModelDir, newSerialization=False):
def update(self, results):
def getMetrics(self):
def getMetricDetails(self, metricLabel):
def getMetricLabels(self):
def _addResults(self, results):
def _getGroundTruth(self, inferenceElement):
def _getInference(self, inferenceElement):
def _getRawGroundTruth(self):
def __constructMetricsModules(self, metricSpecs):
def getLabel(self, inferenceType=None):
@classmethod DCNL def getInferenceTypeFromLabel(cls, label):
def __init__(self, windowSize=None):
def __init__(self, metricSpec):
def _getShiftedGroundTruth(self, groundTruth):
def addInstance(self, groundTruth, prediction, record=None, result=None):
def getMetric(self):
def mostLikely(self, pred):
def expValue(self, pred):
def accumulate(self, groundTruth, prediction, accumulatedError, historyBuffer, result=None):
def __init__(self, metricSpec):
def __init__(self, weights, metrics, window=None):
def __init__(self, model, task, cmdOptions):
def run(self):
def _createPeriodicActivities(self):
def __init__(self, requestedActivities):
def tick(self):
def _translateMetricsToJSON(self, metrics, label):
def __init__(self, experimentDir, label, inferenceType, fields, metricNames=None, checkpointSource=None):
def __openDatafile(self, modelResult):
def setLoggedMetrics(self, metricNames):
def close(self):
def __getListMetaInfo(self, inferenceElement):
def __getDictMetaInfo(self, inferenceElement, inferenceDict):
def append(self, modelResult):
def checkpoint(self, checkpointSink, maxRows):
def update(self, modelResult):
def __init__(self, writer):
def update(self, modelResult):
@staticmethod DCNL def getExperimentInferenceDirPath(experimentDir):
@classmethod DCNL def createExperimentInferenceDir(cls, experimentDir):
@staticmethod DCNL def makeDirectory(path):
@staticmethod DCNL def getInputElement(inferenceElement):
@staticmethod DCNL def isTemporal(inferenceElement):
@staticmethod DCNL def getTemporalDelay(inferenceElement, key=None):
@staticmethod DCNL def getMaxDelay(inferences):
@staticmethod DCNL def isTemporal(inferenceType):
def __init__(self, inferenceType=None, proto=None):
def run(self, inputRecord):
def getInferenceType(self):
def enableLearning(self):
def disableLearning(self):
def isLearningEnabled(self):
def enableInference(self, inferenceArgs=None):
def getInferenceArgs(self):
def disableInference(self):
def isInferenceEnabled(self):
@staticmethod DCNL def getSchema():
@staticmethod DCNL def _getModelCheckpointFilePath(checkpointDir):
def writeToCheckpoint(self, checkpointDir):
@classmethod DCNL def readFromCheckpoint(cls, checkpointDir):
def writeBaseToProto(self, proto):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
def save(self, saveModelDir):
def _serializeExtraData(self, extraDataDir):
@classmethod DCNL def load(cls, savedModelDir):
def _deSerializeExtraData(self, extraDataDir):
@staticmethod DCNL def _getModelPickleFilePath(saveModelDir):
@staticmethod DCNL def _getModelExtraDataDir(saveModelDir):
@staticmethod DCNL def __makeDirectoryFromAbsolutePath(absDirPath):
def __call__(self, topContainer):
def handleGetValue(self, topContainer):
def __init__(self, referenceDict, *dictKeyChain):
def handleGetValue(self, topContainer):
def __init__(self, *dictKeyChain):
def _getImpl(self, model):
def _getImpl(self, model):
def _getImpl(self, model):
def replaceIterationCycle(self, phaseSpecs):
def setup(self):
def finalize(self):
def handleInputRecord(self, inputRecord):
def getMetrics(self):
def getMetricLabels(self):
def __init__(self, model, phaseSpecs):
def __advancePhase(self):
def handleInputRecord(self, inputRecord):
def __init__(self, nIters):
@abstractmethod DCNL def enterPhase(self):
def advance(self):
def __init__(self, model, nIters):
def enterPhase(self):
def __init__(self, model, nIters, inferenceArgs):
def enterPhase(self):
def __init__(self, model, nIters, inferenceArgs):
def enterPhase(self):
def __init__(self, model, nIters, inferenceArgs):
def enterPhase(self):
def setFieldStatistics(self, fieldStats):
@classmethod DCNL def read(cls, proto):
def write(self, proto):
def __init__(self, net, statsCollectors):
def __init__(self, sensorParams={}, inferenceType=InferenceType.TemporalNextStep, spEnable=True, spParams={}, trainSPNetOnlyIfRequested=False, tmEnable=True, tmParams={}, clEnable=True, clParams={}, anomalyParams={}, minLikelihoodThreshold=DEFAULT_LIKELIHOOD_THRESHOLD, maxPredictionsPerStep=DEFAULT_MAX_PREDICTIONS_PER_STEP, network=None, baseProto=None):
def getParameter(self, paramName):
@requireAnomalyModel DCNL def setAnomalyParameter(self, param, value):
@requireAnomalyModel DCNL def getAnomalyParameter(self, param):
@requireAnomalyModel DCNL def anomalyRemoveLabels(self, start, end, labelFilter):
@requireAnomalyModel DCNL def anomalyAddLabel(self, start, end, labelName):
@requireAnomalyModel DCNL def anomalyGetLabels(self, start, end):
def _getSensorInputRecord(self, inputRecord):
def _getClassifierInputRecord(self, inputRecord):
def _anomalyCompute(self):
def _handleSDRClassifierMultiStep(self, patternNZ, inputTSRecordIdx, rawInput):
@classmethod DCNL def _removeUnlikelyPredictions(cls, likelihoodsDict, minLikelihoodThreshold, maxPredictionsPerStep):
def getRuntimeStats(self):
def _getLogger(self):
def _getSPRegion(self):
def _getTPRegion(self):
def _getSensorRegion(self):
def _getClassifierRegion(self):
def _getEncoder(self):
def _getClassifierOnlyEncoder(self):
def _getDataSource(self):
def __createHTMNetwork(self, sensorParams, spEnable, spParams, tmEnable, tmParams, clEnable, clParams, anomalyParams):
def __getstate__(self):
def __setstate__(self, state):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
def _serializeExtraData(self, extraDataDir):
def _deSerializeExtraData(self, extraDataDir):
def _addAnomalyClassifierRegion(self, network, params, spEnable, tmEnable):
def __getNetworkStateDirectory(self, extraDataDir):
def __manglePrivateMemberName(self, privateMemberName, skipCheck=False):
def __init__(self, *args, **kwargs):
def __validateExperimentControl(self, control):
def __validateNupicControl(self, control):
def normalizeStreamSource(self, stream):
def normalizeStreamSources(self):
def convertNupicEnvToOPF(self):
def __init__(self, requestedActivities=[]):
def addActivities(self, periodicActivities):
def tick(self):
def __appendActivities(self, periodicActivities):
def addLabel(self, start, end, labelName):
def removeLabels(self, start=None, end=None, labelFilter=None):
def _addRecordToKNN(self, record):
def _deleteRecordsFromKNN(self, recordsToDelete):
def _deleteRangeFromKNN(self, start=0, end=None):
def _recomputeRecordFromKNN(self, record):
def _constructClassificationRecord(self):
def compute(self):
def setAutoDetectWaitRecords(self, waitRecords):
def getAutoDetectWaitRecords(self):
def setAutoDetectThreshold(self, threshold):
def getAutoDetectThreshold(self):
def _labelToCategoryNumber(self, label):
def _labelListToCategoryNumber(self, labelList):
def _categoryToLabelList(self, category):
def _getStateAnomalyVector(self, state):
def __init__(self, windowSize, existingHistoricalValues=None):
@staticmethod DCNL def compute(slidingWindow, total, newVal, windowSize):
def next(self, newValue):
def getCurrentAvg(self):
def __setstate__(self, state):
@classmethod DCNL @abstractmethod DCNL def getSchema(cls):
@classmethod DCNL @abstractmethod DCNL def read(cls, proto):
@abstractmethod DCNL def write(self, proto):
@classmethod DCNL def readFromFile(cls, f, packed=True):
def writeToFile(self, f, packed=True):
@staticmethod DCNL def connectionsFactory(*args, **kwargs):
def compute(self, activeColumns, learn=True):
def activateCells(self, activeColumns, learn=True):
def activateDendrites(self, learn=True):
def reset(self):
def activatePredictedColumn(self, column, columnActiveSegments, columnMatchingSegments, prevActiveCells, prevWinnerCells, learn):
def burstColumn(self, column, columnMatchingSegments, prevActiveCells, prevWinnerCells, learn):
def punishPredictedColumn(self, column, columnActiveSegments, columnMatchingSegments, prevActiveCells, prevWinnerCells):
def createSegment(self, cell):
@classmethod DCNL def _activatePredictedColumn(cls, connections, random, columnActiveSegments, prevActiveCells, prevWinnerCells, numActivePotentialSynapsesForSegment, maxNewSynapseCount, initialPermanence, permanenceIncrement, permanenceDecrement, maxSynapsesPerSegment, learn):
@classmethod DCNL def _burstColumn(cls, connections, random, lastUsedIterationForSegment, column, columnMatchingSegments, prevActiveCells, prevWinnerCells, cellsForColumn, numActivePotentialSynapsesForSegment, iteration, maxNewSynapseCount, initialPermanence, permanenceIncrement, permanenceDecrement, maxSegmentsPerCell, maxSynapsesPerSegment, learn):
@classmethod DCNL def _punishPredictedColumn(cls, connections, columnMatchingSegments, prevActiveCells, predictedSegmentDecrement):
@classmethod DCNL def _createSegment(cls, connections, lastUsedIterationForSegment, cell, iteration, maxSegmentsPerCell):
@classmethod DCNL def _destroyMinPermanenceSynapses(cls, connections, random, segment, nDestroy, excludeCells):
@classmethod DCNL def _leastUsedCell(cls, random, cells, connections):
@classmethod DCNL def _growSynapses(cls, connections, random, segment, nDesiredNewSynapes, prevWinnerCells, initialPermanence, maxSynapsesPerSegment):
@classmethod DCNL def _adaptSegment(cls, connections, segment, prevActiveCells, permanenceIncrement, permanenceDecrement):
def columnForCell(self, cell):
def cellsForColumn(self, column):
def numberOfColumns(self):
def numberOfCells(self):
def mapCellsToColumns(self, cells):
def getActiveCells(self):
def getPredictiveCells(self):
def getWinnerCells(self):
def getActiveSegments(self):
def getMatchingSegments(self):
def getCellsPerColumn(self):
def getColumnDimensions(self):
def getActivationThreshold(self):
def setActivationThreshold(self, activationThreshold):
def getInitialPermanence(self):
def setInitialPermanence(self, initialPermanence):
def getMinThreshold(self):
def setMinThreshold(self, minThreshold):
def getMaxNewSynapseCount(self):
def setMaxNewSynapseCount(self, maxNewSynapseCount):
def getPermanenceIncrement(self):
def setPermanenceIncrement(self, permanenceIncrement):
def getPermanenceDecrement(self):
def setPermanenceDecrement(self, permanenceDecrement):
def getPredictedSegmentDecrement(self):
def setPredictedSegmentDecrement(self, predictedSegmentDecrement):
def getConnectedPermanence(self):
def setConnectedPermanence(self, connectedPermanence):
def getMaxSegmentsPerCell(self):
def getMaxSynapsesPerSegment(self):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
def __eq__(self, other):
def __ne__(self, other):
def _validateColumn(self, column):
def _validateCell(self, cell):
@classmethod DCNL def getCellIndices(cls, cells):
@staticmethod DCNL def getCellIndex(cell):
@staticmethod DCNL def create(*args, **kwargs):
@staticmethod DCNL def read(proto):
def clear(self):
def prototypeSetCategory(self, idToCategorize, newCategory):
def removeIds(self, idsToRemove):
def removeCategory(self, categoryToRemove):
def _removeRows(self, rowsToRemove):
def doIteration(self):
def learn(self, inputPattern, inputCategory, partitionId=None, isSparse=0, rowID=None):
def getOverlaps(self, inputPattern):
def getDistances(self, inputPattern):
def infer(self, inputPattern, computeScores=True, overCategories=True, partitionId=None):
def getClosest(self, inputPattern, topKCategories=3):
def closestTrainingPattern(self, inputPattern, cat):
def closestOtherTrainingPattern(self, inputPattern, cat):
def getPattern(self, idx, sparseBinaryForm=False, cat=None):
def getPartitionId(self, i):
def getPartitionIdList(self):
def getNumPartitionIds(self):
def getPartitionIdKeys(self):
def getPatternIndicesWithPartitionId(self, partitionId):
def _addPartitionId(self, index, partitionId=None):
def _rebuildPartitionIdMap(self, partitionIdList):
def _calcDistance(self, inputPattern, distanceNorm=None):
def _getDistances(self, inputPattern, partitionId=None):
def finishLearning(self):
def computeSVD(self, numSVDSamples=None, finalize=True):
def getAdaptiveSVDDims(self, singularValues, fractionOfMax=0.001):
def _finalizeSVD(self, numSVDDims=None):
def remapCategories(self, mapping):
def setCategoryOfVectors(self, vectorIndices, categoryIndices):
def __getstate__(self):
def __setstate__(self, state):
def compute(self, activeColumns, predictedColumns, inputValue=None, timestamp=None):
def __setstate__(self, state):
def __init__(self, numberOfCols=500, cellsPerColumn=10, initialPerm=0.11, connectedPerm=0.5, minThreshold=8, newSynapseCount=15, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1.0, activationThreshold=12, predictedSegmentDecrement=0.0, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, globalDecay=0.1, maxAge=100000, pamLength=1, verbosity=0, outputType='normal', seed=42):
@classmethod DCNL def read(cls, proto):
def compute(self, bottomUpInput, enableLearn, computeInfOutput=None):
def topDownCompute(self, topDownIn=None):
def __init__(self, numberOfCols=500, cellsPerColumn=10, initialPerm=0.11, connectedPerm=0.5, minThreshold=8, newSynapseCount=15, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1.0, activationThreshold=12, predictedSegmentDecrement=0.0, maxSegmentsPerCell=255, maxSynapsesPerSegment=255, globalDecay=0.1, maxAge=100000, pamLength=1, verbosity=0, outputType='normal', seed=42):
def compute(self, bottomUpInput, enableLearn, computeInfOutput=None):
def topDownCompute(self, topDownIn=None):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
def __setstate__(self, state):
def _getEphemeralMembers(self):
def _initEphemerals(self):
def saveToFile(self, filePath):
def loadFromFile(self, filePath):
def __getattr__(self, name):
def compute(self, bottomUpInput, enableLearn, enableInference=None):
def _inferPhase2(self):
def _copyAllocatedStates(self):
def _setStatePointers(self):
def reset(self):
def finishLearning(self):
def trimSegments(self, minPermanence=None, minNumSyns=None):
def printSegmentUpdates(self):
def _slowIsSegmentActive(self, seg, timeStep):
def printCell(self, c, i, onlyActiveSegments=False):
def getAvgLearnedSeqLength(self):
def getColCellIdx(self, idx):
def getSegmentOnCell(self, c, i, segIdx):
def getNumSegments(self):
def getNumSynapses(self):
def getNumSegmentsInCell(self, c, i):
def getSegmentInfo(self, collectActiveData=False):
def __getitem__(self, columnIndex):
def replace(self, columnIndex, bitmap):
def update(self, columnIndex, vector):
def getColumnDimensions(self):
def getInputDimensions(self):
def getNumColumns(self):
def getNumInputs(self):
def getPotentialRadius(self):
def setPotentialRadius(self, potentialRadius):
def getPotentialPct(self):
def setPotentialPct(self, potentialPct):
def getGlobalInhibition(self):
def setGlobalInhibition(self, globalInhibition):
def getNumActiveColumnsPerInhArea(self):
def setNumActiveColumnsPerInhArea(self, numActiveColumnsPerInhArea):
def getLocalAreaDensity(self):
def setLocalAreaDensity(self, localAreaDensity):
def getStimulusThreshold(self):
def setStimulusThreshold(self, stimulusThreshold):
def getInhibitionRadius(self):
def setInhibitionRadius(self, inhibitionRadius):
def getDutyCyclePeriod(self):
def setDutyCyclePeriod(self, dutyCyclePeriod):
def getBoostStrength(self):
def setBoostStrength(self, boostStrength):
def getIterationNum(self):
def setIterationNum(self, iterationNum):
def getIterationLearnNum(self):
def setIterationLearnNum(self, iterationLearnNum):
def getSpVerbosity(self):
def setSpVerbosity(self, spVerbosity):
def getUpdatePeriod(self):
def setUpdatePeriod(self, updatePeriod):
def getSynPermTrimThreshold(self):
def setSynPermTrimThreshold(self, synPermTrimThreshold):
def getSynPermActiveInc(self):
def setSynPermActiveInc(self, synPermActiveInc):
def getSynPermInactiveDec(self):
def setSynPermInactiveDec(self, synPermInactiveDec):
def getSynPermBelowStimulusInc(self):
def setSynPermBelowStimulusInc(self, synPermBelowStimulusInc):
def getSynPermConnected(self):
def setSynPermConnected(self, synPermConnected):
def getMinPctOverlapDutyCycles(self):
def setMinPctOverlapDutyCycles(self, minPctOverlapDutyCycles):
def getBoostFactors(self, boostFactors):
def setBoostFactors(self, boostFactors):
def getOverlapDutyCycles(self, overlapDutyCycles):
def setOverlapDutyCycles(self, overlapDutyCycles):
def getActiveDutyCycles(self, activeDutyCycles):
def setActiveDutyCycles(self, activeDutyCycles):
def getMinOverlapDutyCycles(self, minOverlapDutyCycles):
def setMinOverlapDutyCycles(self, minOverlapDutyCycles):
def getPotential(self, columnIndex, potential):
def setPotential(self, columnIndex, potential):
def getPermanence(self, columnIndex, permanence):
def setPermanence(self, columnIndex, permanence):
def getConnectedSynapses(self, columnIndex, connectedSynapses):
def getConnectedCounts(self, connectedCounts):
def getOverlaps(self):
def getBoostedOverlaps(self):
def compute(self, inputVector, learn, activeArray):
def stripUnlearnedColumns(self, activeArray):
def _updateMinDutyCycles(self):
def _updateMinDutyCyclesGlobal(self):
def _updateMinDutyCyclesLocal(self):
def _updateDutyCycles(self, overlaps, activeColumns):
def _updateInhibitionRadius(self):
def _avgColumnsPerInput(self):
def _avgConnectedSpanForColumn1D(self, columnIndex):
def _avgConnectedSpanForColumn2D(self, columnIndex):
def _avgConnectedSpanForColumnND(self, columnIndex):
def _adaptSynapses(self, inputVector, activeColumns):
def _bumpUpWeakColumns(self):
def _raisePermanenceToThreshold(self, perm, mask):
def _updatePermanencesForColumn(self, perm, columnIndex, raisePerm=True):
def _initPermConnected(self):
def _initPermNonConnected(self):
def _initPermanence(self, potential, connectedPct):
def _mapColumn(self, index):
def _mapPotential(self, index):
@staticmethod DCNL def _updateDutyCyclesHelper(dutyCycles, newInput, period):
def _updateBoostFactors(self):
def _updateBoostFactorsGlobal(self):
def _updateBoostFactorsLocal(self):
def _updateBookeepingVars(self, learn):
def _calculateOverlap(self, inputVector):
def _inhibitColumns(self, overlaps):
def _inhibitColumnsGlobal(self, overlaps, density):
def _inhibitColumnsLocal(self, overlaps, density):
def _isUpdateRound(self):
def _getColumnNeighborhood(self, centerColumn):
def _getInputNeighborhood(self, centerInput):
def _seed(self, seed=(-1)):
def __setstate__(self, state):
def printParameters(self):
def __init__(self, claLearningPeriod=None, learningPeriod=288, estimationSamples=100, historicWindowSize=8640, reestimationPeriod=100):
@staticmethod DCNL def computeLogLikelihood(likelihood):
@staticmethod DCNL def _calcSkipRecords(numIngested, windowSize, learningPeriod):
@classmethod DCNL def read(cls, proto):
def write(self, proto):
def anomalyProbability(self, value, anomalyScore, timestamp=None):
def __init__(self, monitor, title):
@staticmethod DCNL def prettyPrintDatum(datum):
def makeCountsTrace(self):
def makeCumCountsTrace(self):
def mmGetTraceActiveColumns(self):
def mmGetTracePredictiveCells(self):
def mmGetTraceNumSegments(self):
def mmGetTraceNumSynapses(self):
def mmGetTraceSequenceLabels(self):
def mmGetTraceResets(self):
def mmGetTracePredictedActiveCells(self):
def mmGetTracePredictedInactiveCells(self):
def mmGetTracePredictedActiveColumns(self):
def mmGetTracePredictedInactiveColumns(self):
def mmGetTraceUnpredictedActiveColumns(self):
def mmGetMetricFromTrace(self, trace):
def mmGetMetricSequencesPredictedActiveCellsPerColumn(self):
def mmGetMetricSequencesPredictedActiveCellsShared(self):
def mmPrettyPrintConnections(self):
def mmPrettyPrintSequenceCellRepresentations(self, sortby='Column'):
def _mmComputeTransitionTraces(self):
def mmGetCellActivityPlot(self, title='', showReset=False, resetShading=0.25, activityType='activeCells'):
def __init__(self, monitor, title, data):
def __init__(self, monitor, title, show=True):
def addGraph(self, data, position=111, xlabel=None, ylabel=None):
def addHistogram(self, data, position=111, xlabel=None, ylabel=None, bins=None):
def add2DArray(self, data, position=111, xlabel=None, ylabel=None, cmap=None, aspect='auto', interpolation='nearest', name=None):
def _addBase(self, position, xlabel=None, ylabel=None):
def __init__(self, *args, **kwargs):
def mmClearHistory(self):
@staticmethod DCNL def mmPrettyPrintTraces(traces, breakOnResets=None):
@staticmethod DCNL def mmPrettyPrintMetrics(metrics, sigFigs=5):
def mmGetDefaultTraces(self, verbosity=1):
def mmGetDefaultMetrics(self, verbosity=1):
def mmGetCellTracePlot(self, cellTrace, cellCount, activityType, title='', showReset=False, resetShading=0.25):
def __init__(self, columnDimensions=(2048,), cellsPerColumn=32, activationThreshold=13, initialPermanence=0.21, connectedPermanence=0.5, minThreshold=10, maxNewSynapseCount=20, permanenceIncrement=0.1, permanenceDecrement=0.1, seed=42):
def compute(self, activeColumns, learn=True):
def compute(self, recordNum, patternNZ, classification, learn, infer):
def infer(self, patternNZ, actValueList):
def inferSingleStep(self, patternNZ, weightMatrix):
def _calculateError(self, recordNum, bucketIdxList):
def __eq__(self, other):
def __eq__(self, other):
def segmentsForCell(self, cell):
def synapsesForSegment(self, segment):
def dataForSynapse(self, synapse):
def dataForSegment(self, segment):
def getSegment(self, cell, idx):
def segmentForFlatIdx(self, flatIdx):
def segmentFlatListLength(self):
def synapsesForPresynapticCell(self, presynapticCell):
def createSegment(self, cell):
def destroySegment(self, segment):
def createSynapse(self, segment, presynapticCell, permanence):
def destroySynapse(self, synapse):
def updateSynapsePermanence(self, synapse, permanence):
def computeActivity(self, activePresynapticCells, connectedPermanence):
def numSegments(self, cell=None):
def numSynapses(self, segment=None):
def segmentPositionSortKey(self, segment):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
def __eq__(self, other):
def __ne__(self, other):
def _getEphemeralMembers(self):
def _initEphemerals(self):
def __getstate__(self):
def __setstate__(self, state):
def write(self, proto):
@classmethod DCNL def read(cls, proto):
def __getattr__(self, name):
def saveToFile(self, filePath):
def loadFromFile(self, filePath):
def _getRandomState(self):
def _setRandomState(self, state):
def reset(self):
def resetStats(self):
def getStats(self):
def _updateStatsInferEnd(self, stats, bottomUpNZ, predictedState, colConfidence):
def printState(self, aState):
def printConfidence(self, aState, maxCols=20):
def printColConfidence(self, aState, maxCols=20):
def printStates(self, printPrevious=True, printLearnState=True):
def printOutput(self, y):
def printInput(self, x):
def printParameters(self):
def printActiveIndices(self, state, andValues=False):
def printComputeEnd(self, output, learn=False):
def printSegmentUpdates(self):
def printCell(self, c, i, onlyActiveSegments=False):
def printCells(self, predictedOnly=False):
def getNumSegmentsInCell(self, c, i):
def getNumSynapses(self):
def getNumSynapsesPerSegmentAvg(self):
def getNumSegments(self):
def getNumCells(self):
def getSegmentOnCell(self, c, i, segIdx):
def _addToSegmentUpdates(self, c, i, segUpdate):
def _removeSegmentUpdate(self, updateInfo):
def _computeOutput(self):
def _getActiveState(self):
def getPredictedState(self):
def predict(self, nSteps):
def _getTPDynamicStateVariableNames(self):
def _getTPDynamicState(self):
def _setTPDynamicState(self, tpDynamicState):
def _updateAvgLearnedSeqLength(self, prevSeqLength):
def getAvgLearnedSeqLength(self):
def _inferBacktrack(self, activeColumns):
def _inferPhase1(self, activeColumns, useStartCells):
def _inferPhase2(self):
def _updateInferenceState(self, activeColumns):
def _learnBacktrackFrom(self, startOffset, readOnly=True):
def _learnBacktrack(self):
def _learnPhase1(self, activeColumns, readOnly=False):
def _learnPhase2(self, readOnly=False):
def _updateLearningState(self, activeColumns):
def compute(self, bottomUpInput, enableLearn, enableInference=None):
def infer(self, bottomUpInput):
def learn(self, bottomUpInput, enableInference=None):
def _columnConfidences(self):
def topDownCompute(self):
def _trimSegmentsInCell(self, colIdx, cellIdx, segList, minPermanence, minNumSyns):
def trimSegments(self, minPermanence=None, minNumSyns=None):
def _cleanUpdatesList(self, col, cellIdx, seg):
def finishLearning(self):
def _checkPrediction(self, patternNZs, output=None, colConfidence=None, details=False):
def _isSegmentActive(self, seg, activeState):
def _getSegmentActivityLevel(self, seg, activeState, connectedSynapsesOnly=False):
def _getBestMatchingCell(self, c, activeState, minThreshold):
def _getBestMatchingSegment(self, c, i, activeState):
def _getCellForNewSegment(self, colIdx):
def _getSegmentActiveSynapses(self, c, i, s, activeState, newSynapses=False):
def _chooseCellsToLearnFrom(self, c, i, s, n, activeState):
def _processSegmentUpdates(self, activeColumns):
def _adaptSegment(self, segUpdate):
def getSegmentInfo(self, collectActiveData=False):
def dutyCycle(self, active=False, readOnly=False):
def debugPrint(self):
def freeNSynapses(self, numToFree, inactiveSynapseIndices, verbosity=0):
def addSynapse(self, srcCellCol, srcCellIdx, perm):
def updateSynapses(self, synapses, delta):
def __constructEphemeralInstanceVars(self):
def initialize(self):
def compute(self, inputs, outputs):
@classmethod DCNL def getSpec(cls):
def getParameter(self, parameterName, index=(-1)):
def setParameter(self, parameterName, index, parameterValue):
def setIdentityPolicyInstance(self, identityPolicyObj):
def getIdentityPolicyInstance(self):
def write(self, proto):
def read(self, proto):
def __getstate__(self):
def __setstate__(self, state):
def _initializeEphemeralMembers(self):
def initialize(self):
def _allocateSpatialFDR(self, rfInput):
def compute(self, inputs, outputs):
def _compute(self, inputs, outputs):
def _doBottomUpCompute(self, rfInput, resetSignal):
def _doTopDownInfer(self, topDownInput=None):
@classmethod DCNL def getBaseSpec(cls):
@classmethod DCNL def getSpec(cls):
def getAlgorithmInstance(self):
def getParameter(self, parameterName, index=(-1)):
def setParameter(self, parameterName, index, parameterValue):
@staticmethod DCNL def getSchema():
def writeToProto(self, proto):
@classmethod DCNL def readFromProto(cls, proto):
def __getstate__(self):
def __setstate__(self, state):
def _initEphemerals(self):
def _getEphemeralMembers(self):
def _getEphemeralMembersBase(self):
def _getEphemeralMembersAll(self):
def getParameterArrayCount(self, name, index):
def getParameterArray(self, name, index, a):
def invariant(self):
def toDict(self):
@classmethod DCNL def getSpec(cls):
def _getEphemeralAttributes(self):
def _initEphemerals(self):
def __setstate__(self, state):
def __getstate__(self):
def getAlgorithmInstance(self):
def getParameter(self, name, index=(-1)):
def setParameter(self, name, index, value):
def reset(self):
def enableTap(self, tapPath):
def disableTap(self):
def handleLogInput(self, inputs):
def handleLogOutput(self, output):
def _storeSample(self, inputVector, trueCatIndex, partition=0):
def compute(self, inputs, outputs):
def getCategoryList(self):
def removeCategory(self, categoryToRemove):
def getLatestDistances(self):
def getAllDistances(self):
def _finishLearning(self):
def _finishSphering(self):
def getOutputElementCount(self, name):
def rewind(self):
def getNextRecord(self):
def applyFilters(self, data):
def populateCategoriesOut(self, categories, output):
def compute(self, inputs, outputs):
def _convertNonNumericData(self, spatialOutput, temporalOutput, output):
def getOutputValues(self, outputName):
def getOutputElementCount(self, name):
def setParameter(self, parameterName, index, parameterValue):
@staticmethod DCNL def getSchema():
def writeToProto(self, proto):
@classmethod DCNL def readFromProto(cls, proto):
def _initialize(self):
def initialize(self):
def compute(self, inputs, outputs):
def _compute(self, inputs, outputs):
@classmethod DCNL def getBaseSpec(cls):
@classmethod DCNL def getSpec(cls):
def getAlgorithmInstance(self):
def getParameter(self, parameterName, index=(-1)):
def setParameter(self, parameterName, index, parameterValue):
def resetSequenceStates(self):
def finishLearning(self):
@staticmethod DCNL def getSchema():
def writeToProto(self, proto):
@classmethod DCNL def readFromProto(cls, proto):
def __getstate__(self):
def serializeExtraData(self, filePath):
def deSerializeExtraData(self, filePath):
def __setstate__(self, state):
def _initEphemerals(self):
def _getEphemeralMembers(self):
def _getEphemeralMembersBase(self):
def _getEphemeralMembersAll(self):
def getOutputElementCount(self, name):
def getParameterArrayCount(self, name, index):
def getParameterArray(self, name, index, a):
@classmethod DCNL def getSpec(cls):
def initialize(self):
def getAlgorithmInstance(self):
def getParameter(self, name, index=(-1)):
def setParameter(self, name, index, value):
@staticmethod DCNL def getSchema():
def writeToProto(self, proto):
@classmethod DCNL def readFromProto(cls, proto):
def compute(self, inputs, outputs):
def customCompute(self, recordNum, patternNZ, classification):
def getOutputElementCount(self, outputName):
@classmethod DCNL def getSpec(cls):
def getParameter(self, name, index=(-1)):
def setParameter(self, name, index, value):
def compute(self, inputs, outputs):
def getLabelResults(self):
def _classifyStates(self):
def _classifyState(self, state):
def _constructClassificationRecord(self, inputs):
def _addRecordToKNN(self, record):
def _deleteRecordsFromKNN(self, recordsToDelete):
def _deleteRangeFromKNN(self, start=0, end=None):
def _recomputeRecordFromKNN(self, record):
def _labelToCategoryNumber(self, label):
def _labelListToCategoryNumber(self, labelList):
def _categoryToLabelList(self, category):
def _getStateAnomalyVector(self, state):
def getLabels(self, start=None, end=None):
def addLabel(self, start, end, labelName):
def removeLabels(self, start=None, end=None, labelFilter=None):
def __getstate__(self):
def __setstate__(self, state):
def getOutputElementCount(self, name):
def getSensedValue(self):
def setSensedValue(self, value):
@classmethod DCNL def dbNamePrefix(cls):
@classmethod DCNL def __getDBNamePrefixForVersion(cls, dbVersion):
@classmethod DCNL def _getDBName(cls):
@classmethod DCNL def __getDBNameForVersion(cls, dbVersion):
@staticmethod DCNL @logExceptions(_LOGGER) DCNL def get():
@logExceptions(_LOGGER) DCNL def __init__(self):
def _columnNameDBToPublic(self, dbName):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def connect(self, deleteOldVersions=False, recreate=False):
@logExceptions(_LOGGER) DCNL def _initTables(self, cursor, deleteOldVersions, recreate):
def _getMatchingRowsNoRetries(self, tableInfo, conn, fieldsToMatch, selectFieldNames, maxRows=None):
@g_retrySQL DCNL def _getMatchingRowsWithRetries(self, tableInfo, fieldsToMatch, selectFieldNames, maxRows=None):
def _getOneMatchingRowNoRetries(self, tableInfo, conn, fieldsToMatch, selectFieldNames):
@g_retrySQL DCNL def _getOneMatchingRowWithRetries(self, tableInfo, fieldsToMatch, selectFieldNames):
def _insertOrGetUniqueJobNoRetries(self, conn, client, cmdLine, jobHash, clientInfo, clientKey, params, minimumWorkers, maximumWorkers, jobType, priority, alreadyRunning):
def _resumeJobNoRetries(self, conn, jobID, alreadyRunning):
def getConnectionID(self):
@logExceptions(_LOGGER) DCNL def jobSuspend(self, jobID):
@logExceptions(_LOGGER) DCNL def jobResume(self, jobID, alreadyRunning=False):
@logExceptions(_LOGGER) DCNL def jobInsert(self, client, cmdLine, clientInfo='', clientKey='', params='', alreadyRunning=False, minimumWorkers=0, maximumWorkers=0, jobType='', priority=DEFAULT_JOB_PRIORITY):
@logExceptions(_LOGGER) DCNL def jobInsertUnique(self, client, cmdLine, jobHash, clientInfo='', clientKey='', params='', minimumWorkers=0, maximumWorkers=0, jobType='', priority=DEFAULT_JOB_PRIORITY):
@g_retrySQL DCNL def _startJobWithRetries(self, jobID):
@logExceptions(_LOGGER) DCNL def jobStartNext(self):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobReactivateRunningJobs(self):
@logExceptions(_LOGGER) DCNL def jobGetDemand(self):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobCancelAllRunningJobs(self):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobCountCancellingJobs(self):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobGetCancellingJobs(self):
@staticmethod DCNL @logExceptions(_LOGGER) DCNL def partitionAtIntervals(data, intervals):
@staticmethod DCNL @logExceptions(_LOGGER) DCNL def _combineResults(result, *namedTuples):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobInfoWithModels(self, jobID):
@logExceptions(_LOGGER) DCNL def jobInfo(self, jobID):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetStatus(self, jobID, status, useConnectionID=True):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetCompleted(self, jobID, completionReason, completionMsg, useConnectionID=True):
@logExceptions(_LOGGER) DCNL def jobCancel(self, jobID):
@logExceptions(_LOGGER) DCNL def jobGetModelIDs(self, jobID):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobCountForClientInfo(self, clientInfo):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobCountForClientKey(self, clientKey):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobsForClientInfo(self, clientInfo, fields=[]):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getActiveJobsForClientKey(self, clientKey, fields=[]):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getJobs(self, fields=[]):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def getFieldsForActiveJobsOfType(self, jobType, fields=[]):
@logExceptions(_LOGGER) DCNL def jobGetFields(self, jobID, fields):
@logExceptions(_LOGGER) DCNL def jobsGetFields(self, jobIDs, fields, requireAll=True):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetFields(self, jobID, fields, useConnectionID=True, ignoreUnchanged=False):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobSetFieldIfEqual(self, jobID, fieldName, newValue, curValue):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobIncrementIntField(self, jobID, fieldName, increment=1, useConnectionID=False):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def jobUpdateResults(self, jobID, results):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelsClearAll(self):
@logExceptions(_LOGGER) DCNL def modelInsertAndStart(self, jobID, params, paramsHash, particleHash=None):
@logExceptions(_LOGGER) DCNL def modelsInfo(self, modelIDs):
@logExceptions(_LOGGER) DCNL def modelsGetFields(self, modelIDs, fields):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelsGetFieldsForJob(self, jobID, fields, ignoreKilled=False):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelsGetFieldsForCheckpointed(self, jobID, fields):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelSetFields(self, modelID, fields, ignoreUnchanged=False):
@logExceptions(_LOGGER) DCNL def modelsGetParams(self, modelIDs):
@logExceptions(_LOGGER) DCNL def modelsGetResultAndStatus(self, modelIDs):
@logExceptions(_LOGGER) DCNL def modelsGetUpdateCounters(self, jobID):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelUpdateResults(self, modelID, results=None, metricValue=None, numRecords=None):
@logExceptions(_LOGGER) DCNL @g_retrySQL DCNL def modelSetCompleted(self, modelID, completionReason, completionMsg, cpuTime=0, useConnectionID=True):
@logExceptions(_LOGGER) DCNL def modelAdoptNextOrphan(self, jobId, maxUpdateInterval):
@classmethod DCNL def get(cls):
@classmethod DCNL def close(cls):
@classmethod DCNL def setConnectionPolicyProvider(cls, provider):
@classmethod DCNL def _createDefaultPolicy(cls):
def __init__(self, dbConn, cursor, releaser, logger):
def __enter__(self):
def __exit__(self, exc_type, exc_val, exc_tb):
def release(self):
def _trackInstanceAndCheckForConcurrencyViolation(self):
def close(self):
def acquireConnection(self):
def __init__(self):
def close(self):
def acquireConnection(self):
def _releaseConnection(self, dbConn, cursor):
def __init__(self):
def close(self):
def acquireConnection(self):
def _releaseConnection(self, dbConn, cursor):
def __init__(self):
def close(self):
def acquireConnection(self):
def _releaseConnection(self, dbConn, cursor):
def __init__(self, n, w=None, name='sparse_pass_through', forced=False, verbosity=0):
def encodeIntoArray(self, value, output):
def __init__(self, w, minval=None, maxval=None, periodic=False, n=0, radius=0, resolution=0, name=None, verbosity=0, clipInput=True, forced=False):
def topDownCompute(self, encoded):
def getDecoderOutputFieldTypes(self):
def _getScaledValue(self, inpt):
def getBucketIndices(self, inpt):
def encodeIntoArray(self, inpt, output):
def decode(self, encoded, parentFieldName=''):
def getBucketValues(self):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def closenessScores(self, expValues, actValues, fractional=True):
def getDescription(self):
def getScalars(self, inputData):
def encodeIntoArray(self, inputData, output):
def coordinateForPosition(self, longitude, latitude, altitude=None):
def radiusForSpeed(self, speed):
def getWidth(self):
def encodeIntoArray(self, inputData, output):
def setLearning(self, learningEnabled):
def setFieldStats(self, fieldName, fieldStatistics):
def encode(self, inputData):
def getScalarNames(self, parentFieldName=''):
def getDecoderOutputFieldTypes(self):
def setStateLock(self, lock):
def _getInputValue(self, obj, fieldName):
def getEncoderList(self):
def getScalars(self, inputData):
def getEncodedValues(self, inputData):
def getBucketIndices(self, inputData):
def scalarsToStr(self, scalarValues, scalarNames=None):
def getDescription(self):
def getFieldDescription(self, fieldName):
def encodedBitDescription(self, bitOffset, formatted=False):
def pprintHeader(self, prefix=''):
def pprint(self, output, prefix=''):
def decode(self, encoded, parentFieldName=''):
def decodedToStr(self, decodeResults):
def getBucketValues(self):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def closenessScores(self, expValues, actValues, fractional=True):
def getDisplayWidth(self):
def getDecoderOutputFieldTypes(self):
def getScalars(self, input):
def getBucketIndices(self, input):
def encodeIntoArray(self, inputVal, outputVal):
def decode(self, encoded, parentFieldName=''):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def closenessScores(self, expValues, actValues, **kwargs):
def getDecoderOutputFieldTypes(self):
def getScalars(self, input):
def getBucketIndices(self, input):
def decode(self, encoded, parentFieldName=''):
def closenessScores(self, expValues, actValues, fractional=True):
def getBucketValues(self):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def _setEncoderParams(self):
def setFieldStats(self, fieldName, fieldStats):
def _setMinAndMax(self, input, learn):
def getBucketIndices(self, input, learn=None):
def encodeIntoArray(self, input, output, learn=None):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def _seed(self, seed=(-1)):
def getDecoderOutputFieldTypes(self):
def _newRep(self):
def getScalars(self, input):
def getBucketIndices(self, input):
def decode(self, encoded, parentFieldName=''):
def _getTopDownMapping(self):
def getBucketValues(self):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def closenessScores(self, expValues, actValues, fractional=True):
def _seed(self, seed=(-1)):
def getDecoderOutputFieldTypes(self):
def getWidth(self):
def getBucketIndices(self, x):
def mapBucketIndexToNonZeroBits(self, index):
def encodeIntoArray(self, x, output):
def _createBucket(self, index):
def _newRepresentation(self, index, newIndex):
def _newRepresentationOK(self, newRep, newIndex):
def _countOverlapIndices(self, i, j):
@staticmethod DCNL def _countOverlap(rep1, rep2):
def _overlapOK(self, i, j, overlap=None):
def _initializeBucketMap(self, maxBuckets, offset):
def _initEncoder(self, w, minval, maxval, n, radius, resolution):
def _checkReasonableSettings(self):
def getDecoderOutputFieldTypes(self):
def _getFirstOnBit(self, input):
def getBucketIndices(self, input):
def encodeIntoArray(self, input, output, learn=True):
def decode(self, encoded, parentFieldName=''):
def _generateRangeDescription(self, ranges):
def _getTopDownMapping(self):
def getBucketValues(self):
def getBucketInfo(self, buckets):
def topDownCompute(self, encoded):
def closenessScores(self, expValues, actValues, fractional=True):
def getScalarNames(self, parentFieldName=''):
def getEncodedValues(self, input):
def getScalars(self, input):
def getBucketIndices(self, input):
def encodeIntoArray(self, input, output):
def addEncoder(self, name, encoder):
def getWidth(self):
def addMultipleEncoders(self, fieldEncodings):
def getWidth(self):
def getDescription(self):
def getScalars(self, inputData):
def encodeIntoArray(self, inputData, output):
@staticmethod DCNL def _neighbors(coordinate, radius):
@classmethod DCNL def _topWCoordinates(cls, coordinates, w):
@staticmethod DCNL def _hashCoordinate(coordinate):
@classmethod DCNL def _orderForCoordinate(cls, coordinate):
@classmethod DCNL def _bitForCoordinate(cls, coordinate, n):
def __init__(cls, name, bases, dict):
def printTestHeader(self):
def printBanner(self, msg, *args):
def addExtraLogItem(self, item):
def __wrapMsg(self, msg):
def assertEqual(self, first, second, msg=None):
def assertNotEqual(self, first, second, msg=None):
def assertTrue(self, expr, msg=None):
def assertFalse(self, expr, msg=None):
def getDefaultTMParams(self):
def init(self, overrides=None):
@classmethod DCNL def getCustomDict(cls):
@classmethod DCNL def setCustomProperty(cls, propertyName, value):
@classmethod DCNL def setCustomProperties(cls, properties):
@classmethod DCNL def clear(cls):
@classmethod DCNL def resetCustomConfig(cls):
@classmethod DCNL def loadCustomConfig(cls):
@classmethod DCNL def _readStdConfigFiles(cls):
@classmethod DCNL def clear(cls, persistent=False):
@classmethod DCNL def getCustomDict(cls):
@classmethod DCNL def edit(cls, properties):
@classmethod DCNL def _setPath(cls):
@classmethod DCNL def getPath(cls):
@classmethod DCNL def getString(cls, prop):
@classmethod DCNL def getBool(cls, prop):
@classmethod DCNL def getInt(cls, prop):
@classmethod DCNL def getFloat(cls, prop):
@classmethod DCNL def get(cls, prop, default=None):
@classmethod DCNL def set(cls, prop, value):
@classmethod DCNL def dict(cls):
@classmethod DCNL def readConfigFile(cls, filename, path=None):
@classmethod DCNL def _readConfigFile(cls, filename, path=None):
@classmethod DCNL def clear(cls):
@classmethod DCNL def findConfigFile(cls, filename):
@classmethod DCNL def getConfigPaths(cls):
@classmethod DCNL def setConfigPaths(cls, paths):
@classmethod DCNL def _readStdConfigFiles(cls):
def cPrint(self, level, message, *args, **kw):
def propose(self, current, r):
def propose(self, current, r):
def sample(self, rgen):
def logProbability(self, distn):
def sample(self, rgen):
def numRows(self):
def numColumns(self):
def grow(self, rows, cols):
def updateRow(self, row, distribution):
def inferRow(self, distribution):
def inferRowEvidence(self, distribution):
def inferRowCompat(self, distribution):
def clean_outcpd(self):
def shift(self, modelResult):
def __init__(self, filterDict):
def match(self, record):
def __init__(self, n, w, num=100, seed=42):
def get(self, number):
def addNoise(self, bits, amount):
def numbersForBit(self, bit):
def numberMapForBits(self, bits):
def prettyPrintPattern(self, bits, verbosity=1):
def _generate(self):
def _getW(self):
def _generate(self):
def getNext(self):
def getData(self, n):
def getDescription(self):
def __init__(self, patternMachine, seed=42):
def generateFromNumbers(self, numbers):
def addSpatialNoise(self, sequence, amount):
def prettyPrintSequence(self, sequence, verbosity=1):
def generateNumbers(self, numSequences, sequenceLength, sharedRange=None):
def __init__(self, name='testDataset', seed=42, verbosity=0):
def getDescription(self):
def setSeed(self, seed):
def addField(self, name, fieldParams, encoderParams):
def addMultipleFields(self, fieldsInfo):
def defineField(self, name, encoderParams=None):
def setFlag(self, index, flag):
def generateRecord(self, record):
def generateRecords(self, records):
def getRecord(self, n=None):
def getAllRecords(self):
def encodeRecord(self, record, toBeAdded=True):
def encodeAllRecords(self, records=None, toBeAdded=True):
def addValueToField(self, i, value=None):
def addValuesToField(self, i, numValues):
def getSDRforValue(self, i, j):
def getZeroedOutEncoding(self, n):
def getTotaln(self):
def getTotalw(self):
def getEncoding(self, n):
def getAllEncodings(self):
def getAllFieldNames(self):
def getAllFlags(self):
def getAllDataTypes(self):
def getFieldDescriptions(self):
def saveRecords(self, path='myOutput'):
def removeAllRecords(self):
def __init__(self, name, encoderSpec):
def addValues(self, values):
def addValue(self, value):
def encodeValue(self, value, toBeAdded=True):
def _setTypes(self, encoderSpec):
def _initializeEncoders(self, encoderSpec):
@staticmethod DCNL def createFromFileFieldElement(fieldInfoTuple):
@classmethod DCNL def createListFromFileFieldList(cls, fields):
@classmethod DCNL def isValid(cls, fieldDataType):
@classmethod DCNL def isValid(cls, attr):
def getStats(self, stats):
def __init__(self, origField, deltaField):
@staticmethod DCNL def _openStream(dataUrl, isBlocking, maxTimeout, bookmark, firstRecordIdx):
def close(self):
def getNextRecord(self):
def getDataRowCount(self):
def getNextRecordIdx(self):
def recordsExistAfter(self, bookmark):
def getAggregationMonthsAndSeconds(self):
def getFieldNames(self):
def getFields(self):
def getBookmark(self):
def clearStats(self):
def getStats(self):
def getError(self):
def setError(self, error):
def isCompleted(self):
def setCompleted(self, completed=True):
def setTimeout(self, timeout):
def _cacheSequenceInfoType(self):
def __init__(self, aggregationInfo, inputFields, timeFieldName=None, sequenceIdFieldName=None, resetFieldName=None, filterInfo=None):
def _getEndTime(self, t):
def _getFuncPtrAndParams(self, funcName):
def _createAggregateRecord(self):
def isNullAggregation(self):
def next(self, record, curInputBookmark):
def __init__(self, fields, aggregationPeriod=None):
def rewind(self):
def encode(self, inputRow):
def _computeTimestampRecordIdx(self, recordTS):
def rewind(self):
def getNextRecordDict(self):
def getAggregationMonthsAndSeconds(self):
def getFieldMin(self, fieldName):
def getFieldMax(self, fieldName):
def getResetFieldIdx(self):
def getTimestampFieldIdx(self):
def getSequenceIdFieldIdx(self):
def getCategoryFieldIdx(self):
def getLearningFieldIdx(self):
def close(self):
def rewind(self):
def getNextRecord(self, useCache=True):
def appendRecord(self, record):
def appendRecords(self, records, progressCB=None):
def getBookmark(self):
def recordsExistAfter(self, bookmark):
def seekFromEnd(self, numRecords):
def setAutoRewind(self, autoRewind):
def getStats(self):
def clearStats(self):
def getError(self):
def setError(self, error):
def isCompleted(self):
def setCompleted(self, completed=True):
def getFieldNames(self):
def getFields(self):
def _updateSequenceInfo(self, r):
def _getStartRow(self, bookmark):
def _getTotalLineCount(self):
def getNextRecordIdx(self):
def getDataRowCount(self):
def flush(self):
def __enter__(self):
def __exit__(self, yupe, value, traceback):
def __iter__(self):
def next(self):
def __init__(self, *args):
def __init__(self, region, network):
@staticmethod DCNL def getSpecFromType(nodeType):
def compute(self):
def getInputData(self, inputName):
def getOutputData(self, outputName):
def getInputNames(self):
def getOutputNames(self):
def executeCommand(self, args):
def _getSpec(self):
def _getDimensions(self):
def _getNetwork(self):
def __hash__(self):
def __cmp__(self, other):
def _getParameterMethods(self, paramName):
def getParameter(self, paramName):
def setParameter(self, paramName, value):
def _get(self, method):
def __init__(self, *args):
def _getRegions(self):
def addRegion(self, name, nodeType, nodeParams):
def addRegionFromBundle(self, name, nodeType, dimensions, bundlePath, label):
def setPhases(self, name, phases):
def run(self, n):
def disableProfiling(self, *args, **kwargs):
def enableProfiling(self, *args, **kwargs):
def getCallbacks(self, *args, **kwargs):
def initialize(self, *args, **kwargs):
def link(self, *args, **kwargs):
def removeLink(self, *args, **kwargs):
def removeRegion(self, *args, **kwargs):
def resetProfiling(self, *args, **kwargs):
def save(self, *args, **kwargs):
def getRegionsByType(self, regionClass):
@staticmethod DCNL def registerRegion(regionClass):
@staticmethod DCNL def unregisterRegion(regionName):
